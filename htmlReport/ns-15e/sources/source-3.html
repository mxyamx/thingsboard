<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > AlarmRuleState</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.server.service.cf.ctx.state.alarm</a>
</div>

<h1>Coverage Summary for Class: AlarmRuleState (org.thingsboard.server.service.cf.ctx.state.alarm)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AlarmRuleState</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/118)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/144)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AlarmRuleState$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AlarmRuleState$StateInfo</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/28)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/118)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/148)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.server.service.cf.ctx.state.alarm;
&nbsp;
&nbsp;import com.fasterxml.jackson.databind.node.ObjectNode;
&nbsp;import lombok.Data;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.thingsboard.common.util.JacksonUtil;
&nbsp;import org.thingsboard.common.util.KvUtil;
&nbsp;import org.thingsboard.server.common.data.alarm.AlarmSeverity;
&nbsp;import org.thingsboard.server.common.data.alarm.rule.AlarmRule;
&nbsp;import org.thingsboard.server.common.data.alarm.rule.condition.AlarmCondition;
&nbsp;import org.thingsboard.server.common.data.alarm.rule.condition.AlarmConditionType;
&nbsp;import org.thingsboard.server.common.data.alarm.rule.condition.AlarmConditionValue;
&nbsp;import org.thingsboard.server.common.data.alarm.rule.condition.DurationAlarmCondition;
&nbsp;import org.thingsboard.server.common.data.alarm.rule.condition.RepeatingAlarmCondition;
&nbsp;import org.thingsboard.server.common.data.alarm.rule.condition.expression.AlarmConditionExpression;
&nbsp;import org.thingsboard.server.common.data.alarm.rule.condition.schedule.AlarmSchedule;
&nbsp;import org.thingsboard.server.common.data.alarm.rule.condition.schedule.AlarmScheduleType;
&nbsp;import org.thingsboard.server.common.data.alarm.rule.condition.schedule.AnyTimeSchedule;
&nbsp;import org.thingsboard.server.common.data.alarm.rule.condition.schedule.CustomTimeSchedule;
&nbsp;import org.thingsboard.server.common.data.alarm.rule.condition.schedule.CustomTimeScheduleItem;
&nbsp;import org.thingsboard.server.common.data.alarm.rule.condition.schedule.SpecificTimeSchedule;
&nbsp;import org.thingsboard.server.common.msg.tools.SchedulerUtils;
&nbsp;import org.thingsboard.server.service.cf.ctx.state.CalculatedFieldCtx;
&nbsp;
&nbsp;import java.time.Instant;
&nbsp;import java.time.ZoneId;
&nbsp;import java.time.ZonedDateTime;
&nbsp;import java.util.Optional;
&nbsp;import java.util.concurrent.ScheduledFuture;
&nbsp;
&nbsp;import static org.thingsboard.server.service.cf.ctx.state.alarm.AlarmEvalResult.Status.TRUE;
&nbsp;
&nbsp;@Data
<b class="nc">&nbsp;@Slf4j</b>
&nbsp;public class AlarmRuleState {
&nbsp;
&nbsp;    private final AlarmSeverity severity;
&nbsp;    private AlarmRule alarmRule;
&nbsp;    private AlarmCalculatedFieldState state;
&nbsp;
&nbsp;    private AlarmCondition condition;
&nbsp;
&nbsp;    private long eventCount;
&nbsp;    private long firstEventTs; // when duration condition started
&nbsp;    private long lastCheckTs;
&nbsp;    private transient long duration;
&nbsp;    private ScheduledFuture&lt;?&gt; durationCheckFuture;
&nbsp;    private Boolean active;
&nbsp;
<b class="nc">&nbsp;    public AlarmRuleState(AlarmSeverity severity, AlarmRule alarmRule, AlarmCalculatedFieldState state) {</b>
<b class="nc">&nbsp;        this.severity = severity;</b>
<b class="nc">&nbsp;        if (alarmRule != null) {</b>
<b class="nc">&nbsp;            setAlarmRule(alarmRule);</b>
&nbsp;        }
<b class="nc">&nbsp;        this.state = state;</b>
&nbsp;    }
&nbsp;
&nbsp;    public AlarmEvalResult eval(boolean newEvent, CalculatedFieldCtx ctx) { // on event or config change
<b class="nc">&nbsp;        long ts = newEvent ? state.getLatestTimestamp() : System.currentTimeMillis();</b>
<b class="nc">&nbsp;        active = isActive(ts);</b>
<b class="nc">&nbsp;        if (!active) {</b>
<b class="nc">&nbsp;            return AlarmEvalResult.FALSE;</b>
&nbsp;        }
<b class="nc">&nbsp;        return doEval(newEvent, ctx);</b>
&nbsp;    }
&nbsp;
&nbsp;    public AlarmEvalResult reeval(long ts, CalculatedFieldCtx ctx) { // on scheduled duration check or periodic re-eval for rules with schedule
<b class="nc">&nbsp;        boolean active = isActive(ts);</b>
<b class="nc">&nbsp;        switch (condition.getType()) {</b>
&nbsp;            case SIMPLE, REPEATING -&gt; {
<b class="nc">&nbsp;                boolean activeChanged = this.active == null || active != this.active;</b>
<b class="nc">&nbsp;                this.active = active;</b>
<b class="nc">&nbsp;                if (!active) {</b>
<b class="nc">&nbsp;                    return AlarmEvalResult.EMPTY;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if ((condition.hasSchedule() &amp;&amp; activeChanged) ||</b>
<b class="nc">&nbsp;                    condition.getExpression().requiresScheduledReevaluation()) {</b>
<b class="nc">&nbsp;                    AlarmEvalResult result = doEval(false, ctx);</b>
<b class="nc">&nbsp;                    if (result.getStatus() == TRUE) {</b>
<b class="nc">&nbsp;                        return result;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        return AlarmEvalResult.EMPTY;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;            case DURATION -&gt; {
<b class="nc">&nbsp;                if (!active) {</b>
<b class="nc">&nbsp;                    return AlarmEvalResult.FALSE;</b>
&nbsp;                }
<b class="nc">&nbsp;                long requiredDuration = getRequiredDurationInMs();</b>
<b class="nc">&nbsp;                if (requiredDuration &gt; 0 &amp;&amp; firstEventTs &gt; 0 &amp;&amp; ts &gt; firstEventTs) {</b>
<b class="nc">&nbsp;                    duration = ts - firstEventTs;</b>
<b class="nc">&nbsp;                    long prevDuration = lastCheckTs - firstEventTs;</b>
<b class="nc">&nbsp;                    lastCheckTs = ts;</b>
&nbsp;
<b class="nc">&nbsp;                    long leftDuration = requiredDuration - duration;</b>
<b class="nc">&nbsp;                    if (leftDuration &lt;= 0) {</b>
<b class="nc">&nbsp;                        if (prevDuration &gt;= requiredDuration) {</b>
&nbsp;                            // already evaluated as true on previous check, no need to update alarm
<b class="nc">&nbsp;                            return AlarmEvalResult.EMPTY;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        return AlarmEvalResult.TRUE;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        return AlarmEvalResult.notYetTrue(0, leftDuration);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return AlarmEvalResult.EMPTY;</b>
&nbsp;    }
&nbsp;
&nbsp;    public AlarmEvalResult doEval(boolean newEvent, CalculatedFieldCtx ctx) {
<b class="nc">&nbsp;        return switch (condition.getType()) {</b>
<b class="nc">&nbsp;            case SIMPLE -&gt; evalSimple(ctx);</b>
<b class="nc">&nbsp;            case DURATION -&gt; evalDuration(ctx);</b>
<b class="nc">&nbsp;            case REPEATING -&gt; evalRepeating(newEvent, ctx);</b>
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    private AlarmEvalResult evalSimple(CalculatedFieldCtx ctx) {
<b class="nc">&nbsp;        return eval(condition.getExpression(), ctx) ? AlarmEvalResult.TRUE : AlarmEvalResult.FALSE;</b>
&nbsp;    }
&nbsp;
&nbsp;    private AlarmEvalResult evalRepeating(boolean newEvent, CalculatedFieldCtx ctx) {
<b class="nc">&nbsp;        if (eval(condition.getExpression(), ctx)) {</b>
<b class="nc">&nbsp;            if (newEvent) {</b>
<b class="nc">&nbsp;                eventCount++;</b>
&nbsp;            }
<b class="nc">&nbsp;            long requiredRepeats = getIntValue(((RepeatingAlarmCondition) condition).getCount());</b>
<b class="nc">&nbsp;            if (requiredRepeats &gt; 0) {</b>
<b class="nc">&nbsp;                long leftRepeats = requiredRepeats - eventCount;</b>
<b class="nc">&nbsp;                return leftRepeats &lt;= 0 ? AlarmEvalResult.TRUE : AlarmEvalResult.notYetTrue(leftRepeats, 0);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return AlarmEvalResult.NOT_YET_TRUE;</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            return AlarmEvalResult.FALSE;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private AlarmEvalResult evalDuration(CalculatedFieldCtx ctx) {
<b class="nc">&nbsp;        if (eval(condition.getExpression(), ctx)) {</b>
<b class="nc">&nbsp;            long ts = System.currentTimeMillis();</b>
<b class="nc">&nbsp;            if (firstEventTs &lt;= 0) {</b>
<b class="nc">&nbsp;                firstEventTs = state.getLatestTimestamp();</b>
&nbsp;            }
<b class="nc">&nbsp;            lastCheckTs = ts;</b>
&nbsp;
<b class="nc">&nbsp;            long requiredDuration = getRequiredDurationInMs();</b>
<b class="nc">&nbsp;            if (requiredDuration &gt; 0 &amp;&amp; firstEventTs &gt; 0 &amp;&amp; ts &gt; firstEventTs) {</b>
<b class="nc">&nbsp;                duration = ts - firstEventTs;</b>
<b class="nc">&nbsp;                long leftDuration = requiredDuration - duration;</b>
<b class="nc">&nbsp;                if (leftDuration &lt;= 0) {</b>
<b class="nc">&nbsp;                    return AlarmEvalResult.TRUE;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return AlarmEvalResult.notYetTrue(0, leftDuration);</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                return AlarmEvalResult.NOT_YET_TRUE;</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            return AlarmEvalResult.FALSE;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private boolean isActive(long eventTs) {
<b class="nc">&nbsp;        if (condition.getSchedule() == null) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        AlarmSchedule schedule = state.resolveValue(condition.getSchedule(), entry -&gt; Optional.ofNullable(KvUtil.getStringValue(entry))</b>
<b class="nc">&nbsp;                .map(this::parseSchedule).orElse(null));</b>
<b class="nc">&nbsp;        boolean active = switch (schedule.getType()) {</b>
<b class="nc">&nbsp;            case ANY_TIME -&gt; true;</b>
<b class="nc">&nbsp;            case SPECIFIC_TIME -&gt; isActiveSpecific((SpecificTimeSchedule) schedule, eventTs);</b>
<b class="nc">&nbsp;            case CUSTOM -&gt; isActiveCustom((CustomTimeSchedule) schedule, eventTs);</b>
&nbsp;        };
<b class="nc">&nbsp;        log.trace(&quot;Alarm rule active = {} for schedule {}&quot;, active, schedule);</b>
<b class="nc">&nbsp;        return active;</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean isActiveSpecific(SpecificTimeSchedule schedule, long eventTs) {
<b class="nc">&nbsp;        ZoneId zoneId = SchedulerUtils.getZoneId(schedule.getTimezone());</b>
<b class="nc">&nbsp;        ZonedDateTime zdt = ZonedDateTime.ofInstant(Instant.ofEpochMilli(eventTs), zoneId);</b>
<b class="nc">&nbsp;        if (schedule.getDaysOfWeek().size() != 7) {</b>
<b class="nc">&nbsp;            int dayOfWeek = zdt.getDayOfWeek().getValue();</b>
<b class="nc">&nbsp;            if (!schedule.getDaysOfWeek().contains(dayOfWeek)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        long endsOn = schedule.getEndsOn();</b>
<b class="nc">&nbsp;        if (endsOn == 0) {</b>
&nbsp;            // 24 hours in milliseconds
<b class="nc">&nbsp;            endsOn = 86400000;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return isActive(eventTs, zoneId, zdt, schedule.getStartsOn(), endsOn);</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean isActiveCustom(CustomTimeSchedule schedule, long eventTs) {
<b class="nc">&nbsp;        ZoneId zoneId = SchedulerUtils.getZoneId(schedule.getTimezone());</b>
<b class="nc">&nbsp;        ZonedDateTime zdt = ZonedDateTime.ofInstant(Instant.ofEpochMilli(eventTs), zoneId);</b>
<b class="nc">&nbsp;        int dayOfWeek = zdt.toLocalDate().getDayOfWeek().getValue();</b>
<b class="nc">&nbsp;        for (CustomTimeScheduleItem item : schedule.getItems()) {</b>
<b class="nc">&nbsp;            if (item.getDayOfWeek() == dayOfWeek) {</b>
<b class="nc">&nbsp;                if (item.isEnabled()) {</b>
<b class="nc">&nbsp;                    long endsOn = item.getEndsOn();</b>
<b class="nc">&nbsp;                    if (endsOn == 0) {</b>
&nbsp;                        // 24 hours in milliseconds
<b class="nc">&nbsp;                        endsOn = 86400000;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return isActive(eventTs, zoneId, zdt, item.getStartsOn(), endsOn);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean isActive(long eventTs, ZoneId zoneId, ZonedDateTime zdt, long startsOn, long endsOn) {
<b class="nc">&nbsp;        long startOfDay = zdt.toLocalDate().atStartOfDay(zoneId).toInstant().toEpochMilli();</b>
<b class="nc">&nbsp;        long msFromStartOfDay = eventTs - startOfDay;</b>
<b class="nc">&nbsp;        if (startsOn &lt;= endsOn) {</b>
<b class="nc">&nbsp;            return startsOn &lt;= msFromStartOfDay &amp;&amp; endsOn &gt; msFromStartOfDay;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return startsOn &lt; msFromStartOfDay || (0 &lt; msFromStartOfDay &amp;&amp; msFromStartOfDay &lt; endsOn);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void clear() {
<b class="nc">&nbsp;        clearRepeatingConditionState();</b>
<b class="nc">&nbsp;        clearDurationConditionState();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void clearRepeatingConditionState() {
<b class="nc">&nbsp;        eventCount = 0L;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void clearDurationConditionState() {
<b class="nc">&nbsp;        firstEventTs = 0L;</b>
<b class="nc">&nbsp;        lastCheckTs = 0L;</b>
<b class="nc">&nbsp;        duration = 0L;</b>
<b class="nc">&nbsp;        if (durationCheckFuture != null) {</b>
<b class="nc">&nbsp;            durationCheckFuture.cancel(true);</b>
<b class="nc">&nbsp;            durationCheckFuture = null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void setDurationCheckFuture(ScheduledFuture&lt;?&gt; durationCheckFuture) {
<b class="nc">&nbsp;        if (this.durationCheckFuture != null) {</b>
<b class="nc">&nbsp;            log.warn(&quot;Setting new duration check future while previous is not null for state {}&quot;, this, new RuntimeException(&quot;stacktrace&quot;));</b>
<b class="nc">&nbsp;            this.durationCheckFuture.cancel(true);</b>
&nbsp;        }
<b class="nc">&nbsp;        this.durationCheckFuture = durationCheckFuture;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isEmpty() {
<b class="nc">&nbsp;        return eventCount == 0L &amp;&amp; firstEventTs == 0L &amp;&amp; lastCheckTs == 0L &amp;&amp; durationCheckFuture == null;</b>
&nbsp;    }
&nbsp;
&nbsp;    private AlarmSchedule parseSchedule(String str) {
<b class="nc">&nbsp;        ObjectNode json = (ObjectNode) JacksonUtil.toJsonNode(str);</b>
<b class="nc">&nbsp;        if (json.isEmpty()) {</b>
<b class="nc">&nbsp;            return new AnyTimeSchedule(); // only if valid json, fail otherwise</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!json.hasNonNull(&quot;type&quot;)) {</b>
&nbsp;            // deducting the schedule type
&nbsp;            AlarmScheduleType type;
<b class="nc">&nbsp;            if (json.hasNonNull(&quot;daysOfWeek&quot;)) {</b>
<b class="nc">&nbsp;                type = AlarmScheduleType.SPECIFIC_TIME;</b>
<b class="nc">&nbsp;            } else if (json.hasNonNull(&quot;items&quot;)) {</b>
<b class="nc">&nbsp;                type = AlarmScheduleType.CUSTOM;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Failed to parse alarm schedule from &#39;&quot; + str + &quot;&#39;&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            json.put(&quot;type&quot;, type.name());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return JacksonUtil.treeToValue(json, AlarmSchedule.class);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Integer getIntValue(AlarmConditionValue&lt;Integer&gt; value) {
<b class="nc">&nbsp;        return state.resolveValue(value, entry -&gt; Optional.ofNullable(KvUtil.getLongValue(entry)).map(Long::intValue).orElse(null));</b>
&nbsp;    }
&nbsp;
&nbsp;    private long getRequiredDurationInMs() {
<b class="nc">&nbsp;        DurationAlarmCondition durationCondition = (DurationAlarmCondition) condition;</b>
<b class="nc">&nbsp;        return durationCondition.getUnit().toMillis(state.resolveValue(durationCondition.getValue(), KvUtil::getLongValue));</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean eval(AlarmConditionExpression expression, CalculatedFieldCtx ctx) {
<b class="nc">&nbsp;        return state.eval(expression, ctx);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setAlarmRule(AlarmRule alarmRule) {
<b class="nc">&nbsp;        this.alarmRule = alarmRule;</b>
<b class="nc">&nbsp;        this.condition = alarmRule.getCondition();</b>
&nbsp;
&nbsp;        // clearing state for other condition types (possibly left from a previous condition type)
<b class="nc">&nbsp;        switch (condition.getType()) {</b>
&nbsp;            case SIMPLE -&gt; {
<b class="nc">&nbsp;                clearRepeatingConditionState();</b>
<b class="nc">&nbsp;                clearDurationConditionState();</b>
&nbsp;            }
&nbsp;            case REPEATING -&gt; {
<b class="nc">&nbsp;                clearDurationConditionState();</b>
&nbsp;            }
&nbsp;            case DURATION -&gt; {
<b class="nc">&nbsp;                clearRepeatingConditionState();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public StateInfo getStateInfo() {
<b class="nc">&nbsp;        if (condition.getType() == AlarmConditionType.REPEATING) {</b>
<b class="nc">&nbsp;            return new StateInfo(eventCount, null);</b>
<b class="nc">&nbsp;        } else if (condition.getType() == AlarmConditionType.DURATION) {</b>
<b class="nc">&nbsp;            return new StateInfo(null, duration);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return StateInfo.EMPTY;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="nc">&nbsp;        return &quot;AlarmRuleState{&quot; +</b>
&nbsp;               &quot;severity=&quot; + severity +
&nbsp;               &quot;, condition=&quot; + condition +
&nbsp;               &quot;, eventCount=&quot; + eventCount +
&nbsp;               &quot;, firstEventTs=&quot; + firstEventTs +
&nbsp;               &quot;, lastCheckTs=&quot; + lastCheckTs +
&nbsp;               &quot;, duration=&quot; + duration +
&nbsp;               &quot;, durationCheckFuture=&quot; + durationCheckFuture +
&nbsp;               &#39;}&#39;;
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public record StateInfo(Long eventCount, Long duration) {</b>
&nbsp;
<b class="nc">&nbsp;        static final StateInfo EMPTY = new StateInfo(null, null);</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
