<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > DeviceActorMessageProcessor</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.server.actors.device</a>
</div>

<h1>Coverage Summary for Class: DeviceActorMessageProcessor (org.thingsboard.server.actors.device)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DeviceActorMessageProcessor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/61)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/274)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/557)
  </span>
</td>
</tr>
  <tr>
    <td class="name">DeviceActorMessageProcessor$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DeviceActorMessageProcessor$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DeviceActorMessageProcessor$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DeviceActorMessageProcessor$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/71)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/278)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/587)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.server.actors.device;
&nbsp;
&nbsp;import com.fasterxml.jackson.databind.JsonNode;
&nbsp;import com.fasterxml.jackson.databind.node.ObjectNode;
&nbsp;import com.google.common.util.concurrent.FutureCallback;
&nbsp;import com.google.common.util.concurrent.Futures;
&nbsp;import com.google.common.util.concurrent.ListenableFuture;
&nbsp;import com.google.common.util.concurrent.MoreExecutors;
&nbsp;import jakarta.annotation.Nullable;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.apache.commons.collections4.CollectionUtils;
&nbsp;import org.thingsboard.common.util.JacksonUtil;
&nbsp;import org.thingsboard.common.util.LinkedHashMapRemoveEldest;
&nbsp;import org.thingsboard.server.actors.ActorSystemContext;
&nbsp;import org.thingsboard.server.actors.TbActorCtx;
&nbsp;import org.thingsboard.server.actors.shared.AbstractContextAwareMsgProcessor;
&nbsp;import org.thingsboard.server.common.data.AttributeScope;
&nbsp;import org.thingsboard.server.common.data.DataConstants;
&nbsp;import org.thingsboard.server.common.data.Device;
&nbsp;import org.thingsboard.server.common.data.EdgeUtils;
&nbsp;import org.thingsboard.server.common.data.StringUtils;
&nbsp;import org.thingsboard.server.common.data.edge.EdgeEvent;
&nbsp;import org.thingsboard.server.common.data.edge.EdgeEventActionType;
&nbsp;import org.thingsboard.server.common.data.edge.EdgeEventType;
&nbsp;import org.thingsboard.server.common.data.id.DeviceId;
&nbsp;import org.thingsboard.server.common.data.id.EdgeId;
&nbsp;import org.thingsboard.server.common.data.id.RpcId;
&nbsp;import org.thingsboard.server.common.data.id.TenantId;
&nbsp;import org.thingsboard.server.common.data.kv.AttributeKey;
&nbsp;import org.thingsboard.server.common.data.kv.AttributeKvEntry;
&nbsp;import org.thingsboard.server.common.data.page.PageData;
&nbsp;import org.thingsboard.server.common.data.page.PageLink;
&nbsp;import org.thingsboard.server.common.data.page.SortOrder;
&nbsp;import org.thingsboard.server.common.data.relation.EntityRelation;
&nbsp;import org.thingsboard.server.common.data.relation.RelationTypeGroup;
&nbsp;import org.thingsboard.server.common.data.rpc.Rpc;
&nbsp;import org.thingsboard.server.common.data.rpc.RpcError;
&nbsp;import org.thingsboard.server.common.data.rpc.RpcStatus;
&nbsp;import org.thingsboard.server.common.data.rpc.ToDeviceRpcRequestBody;
&nbsp;import org.thingsboard.server.common.data.security.DeviceCredentials;
&nbsp;import org.thingsboard.server.common.data.security.DeviceCredentialsType;
&nbsp;import org.thingsboard.server.common.msg.TbActorMsg;
&nbsp;import org.thingsboard.server.common.msg.TbMsgMetaData;
&nbsp;import org.thingsboard.server.common.msg.edge.EdgeHighPriorityMsg;
&nbsp;import org.thingsboard.server.common.msg.queue.TbCallback;
&nbsp;import org.thingsboard.server.common.msg.rpc.FromDeviceRpcResponse;
&nbsp;import org.thingsboard.server.common.msg.rpc.FromDeviceRpcResponseActorMsg;
&nbsp;import org.thingsboard.server.common.msg.rpc.RemoveRpcActorMsg;
&nbsp;import org.thingsboard.server.common.msg.rpc.ToDeviceRpcRequest;
&nbsp;import org.thingsboard.server.common.msg.rpc.ToDeviceRpcRequestActorMsg;
&nbsp;import org.thingsboard.server.common.msg.rule.engine.DeviceAttributesEventNotificationMsg;
&nbsp;import org.thingsboard.server.common.msg.rule.engine.DeviceCredentialsUpdateNotificationMsg;
&nbsp;import org.thingsboard.server.common.msg.rule.engine.DeviceEdgeUpdateMsg;
&nbsp;import org.thingsboard.server.common.msg.rule.engine.DeviceNameOrTypeUpdateMsg;
&nbsp;import org.thingsboard.server.common.msg.timeout.DeviceActorServerSideRpcTimeoutMsg;
&nbsp;import org.thingsboard.server.common.util.KvProtoUtil;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.AttributeUpdateNotificationMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.ClaimDeviceMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.DeviceSessionsCacheEntry;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.GetAttributeRequestMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.GetAttributeResponseMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.SessionCloseNotificationProto;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.SessionCloseReason;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.SessionEvent;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.SessionEventMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.SessionInfoProto;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.SessionSubscriptionInfoProto;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.SessionType;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.SubscribeToAttributeUpdatesMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.SubscribeToRPCMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.SubscriptionInfoProto;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.ToDeviceRpcRequestMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.ToDeviceRpcResponseMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.ToDeviceRpcResponseStatusMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.ToTransportMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.ToTransportUpdateCredentialsProto;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.TransportToDeviceActorMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.TsKvProto;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.UplinkNotificationMsg;
&nbsp;import org.thingsboard.server.service.rpc.RpcSubmitStrategy;
&nbsp;import org.thingsboard.server.service.state.DefaultDeviceStateService;
&nbsp;import org.thingsboard.server.service.transport.msg.TransportToDeviceActorMsgWrapper;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Objects;
&nbsp;import java.util.Optional;
&nbsp;import java.util.Set;
&nbsp;import java.util.UUID;
&nbsp;import java.util.concurrent.ExecutionException;
&nbsp;import java.util.concurrent.ScheduledExecutorService;
&nbsp;import java.util.concurrent.ScheduledFuture;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.function.Consumer;
&nbsp;import java.util.stream.Collectors;
&nbsp;
<b class="nc">&nbsp;@Slf4j</b>
&nbsp;public class DeviceActorMessageProcessor extends AbstractContextAwareMsgProcessor {
&nbsp;
&nbsp;    final TenantId tenantId;
&nbsp;    final DeviceId deviceId;
&nbsp;    final LinkedHashMapRemoveEldest&lt;UUID, SessionInfoMetaData&gt; sessions;
&nbsp;    final Map&lt;UUID, SessionInfo&gt; attributeSubscriptions;
&nbsp;    final Map&lt;UUID, SessionInfo&gt; rpcSubscriptions;
&nbsp;    private final Map&lt;Integer, ToDeviceRpcRequestMetadata&gt; toDeviceRpcPendingMap;
&nbsp;    private final boolean rpcSequential;
&nbsp;    private final RpcSubmitStrategy rpcSubmitStrategy;
&nbsp;    private final ScheduledExecutorService scheduler;
&nbsp;    private final boolean closeTransportSessionOnRpcDeliveryTimeout;
&nbsp;
<b class="nc">&nbsp;    private int rpcSeq = 0;</b>
&nbsp;    private String deviceName;
&nbsp;    private String deviceType;
&nbsp;    private TbMsgMetaData defaultMetaData;
&nbsp;    private EdgeId edgeId;
&nbsp;    private ScheduledFuture&lt;?&gt; awaitRpcResponseFuture;
&nbsp;
&nbsp;    DeviceActorMessageProcessor(ActorSystemContext systemContext, TenantId tenantId, DeviceId deviceId) {
<b class="nc">&nbsp;        super(systemContext);</b>
<b class="nc">&nbsp;        this.tenantId = tenantId;</b>
<b class="nc">&nbsp;        this.deviceId = deviceId;</b>
<b class="nc">&nbsp;        this.rpcSubmitStrategy = RpcSubmitStrategy.parse(systemContext.getRpcSubmitStrategy());</b>
<b class="nc">&nbsp;        this.closeTransportSessionOnRpcDeliveryTimeout = systemContext.isCloseTransportSessionOnRpcDeliveryTimeout();</b>
<b class="nc">&nbsp;        this.rpcSequential = !rpcSubmitStrategy.equals(RpcSubmitStrategy.BURST);</b>
<b class="nc">&nbsp;        this.attributeSubscriptions = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        this.rpcSubscriptions = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        this.toDeviceRpcPendingMap = new LinkedHashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        this.sessions = new LinkedHashMapRemoveEldest&lt;&gt;(systemContext.getMaxConcurrentSessionsPerDevice(), this::notifyTransportAboutClosedSessionMaxSessionsLimit);</b>
<b class="nc">&nbsp;        this.scheduler = systemContext.getScheduler();</b>
<b class="nc">&nbsp;        if (initAttributes()) {</b>
<b class="nc">&nbsp;            restoreSessions();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    boolean initAttributes() {
<b class="nc">&nbsp;        Device device = systemContext.getDeviceService().findDeviceById(tenantId, deviceId);</b>
<b class="nc">&nbsp;        if (device != null) {</b>
<b class="nc">&nbsp;            this.deviceName = device.getName();</b>
<b class="nc">&nbsp;            this.deviceType = device.getType();</b>
<b class="nc">&nbsp;            this.defaultMetaData = new TbMsgMetaData();</b>
<b class="nc">&nbsp;            this.defaultMetaData.putValue(&quot;deviceName&quot;, deviceName);</b>
<b class="nc">&nbsp;            this.defaultMetaData.putValue(&quot;deviceType&quot;, deviceType);</b>
<b class="nc">&nbsp;            if (systemContext.isEdgesEnabled()) {</b>
<b class="nc">&nbsp;                this.edgeId = findRelatedEdgeId();</b>
&nbsp;            }
<b class="nc">&nbsp;            return true;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private EdgeId findRelatedEdgeId() {
<b class="nc">&nbsp;        List&lt;EntityRelation&gt; result =</b>
<b class="nc">&nbsp;                systemContext.getRelationService().findByToAndType(tenantId, deviceId, EntityRelation.CONTAINS_TYPE, RelationTypeGroup.EDGE);</b>
<b class="nc">&nbsp;        if (result != null &amp;&amp; !result.isEmpty()) {</b>
<b class="nc">&nbsp;            EntityRelation relationToEdge = result.get(0);</b>
<b class="nc">&nbsp;            if (relationToEdge.getFrom() != null &amp;&amp; relationToEdge.getFrom().getId() != null) {</b>
<b class="nc">&nbsp;                log.trace(&quot;[{}][{}] found edge [{}] for device&quot;, tenantId, deviceId, relationToEdge.getFrom().getId());</b>
<b class="nc">&nbsp;                return new EdgeId(relationToEdge.getFrom().getId());</b>
&nbsp;            } else {
<b class="nc">&nbsp;                log.trace(&quot;[{}][{}] edge relation is empty {}&quot;, tenantId, deviceId, relationToEdge);</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}] device doesn&#39;t have any related edge&quot;, tenantId, deviceId);</b>
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    void processRpcRequest(TbActorCtx context, ToDeviceRpcRequestActorMsg msg) {
<b class="nc">&nbsp;        ToDeviceRpcRequest request = msg.getMsg();</b>
<b class="nc">&nbsp;        UUID rpcId = request.getId();</b>
<b class="nc">&nbsp;        log.debug(&quot;[{}][{}] Received RPC request to process ...&quot;, deviceId, rpcId);</b>
<b class="nc">&nbsp;        ToDeviceRpcRequestMsg rpcRequest = createToDeviceRpcRequestMsg(request);</b>
&nbsp;
<b class="nc">&nbsp;        long timeout = request.getExpirationTime() - System.currentTimeMillis();</b>
<b class="nc">&nbsp;        boolean persisted = request.isPersisted();</b>
&nbsp;
<b class="nc">&nbsp;        if (timeout &lt;= 0) {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}][{}] Ignoring message due to exp time reached, {}&quot;, deviceId, rpcId, request.getExpirationTime());</b>
<b class="nc">&nbsp;            if (persisted) {</b>
<b class="nc">&nbsp;                createRpc(request, RpcStatus.EXPIRED);</b>
&nbsp;            }
&nbsp;            return;
<b class="nc">&nbsp;        } else if (persisted) {</b>
<b class="nc">&nbsp;            createRpc(request, RpcStatus.QUEUED);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        boolean sent = false;</b>
<b class="nc">&nbsp;        int requestId = rpcRequest.getRequestId();</b>
<b class="nc">&nbsp;        if (systemContext.isEdgesEnabled() &amp;&amp; edgeId != null) {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}][{}] device is related to edge: [{}]. Saving RPC request: [{}][{}] to edge queue&quot;, tenantId, deviceId, edgeId.getId(), rpcId, requestId);</b>
&nbsp;            try {
<b class="nc">&nbsp;                if (systemContext.getEdgeService().isEdgeActiveAsync(tenantId, edgeId, DefaultDeviceStateService.ACTIVITY_STATE).get()) {</b>
<b class="nc">&nbsp;                    saveRpcRequestToEdgeQueue(request, requestId);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    log.error(&quot;[{}][{}][{}] Failed to save RPC request to edge queue {}. The Edge is currently offline or unreachable&quot;, tenantId, deviceId, edgeId.getId(), request);</b>
&nbsp;                }
&nbsp;            } catch (InterruptedException | ExecutionException e) {
<b class="nc">&nbsp;                log.error(&quot;[{}][{}][{}] Failed to save RPC request to edge queue {}&quot;, tenantId, deviceId, edgeId.getId(), request, e);</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (isSendNewRpcAvailable()) {</b>
<b class="nc">&nbsp;            sent = !rpcSubscriptions.isEmpty();</b>
<b class="nc">&nbsp;            Set&lt;UUID&gt; syncSessionSet = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;            rpcSubscriptions.forEach((sessionId, sessionInfo) -&gt; {</b>
<b class="nc">&nbsp;                log.debug(&quot;[{}][{}][{}][{}] send RPC request to transport ...&quot;, deviceId, sessionId, rpcId, requestId);</b>
<b class="nc">&nbsp;                sendToTransport(rpcRequest, sessionId, sessionInfo.getNodeId());</b>
<b class="nc">&nbsp;                if (SessionType.SYNC == sessionInfo.getType()) {</b>
<b class="nc">&nbsp;                    syncSessionSet.add(sessionId);</b>
&nbsp;                }
&nbsp;            });
<b class="nc">&nbsp;            log.trace(&quot;Rpc syncSessionSet [{}] subscription after sent [{}]&quot;, syncSessionSet, rpcSubscriptions);</b>
<b class="nc">&nbsp;            syncSessionSet.forEach(rpcSubscriptions::remove);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (persisted) {</b>
<b class="nc">&nbsp;            ObjectNode response = JacksonUtil.newObjectNode();</b>
<b class="nc">&nbsp;            response.put(&quot;rpcId&quot;, rpcId.toString());</b>
<b class="nc">&nbsp;            systemContext.getTbCoreDeviceRpcService().processRpcResponseFromDeviceActor(new FromDeviceRpcResponse(rpcId, JacksonUtil.toString(response), null));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!persisted &amp;&amp; request.isOneway() &amp;&amp; sent) {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}] RPC command response sent [{}][{}]!&quot;, deviceId, rpcId, requestId);</b>
<b class="nc">&nbsp;            systemContext.getTbCoreDeviceRpcService().processRpcResponseFromDeviceActor(new FromDeviceRpcResponse(rpcId, null, null));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            registerPendingRpcRequest(context, msg, sent, rpcRequest, timeout);</b>
&nbsp;        }
<b class="nc">&nbsp;        String rpcSent = sent ? &quot;sent!&quot; : &quot;NOT sent!&quot;;</b>
<b class="nc">&nbsp;        log.debug(&quot;[{}][{}][{}] RPC request is {}&quot;, deviceId, rpcId, requestId, rpcSent);</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean isSendNewRpcAvailable() {
<b class="nc">&nbsp;        return switch (rpcSubmitStrategy) {</b>
<b class="nc">&nbsp;            case SEQUENTIAL_ON_ACK_FROM_DEVICE -&gt; toDeviceRpcPendingMap.values().stream().filter(md -&gt; !md.isDelivered()).findAny().isEmpty();</b>
<b class="nc">&nbsp;            case SEQUENTIAL_ON_RESPONSE_FROM_DEVICE -&gt; toDeviceRpcPendingMap.isEmpty();</b>
<b class="nc">&nbsp;            default -&gt; true;</b>
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    private void createRpc(ToDeviceRpcRequest request, RpcStatus status) {
<b class="nc">&nbsp;        Rpc rpc = new Rpc(new RpcId(request.getId()));</b>
<b class="nc">&nbsp;        rpc.setCreatedTime(System.currentTimeMillis());</b>
<b class="nc">&nbsp;        rpc.setTenantId(tenantId);</b>
<b class="nc">&nbsp;        rpc.setDeviceId(deviceId);</b>
<b class="nc">&nbsp;        rpc.setExpirationTime(request.getExpirationTime());</b>
<b class="nc">&nbsp;        rpc.setRequest(JacksonUtil.valueToTree(request));</b>
<b class="nc">&nbsp;        rpc.setStatus(status);</b>
<b class="nc">&nbsp;        rpc.setAdditionalInfo(getAdditionalInfo(request));</b>
<b class="nc">&nbsp;        systemContext.getTbRpcService().save(tenantId, rpc);</b>
&nbsp;    }
&nbsp;
&nbsp;    private JsonNode getAdditionalInfo(ToDeviceRpcRequest request) {
&nbsp;        try {
<b class="nc">&nbsp;            return JacksonUtil.toJsonNode(request.getAdditionalInfo());</b>
&nbsp;        } catch (IllegalArgumentException e) {
<b class="nc">&nbsp;            log.debug(&quot;Failed to parse additional info [{}]&quot;, request.getAdditionalInfo());</b>
<b class="nc">&nbsp;            return JacksonUtil.valueToTree(request.getAdditionalInfo());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private ToDeviceRpcRequestMsg createToDeviceRpcRequestMsg(ToDeviceRpcRequest request) {
<b class="nc">&nbsp;        ToDeviceRpcRequestBody body = request.getBody();</b>
<b class="nc">&nbsp;        return ToDeviceRpcRequestMsg.newBuilder()</b>
<b class="nc">&nbsp;                .setRequestId(rpcSeq++)</b>
<b class="nc">&nbsp;                .setMethodName(body.getMethod())</b>
<b class="nc">&nbsp;                .setParams(body.getParams())</b>
<b class="nc">&nbsp;                .setExpirationTime(request.getExpirationTime())</b>
<b class="nc">&nbsp;                .setRequestIdMSB(request.getId().getMostSignificantBits())</b>
<b class="nc">&nbsp;                .setRequestIdLSB(request.getId().getLeastSignificantBits())</b>
<b class="nc">&nbsp;                .setOneway(request.isOneway())</b>
<b class="nc">&nbsp;                .setPersisted(request.isPersisted())</b>
<b class="nc">&nbsp;                .build();</b>
&nbsp;    }
&nbsp;
&nbsp;    void processRpcResponsesFromEdge(FromDeviceRpcResponseActorMsg responseMsg) {
<b class="nc">&nbsp;        log.debug(&quot;[{}] Processing RPC command response from edge session&quot;, deviceId);</b>
<b class="nc">&nbsp;        ToDeviceRpcRequestMetadata requestMd = toDeviceRpcPendingMap.remove(responseMsg.getRequestId());</b>
<b class="nc">&nbsp;        boolean success = requestMd != null;</b>
<b class="nc">&nbsp;        if (success) {</b>
<b class="nc">&nbsp;            systemContext.getTbCoreDeviceRpcService().processRpcResponseFromDeviceActor(responseMsg.getMsg());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            log.debug(&quot;[{}] RPC command response [{}] is stale!&quot;, deviceId, responseMsg.getRequestId());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    void processRemoveRpc(RemoveRpcActorMsg msg) {
<b class="nc">&nbsp;        UUID rpcId = msg.getRequestId();</b>
<b class="nc">&nbsp;        log.debug(&quot;[{}][{}] Received remove RPC request ...&quot;, deviceId, rpcId);</b>
<b class="nc">&nbsp;        Map.Entry&lt;Integer, ToDeviceRpcRequestMetadata&gt; entry = null;</b>
<b class="nc">&nbsp;        for (Map.Entry&lt;Integer, ToDeviceRpcRequestMetadata&gt; e : toDeviceRpcPendingMap.entrySet()) {</b>
<b class="nc">&nbsp;            if (e.getValue().getMsg().getMsg().getId().equals(rpcId)) {</b>
<b class="nc">&nbsp;                entry = e;</b>
&nbsp;                break;
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (entry != null) {</b>
<b class="nc">&nbsp;            Integer requestId = entry.getKey();</b>
<b class="nc">&nbsp;            if (entry.getValue().isDelivered()) {</b>
<b class="nc">&nbsp;                toDeviceRpcPendingMap.remove(requestId);</b>
<b class="nc">&nbsp;                if (rpcSubmitStrategy.equals(RpcSubmitStrategy.SEQUENTIAL_ON_RESPONSE_FROM_DEVICE)) {</b>
<b class="nc">&nbsp;                    clearAwaitRpcResponseScheduler();</b>
<b class="nc">&nbsp;                    sendNextPendingRequest(rpcId, requestId, &quot;Removed pending RPC!&quot;);</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                Optional&lt;Map.Entry&lt;Integer, ToDeviceRpcRequestMetadata&gt;&gt; firstRpc = getFirstRpc();</b>
<b class="nc">&nbsp;                if (firstRpc.isPresent() &amp;&amp; requestId.equals(firstRpc.get().getKey())) {</b>
<b class="nc">&nbsp;                    toDeviceRpcPendingMap.remove(requestId);</b>
<b class="nc">&nbsp;                    sendNextPendingRequest(rpcId, requestId, &quot;Removed pending RPC!&quot;);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    toDeviceRpcPendingMap.remove(requestId);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void registerPendingRpcRequest(TbActorCtx context, ToDeviceRpcRequestActorMsg msg, boolean sent, ToDeviceRpcRequestMsg rpcRequest, long timeout) {
<b class="nc">&nbsp;        int requestId = rpcRequest.getRequestId();</b>
<b class="nc">&nbsp;        UUID rpcId = new UUID(rpcRequest.getRequestIdMSB(), rpcRequest.getRequestIdLSB());</b>
<b class="nc">&nbsp;        log.debug(&quot;[{}][{}][{}] Registering pending RPC request...&quot;, deviceId, rpcId, requestId);</b>
<b class="nc">&nbsp;        toDeviceRpcPendingMap.put(requestId, new ToDeviceRpcRequestMetadata(msg, sent));</b>
<b class="nc">&nbsp;        DeviceActorServerSideRpcTimeoutMsg timeoutMsg = new DeviceActorServerSideRpcTimeoutMsg(requestId, timeout);</b>
<b class="nc">&nbsp;        scheduleMsgWithDelay(context, timeoutMsg, timeoutMsg.getTimeout());</b>
&nbsp;    }
&nbsp;
&nbsp;    void processServerSideRpcTimeout(DeviceActorServerSideRpcTimeoutMsg msg) {
<b class="nc">&nbsp;        Integer requestId = msg.getId();</b>
<b class="nc">&nbsp;        var requestMd = toDeviceRpcPendingMap.remove(requestId);</b>
<b class="nc">&nbsp;        if (requestMd != null) {</b>
<b class="nc">&nbsp;            var toDeviceRpcRequest = requestMd.getMsg().getMsg();</b>
<b class="nc">&nbsp;            UUID rpcId = toDeviceRpcRequest.getId();</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}][{}][{}] RPC request timeout detected!&quot;, deviceId, rpcId, requestId);</b>
<b class="nc">&nbsp;            if (toDeviceRpcRequest.isPersisted()) {</b>
<b class="nc">&nbsp;                systemContext.getTbRpcService().save(tenantId, new RpcId(rpcId), RpcStatus.EXPIRED, null);</b>
&nbsp;            }
<b class="nc">&nbsp;            systemContext.getTbCoreDeviceRpcService().processRpcResponseFromDeviceActor(new FromDeviceRpcResponse(rpcId,</b>
<b class="nc">&nbsp;                    null, requestMd.isSent() ? RpcError.TIMEOUT : RpcError.NO_ACTIVE_CONNECTION));</b>
<b class="nc">&nbsp;            if (!requestMd.isDelivered()) {</b>
<b class="nc">&nbsp;                sendNextPendingRequest(rpcId, requestId, &quot;Pending RPC timeout detected!&quot;);</b>
&nbsp;                return;
&nbsp;            }
<b class="nc">&nbsp;            if (rpcSubmitStrategy.equals(RpcSubmitStrategy.SEQUENTIAL_ON_RESPONSE_FROM_DEVICE)) {</b>
<b class="nc">&nbsp;                clearAwaitRpcResponseScheduler();</b>
<b class="nc">&nbsp;                sendNextPendingRequest(rpcId, requestId, &quot;Pending RPC timeout detected!&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void sendPendingRequests(UUID sessionId, String nodeId) {
<b class="nc">&nbsp;        SessionType sessionType = getSessionType(sessionId);</b>
<b class="nc">&nbsp;        if (!toDeviceRpcPendingMap.isEmpty()) {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}] Pushing {} pending RPC messages to session: [{}]&quot;, deviceId, sessionId, toDeviceRpcPendingMap.size());</b>
<b class="nc">&nbsp;            if (sessionType == SessionType.SYNC) {</b>
<b class="nc">&nbsp;                log.debug(&quot;[{}] Cleanup sync RPC session [{}]&quot;, deviceId, sessionId);</b>
<b class="nc">&nbsp;                rpcSubscriptions.remove(sessionId);</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            log.debug(&quot;[{}] No pending RPC messages for session: [{}]&quot;, deviceId, sessionId);</b>
&nbsp;        }
<b class="nc">&nbsp;        Set&lt;Integer&gt; sentOneWayIds = new HashSet&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        if (rpcSequential) {</b>
<b class="nc">&nbsp;            getFirstRpc().ifPresent(processPendingRpc(sessionId, nodeId, sentOneWayIds));</b>
<b class="nc">&nbsp;        } else if (sessionType == SessionType.ASYNC) {</b>
<b class="nc">&nbsp;            toDeviceRpcPendingMap.entrySet().forEach(processPendingRpc(sessionId, nodeId, sentOneWayIds));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            toDeviceRpcPendingMap.entrySet().stream().findFirst().ifPresent(processPendingRpc(sessionId, nodeId, sentOneWayIds));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        sentOneWayIds.stream().filter(id -&gt; !toDeviceRpcPendingMap.get(id).getMsg().getMsg().isPersisted()).forEach(toDeviceRpcPendingMap::remove);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Optional&lt;Map.Entry&lt;Integer, ToDeviceRpcRequestMetadata&gt;&gt; getFirstRpc() {
<b class="nc">&nbsp;        if (rpcSubmitStrategy.equals(RpcSubmitStrategy.SEQUENTIAL_ON_RESPONSE_FROM_DEVICE)) {</b>
<b class="nc">&nbsp;            return toDeviceRpcPendingMap.entrySet().stream()</b>
<b class="nc">&nbsp;                    .findFirst().filter(entry -&gt; {</b>
<b class="nc">&nbsp;                        var md = entry.getValue();</b>
<b class="nc">&nbsp;                        if (md.isDelivered()) {</b>
<b class="nc">&nbsp;                            if (awaitRpcResponseFuture == null || awaitRpcResponseFuture.isCancelled()) {</b>
<b class="nc">&nbsp;                                var toDeviceRpcRequest = md.getMsg().getMsg();</b>
<b class="nc">&nbsp;                                awaitRpcResponseFuture = scheduleAwaitRpcResponseFuture(toDeviceRpcRequest.getId(), entry.getKey());</b>
&nbsp;                            }
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    });
&nbsp;        }
<b class="nc">&nbsp;        return toDeviceRpcPendingMap.entrySet().stream().filter(e -&gt; !e.getValue().isDelivered()).findFirst();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void sendNextPendingRequest(UUID rpcId, int requestId, String logMessage) {
<b class="nc">&nbsp;        log.debug(&quot;[{}][{}][{}] {} Going to send next pending request ...&quot;, deviceId, rpcId, requestId, logMessage);</b>
<b class="nc">&nbsp;        if (rpcSequential) {</b>
<b class="nc">&nbsp;            rpcSubscriptions.forEach((id, s) -&gt; sendPendingRequests(id, s.getNodeId()));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private Consumer&lt;Map.Entry&lt;Integer, ToDeviceRpcRequestMetadata&gt;&gt; processPendingRpc(UUID sessionId, String nodeId, Set&lt;Integer&gt; sentOneWayIds) {
<b class="nc">&nbsp;        return entry -&gt; {</b>
<b class="nc">&nbsp;            ToDeviceRpcRequest request = entry.getValue().getMsg().getMsg();</b>
<b class="nc">&nbsp;            ToDeviceRpcRequestBody body = request.getBody();</b>
<b class="nc">&nbsp;            Integer requestId = entry.getKey();</b>
<b class="nc">&nbsp;            UUID rpcId = request.getId();</b>
<b class="nc">&nbsp;            if (request.isOneway() &amp;&amp; !rpcSequential) {</b>
<b class="nc">&nbsp;                sentOneWayIds.add(requestId);</b>
<b class="nc">&nbsp;                systemContext.getTbCoreDeviceRpcService().processRpcResponseFromDeviceActor(new FromDeviceRpcResponse(rpcId, null, null));</b>
&nbsp;            }
<b class="nc">&nbsp;            ToDeviceRpcRequestMsg rpcRequest = ToDeviceRpcRequestMsg.newBuilder()</b>
<b class="nc">&nbsp;                    .setRequestId(requestId)</b>
<b class="nc">&nbsp;                    .setMethodName(body.getMethod())</b>
<b class="nc">&nbsp;                    .setParams(body.getParams())</b>
<b class="nc">&nbsp;                    .setExpirationTime(request.getExpirationTime())</b>
<b class="nc">&nbsp;                    .setRequestIdMSB(rpcId.getMostSignificantBits())</b>
<b class="nc">&nbsp;                    .setRequestIdLSB(rpcId.getLeastSignificantBits())</b>
<b class="nc">&nbsp;                    .setOneway(request.isOneway())</b>
<b class="nc">&nbsp;                    .setPersisted(request.isPersisted())</b>
<b class="nc">&nbsp;                    .build();</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}][{}][{}][{}] Send pending RPC request to transport ...&quot;, deviceId, sessionId, rpcId, requestId);</b>
<b class="nc">&nbsp;            sendToTransport(rpcRequest, sessionId, nodeId);</b>
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    void process(TransportToDeviceActorMsgWrapper wrapper) {
<b class="nc">&nbsp;        TransportToDeviceActorMsg msg = wrapper.getMsg();</b>
<b class="nc">&nbsp;        TbCallback callback = wrapper.getCallback();</b>
<b class="nc">&nbsp;        var sessionInfo = msg.getSessionInfo();</b>
&nbsp;
<b class="nc">&nbsp;        if (msg.hasSessionEvent()) {</b>
<b class="nc">&nbsp;            processSessionStateMsgs(sessionInfo, msg.getSessionEvent());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (msg.hasSubscribeToAttributes()) {</b>
<b class="nc">&nbsp;            processSubscriptionCommands(sessionInfo, msg.getSubscribeToAttributes());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (msg.hasSubscribeToRPC()) {</b>
<b class="nc">&nbsp;            processSubscriptionCommands(sessionInfo, msg.getSubscribeToRPC());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (msg.hasSendPendingRPC()) {</b>
<b class="nc">&nbsp;            sendPendingRequests(getSessionId(sessionInfo), sessionInfo.getNodeId());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (msg.hasGetAttributes()) {</b>
<b class="nc">&nbsp;            handleGetAttributesRequest(sessionInfo, msg.getGetAttributes());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (msg.hasToDeviceRPCCallResponse()) {</b>
<b class="nc">&nbsp;            processRpcResponses(sessionInfo, msg.getToDeviceRPCCallResponse());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (msg.hasSubscriptionInfo()) {</b>
<b class="nc">&nbsp;            handleSessionActivity(sessionInfo, msg.getSubscriptionInfo());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (msg.hasClaimDevice()) {</b>
<b class="nc">&nbsp;            handleClaimDeviceMsg(sessionInfo, msg.getClaimDevice());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (msg.hasRpcResponseStatusMsg()) {</b>
<b class="nc">&nbsp;            processRpcResponseStatus(sessionInfo, msg.getRpcResponseStatusMsg());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (msg.hasUplinkNotificationMsg()) {</b>
<b class="nc">&nbsp;            processUplinkNotificationMsg(sessionInfo, msg.getUplinkNotificationMsg());</b>
&nbsp;        }
<b class="nc">&nbsp;        callback.onSuccess();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void processUplinkNotificationMsg(SessionInfoProto sessionInfo, UplinkNotificationMsg uplinkNotificationMsg) {
<b class="nc">&nbsp;        String nodeId = sessionInfo.getNodeId();</b>
<b class="nc">&nbsp;        sessions.entrySet().stream()</b>
<b class="nc">&nbsp;                .filter(kv -&gt; kv.getValue().getSessionInfo().getNodeId().equals(nodeId) &amp;&amp; (kv.getValue().isSubscribedToAttributes() || kv.getValue().isSubscribedToRPC()))</b>
<b class="nc">&nbsp;                .forEach(kv -&gt; {</b>
<b class="nc">&nbsp;                    ToTransportMsg msg = ToTransportMsg.newBuilder()</b>
<b class="nc">&nbsp;                            .setSessionIdMSB(kv.getKey().getMostSignificantBits())</b>
<b class="nc">&nbsp;                            .setSessionIdLSB(kv.getKey().getLeastSignificantBits())</b>
<b class="nc">&nbsp;                            .setUplinkNotificationMsg(uplinkNotificationMsg)</b>
<b class="nc">&nbsp;                            .build();</b>
<b class="nc">&nbsp;                    systemContext.getTbCoreToTransportService().process(kv.getValue().getSessionInfo().getNodeId(), msg);</b>
&nbsp;                });
&nbsp;    }
&nbsp;
&nbsp;    private void handleClaimDeviceMsg(SessionInfoProto sessionInfo, ClaimDeviceMsg msg) {
<b class="nc">&nbsp;        UUID sessionId = getSessionId(sessionInfo);</b>
<b class="nc">&nbsp;        DeviceId deviceId = new DeviceId(new UUID(msg.getDeviceIdMSB(), msg.getDeviceIdLSB()));</b>
<b class="nc">&nbsp;        ListenableFuture&lt;Void&gt; registrationFuture = systemContext.getClaimDevicesService()</b>
<b class="nc">&nbsp;                .registerClaimingInfo(tenantId, deviceId, msg.getSecretKey(), msg.getDurationMs());</b>
<b class="nc">&nbsp;        Futures.addCallback(registrationFuture, new FutureCallback&lt;&gt;() {</b>
&nbsp;            @Override
&nbsp;            public void onSuccess(Void result) {
<b class="nc">&nbsp;                log.debug(&quot;[{}][{}] Successfully processed register claiming info request!&quot;, sessionId, deviceId);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void onFailure(Throwable t) {
<b class="nc">&nbsp;                log.error(&quot;[{}][{}] Failed to process register claiming info request due to: &quot;, sessionId, deviceId, t);</b>
&nbsp;            }
<b class="nc">&nbsp;        }, MoreExecutors.directExecutor());</b>
&nbsp;    }
&nbsp;
&nbsp;    private void reportSessionOpen() {
<b class="nc">&nbsp;        systemContext.getDeviceStateService().onDeviceConnect(tenantId, deviceId);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void reportSessionClose() {
<b class="nc">&nbsp;        systemContext.getDeviceStateService().onDeviceDisconnect(tenantId, deviceId);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void handleGetAttributesRequest(SessionInfoProto sessionInfo, GetAttributeRequestMsg request) {
<b class="nc">&nbsp;        int requestId = request.getRequestId();</b>
<b class="nc">&nbsp;        if (request.getOnlyShared()) {</b>
<b class="nc">&nbsp;            Futures.addCallback(findAllAttributesByScope(AttributeScope.SHARED_SCOPE), new FutureCallback&lt;&gt;() {</b>
&nbsp;                @Override
&nbsp;                public void onSuccess(@Nullable List&lt;AttributeKvEntry&gt; result) {
<b class="nc">&nbsp;                    GetAttributeResponseMsg responseMsg = GetAttributeResponseMsg.newBuilder()</b>
<b class="nc">&nbsp;                            .setRequestId(requestId)</b>
<b class="nc">&nbsp;                            .setSharedStateMsg(true)</b>
<b class="nc">&nbsp;                            .addAllSharedAttributeList(KvProtoUtil.attrToTsKvProtos(result))</b>
<b class="nc">&nbsp;                            .setIsMultipleAttributesRequest(request.getSharedAttributeNamesCount() &gt; 1)</b>
<b class="nc">&nbsp;                            .build();</b>
<b class="nc">&nbsp;                    sendToTransport(responseMsg, sessionInfo);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onFailure(Throwable t) {
<b class="nc">&nbsp;                    GetAttributeResponseMsg responseMsg = GetAttributeResponseMsg.newBuilder()</b>
<b class="nc">&nbsp;                            .setError(t.getMessage())</b>
<b class="nc">&nbsp;                            .setSharedStateMsg(true)</b>
<b class="nc">&nbsp;                            .build();</b>
<b class="nc">&nbsp;                    sendToTransport(responseMsg, sessionInfo);</b>
&nbsp;                }
<b class="nc">&nbsp;            }, MoreExecutors.directExecutor());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            Futures.addCallback(getAttributesKvEntries(request), new FutureCallback&lt;&gt;() {</b>
&nbsp;                @Override
&nbsp;                public void onSuccess(@Nullable List&lt;List&lt;AttributeKvEntry&gt;&gt; result) {
<b class="nc">&nbsp;                    GetAttributeResponseMsg responseMsg = GetAttributeResponseMsg.newBuilder()</b>
<b class="nc">&nbsp;                            .setRequestId(requestId)</b>
<b class="nc">&nbsp;                            .addAllClientAttributeList(KvProtoUtil.attrToTsKvProtos(result.get(0)))</b>
<b class="nc">&nbsp;                            .addAllSharedAttributeList(KvProtoUtil.attrToTsKvProtos(result.get(1)))</b>
<b class="nc">&nbsp;                            .setIsMultipleAttributesRequest(</b>
<b class="nc">&nbsp;                                    request.getSharedAttributeNamesCount() + request.getClientAttributeNamesCount() &gt; 1)</b>
<b class="nc">&nbsp;                            .build();</b>
<b class="nc">&nbsp;                    sendToTransport(responseMsg, sessionInfo);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onFailure(Throwable t) {
<b class="nc">&nbsp;                    GetAttributeResponseMsg responseMsg = GetAttributeResponseMsg.newBuilder()</b>
<b class="nc">&nbsp;                            .setError(t.getMessage())</b>
<b class="nc">&nbsp;                            .build();</b>
<b class="nc">&nbsp;                    sendToTransport(responseMsg, sessionInfo);</b>
&nbsp;                }
<b class="nc">&nbsp;            }, MoreExecutors.directExecutor());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private ListenableFuture&lt;List&lt;List&lt;AttributeKvEntry&gt;&gt;&gt; getAttributesKvEntries(GetAttributeRequestMsg request) {
&nbsp;        ListenableFuture&lt;List&lt;AttributeKvEntry&gt;&gt; clientAttributesFuture;
&nbsp;        ListenableFuture&lt;List&lt;AttributeKvEntry&gt;&gt; sharedAttributesFuture;
<b class="nc">&nbsp;        if (CollectionUtils.isEmpty(request.getClientAttributeNamesList()) &amp;&amp; CollectionUtils.isEmpty(request.getSharedAttributeNamesList())) {</b>
<b class="nc">&nbsp;            clientAttributesFuture = findAllAttributesByScope(AttributeScope.CLIENT_SCOPE);</b>
<b class="nc">&nbsp;            sharedAttributesFuture = findAllAttributesByScope(AttributeScope.SHARED_SCOPE);</b>
<b class="nc">&nbsp;        } else if (!CollectionUtils.isEmpty(request.getClientAttributeNamesList()) &amp;&amp; !CollectionUtils.isEmpty(request.getSharedAttributeNamesList())) {</b>
<b class="nc">&nbsp;            clientAttributesFuture = findAttributesByScope(toSet(request.getClientAttributeNamesList()), AttributeScope.CLIENT_SCOPE);</b>
<b class="nc">&nbsp;            sharedAttributesFuture = findAttributesByScope(toSet(request.getSharedAttributeNamesList()), AttributeScope.SHARED_SCOPE);</b>
<b class="nc">&nbsp;        } else if (CollectionUtils.isEmpty(request.getClientAttributeNamesList()) &amp;&amp; !CollectionUtils.isEmpty(request.getSharedAttributeNamesList())) {</b>
<b class="nc">&nbsp;            clientAttributesFuture = Futures.immediateFuture(Collections.emptyList());</b>
<b class="nc">&nbsp;            sharedAttributesFuture = findAttributesByScope(toSet(request.getSharedAttributeNamesList()), AttributeScope.SHARED_SCOPE);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            sharedAttributesFuture = Futures.immediateFuture(Collections.emptyList());</b>
<b class="nc">&nbsp;            clientAttributesFuture = findAttributesByScope(toSet(request.getClientAttributeNamesList()), AttributeScope.CLIENT_SCOPE);</b>
&nbsp;        }
<b class="nc">&nbsp;        return Futures.allAsList(Arrays.asList(clientAttributesFuture, sharedAttributesFuture));</b>
&nbsp;    }
&nbsp;
&nbsp;    private ListenableFuture&lt;List&lt;AttributeKvEntry&gt;&gt; findAllAttributesByScope(AttributeScope scope) {
<b class="nc">&nbsp;        return systemContext.getAttributesService().findAll(tenantId, deviceId, scope);</b>
&nbsp;    }
&nbsp;
&nbsp;    private ListenableFuture&lt;List&lt;AttributeKvEntry&gt;&gt; findAttributesByScope(Set&lt;String&gt; attributesSet, AttributeScope scope) {
<b class="nc">&nbsp;        return systemContext.getAttributesService().find(tenantId, deviceId, scope, attributesSet);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Set&lt;String&gt; toSet(List&lt;String&gt; strings) {
<b class="nc">&nbsp;        return new HashSet&lt;&gt;(strings);</b>
&nbsp;    }
&nbsp;
&nbsp;    private SessionType getSessionType(UUID sessionId) {
<b class="nc">&nbsp;        return sessions.containsKey(sessionId) ? SessionType.ASYNC : SessionType.SYNC;</b>
&nbsp;    }
&nbsp;
&nbsp;    void processAttributesUpdate(DeviceAttributesEventNotificationMsg msg) {
<b class="nc">&nbsp;        if (!attributeSubscriptions.isEmpty()) {</b>
<b class="nc">&nbsp;            boolean hasNotificationData = false;</b>
<b class="nc">&nbsp;            AttributeUpdateNotificationMsg.Builder notification = AttributeUpdateNotificationMsg.newBuilder();</b>
<b class="nc">&nbsp;            if (msg.isDeleted()) {</b>
<b class="nc">&nbsp;                List&lt;String&gt; sharedKeys = msg.getDeletedKeys().stream()</b>
<b class="nc">&nbsp;                        .filter(key -&gt; DataConstants.SHARED_SCOPE.equals(key.getScope()))</b>
<b class="nc">&nbsp;                        .map(AttributeKey::getAttributeKey)</b>
<b class="nc">&nbsp;                        .collect(Collectors.toList());</b>
<b class="nc">&nbsp;                if (!sharedKeys.isEmpty()) {</b>
<b class="nc">&nbsp;                    notification.addAllSharedDeleted(sharedKeys);</b>
<b class="nc">&nbsp;                    hasNotificationData = true;</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                if (DataConstants.SHARED_SCOPE.equals(msg.getScope())) {</b>
<b class="nc">&nbsp;                    List&lt;AttributeKvEntry&gt; attributes = new ArrayList&lt;&gt;(msg.getValues());</b>
<b class="nc">&nbsp;                    if (!attributes.isEmpty()) {</b>
<b class="nc">&nbsp;                        List&lt;TsKvProto&gt; sharedUpdated = msg.getValues().stream().map(t -&gt; KvProtoUtil.toTsKvProto(t.getLastUpdateTs(), t))</b>
<b class="nc">&nbsp;                                .collect(Collectors.toList());</b>
<b class="nc">&nbsp;                        if (!sharedUpdated.isEmpty()) {</b>
<b class="nc">&nbsp;                            notification.addAllSharedUpdated(sharedUpdated);</b>
<b class="nc">&nbsp;                            hasNotificationData = true;</b>
&nbsp;                        }
&nbsp;                    } else {
<b class="nc">&nbsp;                        log.debug(&quot;[{}] No public shared side attributes changed!&quot;, deviceId);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (hasNotificationData) {</b>
<b class="nc">&nbsp;                AttributeUpdateNotificationMsg finalNotification = notification.build();</b>
<b class="nc">&nbsp;                attributeSubscriptions.forEach((key, value) -&gt; sendToTransport(finalNotification, key, value.getNodeId()));</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            log.debug(&quot;[{}] No registered attributes subscriptions to process!&quot;, deviceId);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void processRpcResponses(SessionInfoProto sessionInfo, ToDeviceRpcResponseMsg responseMsg) {
<b class="nc">&nbsp;        UUID sessionId = getSessionId(sessionInfo);</b>
<b class="nc">&nbsp;        log.debug(&quot;[{}][{}] Processing RPC command response: {}&quot;, deviceId, sessionId, responseMsg);</b>
<b class="nc">&nbsp;        int requestId = responseMsg.getRequestId();</b>
<b class="nc">&nbsp;        ToDeviceRpcRequestMetadata requestMd = toDeviceRpcPendingMap.remove(requestId);</b>
<b class="nc">&nbsp;        boolean success = requestMd != null;</b>
<b class="nc">&nbsp;        if (success) {</b>
<b class="nc">&nbsp;            ToDeviceRpcRequest toDeviceRequestMsg = requestMd.getMsg().getMsg();</b>
<b class="nc">&nbsp;            UUID rpcId = toDeviceRequestMsg.getId();</b>
<b class="nc">&nbsp;            boolean delivered = requestMd.isDelivered();</b>
<b class="nc">&nbsp;            boolean hasError = StringUtils.isNotEmpty(responseMsg.getError());</b>
&nbsp;            try {
<b class="nc">&nbsp;                String payload = hasError ? responseMsg.getError() : responseMsg.getPayload();</b>
<b class="nc">&nbsp;                systemContext.getTbCoreDeviceRpcService().processRpcResponseFromDeviceActor(</b>
&nbsp;                        new FromDeviceRpcResponse(rpcId, payload, null));
<b class="nc">&nbsp;                if (toDeviceRequestMsg.isPersisted()) {</b>
<b class="nc">&nbsp;                    RpcStatus status = hasError ? RpcStatus.FAILED : RpcStatus.SUCCESSFUL;</b>
&nbsp;                    JsonNode response;
&nbsp;                    try {
<b class="nc">&nbsp;                        response = JacksonUtil.toJsonNode(payload);</b>
&nbsp;                    } catch (IllegalArgumentException e) {
<b class="nc">&nbsp;                        response = JacksonUtil.newObjectNode().put(&quot;error&quot;, payload);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    systemContext.getTbRpcService().save(tenantId, new RpcId(rpcId), status, response);</b>
&nbsp;                }
&nbsp;            } finally {
<b class="nc">&nbsp;                if (rpcSubmitStrategy.equals(RpcSubmitStrategy.SEQUENTIAL_ON_RESPONSE_FROM_DEVICE)) {</b>
<b class="nc">&nbsp;                    clearAwaitRpcResponseScheduler();</b>
<b class="nc">&nbsp;                    String errorResponse = hasError ? &quot;error response&quot; : &quot;response&quot;;</b>
<b class="nc">&nbsp;                    String rpcState = delivered ? &quot;&quot; : &quot;undelivered &quot;;</b>
<b class="nc">&nbsp;                    sendNextPendingRequest(rpcId, requestId, String.format(&quot;Received %s for %sRPC!&quot;, errorResponse, rpcState));</b>
<b class="nc">&nbsp;                } else if (!delivered) {</b>
<b class="nc">&nbsp;                    String errorResponse = hasError ? &quot;error response&quot; : &quot;response&quot;;</b>
<b class="nc">&nbsp;                    sendNextPendingRequest(rpcId, requestId, String.format(&quot;Received %s for undelivered RPC!&quot;, errorResponse));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            log.debug(&quot;[{}][{}][{}] RPC command response is stale!&quot;, deviceId, sessionId, requestId);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void processRpcResponseStatus(SessionInfoProto sessionInfo, ToDeviceRpcResponseStatusMsg responseMsg) {
<b class="nc">&nbsp;        UUID rpcId = new UUID(responseMsg.getRequestIdMSB(), responseMsg.getRequestIdLSB());</b>
<b class="nc">&nbsp;        RpcStatus status = RpcStatus.valueOf(responseMsg.getStatus());</b>
<b class="nc">&nbsp;        UUID sessionId = getSessionId(sessionInfo);</b>
<b class="nc">&nbsp;        int requestId = responseMsg.getRequestId();</b>
<b class="nc">&nbsp;        log.debug(&quot;[{}][{}][{}][{}] Processing RPC command response status: [{}]&quot;, deviceId, sessionId, rpcId, requestId, status);</b>
<b class="nc">&nbsp;        ToDeviceRpcRequestMetadata md = toDeviceRpcPendingMap.get(requestId);</b>
<b class="nc">&nbsp;        if (md != null) {</b>
<b class="nc">&nbsp;            var toDeviceRpcRequest = md.getMsg().getMsg();</b>
<b class="nc">&nbsp;            boolean persisted = toDeviceRpcRequest.isPersisted();</b>
<b class="nc">&nbsp;            boolean oneWayRpc = toDeviceRpcRequest.isOneway();</b>
<b class="nc">&nbsp;            JsonNode response = null;</b>
<b class="nc">&nbsp;            if (status.equals(RpcStatus.DELIVERED)) {</b>
<b class="nc">&nbsp;                if (oneWayRpc) {</b>
<b class="nc">&nbsp;                    toDeviceRpcPendingMap.remove(requestId);</b>
<b class="nc">&nbsp;                    if (rpcSequential) {</b>
<b class="nc">&nbsp;                        var fromDeviceRpcResponse = new FromDeviceRpcResponse(rpcId, null, null);</b>
<b class="nc">&nbsp;                        systemContext.getTbCoreDeviceRpcService().processRpcResponseFromDeviceActor(fromDeviceRpcResponse);</b>
&nbsp;                    }
&nbsp;                } else {
<b class="nc">&nbsp;                    md.setDelivered(true);</b>
<b class="nc">&nbsp;                    if (rpcSubmitStrategy.equals(RpcSubmitStrategy.SEQUENTIAL_ON_RESPONSE_FROM_DEVICE)) {</b>
<b class="nc">&nbsp;                        awaitRpcResponseFuture = scheduleAwaitRpcResponseFuture(rpcId, requestId);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            } else if (status.equals(RpcStatus.TIMEOUT)) {</b>
<b class="nc">&nbsp;                Integer maxRpcRetries = toDeviceRpcRequest.getRetries();</b>
<b class="nc">&nbsp;                maxRpcRetries = maxRpcRetries == null ?</b>
<b class="nc">&nbsp;                        systemContext.getMaxRpcRetries() : Math.min(maxRpcRetries, systemContext.getMaxRpcRetries());</b>
<b class="nc">&nbsp;                if (maxRpcRetries &lt;= md.getRetries()) {</b>
<b class="nc">&nbsp;                    if (closeTransportSessionOnRpcDeliveryTimeout) {</b>
<b class="nc">&nbsp;                        md.setRetries(0);</b>
<b class="nc">&nbsp;                        status = RpcStatus.QUEUED;</b>
<b class="nc">&nbsp;                        notifyTransportAboutSessionsCloseAndDumpSessions(TransportSessionCloseReason.RPC_DELIVERY_TIMEOUT);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        toDeviceRpcPendingMap.remove(requestId);</b>
<b class="nc">&nbsp;                        status = RpcStatus.FAILED;</b>
<b class="nc">&nbsp;                        response = JacksonUtil.newObjectNode().put(&quot;error&quot;, &quot;There was a Timeout and all retry &quot; +</b>
&nbsp;                                &quot;attempts have been exhausted. Retry attempts set: &quot; + maxRpcRetries);
&nbsp;                    }
&nbsp;                } else {
<b class="nc">&nbsp;                    md.setRetries(md.getRetries() + 1);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (persisted) {</b>
<b class="nc">&nbsp;                systemContext.getTbRpcService().save(tenantId, new RpcId(rpcId), status, response);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (rpcSubmitStrategy.equals(RpcSubmitStrategy.SEQUENTIAL_ON_RESPONSE_FROM_DEVICE)</b>
<b class="nc">&nbsp;                    &amp;&amp; status.equals(RpcStatus.DELIVERED) &amp;&amp; !oneWayRpc) {</b>
&nbsp;                return;
&nbsp;            }
<b class="nc">&nbsp;            if (!status.equals(RpcStatus.SENT)) {</b>
<b class="nc">&nbsp;                sendNextPendingRequest(rpcId, requestId, String.format(&quot;RPC was %s!&quot;, status.name().toLowerCase()));</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            log.warn(&quot;[{}][{}][{}][{}] RPC has already been removed from pending map.&quot;, deviceId, sessionId, rpcId, requestId);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void processSubscriptionCommands(SessionInfoProto sessionInfo, SubscribeToAttributeUpdatesMsg subscribeCmd) {
<b class="nc">&nbsp;        UUID sessionId = getSessionId(sessionInfo);</b>
<b class="nc">&nbsp;        if (subscribeCmd.getUnsubscribe()) {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}] Canceling attributes subscription for session: [{}]&quot;, deviceId, sessionId);</b>
<b class="nc">&nbsp;            attributeSubscriptions.remove(sessionId);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            SessionInfoMetaData sessionMD = sessions.get(sessionId);</b>
<b class="nc">&nbsp;            if (sessionMD == null) {</b>
<b class="nc">&nbsp;                sessionMD = new SessionInfoMetaData(new SessionInfo(subscribeCmd.getSessionType(), sessionInfo.getNodeId()));</b>
&nbsp;            }
<b class="nc">&nbsp;            sessionMD.setSubscribedToAttributes(true);</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}] Registering attributes subscription for session: [{}]&quot;, deviceId, sessionId);</b>
<b class="nc">&nbsp;            attributeSubscriptions.put(sessionId, sessionMD.getSessionInfo());</b>
<b class="nc">&nbsp;            dumpSessions();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private UUID getSessionId(SessionInfoProto sessionInfo) {
<b class="nc">&nbsp;        return new UUID(sessionInfo.getSessionIdMSB(), sessionInfo.getSessionIdLSB());</b>
&nbsp;    }
&nbsp;
&nbsp;    private void processSubscriptionCommands(SessionInfoProto sessionInfo, SubscribeToRPCMsg subscribeCmd) {
<b class="nc">&nbsp;        UUID sessionId = getSessionId(sessionInfo);</b>
<b class="nc">&nbsp;        if (subscribeCmd.getUnsubscribe()) {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}] Canceling RPC subscription for session: [{}]&quot;, deviceId, sessionId);</b>
<b class="nc">&nbsp;            rpcSubscriptions.remove(sessionId);</b>
<b class="nc">&nbsp;            clearAwaitRpcResponseScheduler();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            SessionInfoMetaData sessionMD = sessions.get(sessionId);</b>
<b class="nc">&nbsp;            if (sessionMD == null) {</b>
<b class="nc">&nbsp;                sessionMD = new SessionInfoMetaData(new SessionInfo(subscribeCmd.getSessionType(), sessionInfo.getNodeId()));</b>
&nbsp;            }
<b class="nc">&nbsp;            sessionMD.setSubscribedToRPC(true);</b>
<b class="nc">&nbsp;            rpcSubscriptions.put(sessionId, sessionMD.getSessionInfo());</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}] Registered RPC subscription for session: [{}] Going to check for pending requests ...&quot;, deviceId, sessionId);</b>
<b class="nc">&nbsp;            sendPendingRequests(sessionId, sessionInfo.getNodeId());</b>
<b class="nc">&nbsp;            dumpSessions();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void processSessionStateMsgs(SessionInfoProto sessionInfo, SessionEventMsg msg) {
<b class="nc">&nbsp;        UUID sessionId = getSessionId(sessionInfo);</b>
<b class="nc">&nbsp;        Objects.requireNonNull(sessionId);</b>
<b class="nc">&nbsp;        if (msg.getEvent() == SessionEvent.OPEN) {</b>
<b class="nc">&nbsp;            if (sessions.containsKey(sessionId)) {</b>
<b class="nc">&nbsp;                log.debug(&quot;[{}][{}] Received duplicate session open event.&quot;, deviceId, sessionId);</b>
&nbsp;                return;
&nbsp;            }
<b class="nc">&nbsp;            log.debug(&quot;[{}] Processing new session: [{}] Current sessions size: {}&quot;, deviceId, sessionId, sessions.size());</b>
&nbsp;
<b class="nc">&nbsp;            sessions.put(sessionId, new SessionInfoMetaData(new SessionInfo(SessionType.ASYNC, sessionInfo.getNodeId())));</b>
<b class="nc">&nbsp;            if (sessions.size() == 1) {</b>
<b class="nc">&nbsp;                reportSessionOpen();</b>
&nbsp;            }
<b class="nc">&nbsp;            systemContext.getDeviceStateService().onDeviceActivity(tenantId, deviceId, System.currentTimeMillis());</b>
<b class="nc">&nbsp;            dumpSessions();</b>
<b class="nc">&nbsp;        } else if (msg.getEvent() == SessionEvent.CLOSED) {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}][{}] Canceling subscriptions for closed session.&quot;, deviceId, sessionId);</b>
<b class="nc">&nbsp;            sessions.remove(sessionId);</b>
<b class="nc">&nbsp;            attributeSubscriptions.remove(sessionId);</b>
<b class="nc">&nbsp;            rpcSubscriptions.remove(sessionId);</b>
<b class="nc">&nbsp;            clearAwaitRpcResponseScheduler();</b>
<b class="nc">&nbsp;            if (sessions.isEmpty()) {</b>
<b class="nc">&nbsp;                reportSessionClose();</b>
&nbsp;            }
<b class="nc">&nbsp;            dumpSessions();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private ScheduledFuture&lt;?&gt; scheduleAwaitRpcResponseFuture(UUID rpcId, int requestId) {
<b class="nc">&nbsp;        return scheduler.schedule(() -&gt; {</b>
<b class="nc">&nbsp;            var md = toDeviceRpcPendingMap.remove(requestId);</b>
<b class="nc">&nbsp;            if (md == null) {</b>
&nbsp;                return;
&nbsp;            }
<b class="nc">&nbsp;            sendNextPendingRequest(rpcId, requestId, &quot;RPC was removed from pending map due to await timeout on response from device!&quot;);</b>
<b class="nc">&nbsp;            var toDeviceRpcRequest = md.getMsg().getMsg();</b>
<b class="nc">&nbsp;            if (toDeviceRpcRequest.isPersisted()) {</b>
<b class="nc">&nbsp;                var responseAwaitTimeout = JacksonUtil.newObjectNode().put(&quot;error&quot;, &quot;There was a timeout awaiting for RPC response from device.&quot;);</b>
<b class="nc">&nbsp;                systemContext.getTbRpcService().save(tenantId, new RpcId(rpcId), RpcStatus.FAILED, responseAwaitTimeout);</b>
&nbsp;            }
<b class="nc">&nbsp;        }, systemContext.getRpcResponseTimeout(), TimeUnit.MILLISECONDS);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void clearAwaitRpcResponseScheduler() {
<b class="nc">&nbsp;        if (rpcSubmitStrategy.equals(RpcSubmitStrategy.SEQUENTIAL_ON_RESPONSE_FROM_DEVICE) &amp;&amp; awaitRpcResponseFuture != null) {</b>
<b class="nc">&nbsp;            awaitRpcResponseFuture.cancel(true);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void handleSessionActivity(SessionInfoProto sessionInfoProto, SubscriptionInfoProto subscriptionInfo) {
<b class="nc">&nbsp;        UUID sessionId = getSessionId(sessionInfoProto);</b>
<b class="nc">&nbsp;        Objects.requireNonNull(sessionId);</b>
&nbsp;
<b class="nc">&nbsp;        SessionInfoMetaData sessionMD = sessions.get(sessionId);</b>
<b class="nc">&nbsp;        if (sessionMD != null) {</b>
<b class="nc">&nbsp;            sessionMD.setLastActivityTime(subscriptionInfo.getLastActivityTime());</b>
<b class="nc">&nbsp;            sessionMD.setSubscribedToAttributes(subscriptionInfo.getAttributeSubscription());</b>
<b class="nc">&nbsp;            sessionMD.setSubscribedToRPC(subscriptionInfo.getRpcSubscription());</b>
<b class="nc">&nbsp;            if (subscriptionInfo.getAttributeSubscription()) {</b>
<b class="nc">&nbsp;                attributeSubscriptions.putIfAbsent(sessionId, sessionMD.getSessionInfo());</b>
&nbsp;            }
<b class="nc">&nbsp;            if (subscriptionInfo.getRpcSubscription()) {</b>
<b class="nc">&nbsp;                rpcSubscriptions.putIfAbsent(sessionId, sessionMD.getSessionInfo());</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        systemContext.getDeviceStateService().onDeviceActivity(tenantId, deviceId, subscriptionInfo.getLastActivityTime());</b>
<b class="nc">&nbsp;        if (sessionMD != null) {</b>
<b class="nc">&nbsp;            dumpSessions();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    void processCredentialsUpdate(TbActorMsg msg) {
<b class="nc">&nbsp;        if (((DeviceCredentialsUpdateNotificationMsg) msg).getDeviceCredentials().getCredentialsType() == DeviceCredentialsType.LWM2M_CREDENTIALS) {</b>
<b class="nc">&nbsp;            sessions.forEach((k, v) -&gt;</b>
<b class="nc">&nbsp;                    notifyTransportAboutDeviceCredentialsUpdate(k, v, ((DeviceCredentialsUpdateNotificationMsg) msg).getDeviceCredentials()));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            notifyTransportAboutSessionsCloseAndDumpSessions(TransportSessionCloseReason.CREDENTIALS_UPDATED);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void notifyTransportAboutSessionsCloseAndDumpSessions(TransportSessionCloseReason transportSessionCloseReason) {
<b class="nc">&nbsp;        sessions.forEach((sessionId, sessionMd) -&gt; notifyTransportAboutClosedSession(sessionId, sessionMd, transportSessionCloseReason));</b>
<b class="nc">&nbsp;        attributeSubscriptions.clear();</b>
<b class="nc">&nbsp;        rpcSubscriptions.clear();</b>
<b class="nc">&nbsp;        dumpSessions();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void notifyTransportAboutClosedSessionMaxSessionsLimit(UUID sessionId, SessionInfoMetaData sessionMd) {
<b class="nc">&nbsp;        attributeSubscriptions.remove(sessionId);</b>
<b class="nc">&nbsp;        rpcSubscriptions.remove(sessionId);</b>
<b class="nc">&nbsp;        notifyTransportAboutClosedSession(sessionId, sessionMd, TransportSessionCloseReason.MAX_CONCURRENT_SESSIONS_LIMIT_REACHED);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void notifyTransportAboutClosedSession(UUID sessionId, SessionInfoMetaData sessionMd, TransportSessionCloseReason transportSessionCloseReason) {
<b class="nc">&nbsp;        log.debug(&quot;{} sessionId: [{}] sessionMd: [{}]&quot;, transportSessionCloseReason.getLogMessage(), sessionId, sessionMd);</b>
&nbsp;        SessionCloseNotificationProto sessionCloseNotificationProto = SessionCloseNotificationProto
<b class="nc">&nbsp;                .newBuilder()</b>
<b class="nc">&nbsp;                .setMessage(transportSessionCloseReason.getNotificationMessage())</b>
<b class="nc">&nbsp;                .setReason(SessionCloseReason.forNumber(transportSessionCloseReason.getProtoNumber()))</b>
<b class="nc">&nbsp;                .build();</b>
<b class="nc">&nbsp;        ToTransportMsg msg = ToTransportMsg.newBuilder()</b>
<b class="nc">&nbsp;                .setSessionIdMSB(sessionId.getMostSignificantBits())</b>
<b class="nc">&nbsp;                .setSessionIdLSB(sessionId.getLeastSignificantBits())</b>
<b class="nc">&nbsp;                .setSessionCloseNotification(sessionCloseNotificationProto)</b>
<b class="nc">&nbsp;                .build();</b>
<b class="nc">&nbsp;        systemContext.getTbCoreToTransportService().process(sessionMd.getSessionInfo().getNodeId(), msg);</b>
&nbsp;    }
&nbsp;
&nbsp;    void notifyTransportAboutDeviceCredentialsUpdate(UUID sessionId, SessionInfoMetaData sessionMd, DeviceCredentials deviceCredentials) {
<b class="nc">&nbsp;        ToTransportUpdateCredentialsProto.Builder notification = ToTransportUpdateCredentialsProto.newBuilder();</b>
<b class="nc">&nbsp;        notification.addCredentialsId(deviceCredentials.getCredentialsId());</b>
<b class="nc">&nbsp;        notification.addCredentialsValue(deviceCredentials.getCredentialsValue());</b>
<b class="nc">&nbsp;        ToTransportMsg msg = ToTransportMsg.newBuilder()</b>
<b class="nc">&nbsp;                .setSessionIdMSB(sessionId.getMostSignificantBits())</b>
<b class="nc">&nbsp;                .setSessionIdLSB(sessionId.getLeastSignificantBits())</b>
<b class="nc">&nbsp;                .setToTransportUpdateCredentialsNotification(notification).build();</b>
<b class="nc">&nbsp;        systemContext.getTbCoreToTransportService().process(sessionMd.getSessionInfo().getNodeId(), msg);</b>
&nbsp;    }
&nbsp;
&nbsp;    void processNameOrTypeUpdate(DeviceNameOrTypeUpdateMsg msg) {
<b class="nc">&nbsp;        this.deviceName = msg.getDeviceName();</b>
<b class="nc">&nbsp;        this.deviceType = msg.getDeviceType();</b>
<b class="nc">&nbsp;        this.defaultMetaData = new TbMsgMetaData();</b>
<b class="nc">&nbsp;        this.defaultMetaData.putValue(&quot;deviceName&quot;, deviceName);</b>
<b class="nc">&nbsp;        this.defaultMetaData.putValue(&quot;deviceType&quot;, deviceType);</b>
&nbsp;    }
&nbsp;
&nbsp;    void processEdgeUpdate(DeviceEdgeUpdateMsg msg) {
<b class="nc">&nbsp;        log.trace(&quot;[{}] Processing edge update {}&quot;, deviceId, msg);</b>
<b class="nc">&nbsp;        this.edgeId = msg.getEdgeId();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void sendToTransport(GetAttributeResponseMsg responseMsg, SessionInfoProto sessionInfo) {
<b class="nc">&nbsp;        ToTransportMsg msg = ToTransportMsg.newBuilder()</b>
<b class="nc">&nbsp;                .setSessionIdMSB(sessionInfo.getSessionIdMSB())</b>
<b class="nc">&nbsp;                .setSessionIdLSB(sessionInfo.getSessionIdLSB())</b>
<b class="nc">&nbsp;                .setGetAttributesResponse(responseMsg).build();</b>
<b class="nc">&nbsp;        systemContext.getTbCoreToTransportService().process(sessionInfo.getNodeId(), msg);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void sendToTransport(AttributeUpdateNotificationMsg notificationMsg, UUID sessionId, String nodeId) {
<b class="nc">&nbsp;        ToTransportMsg msg = ToTransportMsg.newBuilder()</b>
<b class="nc">&nbsp;                .setSessionIdMSB(sessionId.getMostSignificantBits())</b>
<b class="nc">&nbsp;                .setSessionIdLSB(sessionId.getLeastSignificantBits())</b>
<b class="nc">&nbsp;                .setAttributeUpdateNotification(notificationMsg).build();</b>
<b class="nc">&nbsp;        systemContext.getTbCoreToTransportService().process(nodeId, msg);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void sendToTransport(ToDeviceRpcRequestMsg rpcMsg, UUID sessionId, String nodeId) {
<b class="nc">&nbsp;        ToTransportMsg msg = ToTransportMsg.newBuilder()</b>
<b class="nc">&nbsp;                .setSessionIdMSB(sessionId.getMostSignificantBits())</b>
<b class="nc">&nbsp;                .setSessionIdLSB(sessionId.getLeastSignificantBits())</b>
<b class="nc">&nbsp;                .setToDeviceRequest(rpcMsg).build();</b>
<b class="nc">&nbsp;        systemContext.getTbCoreToTransportService().process(nodeId, msg);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void saveRpcRequestToEdgeQueue(ToDeviceRpcRequest msg, Integer requestId) {
<b class="nc">&nbsp;        ObjectNode body = JacksonUtil.newObjectNode();</b>
<b class="nc">&nbsp;        body.put(&quot;requestId&quot;, requestId);</b>
<b class="nc">&nbsp;        body.put(&quot;requestUUID&quot;, msg.getId().toString());</b>
<b class="nc">&nbsp;        body.put(&quot;oneway&quot;, msg.isOneway());</b>
<b class="nc">&nbsp;        body.put(&quot;expirationTime&quot;, msg.getExpirationTime());</b>
<b class="nc">&nbsp;        body.put(&quot;method&quot;, msg.getBody().getMethod());</b>
<b class="nc">&nbsp;        body.put(&quot;params&quot;, msg.getBody().getParams());</b>
<b class="nc">&nbsp;        body.put(&quot;persisted&quot;, msg.isPersisted());</b>
<b class="nc">&nbsp;        body.put(&quot;retries&quot;, msg.getRetries());</b>
<b class="nc">&nbsp;        body.put(&quot;additionalInfo&quot;, msg.getAdditionalInfo());</b>
&nbsp;
<b class="nc">&nbsp;        EdgeEvent edgeEvent = EdgeUtils.constructEdgeEvent(tenantId, edgeId, EdgeEventType.DEVICE, EdgeEventActionType.RPC_CALL, deviceId, body);</b>
&nbsp;
<b class="nc">&nbsp;        systemContext.getClusterService().onEdgeHighPriorityMsg(new EdgeHighPriorityMsg(tenantId, edgeEvent));</b>
&nbsp;    }
&nbsp;
&nbsp;    void restoreSessions() {
<b class="nc">&nbsp;        if (systemContext.isLocalCacheType()) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        log.debug(&quot;[{}] Restoring sessions from cache&quot;, deviceId);</b>
&nbsp;        DeviceSessionsCacheEntry sessionsDump;
&nbsp;        try {
<b class="nc">&nbsp;            sessionsDump = systemContext.getDeviceSessionCacheService().get(deviceId);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.warn(&quot;[{}] Failed to decode device sessions from cache&quot;, deviceId);</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        if (sessionsDump.getSessionsCount() == 0) {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}] No session information found&quot;, deviceId);</b>
&nbsp;            return;
&nbsp;        }
&nbsp;        // TODO: Take latest max allowed sessions size from cache
<b class="nc">&nbsp;        for (SessionSubscriptionInfoProto sessionSubscriptionInfoProto : sessionsDump.getSessionsList()) {</b>
<b class="nc">&nbsp;            SessionInfoProto sessionInfoProto = sessionSubscriptionInfoProto.getSessionInfo();</b>
<b class="nc">&nbsp;            UUID sessionId = getSessionId(sessionInfoProto);</b>
<b class="nc">&nbsp;            SessionInfo sessionInfo = new SessionInfo(SessionType.ASYNC, sessionInfoProto.getNodeId());</b>
<b class="nc">&nbsp;            SubscriptionInfoProto subInfo = sessionSubscriptionInfoProto.getSubscriptionInfo();</b>
<b class="nc">&nbsp;            SessionInfoMetaData sessionMD = new SessionInfoMetaData(sessionInfo, subInfo.getLastActivityTime());</b>
<b class="nc">&nbsp;            sessions.put(sessionId, sessionMD);</b>
<b class="nc">&nbsp;            if (subInfo.getAttributeSubscription()) {</b>
<b class="nc">&nbsp;                attributeSubscriptions.put(sessionId, sessionInfo);</b>
<b class="nc">&nbsp;                sessionMD.setSubscribedToAttributes(true);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (subInfo.getRpcSubscription()) {</b>
<b class="nc">&nbsp;                rpcSubscriptions.put(sessionId, sessionInfo);</b>
<b class="nc">&nbsp;                sessionMD.setSubscribedToRPC(true);</b>
&nbsp;            }
<b class="nc">&nbsp;            log.debug(&quot;[{}] Restored session: {}&quot;, deviceId, sessionMD);</b>
&nbsp;        }
<b class="nc">&nbsp;        log.debug(&quot;[{}] Restored sessions: {}, RPC subscriptions: {}, attribute subscriptions: {}&quot;, deviceId, sessions.size(), rpcSubscriptions.size(), attributeSubscriptions.size());</b>
&nbsp;    }
&nbsp;
&nbsp;    private void dumpSessions() {
<b class="nc">&nbsp;        if (systemContext.isLocalCacheType()) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        log.debug(&quot;[{}] Dumping sessions: {}, RPC subscriptions: {}, attribute subscriptions: {} to cache&quot;, deviceId, sessions.size(), rpcSubscriptions.size(), attributeSubscriptions.size());</b>
<b class="nc">&nbsp;        List&lt;SessionSubscriptionInfoProto&gt; sessionsList = new ArrayList&lt;&gt;(sessions.size());</b>
<b class="nc">&nbsp;        sessions.forEach((uuid, sessionMD) -&gt; {</b>
<b class="nc">&nbsp;            if (sessionMD.getSessionInfo().getType() == SessionType.SYNC) {</b>
&nbsp;                return;
&nbsp;            }
<b class="nc">&nbsp;            SessionInfo sessionInfo = sessionMD.getSessionInfo();</b>
<b class="nc">&nbsp;            SubscriptionInfoProto subscriptionInfoProto = SubscriptionInfoProto.newBuilder()</b>
<b class="nc">&nbsp;                    .setLastActivityTime(sessionMD.getLastActivityTime())</b>
<b class="nc">&nbsp;                    .setAttributeSubscription(sessionMD.isSubscribedToAttributes())</b>
<b class="nc">&nbsp;                    .setRpcSubscription(sessionMD.isSubscribedToRPC()).build();</b>
<b class="nc">&nbsp;            SessionInfoProto sessionInfoProto = SessionInfoProto.newBuilder()</b>
<b class="nc">&nbsp;                    .setSessionIdMSB(uuid.getMostSignificantBits())</b>
<b class="nc">&nbsp;                    .setSessionIdLSB(uuid.getLeastSignificantBits())</b>
<b class="nc">&nbsp;                    .setNodeId(sessionInfo.getNodeId()).build();</b>
<b class="nc">&nbsp;            sessionsList.add(SessionSubscriptionInfoProto.newBuilder()</b>
<b class="nc">&nbsp;                    .setSessionInfo(sessionInfoProto)</b>
<b class="nc">&nbsp;                    .setSubscriptionInfo(subscriptionInfoProto).build());</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}] Dumping session: {}&quot;, deviceId, sessionMD);</b>
&nbsp;        });
<b class="nc">&nbsp;        systemContext.getDeviceSessionCacheService()</b>
<b class="nc">&nbsp;                .put(deviceId, DeviceSessionsCacheEntry.newBuilder()</b>
<b class="nc">&nbsp;                        .addAllSessions(sessionsList).build());</b>
&nbsp;    }
&nbsp;
&nbsp;    void init(TbActorCtx ctx) {
<b class="nc">&nbsp;        PageLink pageLink = new PageLink(1024, 0, null, new SortOrder(&quot;createdTime&quot;));</b>
&nbsp;        PageData&lt;Rpc&gt; pageData;
&nbsp;        do {
<b class="nc">&nbsp;            pageData = systemContext.getTbRpcService().findAllByDeviceIdAndStatus(tenantId, deviceId, RpcStatus.QUEUED, pageLink);</b>
<b class="nc">&nbsp;            pageData.getData().forEach(rpc -&gt; {</b>
<b class="nc">&nbsp;                ToDeviceRpcRequest msg = JacksonUtil.convertValue(rpc.getRequest(), ToDeviceRpcRequest.class);</b>
<b class="nc">&nbsp;                long timeout = rpc.getExpirationTime() - System.currentTimeMillis();</b>
<b class="nc">&nbsp;                if (timeout &lt;= 0) {</b>
<b class="nc">&nbsp;                    rpc.setStatus(RpcStatus.EXPIRED);</b>
<b class="nc">&nbsp;                    systemContext.getTbRpcService().save(tenantId, rpc);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    registerPendingRpcRequest(ctx, new ToDeviceRpcRequestActorMsg(systemContext.getServiceId(), msg), false, createToDeviceRpcRequestMsg(msg), timeout);</b>
&nbsp;                }
&nbsp;            });
<b class="nc">&nbsp;            if (pageData.hasNext()) {</b>
<b class="nc">&nbsp;                pageLink = pageLink.nextPageLink();</b>
&nbsp;            }
<b class="nc">&nbsp;        } while (pageData.hasNext());</b>
&nbsp;    }
&nbsp;
&nbsp;    void checkSessionsTimeout() {
<b class="nc">&nbsp;        final long expTime = System.currentTimeMillis() - systemContext.getSessionInactivityTimeout();</b>
<b class="nc">&nbsp;        List&lt;UUID&gt; expiredIds = null;</b>
&nbsp;
<b class="nc">&nbsp;        for (Map.Entry&lt;UUID, SessionInfoMetaData&gt; kv : sessions.entrySet()) { //entry set are cached for stable sessions</b>
<b class="nc">&nbsp;            if (kv.getValue().getLastActivityTime() &lt; expTime) {</b>
<b class="nc">&nbsp;                final UUID id = kv.getKey();</b>
<b class="nc">&nbsp;                if (expiredIds == null) {</b>
<b class="nc">&nbsp;                    expiredIds = new ArrayList&lt;&gt;(1); //most of the expired sessions is a single event</b>
&nbsp;                }
<b class="nc">&nbsp;                expiredIds.add(id);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (expiredIds != null) {</b>
<b class="nc">&nbsp;            int removed = 0;</b>
<b class="nc">&nbsp;            for (UUID id : expiredIds) {</b>
<b class="nc">&nbsp;                final SessionInfoMetaData session = sessions.remove(id);</b>
<b class="nc">&nbsp;                rpcSubscriptions.remove(id);</b>
<b class="nc">&nbsp;                attributeSubscriptions.remove(id);</b>
<b class="nc">&nbsp;                if (session != null) {</b>
<b class="nc">&nbsp;                    removed++;</b>
<b class="nc">&nbsp;                    notifyTransportAboutClosedSession(id, session, TransportSessionCloseReason.SESSION_TIMEOUT);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (removed != 0) {</b>
<b class="nc">&nbsp;                dumpSessions();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
