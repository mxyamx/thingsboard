<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > TbRuleEngineQueueConsumerManager</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.server.service.queue.ruleengine</a>
</div>

<h1>Coverage Summary for Class: TbRuleEngineQueueConsumerManager (org.thingsboard.server.service.queue.ruleengine)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TbRuleEngineQueueConsumerManager</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/42)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/93)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.server.service.queue.ruleengine;
&nbsp;
&nbsp;import com.google.protobuf.ProtocolStringList;
&nbsp;import lombok.Builder;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.thingsboard.server.common.data.id.EntityId;
&nbsp;import org.thingsboard.server.common.data.id.EntityIdFactory;
&nbsp;import org.thingsboard.server.common.data.id.TenantId;
&nbsp;import org.thingsboard.server.common.data.queue.Queue;
&nbsp;import org.thingsboard.server.common.msg.TbMsg;
&nbsp;import org.thingsboard.server.common.msg.gen.MsgProtos;
&nbsp;import org.thingsboard.server.common.msg.queue.QueueToRuleEngineMsg;
&nbsp;import org.thingsboard.server.common.msg.queue.RuleEngineException;
&nbsp;import org.thingsboard.server.common.msg.queue.RuleNodeInfo;
&nbsp;import org.thingsboard.server.common.msg.queue.ServiceType;
&nbsp;import org.thingsboard.server.common.msg.queue.TbMsgCallback;
&nbsp;import org.thingsboard.server.common.msg.queue.TopicPartitionInfo;
&nbsp;import org.thingsboard.server.common.util.ProtoUtils;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.ToRuleEngineMsg;
&nbsp;import org.thingsboard.server.queue.TbQueueConsumer;
&nbsp;import org.thingsboard.server.queue.common.TbProtoQueueMsg;
&nbsp;import org.thingsboard.server.queue.common.consumer.MainQueueConsumerManager;
&nbsp;import org.thingsboard.server.queue.common.consumer.TbQueueConsumerManagerTask;
&nbsp;import org.thingsboard.server.queue.common.consumer.TbQueueConsumerManagerTask.DeleteQueueTask;
&nbsp;import org.thingsboard.server.queue.common.consumer.TbQueueConsumerTask;
&nbsp;import org.thingsboard.server.queue.common.consumer.TbQueueConsumerTask.ConsumerKey;
&nbsp;import org.thingsboard.server.queue.discovery.QueueKey;
&nbsp;import org.thingsboard.server.service.queue.TbMsgPackCallback;
&nbsp;import org.thingsboard.server.service.queue.TbMsgPackProcessingContext;
&nbsp;import org.thingsboard.server.service.queue.TbRuleEngineConsumerStats;
&nbsp;import org.thingsboard.server.service.queue.processing.TbRuleEngineProcessingDecision;
&nbsp;import org.thingsboard.server.service.queue.processing.TbRuleEngineProcessingResult;
&nbsp;import org.thingsboard.server.service.queue.processing.TbRuleEngineProcessingStrategy;
&nbsp;import org.thingsboard.server.service.queue.processing.TbRuleEngineSubmitStrategy;
&nbsp;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import java.util.UUID;
&nbsp;import java.util.concurrent.ExecutorService;
&nbsp;import java.util.concurrent.ScheduledExecutorService;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.stream.Collectors;
&nbsp;
<b class="nc">&nbsp;@Slf4j</b>
&nbsp;public class TbRuleEngineQueueConsumerManager extends MainQueueConsumerManager&lt;TbProtoQueueMsg&lt;ToRuleEngineMsg&gt;, Queue&gt; {
&nbsp;
&nbsp;    public static final String SUCCESSFUL_STATUS = &quot;successful&quot;;
&nbsp;    public static final String FAILED_STATUS = &quot;failed&quot;;
&nbsp;
&nbsp;    private final TbRuleEngineConsumerContext ctx;
&nbsp;    private final TbRuleEngineConsumerStats stats;
&nbsp;
&nbsp;    @Builder(builderMethodName = &quot;create&quot;) // not to conflict with super.builder()
&nbsp;    public TbRuleEngineQueueConsumerManager(TbRuleEngineConsumerContext ctx,
&nbsp;                                            QueueKey queueKey,
&nbsp;                                            ExecutorService consumerExecutor,
&nbsp;                                            ScheduledExecutorService scheduler,
&nbsp;                                            ExecutorService taskExecutor) {
<b class="nc">&nbsp;        super(queueKey, null, null,</b>
&nbsp;                (queueConfig, tpi) -&gt; {
<b class="nc">&nbsp;                    Integer partitionId = tpi != null ? tpi.getPartition().orElse(-1) : null;</b>
<b class="nc">&nbsp;                    return ctx.getQueueFactory().createToRuleEngineMsgConsumer(queueConfig, partitionId);</b>
&nbsp;                },
&nbsp;                consumerExecutor, scheduler, taskExecutor, null);
<b class="nc">&nbsp;        this.ctx = ctx;</b>
<b class="nc">&nbsp;        this.stats = new TbRuleEngineConsumerStats(queueKey, ctx.getStatsFactory());</b>
&nbsp;    }
&nbsp;
&nbsp;    public void delete(boolean drainQueue) {
<b class="nc">&nbsp;        addTask(new DeleteQueueTask(drainQueue));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected void processTask(TbQueueConsumerManagerTask task) {
<b class="nc">&nbsp;        if (task instanceof DeleteQueueTask deleteQueueTask) {</b>
<b class="nc">&nbsp;            doDelete(deleteQueueTask.drainQueue());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void doDelete(boolean drainQueue) {
<b class="nc">&nbsp;        stopped = true;</b>
<b class="nc">&nbsp;        log.info(&quot;[{}] Handling queue deletion&quot;, queueKey);</b>
<b class="nc">&nbsp;        consumerWrapper.getConsumers().forEach(TbQueueConsumerTask::awaitCompletion);</b>
&nbsp;
<b class="nc">&nbsp;        List&lt;TbQueueConsumer&lt;TbProtoQueueMsg&lt;ToRuleEngineMsg&gt;&gt;&gt; queueConsumers = consumerWrapper.getConsumers().stream()</b>
<b class="nc">&nbsp;                .map(TbQueueConsumerTask::getConsumer).collect(Collectors.toList());</b>
<b class="nc">&nbsp;        consumerExecutor.submit(() -&gt; {</b>
<b class="nc">&nbsp;            if (drainQueue) {</b>
<b class="nc">&nbsp;                drainQueue(queueConsumers);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            queueConsumers.forEach(consumer -&gt; {</b>
<b class="nc">&nbsp;                for (String topic : consumer.getFullTopicNames()) {</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        ctx.getQueueAdmin().deleteTopic(topic);</b>
<b class="nc">&nbsp;                        log.info(&quot;Deleted topic {}&quot;, topic);</b>
&nbsp;                    } catch (Exception e) {
<b class="nc">&nbsp;                        log.error(&quot;Failed to delete topic {}&quot;, topic, e);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                try {
<b class="nc">&nbsp;                    consumer.unsubscribe();</b>
&nbsp;                } catch (Exception e) {
<b class="nc">&nbsp;                    log.error(&quot;[{}] Failed to unsubscribe consumer&quot;, queueKey, e);</b>
&nbsp;                }
&nbsp;            });
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected void processMsgs(List&lt;TbProtoQueueMsg&lt;ToRuleEngineMsg&gt;&gt; msgs,
&nbsp;                               TbQueueConsumer&lt;TbProtoQueueMsg&lt;ToRuleEngineMsg&gt;&gt; consumer,
&nbsp;                               ConsumerKey consumerKey,
&nbsp;                               Queue queue) throws Exception {
<b class="nc">&nbsp;        TbRuleEngineSubmitStrategy submitStrategy = getSubmitStrategy(queue);</b>
<b class="nc">&nbsp;        TbRuleEngineProcessingStrategy ackStrategy = getProcessingStrategy(queue);</b>
<b class="nc">&nbsp;        submitStrategy.init(msgs);</b>
<b class="nc">&nbsp;        while (!stopped &amp;&amp; !consumer.isStopped()) {</b>
<b class="nc">&nbsp;            TbMsgPackProcessingContext packCtx = new TbMsgPackProcessingContext(queue.getName(), submitStrategy, ackStrategy.isSkipTimeoutMsgs());</b>
<b class="nc">&nbsp;            submitStrategy.submitAttempt((id, msg) -&gt; submitMessage(packCtx, id, msg));</b>
&nbsp;
<b class="nc">&nbsp;            final boolean timeout = !packCtx.await(queue.getPackProcessingTimeout(), TimeUnit.MILLISECONDS);</b>
&nbsp;
<b class="nc">&nbsp;            TbRuleEngineProcessingResult result = new TbRuleEngineProcessingResult(queue.getName(), timeout, packCtx);</b>
<b class="nc">&nbsp;            if (timeout) {</b>
<b class="nc">&nbsp;                printFirstOrAll(packCtx, packCtx.getPendingMap(), &quot;Timeout&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (!packCtx.getFailedMap().isEmpty()) {</b>
<b class="nc">&nbsp;                printFirstOrAll(packCtx, packCtx.getFailedMap(), &quot;Failed&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            packCtx.printProfilerStats();</b>
&nbsp;
<b class="nc">&nbsp;            TbRuleEngineProcessingDecision decision = ackStrategy.analyze(result);</b>
<b class="nc">&nbsp;            if (ctx.isStatsEnabled()) {</b>
<b class="nc">&nbsp;                stats.log(result, decision.isCommit());</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            packCtx.cleanup();</b>
&nbsp;
<b class="nc">&nbsp;            if (decision.isCommit()) {</b>
<b class="nc">&nbsp;                submitStrategy.stop();</b>
<b class="nc">&nbsp;                consumer.commit();</b>
&nbsp;                break;
&nbsp;            } else {
<b class="nc">&nbsp;                submitStrategy.update(decision.getReprocessMap());</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private TbRuleEngineSubmitStrategy getSubmitStrategy(Queue queue) {
<b class="nc">&nbsp;        return ctx.getSubmitStrategyFactory().newInstance(queue.getName(), queue.getSubmitStrategy());</b>
&nbsp;    }
&nbsp;
&nbsp;    private TbRuleEngineProcessingStrategy getProcessingStrategy(Queue queue) {
<b class="nc">&nbsp;        return ctx.getProcessingStrategyFactory().newInstance(queue.getName(), queue.getProcessingStrategy());</b>
&nbsp;    }
&nbsp;
&nbsp;    private void submitMessage(TbMsgPackProcessingContext packCtx, UUID id, TbProtoQueueMsg&lt;ToRuleEngineMsg&gt; msg) {
<b class="nc">&nbsp;        log.trace(&quot;[{}] Creating callback for topic {} message: {}&quot;, id, config.getName(), msg.getValue());</b>
<b class="nc">&nbsp;        ToRuleEngineMsg toRuleEngineMsg = msg.getValue();</b>
<b class="nc">&nbsp;        TenantId tenantId = TenantId.fromUUID(new UUID(toRuleEngineMsg.getTenantIdMSB(), toRuleEngineMsg.getTenantIdLSB()));</b>
<b class="nc">&nbsp;        TbMsgCallback callback = ctx.isPrometheusStatsEnabled() ?</b>
<b class="nc">&nbsp;                new TbMsgPackCallback(id, tenantId, packCtx, stats.getTimer(tenantId, SUCCESSFUL_STATUS), stats.getTimer(tenantId, FAILED_STATUS)) :</b>
<b class="nc">&nbsp;                new TbMsgPackCallback(id, tenantId, packCtx);</b>
&nbsp;        try {
<b class="nc">&nbsp;            if (!toRuleEngineMsg.getTbMsg().isEmpty() || toRuleEngineMsg.hasTbMsgProto()) {</b>
<b class="nc">&nbsp;                forwardToRuleEngineActor(config.getName(), tenantId, toRuleEngineMsg, callback);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                callback.onSuccess();</b>
&nbsp;            }
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            callback.onFailure(new RuleEngineException(e.getMessage(), e));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void forwardToRuleEngineActor(String queueName, TenantId tenantId, ToRuleEngineMsg toRuleEngineMsg, TbMsgCallback callback) {
<b class="nc">&nbsp;        TbMsg tbMsg = ProtoUtils.fromTbMsgProto(queueName, toRuleEngineMsg, callback);</b>
&nbsp;        QueueToRuleEngineMsg msg;
<b class="nc">&nbsp;        ProtocolStringList relationTypesList = toRuleEngineMsg.getRelationTypesList();</b>
&nbsp;        Set&lt;String&gt; relationTypes;
<b class="nc">&nbsp;        if (relationTypesList.size() == 1) {</b>
<b class="nc">&nbsp;            relationTypes = Collections.singleton(relationTypesList.get(0));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            relationTypes = new HashSet&lt;&gt;(relationTypesList);</b>
&nbsp;        }
<b class="nc">&nbsp;        msg = new QueueToRuleEngineMsg(tenantId, tbMsg, relationTypes, toRuleEngineMsg.getFailureMessage());</b>
<b class="nc">&nbsp;        ctx.getActorContext().tell(msg);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void printFirstOrAll(TbMsgPackProcessingContext ctx, Map&lt;UUID, TbProtoQueueMsg&lt;ToRuleEngineMsg&gt;&gt; map, String prefix) {
<b class="nc">&nbsp;        boolean printAll = log.isTraceEnabled();</b>
<b class="nc">&nbsp;        log.info(&quot;[{}] {} to process [{}] messages&quot;, queueKey, prefix, map.size());</b>
<b class="nc">&nbsp;        for (Map.Entry&lt;UUID, TbProtoQueueMsg&lt;ToRuleEngineMsg&gt;&gt; pending : map.entrySet()) {</b>
<b class="nc">&nbsp;            ToRuleEngineMsg tmp = pending.getValue().getValue();</b>
<b class="nc">&nbsp;            TbMsg tmpMsg = ProtoUtils.fromTbMsgProto(config.getName(), tmp, TbMsgCallback.EMPTY);</b>
<b class="nc">&nbsp;            RuleNodeInfo ruleNodeInfo = ctx.getLastVisitedRuleNode(pending.getKey());</b>
<b class="nc">&nbsp;            if (printAll) {</b>
<b class="nc">&nbsp;                log.trace(&quot;[{}][{}] {} to process message: {}, Last Rule Node: {}&quot;, queueKey, TenantId.fromUUID(new UUID(tmp.getTenantIdMSB(), tmp.getTenantIdLSB())), prefix, tmpMsg, ruleNodeInfo);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                log.info(&quot;[{}] {} to process message: {}, Last Rule Node: {}&quot;, TenantId.fromUUID(new UUID(tmp.getTenantIdMSB(), tmp.getTenantIdLSB())), prefix, tmpMsg, ruleNodeInfo);</b>
&nbsp;                break;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void printStats(long ts) {
<b class="nc">&nbsp;        stats.printStats();</b>
<b class="nc">&nbsp;        ctx.getStatisticsService().reportQueueStats(ts, stats);</b>
<b class="nc">&nbsp;        stats.reset();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void drainQueue(List&lt;TbQueueConsumer&lt;TbProtoQueueMsg&lt;ToRuleEngineMsg&gt;&gt;&gt; consumers) {
<b class="nc">&nbsp;        long finishTs = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(ctx.getTopicDeletionDelayInSec());</b>
&nbsp;        try {
<b class="nc">&nbsp;            int n = 0;</b>
<b class="nc">&nbsp;            while (System.currentTimeMillis() &lt;= finishTs) {</b>
<b class="nc">&nbsp;                for (TbQueueConsumer&lt;TbProtoQueueMsg&lt;ToRuleEngineMsg&gt;&gt; consumer : consumers) {</b>
<b class="nc">&nbsp;                    List&lt;TbProtoQueueMsg&lt;ToRuleEngineMsg&gt;&gt; msgs = consumer.poll(config.getPollInterval());</b>
<b class="nc">&nbsp;                    if (msgs.isEmpty()) {</b>
&nbsp;                        continue;
&nbsp;                    }
<b class="nc">&nbsp;                    for (TbProtoQueueMsg&lt;ToRuleEngineMsg&gt; msg : msgs) {</b>
&nbsp;                        try {
<b class="nc">&nbsp;                            MsgProtos.TbMsgProto tbMsgProto = ProtoUtils.getTbMsgProto(msg.getValue());</b>
<b class="nc">&nbsp;                            EntityId originator = EntityIdFactory.getByTypeAndUuid(tbMsgProto.getEntityType(), new UUID(tbMsgProto.getEntityIdMSB(), tbMsgProto.getEntityIdLSB()));</b>
&nbsp;
<b class="nc">&nbsp;                            TopicPartitionInfo tpi = ctx.getPartitionService().resolve(ServiceType.TB_RULE_ENGINE, config.getName(), TenantId.SYS_TENANT_ID, originator);</b>
<b class="nc">&nbsp;                            ctx.getProducerProvider().getRuleEngineMsgProducer().send(tpi, msg, null);</b>
<b class="nc">&nbsp;                            n++;</b>
&nbsp;                        } catch (Throwable e) {
<b class="nc">&nbsp;                            log.warn(&quot;Failed to move message to system {}: {}&quot;, consumer.getTopic(), msg, e);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    consumer.commit();</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (n &gt; 0) {</b>
<b class="nc">&nbsp;                log.info(&quot;Moved {} messages from {} to system {}&quot;, n, queueKey, config.getName());</b>
&nbsp;            }
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.error(&quot;[{}] Failed to drain queue&quot;, queueKey, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
