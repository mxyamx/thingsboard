<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > DefaultDeviceStateService</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.server.service.state</a>
</div>

<h1>Coverage Summary for Class: DefaultDeviceStateService (org.thingsboard.server.service.state)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DefaultDeviceStateService</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/50)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/162)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/350)
  </span>
</td>
</tr>
  <tr>
    <td class="name">DefaultDeviceStateService$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultDeviceStateService$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultDeviceStateService$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultDeviceStateService$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/28)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultDeviceStateService$DevicePackFutureHolder</td>
  </tr>
  <tr>
    <td class="name">DefaultDeviceStateService$TelemetrySaveCallback</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/64)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/170)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/411)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.server.service.state;
&nbsp;
&nbsp;import com.fasterxml.jackson.databind.node.ObjectNode;
&nbsp;import com.google.common.base.Function;
&nbsp;import com.google.common.collect.Lists;
&nbsp;import com.google.common.util.concurrent.FutureCallback;
&nbsp;import com.google.common.util.concurrent.Futures;
&nbsp;import com.google.common.util.concurrent.ListenableFuture;
&nbsp;import com.google.common.util.concurrent.ListeningExecutorService;
&nbsp;import com.google.common.util.concurrent.MoreExecutors;
&nbsp;import jakarta.annotation.Nonnull;
&nbsp;import jakarta.annotation.Nullable;
&nbsp;import jakarta.annotation.PostConstruct;
&nbsp;import jakarta.annotation.PreDestroy;
&nbsp;import lombok.RequiredArgsConstructor;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.apache.commons.lang3.tuple.Pair;
&nbsp;import org.checkerframework.checker.nullness.qual.NonNull;
&nbsp;import org.springframework.beans.factory.annotation.Autowired;
&nbsp;import org.springframework.beans.factory.annotation.Value;
&nbsp;import org.springframework.context.annotation.Lazy;
&nbsp;import org.springframework.stereotype.Service;
&nbsp;import org.thingsboard.common.util.JacksonUtil;
&nbsp;import org.thingsboard.common.util.ThingsBoardExecutors;
&nbsp;import org.thingsboard.rule.engine.api.AttributesSaveRequest;
&nbsp;import org.thingsboard.rule.engine.api.TimeseriesSaveRequest;
&nbsp;import org.thingsboard.server.cluster.TbClusterService;
&nbsp;import org.thingsboard.server.common.data.ApiUsageRecordKey;
&nbsp;import org.thingsboard.server.common.data.AttributeScope;
&nbsp;import org.thingsboard.server.common.data.Device;
&nbsp;import org.thingsboard.server.common.data.DeviceIdInfo;
&nbsp;import org.thingsboard.server.common.data.EntityType;
&nbsp;import org.thingsboard.server.common.data.StringUtils;
&nbsp;import org.thingsboard.server.common.data.exception.TenantNotFoundException;
&nbsp;import org.thingsboard.server.common.data.id.DeviceId;
&nbsp;import org.thingsboard.server.common.data.id.EntityId;
&nbsp;import org.thingsboard.server.common.data.id.TenantId;
&nbsp;import org.thingsboard.server.common.data.id.UUIDBased;
&nbsp;import org.thingsboard.server.common.data.kv.AttributeKvEntry;
&nbsp;import org.thingsboard.server.common.data.kv.BaseAttributeKvEntry;
&nbsp;import org.thingsboard.server.common.data.kv.BasicTsKvEntry;
&nbsp;import org.thingsboard.server.common.data.kv.BooleanDataEntry;
&nbsp;import org.thingsboard.server.common.data.kv.KvEntry;
&nbsp;import org.thingsboard.server.common.data.kv.LongDataEntry;
&nbsp;import org.thingsboard.server.common.data.kv.TsKvEntry;
&nbsp;import org.thingsboard.server.common.data.msg.TbMsgType;
&nbsp;import org.thingsboard.server.common.data.notification.rule.trigger.DeviceActivityTrigger;
&nbsp;import org.thingsboard.server.common.data.page.PageData;
&nbsp;import org.thingsboard.server.common.data.page.PageDataIterable;
&nbsp;import org.thingsboard.server.common.data.query.EntityData;
&nbsp;import org.thingsboard.server.common.data.query.EntityDataPageLink;
&nbsp;import org.thingsboard.server.common.data.query.EntityDataQuery;
&nbsp;import org.thingsboard.server.common.data.query.EntityKey;
&nbsp;import org.thingsboard.server.common.data.query.EntityKeyType;
&nbsp;import org.thingsboard.server.common.data.query.EntityListFilter;
&nbsp;import org.thingsboard.server.common.msg.TbMsg;
&nbsp;import org.thingsboard.server.common.msg.TbMsgDataType;
&nbsp;import org.thingsboard.server.common.msg.TbMsgMetaData;
&nbsp;import org.thingsboard.server.common.msg.notification.NotificationRuleProcessor;
&nbsp;import org.thingsboard.server.common.msg.queue.ServiceType;
&nbsp;import org.thingsboard.server.common.msg.queue.TbCallback;
&nbsp;import org.thingsboard.server.common.msg.queue.TopicPartitionInfo;
&nbsp;import org.thingsboard.server.common.stats.TbApiUsageReportClient;
&nbsp;import org.thingsboard.server.dao.attributes.AttributesService;
&nbsp;import org.thingsboard.server.dao.device.DeviceService;
&nbsp;import org.thingsboard.server.dao.sql.query.EntityQueryRepository;
&nbsp;import org.thingsboard.server.dao.timeseries.TimeseriesService;
&nbsp;import org.thingsboard.server.dao.util.DbTypeInfoComponent;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos;
&nbsp;import org.thingsboard.server.queue.discovery.PartitionService;
&nbsp;import org.thingsboard.server.queue.util.TbCoreComponent;
&nbsp;import org.thingsboard.server.service.partition.AbstractPartitionBasedService;
&nbsp;import org.thingsboard.server.service.telemetry.TelemetrySubscriptionService;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Objects;
&nbsp;import java.util.Optional;
&nbsp;import java.util.Random;
&nbsp;import java.util.Set;
&nbsp;import java.util.UUID;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.concurrent.ConcurrentMap;
&nbsp;import java.util.concurrent.ExecutionException;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.concurrent.TimeoutException;
&nbsp;import java.util.concurrent.atomic.AtomicInteger;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;import static org.thingsboard.server.common.data.DataConstants.SCOPE;
&nbsp;import static org.thingsboard.server.common.data.DataConstants.SERVER_SCOPE;
&nbsp;
&nbsp;/**
&nbsp; * Created by ashvayka on 01.05.18.
&nbsp; */
&nbsp;@Service
&nbsp;@TbCoreComponent
<b class="nc">&nbsp;@Slf4j</b>
&nbsp;@RequiredArgsConstructor
<b class="nc">&nbsp;public class DefaultDeviceStateService extends AbstractPartitionBasedService&lt;DeviceId&gt; implements DeviceStateService {</b>
&nbsp;
&nbsp;    public static final String ACTIVITY_STATE = &quot;active&quot;;
&nbsp;    public static final String LAST_CONNECT_TIME = &quot;lastConnectTime&quot;;
&nbsp;    public static final String LAST_DISCONNECT_TIME = &quot;lastDisconnectTime&quot;;
&nbsp;    public static final String LAST_ACTIVITY_TIME = &quot;lastActivityTime&quot;;
&nbsp;    public static final String INACTIVITY_ALARM_TIME = &quot;inactivityAlarmTime&quot;;
&nbsp;    public static final String INACTIVITY_TIMEOUT = &quot;inactivityTimeout&quot;;
&nbsp;
<b class="nc">&nbsp;    private static final List&lt;EntityKey&gt; PERSISTENT_TELEMETRY_KEYS = Arrays.asList(</b>
&nbsp;            new EntityKey(EntityKeyType.TIME_SERIES, LAST_ACTIVITY_TIME),
&nbsp;            new EntityKey(EntityKeyType.TIME_SERIES, INACTIVITY_ALARM_TIME),
&nbsp;            new EntityKey(EntityKeyType.TIME_SERIES, ACTIVITY_STATE),
&nbsp;            new EntityKey(EntityKeyType.TIME_SERIES, LAST_CONNECT_TIME),
&nbsp;            new EntityKey(EntityKeyType.TIME_SERIES, LAST_DISCONNECT_TIME),
&nbsp;            new EntityKey(EntityKeyType.SERVER_ATTRIBUTE, INACTIVITY_TIMEOUT)); // inactivity timeout is always a server attribute, even when activity data is stored as time series
&nbsp;
<b class="nc">&nbsp;    private static final List&lt;EntityKey&gt; PERSISTENT_ATTRIBUTE_KEYS = Arrays.asList(</b>
&nbsp;            new EntityKey(EntityKeyType.SERVER_ATTRIBUTE, LAST_ACTIVITY_TIME),
&nbsp;            new EntityKey(EntityKeyType.SERVER_ATTRIBUTE, INACTIVITY_ALARM_TIME),
&nbsp;            new EntityKey(EntityKeyType.SERVER_ATTRIBUTE, INACTIVITY_TIMEOUT),
&nbsp;            new EntityKey(EntityKeyType.SERVER_ATTRIBUTE, ACTIVITY_STATE),
&nbsp;            new EntityKey(EntityKeyType.SERVER_ATTRIBUTE, LAST_CONNECT_TIME),
&nbsp;            new EntityKey(EntityKeyType.SERVER_ATTRIBUTE, LAST_DISCONNECT_TIME));
&nbsp;
<b class="nc">&nbsp;    public static final Set&lt;String&gt; ACTIVITY_KEYS_WITHOUT_INACTIVITY_TIMEOUT = Set.of(</b>
&nbsp;            ACTIVITY_STATE, LAST_CONNECT_TIME, LAST_DISCONNECT_TIME, LAST_ACTIVITY_TIME, INACTIVITY_ALARM_TIME
&nbsp;    );
&nbsp;
<b class="nc">&nbsp;    public static final Set&lt;String&gt; ACTIVITY_KEYS_WITH_INACTIVITY_TIMEOUT = Set.of(</b>
&nbsp;            ACTIVITY_STATE, LAST_CONNECT_TIME, LAST_DISCONNECT_TIME, LAST_ACTIVITY_TIME, INACTIVITY_ALARM_TIME, INACTIVITY_TIMEOUT
&nbsp;    );
&nbsp;
<b class="nc">&nbsp;    private static final List&lt;EntityKey&gt; PERSISTENT_ENTITY_FIELDS = Arrays.asList(</b>
&nbsp;            new EntityKey(EntityKeyType.ENTITY_FIELD, &quot;name&quot;),
&nbsp;            new EntityKey(EntityKeyType.ENTITY_FIELD, &quot;type&quot;),
&nbsp;            new EntityKey(EntityKeyType.ENTITY_FIELD, &quot;label&quot;),
&nbsp;            new EntityKey(EntityKeyType.ENTITY_FIELD, &quot;createdTime&quot;));
&nbsp;
&nbsp;    private final DeviceService deviceService;
&nbsp;    private final AttributesService attributesService;
&nbsp;    private final TimeseriesService tsService;
&nbsp;    private final TbClusterService clusterService;
&nbsp;    private final PartitionService partitionService;
&nbsp;    private final EntityQueryRepository entityQueryRepository;
&nbsp;    private final DbTypeInfoComponent dbTypeInfoComponent;
&nbsp;    private final TbApiUsageReportClient apiUsageReportClient;
&nbsp;    private final NotificationRuleProcessor notificationRuleProcessor;
&nbsp;    @Autowired
&nbsp;    @Lazy
&nbsp;    private TelemetrySubscriptionService tsSubService;
&nbsp;
&nbsp;    @Value(&quot;#{${state.defaultInactivityTimeoutInSec} * 1000}&quot;)
&nbsp;    private long defaultInactivityTimeoutMs;
&nbsp;
&nbsp;    @Value(&quot;${state.defaultStateCheckIntervalInSec}&quot;)
&nbsp;    private int defaultStateCheckIntervalInSec;
&nbsp;
&nbsp;    @Value(&quot;${usage.stats.devices.report_interval:60}&quot;)
&nbsp;    private int defaultActivityStatsIntervalInSec;
&nbsp;
&nbsp;    @Value(&quot;${state.persistToTelemetry:false}&quot;)
&nbsp;    private boolean persistToTelemetry;
&nbsp;
&nbsp;    @Value(&quot;${state.initFetchPackSize:50000}&quot;)
&nbsp;    private int initFetchPackSize;
&nbsp;
&nbsp;    @Value(&quot;${state.telemetryTtl:0}&quot;)
&nbsp;    private int telemetryTtl;
&nbsp;
&nbsp;    private ListeningExecutorService deviceStateExecutor;
&nbsp;    private ListeningExecutorService deviceStateCallbackExecutor;
&nbsp;
&nbsp;    final ConcurrentMap&lt;DeviceId, DeviceStateData&gt; deviceStates = new ConcurrentHashMap&lt;&gt;();
&nbsp;
&nbsp;    @PostConstruct
&nbsp;    public void init() {
<b class="nc">&nbsp;        super.init();</b>
<b class="nc">&nbsp;        deviceStateExecutor = MoreExecutors.listeningDecorator(ThingsBoardExecutors.newWorkStealingPool(</b>
<b class="nc">&nbsp;                Math.max(4, Runtime.getRuntime().availableProcessors()), &quot;device-state&quot;));</b>
<b class="nc">&nbsp;        deviceStateCallbackExecutor = MoreExecutors.listeningDecorator(ThingsBoardExecutors.newWorkStealingPool(</b>
<b class="nc">&nbsp;                Math.max(4, Runtime.getRuntime().availableProcessors()), &quot;device-state-callback&quot;));</b>
<b class="nc">&nbsp;        scheduledExecutor.scheduleWithFixedDelay(this::checkStates, new Random().nextInt(defaultStateCheckIntervalInSec), defaultStateCheckIntervalInSec, TimeUnit.SECONDS);</b>
<b class="nc">&nbsp;        scheduledExecutor.scheduleWithFixedDelay(this::reportActivityStats, defaultActivityStatsIntervalInSec, defaultActivityStatsIntervalInSec, TimeUnit.SECONDS);</b>
&nbsp;    }
&nbsp;
&nbsp;    @PreDestroy
&nbsp;    public void stop() {
<b class="nc">&nbsp;        super.stop();</b>
<b class="nc">&nbsp;        if (deviceStateExecutor != null) {</b>
<b class="nc">&nbsp;            deviceStateExecutor.shutdownNow();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (deviceStateCallbackExecutor != null) {</b>
<b class="nc">&nbsp;            deviceStateCallbackExecutor.shutdownNow();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected String getServiceName() {
<b class="nc">&nbsp;        return &quot;Device State&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected String getSchedulerExecutorName() {
<b class="nc">&nbsp;        return &quot;device-state-scheduled&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void onDeviceConnect(TenantId tenantId, DeviceId deviceId, long lastConnectTime) {
<b class="nc">&nbsp;        if (cleanDeviceStateIfBelongsToExternalPartition(tenantId, deviceId)) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        if (lastConnectTime &lt; 0) {</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}] On device connect: received negative last connect ts [{}]. Skipping this event.&quot;,</b>
<b class="nc">&nbsp;                    tenantId.getId(), deviceId.getId(), lastConnectTime);</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        DeviceStateData stateData = getOrFetchDeviceStateData(deviceId);</b>
<b class="nc">&nbsp;        long currentLastConnectTime = stateData.getState().getLastConnectTime();</b>
<b class="nc">&nbsp;        if (lastConnectTime &lt;= currentLastConnectTime) {</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}] On device connect: received outdated last connect ts [{}]. Skipping this event. Current last connect ts [{}].&quot;,</b>
<b class="nc">&nbsp;                    tenantId.getId(), deviceId.getId(), lastConnectTime, currentLastConnectTime);</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        log.trace(&quot;[{}][{}] On device connect: processing connect event with ts [{}].&quot;, tenantId.getId(), deviceId.getId(), lastConnectTime);</b>
<b class="nc">&nbsp;        stateData.getState().setLastConnectTime(lastConnectTime);</b>
<b class="nc">&nbsp;        save(tenantId, deviceId, LAST_CONNECT_TIME, lastConnectTime);</b>
<b class="nc">&nbsp;        pushRuleEngineMessage(stateData, TbMsgType.CONNECT_EVENT);</b>
<b class="nc">&nbsp;        checkAndUpdateState(deviceId, stateData);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void onDeviceActivity(TenantId tenantId, DeviceId deviceId, long lastReportedActivity) {
<b class="nc">&nbsp;        if (cleanDeviceStateIfBelongsToExternalPartition(tenantId, deviceId)) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        log.trace(&quot;[{}] on Device Activity [{}], lastReportedActivity [{}]&quot;, tenantId.getId(), deviceId.getId(), lastReportedActivity);</b>
<b class="nc">&nbsp;        final DeviceStateData stateData = getOrFetchDeviceStateData(deviceId);</b>
<b class="nc">&nbsp;        if (lastReportedActivity &gt; 0 &amp;&amp; lastReportedActivity &gt; stateData.getState().getLastActivityTime()) {</b>
<b class="nc">&nbsp;            updateActivityState(deviceId, stateData, lastReportedActivity);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    void updateActivityState(DeviceId deviceId, DeviceStateData stateData, long lastReportedActivity) {
<b class="nc">&nbsp;        log.trace(&quot;updateActivityState - fetched state {} for device {}, lastReportedActivity {}&quot;, stateData, deviceId, lastReportedActivity);</b>
<b class="nc">&nbsp;        if (stateData != null) {</b>
<b class="nc">&nbsp;            save(stateData.getTenantId(), deviceId, LAST_ACTIVITY_TIME, lastReportedActivity);</b>
<b class="nc">&nbsp;            DeviceState state = stateData.getState();</b>
<b class="nc">&nbsp;            state.setLastActivityTime(lastReportedActivity);</b>
<b class="nc">&nbsp;            if (!state.isActive()) {</b>
<b class="nc">&nbsp;                if (lastReportedActivity &lt;= state.getLastInactivityAlarmTime()) {</b>
<b class="nc">&nbsp;                    state.setLastInactivityAlarmTime(0);</b>
<b class="nc">&nbsp;                    save(stateData.getTenantId(), deviceId, INACTIVITY_ALARM_TIME, 0);</b>
&nbsp;                }
<b class="nc">&nbsp;                onDeviceActivityStatusChange(true, stateData);</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            log.debug(&quot;updateActivityState - fetched state IS NULL for device {}, lastReportedActivity {}&quot;, deviceId, lastReportedActivity);</b>
<b class="nc">&nbsp;            cleanupEntity(deviceId);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void onDeviceDisconnect(TenantId tenantId, DeviceId deviceId, long lastDisconnectTime) {
<b class="nc">&nbsp;        if (cleanDeviceStateIfBelongsToExternalPartition(tenantId, deviceId)) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        if (lastDisconnectTime &lt; 0) {</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}] On device disconnect: received negative last disconnect ts [{}]. Skipping this event.&quot;,</b>
<b class="nc">&nbsp;                    tenantId.getId(), deviceId.getId(), lastDisconnectTime);</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        DeviceStateData stateData = getOrFetchDeviceStateData(deviceId);</b>
<b class="nc">&nbsp;        long currentLastDisconnectTime = stateData.getState().getLastDisconnectTime();</b>
<b class="nc">&nbsp;        if (lastDisconnectTime &lt;= currentLastDisconnectTime) {</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}] On device disconnect: received outdated last disconnect ts [{}]. Skipping this event. Current last disconnect ts [{}].&quot;,</b>
<b class="nc">&nbsp;                    tenantId.getId(), deviceId.getId(), lastDisconnectTime, currentLastDisconnectTime);</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        log.trace(&quot;[{}][{}] On device disconnect: processing disconnect event with ts [{}].&quot;, tenantId.getId(), deviceId.getId(), lastDisconnectTime);</b>
<b class="nc">&nbsp;        stateData.getState().setLastDisconnectTime(lastDisconnectTime);</b>
<b class="nc">&nbsp;        save(tenantId, deviceId, LAST_DISCONNECT_TIME, lastDisconnectTime);</b>
<b class="nc">&nbsp;        pushRuleEngineMessage(stateData, TbMsgType.DISCONNECT_EVENT);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void onDeviceInactivityTimeoutUpdate(TenantId tenantId, DeviceId deviceId, long inactivityTimeout) {
<b class="nc">&nbsp;        if (cleanDeviceStateIfBelongsToExternalPartition(tenantId, deviceId)) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        if (inactivityTimeout &lt;= 0L) {</b>
<b class="nc">&nbsp;            inactivityTimeout = defaultInactivityTimeoutMs;</b>
&nbsp;        }
<b class="nc">&nbsp;        log.trace(&quot;[{}] on Device Activity Timeout Update device id {} inactivityTimeout {}&quot;, tenantId.getId(), deviceId.getId(), inactivityTimeout);</b>
<b class="nc">&nbsp;        DeviceStateData stateData = getOrFetchDeviceStateData(deviceId);</b>
<b class="nc">&nbsp;        stateData.getState().setInactivityTimeout(inactivityTimeout);</b>
<b class="nc">&nbsp;        checkAndUpdateState(deviceId, stateData);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void onDeviceInactivity(TenantId tenantId, DeviceId deviceId, long lastInactivityTime) {
<b class="nc">&nbsp;        if (cleanDeviceStateIfBelongsToExternalPartition(tenantId, deviceId)) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        if (lastInactivityTime &lt; 0) {</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}] On device inactivity: received negative last inactivity ts [{}]. Skipping this event.&quot;,</b>
<b class="nc">&nbsp;                    tenantId.getId(), deviceId.getId(), lastInactivityTime);</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        DeviceStateData stateData = getOrFetchDeviceStateData(deviceId);</b>
<b class="nc">&nbsp;        long currentLastInactivityAlarmTime = stateData.getState().getLastInactivityAlarmTime();</b>
<b class="nc">&nbsp;        if (lastInactivityTime &lt;= currentLastInactivityAlarmTime) {</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}] On device inactivity: received last inactivity ts [{}] is less than current last inactivity ts [{}]. Skipping this event.&quot;,</b>
<b class="nc">&nbsp;                    tenantId.getId(), deviceId.getId(), lastInactivityTime, currentLastInactivityAlarmTime);</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        long currentLastActivityTime = stateData.getState().getLastActivityTime();</b>
<b class="nc">&nbsp;        if (lastInactivityTime &lt;= currentLastActivityTime) {</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}] On device inactivity: received last inactivity ts [{}] is less or equal to current last activity ts [{}]. Skipping this event.&quot;,</b>
<b class="nc">&nbsp;                    tenantId.getId(), deviceId.getId(), lastInactivityTime, currentLastActivityTime);</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        log.trace(&quot;[{}][{}] On device inactivity: processing inactivity event with ts [{}].&quot;, tenantId.getId(), deviceId.getId(), lastInactivityTime);</b>
<b class="nc">&nbsp;        reportInactivity(lastInactivityTime, stateData);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void onQueueMsg(TransportProtos.DeviceStateServiceMsgProto proto, TbCallback callback) {
&nbsp;        try {
<b class="nc">&nbsp;            TenantId tenantId = TenantId.fromUUID(new UUID(proto.getTenantIdMSB(), proto.getTenantIdLSB()));</b>
<b class="nc">&nbsp;            DeviceId deviceId = new DeviceId(new UUID(proto.getDeviceIdMSB(), proto.getDeviceIdLSB()));</b>
<b class="nc">&nbsp;            if (proto.getDeleted()) {</b>
<b class="nc">&nbsp;                onDeviceDeleted(tenantId, deviceId);</b>
<b class="nc">&nbsp;                callback.onSuccess();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                Device device = deviceService.findDeviceById(TenantId.SYS_TENANT_ID, deviceId);</b>
<b class="nc">&nbsp;                if (device != null) {</b>
<b class="nc">&nbsp;                    if (proto.getAdded()) {</b>
<b class="nc">&nbsp;                        Futures.addCallback(fetchDeviceState(device), new FutureCallback&lt;&gt;() {</b>
&nbsp;                            @Override
&nbsp;                            public void onSuccess(DeviceStateData state) {
<b class="nc">&nbsp;                                TopicPartitionInfo tpi = partitionService.resolve(ServiceType.TB_CORE, tenantId, device.getId());</b>
<b class="nc">&nbsp;                                Set&lt;DeviceId&gt; deviceIds = partitionedEntities.get(tpi);</b>
<b class="nc">&nbsp;                                boolean isMyPartition = deviceIds != null;</b>
<b class="nc">&nbsp;                                if (isMyPartition) {</b>
<b class="nc">&nbsp;                                    deviceIds.add(state.getDeviceId());</b>
<b class="nc">&nbsp;                                    initializeActivityState(deviceId, state);</b>
<b class="nc">&nbsp;                                    callback.onSuccess();</b>
&nbsp;                                } else {
<b class="nc">&nbsp;                                    log.debug(&quot;[{}][{}] Device belongs to external partition. Probably rebalancing is in progress. Topic: {}&quot;, tenantId, deviceId, tpi.getFullTopicName());</b>
<b class="nc">&nbsp;                                    callback.onFailure(new RuntimeException(&quot;Device belongs to external partition &quot; + tpi.getFullTopicName() + &quot;!&quot;));</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public void onFailure(@NonNull Throwable t) {
<b class="nc">&nbsp;                                log.warn(&quot;Failed to register device to the state service&quot;, t);</b>
<b class="nc">&nbsp;                                callback.onFailure(t);</b>
&nbsp;                            }
&nbsp;                        }, deviceStateCallbackExecutor);
<b class="nc">&nbsp;                    } else if (proto.getUpdated()) {</b>
<b class="nc">&nbsp;                        DeviceStateData stateData = getOrFetchDeviceStateData(device.getId());</b>
<b class="nc">&nbsp;                        TbMsgMetaData md = new TbMsgMetaData();</b>
<b class="nc">&nbsp;                        md.putValue(&quot;deviceName&quot;, device.getName());</b>
<b class="nc">&nbsp;                        md.putValue(&quot;deviceLabel&quot;, device.getLabel());</b>
<b class="nc">&nbsp;                        md.putValue(&quot;deviceType&quot;, device.getType());</b>
<b class="nc">&nbsp;                        stateData.setMetaData(md);</b>
<b class="nc">&nbsp;                        callback.onSuccess();</b>
&nbsp;                    }
&nbsp;                } else {
&nbsp;                    //Device was probably deleted while message was in queue;
<b class="nc">&nbsp;                    callback.onSuccess();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.trace(&quot;Failed to process queue msg: [{}]&quot;, proto, e);</b>
<b class="nc">&nbsp;            callback.onFailure(e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void onDeviceDeleted(TenantId tenantId, DeviceId deviceId) {
<b class="nc">&nbsp;        cleanupEntity(deviceId);</b>
<b class="nc">&nbsp;        TopicPartitionInfo tpi = partitionService.resolve(ServiceType.TB_CORE, tenantId, deviceId);</b>
<b class="nc">&nbsp;        Set&lt;DeviceId&gt; deviceIdSet = partitionedEntities.get(tpi);</b>
<b class="nc">&nbsp;        if (deviceIdSet != null) {</b>
<b class="nc">&nbsp;            deviceIdSet.remove(deviceId);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void initializeActivityState(DeviceId deviceId, DeviceStateData fetchedState) {
<b class="nc">&nbsp;        DeviceStateData cachedState = deviceStates.putIfAbsent(fetchedState.getDeviceId(), fetchedState);</b>
<b class="nc">&nbsp;        boolean activityState = Objects.requireNonNullElse(cachedState, fetchedState).getState().isActive();</b>
<b class="nc">&nbsp;        save(fetchedState.getTenantId(), deviceId, ACTIVITY_STATE, activityState);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected Map&lt;TopicPartitionInfo, List&lt;ListenableFuture&lt;?&gt;&gt;&gt; onAddedPartitions(Set&lt;TopicPartitionInfo&gt; addedPartitions) {
<b class="nc">&nbsp;        var result = new HashMap&lt;TopicPartitionInfo, List&lt;ListenableFuture&lt;?&gt;&gt;&gt;();</b>
<b class="nc">&nbsp;        PageDataIterable&lt;DeviceIdInfo&gt; deviceIdInfos = new PageDataIterable&lt;&gt;(deviceService::findDeviceIdInfos, initFetchPackSize);</b>
<b class="nc">&nbsp;        Map&lt;TopicPartitionInfo, List&lt;DeviceIdInfo&gt;&gt; tpiDeviceMap = new HashMap&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        for (DeviceIdInfo idInfo : deviceIdInfos) {</b>
&nbsp;            TopicPartitionInfo tpi;
&nbsp;            try {
<b class="nc">&nbsp;                tpi = partitionService.resolve(ServiceType.TB_CORE, idInfo.getTenantId(), idInfo.getDeviceId());</b>
&nbsp;            } catch (Exception e) {
<b class="nc">&nbsp;                log.warn(&quot;Failed to resolve partition for device with id [{}], tenant id [{}], customer id [{}]. Reason: {}&quot;,</b>
<b class="nc">&nbsp;                        idInfo.getDeviceId(), idInfo.getTenantId(), idInfo.getCustomerId(), e.getMessage());</b>
&nbsp;                continue;
&nbsp;            }
<b class="nc">&nbsp;            if (addedPartitions.contains(tpi) &amp;&amp; !deviceStates.containsKey(idInfo.getDeviceId())) {</b>
<b class="nc">&nbsp;                tpiDeviceMap.computeIfAbsent(tpi, tmp -&gt; new ArrayList&lt;&gt;()).add(idInfo);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (var entry : tpiDeviceMap.entrySet()) {</b>
<b class="nc">&nbsp;            AtomicInteger counter = new AtomicInteger(0);</b>
&nbsp;            // hard-coded limit of 1000 is due to the Entity Data Query limitations and should not be changed.
<b class="nc">&nbsp;            for (List&lt;DeviceIdInfo&gt; partition : Lists.partition(entry.getValue(), 1000)) {</b>
<b class="nc">&nbsp;                log.info(&quot;[{}] Submit task for device states: {}&quot;, entry.getKey(), partition.size());</b>
<b class="nc">&nbsp;                DevicePackFutureHolder devicePackFutureHolder = new DevicePackFutureHolder();</b>
<b class="nc">&nbsp;                var devicePackFuture = deviceStateExecutor.submit(() -&gt; {</b>
&nbsp;                    try {
&nbsp;                        List&lt;DeviceStateData&gt; states;
<b class="nc">&nbsp;                        if (persistToTelemetry &amp;&amp; !dbTypeInfoComponent.isLatestTsDaoStoredToSql()) {</b>
<b class="nc">&nbsp;                            states = fetchDeviceStateDataUsingSeparateRequests(partition);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            states = fetchDeviceStateDataUsingEntityDataQuery(partition);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (devicePackFutureHolder.future == null || !devicePackFutureHolder.future.isCancelled()) {</b>
<b class="nc">&nbsp;                            for (var state : states) {</b>
<b class="nc">&nbsp;                                TopicPartitionInfo tpi = entry.getKey();</b>
<b class="nc">&nbsp;                                Set&lt;DeviceId&gt; deviceIds = partitionedEntities.get(tpi);</b>
<b class="nc">&nbsp;                                boolean isMyPartition = deviceIds != null;</b>
<b class="nc">&nbsp;                                if (isMyPartition) {</b>
<b class="nc">&nbsp;                                    deviceIds.add(state.getDeviceId());</b>
<b class="nc">&nbsp;                                    deviceStates.putIfAbsent(state.getDeviceId(), state);</b>
<b class="nc">&nbsp;                                    checkAndUpdateState(state.getDeviceId(), state);</b>
&nbsp;                                } else {
<b class="nc">&nbsp;                                    log.debug(&quot;[{}] Device belongs to external partition {}&quot;, state.getDeviceId(), tpi.getFullTopicName());</b>
&nbsp;                                }
&nbsp;                            }
<b class="nc">&nbsp;                            log.info(&quot;[{}] Initialized {} out of {} device states&quot;, entry.getKey().getPartition().orElse(0), counter.addAndGet(states.size()), entry.getValue().size());</b>
&nbsp;                        }
&nbsp;                    } catch (Throwable t) {
<b class="nc">&nbsp;                        log.error(&quot;Unexpected exception while device pack fetching&quot;, t);</b>
&nbsp;                        throw t;
&nbsp;                    }
&nbsp;                });
<b class="nc">&nbsp;                devicePackFutureHolder.future = devicePackFuture;</b>
<b class="nc">&nbsp;                result.computeIfAbsent(entry.getKey(), tmp -&gt; new ArrayList&lt;&gt;()).add(devicePackFuture);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class DevicePackFutureHolder {
&nbsp;        private volatile ListenableFuture&lt;?&gt; future;
&nbsp;    }
&nbsp;
&nbsp;    void checkAndUpdateState(@Nonnull DeviceId deviceId, @Nonnull DeviceStateData state) {
<b class="nc">&nbsp;        var deviceState = state.getState();</b>
<b class="nc">&nbsp;        if (deviceState.isActive()) {</b>
<b class="nc">&nbsp;            updateInactivityStateIfExpired(getCurrentTimeMillis(), deviceId, state);</b>
&nbsp;        } else {
&nbsp;            //trying to fix activity state
<b class="nc">&nbsp;            if (isActive(getCurrentTimeMillis(), deviceState)) {</b>
<b class="nc">&nbsp;                updateActivityState(deviceId, state, deviceState.getLastActivityTime());</b>
<b class="nc">&nbsp;                if (deviceState.getLastInactivityAlarmTime() != 0L &amp;&amp; deviceState.getLastInactivityAlarmTime() &gt;= deviceState.getLastActivityTime()) {</b>
<b class="nc">&nbsp;                    deviceState.setLastInactivityAlarmTime(0L);</b>
<b class="nc">&nbsp;                    save(state.getTenantId(), deviceId, INACTIVITY_ALARM_TIME, 0L);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    void checkStates() {
&nbsp;        try {
<b class="nc">&nbsp;            final long ts = getCurrentTimeMillis();</b>
<b class="nc">&nbsp;            partitionedEntities.forEach((tpi, deviceIds) -&gt; {</b>
<b class="nc">&nbsp;                log.debug(&quot;Calculating state updates. tpi {} for {} devices&quot;, tpi.getFullTopicName(), deviceIds.size());</b>
<b class="nc">&nbsp;                Set&lt;DeviceId&gt; idsFromRemovedTenant = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;                for (DeviceId deviceId : deviceIds) {</b>
&nbsp;                    DeviceStateData stateData;
&nbsp;                    try {
<b class="nc">&nbsp;                        stateData = getOrFetchDeviceStateData(deviceId);</b>
&nbsp;                    } catch (Exception e) {
<b class="nc">&nbsp;                        log.error(&quot;[{}] Failed to get or fetch device state data&quot;, deviceId, e);</b>
&nbsp;                        continue;
&nbsp;                    }
&nbsp;                    try {
<b class="nc">&nbsp;                        updateInactivityStateIfExpired(ts, deviceId, stateData);</b>
&nbsp;                    } catch (Exception e) {
<b class="nc">&nbsp;                        if (e instanceof TenantNotFoundException) {</b>
<b class="nc">&nbsp;                            idsFromRemovedTenant.add(deviceId);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            log.warn(&quot;[{}] Failed to update inactivity state [{}]&quot;, deviceId, e.getMessage());</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                deviceIds.removeAll(idsFromRemovedTenant);</b>
&nbsp;            });
&nbsp;        } catch (Throwable t) {
<b class="nc">&nbsp;            log.warn(&quot;Failed to check devices states&quot;, t);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void reportActivityStats() {
&nbsp;        try {
<b class="nc">&nbsp;            Map&lt;TenantId, Pair&lt;AtomicInteger, AtomicInteger&gt;&gt; stats = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;            for (DeviceStateData stateData : deviceStates.values()) {</b>
<b class="nc">&nbsp;                Pair&lt;AtomicInteger, AtomicInteger&gt; tenantDevicesActivity = stats.computeIfAbsent(stateData.getTenantId(),</b>
<b class="nc">&nbsp;                        tenantId -&gt; Pair.of(new AtomicInteger(), new AtomicInteger()));</b>
<b class="nc">&nbsp;                if (stateData.getState().isActive()) {</b>
<b class="nc">&nbsp;                    tenantDevicesActivity.getLeft().incrementAndGet();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    tenantDevicesActivity.getRight().incrementAndGet();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            stats.forEach((tenantId, tenantDevicesActivity) -&gt; {</b>
<b class="nc">&nbsp;                int active = tenantDevicesActivity.getLeft().get();</b>
<b class="nc">&nbsp;                int inactive = tenantDevicesActivity.getRight().get();</b>
<b class="nc">&nbsp;                apiUsageReportClient.report(tenantId, null, ApiUsageRecordKey.ACTIVE_DEVICES, active);</b>
<b class="nc">&nbsp;                apiUsageReportClient.report(tenantId, null, ApiUsageRecordKey.INACTIVE_DEVICES, inactive);</b>
<b class="nc">&nbsp;                if (active &gt; 0) {</b>
<b class="nc">&nbsp;                    log.debug(&quot;[{}] Active devices: {}, inactive devices: {}&quot;, tenantId, active, inactive);</b>
&nbsp;                }
&nbsp;            });
&nbsp;        } catch (Throwable t) {
<b class="nc">&nbsp;            log.warn(&quot;Failed to report activity states&quot;, t);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    void updateInactivityStateIfExpired(long ts, DeviceId deviceId, DeviceStateData stateData) {
<b class="nc">&nbsp;        log.trace(&quot;Processing state {} for device {}&quot;, stateData, deviceId);</b>
<b class="nc">&nbsp;        if (stateData != null) {</b>
<b class="nc">&nbsp;            DeviceState state = stateData.getState();</b>
<b class="nc">&nbsp;            if (!isActive(ts, state)</b>
<b class="nc">&nbsp;                    &amp;&amp; (state.getLastInactivityAlarmTime() == 0L || state.getLastInactivityAlarmTime() &lt;= state.getLastActivityTime())</b>
<b class="nc">&nbsp;                    &amp;&amp; stateData.getDeviceCreationTime() + state.getInactivityTimeout() &lt;= ts) {</b>
<b class="nc">&nbsp;                if (partitionService.resolve(ServiceType.TB_CORE, stateData.getTenantId(), deviceId).isMyPartition()) {</b>
<b class="nc">&nbsp;                    reportInactivity(ts, stateData);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    cleanupEntity(deviceId);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            log.debug(&quot;[{}] Device that belongs to other server is detected and removed.&quot;, deviceId);</b>
<b class="nc">&nbsp;            cleanupEntity(deviceId);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void reportInactivity(long ts, DeviceStateData stateData) {
<b class="nc">&nbsp;        var tenantId = stateData.getTenantId();</b>
<b class="nc">&nbsp;        var deviceId = stateData.getDeviceId();</b>
&nbsp;
<b class="nc">&nbsp;        Futures.addCallback(save(stateData.getTenantId(), deviceId, INACTIVITY_ALARM_TIME, ts), new FutureCallback&lt;&gt;() {</b>
&nbsp;            @Override
&nbsp;            public void onSuccess(Void success) {
<b class="nc">&nbsp;                stateData.getState().setLastInactivityAlarmTime(ts);</b>
<b class="nc">&nbsp;                onDeviceActivityStatusChange(false, stateData);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void onFailure(@NonNull Throwable t) {
<b class="nc">&nbsp;                log.error(&quot;[{}][{}] Failed to update device last inactivity alarm time to &#39;{}&#39;. Device state data: {}&quot;, tenantId, deviceId, ts, stateData, t);</b>
&nbsp;            }
&nbsp;        }, deviceStateCallbackExecutor);
&nbsp;    }
&nbsp;
&nbsp;    private static boolean isActive(long ts, DeviceState state) {
<b class="nc">&nbsp;        return ts &lt; state.getLastActivityTime() + state.getInactivityTimeout();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Nonnull
&nbsp;    DeviceStateData getOrFetchDeviceStateData(DeviceId deviceId) {
<b class="nc">&nbsp;        return deviceStates.computeIfAbsent(deviceId, this::fetchDeviceStateDataUsingSeparateRequests);</b>
&nbsp;    }
&nbsp;
&nbsp;    DeviceStateData fetchDeviceStateDataUsingSeparateRequests(final DeviceId deviceId) {
<b class="nc">&nbsp;        final Device device = deviceService.findDeviceById(TenantId.SYS_TENANT_ID, deviceId);</b>
<b class="nc">&nbsp;        if (device == null) {</b>
<b class="nc">&nbsp;            log.warn(&quot;[{}] Failed to fetch device by Id!&quot;, deviceId);</b>
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Failed to fetch device by id [&quot; + deviceId + &quot;]!&quot;);</b>
&nbsp;        }
&nbsp;        try {
<b class="nc">&nbsp;            return fetchDeviceState(device).get();</b>
&nbsp;        } catch (InterruptedException | ExecutionException e) {
<b class="nc">&nbsp;            log.warn(&quot;[{}] Failed to fetch device state!&quot;, deviceId, e);</b>
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Failed to fetch device state for device [&quot; + deviceId + &quot;]&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void onDeviceActivityStatusChange(boolean active, DeviceStateData stateData) {
<b class="nc">&nbsp;        var tenantId = stateData.getTenantId();</b>
<b class="nc">&nbsp;        var deviceId = stateData.getDeviceId();</b>
&nbsp;
<b class="nc">&nbsp;        Futures.addCallback(save(tenantId, deviceId, ACTIVITY_STATE, active), new FutureCallback&lt;&gt;() {</b>
&nbsp;            @Override
&nbsp;            public void onSuccess(Void success) {
<b class="nc">&nbsp;                stateData.getState().setActive(active);</b>
<b class="nc">&nbsp;                pushRuleEngineMessage(stateData, active ? TbMsgType.ACTIVITY_EVENT : TbMsgType.INACTIVITY_EVENT);</b>
<b class="nc">&nbsp;                TbMsgMetaData metaData = stateData.getMetaData();</b>
<b class="nc">&nbsp;                notificationRuleProcessor.process(DeviceActivityTrigger.builder()</b>
<b class="nc">&nbsp;                        .tenantId(tenantId)</b>
<b class="nc">&nbsp;                        .customerId(stateData.getCustomerId())</b>
<b class="nc">&nbsp;                        .deviceId(deviceId)</b>
<b class="nc">&nbsp;                        .active(active)</b>
<b class="nc">&nbsp;                        .deviceName(metaData.getValue(&quot;deviceName&quot;))</b>
<b class="nc">&nbsp;                        .deviceType(metaData.getValue(&quot;deviceType&quot;))</b>
<b class="nc">&nbsp;                        .deviceLabel(metaData.getValue(&quot;deviceLabel&quot;))</b>
<b class="nc">&nbsp;                        .build());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void onFailure(@NonNull Throwable t) {
<b class="nc">&nbsp;                log.error(&quot;[{}][{}] Failed to change device activity status to &#39;{}&#39;. Device state data: {}&quot;, tenantId, deviceId, active, stateData, t);</b>
&nbsp;            }
&nbsp;        }, deviceStateCallbackExecutor);
&nbsp;    }
&nbsp;
&nbsp;    boolean cleanDeviceStateIfBelongsToExternalPartition(TenantId tenantId, final DeviceId deviceId) {
<b class="nc">&nbsp;        TopicPartitionInfo tpi = partitionService.resolve(ServiceType.TB_CORE, tenantId, deviceId);</b>
<b class="nc">&nbsp;        boolean cleanup = !partitionedEntities.containsKey(tpi);</b>
<b class="nc">&nbsp;        if (cleanup) {</b>
<b class="nc">&nbsp;            cleanupEntity(deviceId);</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}][{}] device belongs to external partition. Probably rebalancing is in progress. Topic: {}&quot;, tenantId, deviceId, tpi.getFullTopicName());</b>
&nbsp;        }
<b class="nc">&nbsp;        return cleanup;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected void cleanupEntityOnPartitionRemoval(DeviceId deviceId) {
<b class="nc">&nbsp;        cleanupEntity(deviceId);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void cleanupEntity(DeviceId deviceId) {
<b class="nc">&nbsp;        deviceStates.remove(deviceId);</b>
&nbsp;    }
&nbsp;
&nbsp;    private ListenableFuture&lt;DeviceStateData&gt; fetchDeviceState(Device device) {
&nbsp;        ListenableFuture&lt;DeviceStateData&gt; future;
<b class="nc">&nbsp;        if (persistToTelemetry) {</b>
<b class="nc">&nbsp;            ListenableFuture&lt;List&lt;TsKvEntry&gt;&gt; timeseriesActivityDataFuture = tsService.findLatest(TenantId.SYS_TENANT_ID, device.getId(), ACTIVITY_KEYS_WITHOUT_INACTIVITY_TIMEOUT);</b>
<b class="nc">&nbsp;            ListenableFuture&lt;Optional&lt;AttributeKvEntry&gt;&gt; inactivityTimeoutAttributeFuture = attributesService.find(</b>
<b class="nc">&nbsp;                    TenantId.SYS_TENANT_ID, device.getId(), AttributeScope.SERVER_SCOPE, INACTIVITY_TIMEOUT</b>
&nbsp;            );
&nbsp;
<b class="nc">&nbsp;            ListenableFuture&lt;List&lt;? extends KvEntry&gt;&gt; fullActivityDataFuture = Futures.whenAllSucceed(timeseriesActivityDataFuture, inactivityTimeoutAttributeFuture).call(() -&gt; {</b>
<b class="nc">&nbsp;                List&lt;TsKvEntry&gt; activityTimeseries = Futures.getDone(timeseriesActivityDataFuture);</b>
<b class="nc">&nbsp;                Optional&lt;AttributeKvEntry&gt; inactivityTimeoutAttribute = Futures.getDone(inactivityTimeoutAttributeFuture);</b>
&nbsp;
<b class="nc">&nbsp;                if (inactivityTimeoutAttribute.isPresent()) {</b>
<b class="nc">&nbsp;                    List&lt;KvEntry&gt; result = new ArrayList&lt;&gt;(activityTimeseries.size() + 1);</b>
<b class="nc">&nbsp;                    result.addAll(activityTimeseries);</b>
<b class="nc">&nbsp;                    result.add(inactivityTimeoutAttribute.get());</b>
<b class="nc">&nbsp;                    return result;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return activityTimeseries;</b>
&nbsp;                }
&nbsp;            }, deviceStateCallbackExecutor);
&nbsp;
<b class="nc">&nbsp;            future = Futures.transform(fullActivityDataFuture, extractDeviceStateData(device), MoreExecutors.directExecutor());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            ListenableFuture&lt;List&lt;AttributeKvEntry&gt;&gt; attributesActivityDataFuture = attributesService.find(</b>
<b class="nc">&nbsp;                    TenantId.SYS_TENANT_ID, device.getId(), AttributeScope.SERVER_SCOPE, ACTIVITY_KEYS_WITH_INACTIVITY_TIMEOUT</b>
&nbsp;            );
<b class="nc">&nbsp;            future = Futures.transform(attributesActivityDataFuture, extractDeviceStateData(device), MoreExecutors.directExecutor());</b>
&nbsp;        }
<b class="nc">&nbsp;        return future;</b>
&nbsp;    }
&nbsp;
&nbsp;    private Function&lt;List&lt;? extends KvEntry&gt;, DeviceStateData&gt; extractDeviceStateData(Device device) {
<b class="nc">&nbsp;        return new Function&lt;&gt;() {</b>
&nbsp;            @Nonnull
&nbsp;            @Override
&nbsp;            public DeviceStateData apply(@Nullable List&lt;? extends KvEntry&gt; data) {
&nbsp;                try {
<b class="nc">&nbsp;                    long lastActivityTime = getEntryValue(data, LAST_ACTIVITY_TIME, 0L);</b>
<b class="nc">&nbsp;                    long inactivityAlarmTime = getEntryValue(data, INACTIVITY_ALARM_TIME, 0L);</b>
<b class="nc">&nbsp;                    long inactivityTimeout = getEntryValue(data, INACTIVITY_TIMEOUT, defaultInactivityTimeoutMs);</b>
&nbsp;                    // Actual active state by wall-clock will be updated outside this method. This method is only for fetching persistent state
<b class="nc">&nbsp;                    final boolean active = getEntryValue(data, ACTIVITY_STATE, false);</b>
<b class="nc">&nbsp;                    DeviceState deviceState = DeviceState.builder()</b>
<b class="nc">&nbsp;                            .active(active)</b>
<b class="nc">&nbsp;                            .lastConnectTime(getEntryValue(data, LAST_CONNECT_TIME, 0L))</b>
<b class="nc">&nbsp;                            .lastDisconnectTime(getEntryValue(data, LAST_DISCONNECT_TIME, 0L))</b>
<b class="nc">&nbsp;                            .lastActivityTime(lastActivityTime)</b>
<b class="nc">&nbsp;                            .lastInactivityAlarmTime(inactivityAlarmTime)</b>
<b class="nc">&nbsp;                            .inactivityTimeout(inactivityTimeout &gt; 0 ? inactivityTimeout : defaultInactivityTimeoutMs)</b>
<b class="nc">&nbsp;                            .build();</b>
<b class="nc">&nbsp;                    TbMsgMetaData md = new TbMsgMetaData();</b>
<b class="nc">&nbsp;                    md.putValue(&quot;deviceName&quot;, device.getName());</b>
<b class="nc">&nbsp;                    md.putValue(&quot;deviceLabel&quot;, device.getLabel());</b>
<b class="nc">&nbsp;                    md.putValue(&quot;deviceType&quot;, device.getType());</b>
<b class="nc">&nbsp;                    DeviceStateData deviceStateData = DeviceStateData.builder()</b>
<b class="nc">&nbsp;                            .customerId(device.getCustomerId())</b>
<b class="nc">&nbsp;                            .tenantId(device.getTenantId())</b>
<b class="nc">&nbsp;                            .deviceId(device.getId())</b>
<b class="nc">&nbsp;                            .deviceCreationTime(device.getCreatedTime())</b>
<b class="nc">&nbsp;                            .metaData(md)</b>
<b class="nc">&nbsp;                            .state(deviceState).build();</b>
<b class="nc">&nbsp;                    log.debug(&quot;[{}] Fetched device state from the DB {}&quot;, device.getId(), deviceStateData);</b>
<b class="nc">&nbsp;                    return deviceStateData;</b>
&nbsp;                } catch (Exception e) {
<b class="nc">&nbsp;                    log.warn(&quot;[{}] Failed to fetch device state data&quot;, device.getId(), e);</b>
<b class="nc">&nbsp;                    throw new RuntimeException(&quot;Failed to fetch device state data for device [&quot; + device.getId() + &quot;]&quot;, e);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;DeviceStateData&gt; fetchDeviceStateDataUsingSeparateRequests(List&lt;DeviceIdInfo&gt; deviceIds) {
<b class="nc">&nbsp;        List&lt;Device&gt; devices = deviceService.findDevicesByIds(deviceIds.stream().map(DeviceIdInfo::getDeviceId).collect(Collectors.toList()));</b>
<b class="nc">&nbsp;        List&lt;ListenableFuture&lt;DeviceStateData&gt;&gt; deviceStateFutures = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Device device : devices) {</b>
<b class="nc">&nbsp;            deviceStateFutures.add(fetchDeviceState(device));</b>
&nbsp;        }
&nbsp;        try {
<b class="nc">&nbsp;            List&lt;DeviceStateData&gt; result = Futures.successfulAsList(deviceStateFutures).get(5, TimeUnit.MINUTES);</b>
<b class="nc">&nbsp;            boolean success = true;</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; result.size(); i++) {</b>
<b class="nc">&nbsp;                success = false;</b>
<b class="nc">&nbsp;                if (result.get(i) == null) {</b>
<b class="nc">&nbsp;                    DeviceIdInfo deviceIdInfo = deviceIds.get(i);</b>
<b class="nc">&nbsp;                    log.warn(&quot;[{}][{}] Failed to initialized device state due to:&quot;, deviceIdInfo.getTenantId(), deviceIdInfo.getDeviceId());</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return success ? result : result.stream().filter(Objects::nonNull).collect(Collectors.toList());</b>
&nbsp;        } catch (InterruptedException | ExecutionException | TimeoutException e) {
<b class="nc">&nbsp;            String deviceIdsStr = deviceIds.stream()</b>
<b class="nc">&nbsp;                    .map(DeviceIdInfo::getDeviceId)</b>
<b class="nc">&nbsp;                    .map(UUIDBased::getId)</b>
<b class="nc">&nbsp;                    .map(UUID::toString)</b>
<b class="nc">&nbsp;                    .collect(Collectors.joining(&quot;, &quot;));</b>
<b class="nc">&nbsp;            log.warn(&quot;Failed to initialized device state futures for ids [{}] due to:&quot;, deviceIdsStr, e);</b>
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Failed to initialized device state futures for ids [&quot; + deviceIdsStr + &quot;]!&quot;, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;DeviceStateData&gt; fetchDeviceStateDataUsingEntityDataQuery(List&lt;DeviceIdInfo&gt; deviceIds) {
<b class="nc">&nbsp;        EntityListFilter ef = new EntityListFilter();</b>
<b class="nc">&nbsp;        ef.setEntityType(EntityType.DEVICE);</b>
<b class="nc">&nbsp;        ef.setEntityList(deviceIds.stream().map(DeviceIdInfo::getDeviceId).map(DeviceId::getId).map(UUID::toString).collect(Collectors.toList()));</b>
&nbsp;
<b class="nc">&nbsp;        EntityDataQuery query = new EntityDataQuery(ef,</b>
<b class="nc">&nbsp;                new EntityDataPageLink(deviceIds.size(), 0, null, null),</b>
&nbsp;                PERSISTENT_ENTITY_FIELDS,
<b class="nc">&nbsp;                persistToTelemetry ? PERSISTENT_TELEMETRY_KEYS : PERSISTENT_ATTRIBUTE_KEYS, Collections.emptyList());</b>
<b class="nc">&nbsp;        PageData&lt;EntityData&gt; queryResult = entityQueryRepository.findEntityDataByQueryInternal(query);</b>
&nbsp;
<b class="nc">&nbsp;        Map&lt;EntityId, DeviceIdInfo&gt; deviceIdInfos = deviceIds.stream().collect(Collectors.toMap(DeviceIdInfo::getDeviceId, java.util.function.Function.identity()));</b>
&nbsp;
<b class="nc">&nbsp;        return queryResult.getData().stream().map(ed -&gt; toDeviceStateData(ed, deviceIdInfos.get(ed.getEntityId()))).collect(Collectors.toList());</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    private DeviceStateData toDeviceStateData(EntityData ed, DeviceIdInfo deviceIdInfo) {
<b class="nc">&nbsp;        long lastActivityTime = getEntryValue(ed, getKeyType(), LAST_ACTIVITY_TIME, 0L);</b>
<b class="nc">&nbsp;        long inactivityAlarmTime = getEntryValue(ed, getKeyType(), INACTIVITY_ALARM_TIME, 0L);</b>
<b class="nc">&nbsp;        long inactivityTimeout = getEntryValue(ed, EntityKeyType.SERVER_ATTRIBUTE, INACTIVITY_TIMEOUT, defaultInactivityTimeoutMs);</b>
&nbsp;        // Actual active state by wall-clock will be updated outside this method. This method is only for fetching persistent state
<b class="nc">&nbsp;        final boolean active = getEntryValue(ed, getKeyType(), ACTIVITY_STATE, false);</b>
<b class="nc">&nbsp;        DeviceState deviceState = DeviceState.builder()</b>
<b class="nc">&nbsp;                .active(active)</b>
<b class="nc">&nbsp;                .lastConnectTime(getEntryValue(ed, getKeyType(), LAST_CONNECT_TIME, 0L))</b>
<b class="nc">&nbsp;                .lastDisconnectTime(getEntryValue(ed, getKeyType(), LAST_DISCONNECT_TIME, 0L))</b>
<b class="nc">&nbsp;                .lastActivityTime(lastActivityTime)</b>
<b class="nc">&nbsp;                .lastInactivityAlarmTime(inactivityAlarmTime)</b>
<b class="nc">&nbsp;                .inactivityTimeout(inactivityTimeout)</b>
<b class="nc">&nbsp;                .build();</b>
<b class="nc">&nbsp;        TbMsgMetaData md = new TbMsgMetaData();</b>
<b class="nc">&nbsp;        md.putValue(&quot;deviceName&quot;, getEntryValue(ed, EntityKeyType.ENTITY_FIELD, &quot;name&quot;, &quot;&quot;));</b>
<b class="nc">&nbsp;        md.putValue(&quot;deviceLabel&quot;, getEntryValue(ed, EntityKeyType.ENTITY_FIELD, &quot;label&quot;, &quot;&quot;));</b>
<b class="nc">&nbsp;        md.putValue(&quot;deviceType&quot;, getEntryValue(ed, EntityKeyType.ENTITY_FIELD, &quot;type&quot;, &quot;&quot;));</b>
<b class="nc">&nbsp;        return DeviceStateData.builder()</b>
<b class="nc">&nbsp;                .customerId(deviceIdInfo.getCustomerId())</b>
<b class="nc">&nbsp;                .tenantId(deviceIdInfo.getTenantId())</b>
<b class="nc">&nbsp;                .deviceId(deviceIdInfo.getDeviceId())</b>
<b class="nc">&nbsp;                .deviceCreationTime(getEntryValue(ed, EntityKeyType.ENTITY_FIELD, &quot;createdTime&quot;, 0L))</b>
<b class="nc">&nbsp;                .metaData(md)</b>
<b class="nc">&nbsp;                .state(deviceState).build();</b>
&nbsp;    }
&nbsp;
&nbsp;    private EntityKeyType getKeyType() {
<b class="nc">&nbsp;        return persistToTelemetry ? EntityKeyType.TIME_SERIES : EntityKeyType.SERVER_ATTRIBUTE;</b>
&nbsp;    }
&nbsp;
&nbsp;    private String getEntryValue(EntityData ed, EntityKeyType keyType, String keyName, String defaultValue) {
<b class="nc">&nbsp;        return getEntryValue(ed, keyType, keyName, s -&gt; s, defaultValue);</b>
&nbsp;    }
&nbsp;
&nbsp;    private long getEntryValue(EntityData ed, EntityKeyType keyType, String keyName, long defaultValue) {
<b class="nc">&nbsp;        return getEntryValue(ed, keyType, keyName, Long::parseLong, defaultValue);</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean getEntryValue(EntityData ed, EntityKeyType keyType, String keyName, boolean defaultValue) {
<b class="nc">&nbsp;        return getEntryValue(ed, keyType, keyName, Boolean::parseBoolean, defaultValue);</b>
&nbsp;    }
&nbsp;
&nbsp;    private &lt;T&gt; T getEntryValue(EntityData ed, EntityKeyType entityKeyType, String attributeName, Function&lt;String, T&gt; converter, T defaultValue) {
<b class="nc">&nbsp;        if (ed != null &amp;&amp; ed.getLatest() != null) {</b>
<b class="nc">&nbsp;            var map = ed.getLatest().get(entityKeyType);</b>
<b class="nc">&nbsp;            if (map != null) {</b>
<b class="nc">&nbsp;                var value = map.get(attributeName);</b>
<b class="nc">&nbsp;                if (value != null &amp;&amp; !StringUtils.isEmpty(value.getValue())) {</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        return converter.apply(value.getValue());</b>
&nbsp;                    } catch (Exception e) {
<b class="nc">&nbsp;                        return defaultValue;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return defaultValue;</b>
&nbsp;    }
&nbsp;
&nbsp;    private long getEntryValue(List&lt;? extends KvEntry&gt; kvEntries, String attributeName, long defaultValue) {
<b class="nc">&nbsp;        if (kvEntries != null) {</b>
<b class="nc">&nbsp;            for (KvEntry entry : kvEntries) {</b>
<b class="nc">&nbsp;                if (entry != null &amp;&amp; !StringUtils.isEmpty(entry.getKey()) &amp;&amp; entry.getKey().equals(attributeName)) {</b>
<b class="nc">&nbsp;                    return entry.getLongValue().orElse(defaultValue);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return defaultValue;</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean getEntryValue(List&lt;? extends KvEntry&gt; kvEntries, String attributeName, boolean defaultValue) {
<b class="nc">&nbsp;        if (kvEntries != null) {</b>
<b class="nc">&nbsp;            for (KvEntry entry : kvEntries) {</b>
<b class="nc">&nbsp;                if (entry != null &amp;&amp; !StringUtils.isEmpty(entry.getKey()) &amp;&amp; entry.getKey().equals(attributeName)) {</b>
<b class="nc">&nbsp;                    return entry.getBooleanValue().orElse(defaultValue);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return defaultValue;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void pushRuleEngineMessage(DeviceStateData stateData, TbMsgType msgType) {
<b class="nc">&nbsp;        var tenantId = stateData.getTenantId();</b>
<b class="nc">&nbsp;        var deviceId = stateData.getDeviceId();</b>
&nbsp;
<b class="nc">&nbsp;        DeviceState state = stateData.getState();</b>
&nbsp;        try {
&nbsp;            String data;
<b class="nc">&nbsp;            if (msgType.equals(TbMsgType.CONNECT_EVENT)) {</b>
<b class="nc">&nbsp;                ObjectNode stateNode = JacksonUtil.convertValue(state, ObjectNode.class);</b>
<b class="nc">&nbsp;                stateNode.remove(ACTIVITY_STATE);</b>
<b class="nc">&nbsp;                data = JacksonUtil.toString(stateNode);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                data = JacksonUtil.toString(state);</b>
&nbsp;            }
<b class="nc">&nbsp;            TbMsgMetaData md = stateData.getMetaData().copy();</b>
<b class="nc">&nbsp;            if (!persistToTelemetry) {</b>
<b class="nc">&nbsp;                md.putValue(SCOPE, SERVER_SCOPE);</b>
&nbsp;            }
<b class="nc">&nbsp;            TbMsg tbMsg = TbMsg.newMsg()</b>
<b class="nc">&nbsp;                    .type(msgType)</b>
<b class="nc">&nbsp;                    .originator(deviceId)</b>
<b class="nc">&nbsp;                    .customerId(stateData.getCustomerId())</b>
<b class="nc">&nbsp;                    .copyMetaData(md)</b>
<b class="nc">&nbsp;                    .dataType(TbMsgDataType.JSON)</b>
<b class="nc">&nbsp;                    .data(data)</b>
<b class="nc">&nbsp;                    .build();</b>
<b class="nc">&nbsp;            clusterService.pushMsgToRuleEngine(stateData.getTenantId(), stateData.getDeviceId(), tbMsg, null);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.warn(&quot;[{}][{}] Failed to push &#39;{}&#39; message to the rule engine due to {}. Device state: {}&quot;, tenantId, deviceId, msgType, e.getMessage(), state);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private ListenableFuture&lt;Void&gt; save(TenantId tenantId, DeviceId deviceId, String key, long value) {
<b class="nc">&nbsp;        return save(tenantId, deviceId, new LongDataEntry(key, value), getCurrentTimeMillis());</b>
&nbsp;    }
&nbsp;
&nbsp;    private ListenableFuture&lt;Void&gt; save(TenantId tenantId, DeviceId deviceId, String key, boolean value) {
<b class="nc">&nbsp;        return save(tenantId, deviceId, new BooleanDataEntry(key, value), getCurrentTimeMillis());</b>
&nbsp;    }
&nbsp;
&nbsp;    private ListenableFuture&lt;Void&gt; save(TenantId tenantId, DeviceId deviceId, KvEntry kvEntry, long ts) {
&nbsp;        ListenableFuture&lt;?&gt; future;
<b class="nc">&nbsp;        if (persistToTelemetry) {</b>
<b class="nc">&nbsp;            future = tsSubService.saveTimeseriesInternal(TimeseriesSaveRequest.builder()</b>
<b class="nc">&nbsp;                    .tenantId(tenantId)</b>
<b class="nc">&nbsp;                    .entityId(deviceId)</b>
<b class="nc">&nbsp;                    .entry(new BasicTsKvEntry(ts, kvEntry))</b>
<b class="nc">&nbsp;                    .ttl(telemetryTtl)</b>
<b class="nc">&nbsp;                    .callback(new TelemetrySaveCallback&lt;&gt;(deviceId, kvEntry))</b>
<b class="nc">&nbsp;                    .build());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            future = tsSubService.saveAttributesInternal(AttributesSaveRequest.builder()</b>
<b class="nc">&nbsp;                    .tenantId(tenantId)</b>
<b class="nc">&nbsp;                    .entityId(deviceId)</b>
<b class="nc">&nbsp;                    .scope(AttributeScope.SERVER_SCOPE)</b>
<b class="nc">&nbsp;                    .entry(new BaseAttributeKvEntry(ts, kvEntry))</b>
<b class="nc">&nbsp;                    .callback(new TelemetrySaveCallback&lt;&gt;(deviceId, kvEntry))</b>
<b class="nc">&nbsp;                    .build());</b>
&nbsp;        }
<b class="nc">&nbsp;        return Futures.transform(future, __ -&gt; null, MoreExecutors.directExecutor());</b>
&nbsp;    }
&nbsp;
&nbsp;    long getCurrentTimeMillis() {
<b class="nc">&nbsp;        return System.currentTimeMillis();</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private record TelemetrySaveCallback&lt;T&gt;(DeviceId deviceId, KvEntry kvEntry) implements FutureCallback&lt;T&gt; {</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void onSuccess(@Nullable T result) {
<b class="nc">&nbsp;            log.trace(&quot;[{}] Successfully updated entry {}&quot;, deviceId, kvEntry);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onFailure(@NonNull Throwable t) {
<b class="nc">&nbsp;            log.warn(&quot;[{}] Failed to update entry {}&quot;, deviceId, kvEntry, t);</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
