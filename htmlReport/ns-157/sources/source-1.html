<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > AbstractCalculatedFieldProcessingService</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.server.service.cf</a>
</div>

<h1>Coverage Summary for Class: AbstractCalculatedFieldProcessingService (org.thingsboard.server.service.cf)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AbstractCalculatedFieldProcessingService</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/47)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/80)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/212)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AbstractCalculatedFieldProcessingService$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractCalculatedFieldProcessingService$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractCalculatedFieldProcessingService$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractCalculatedFieldProcessingService$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/57)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/82)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/233)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.server.service.cf;
&nbsp;
&nbsp;import com.fasterxml.jackson.databind.node.ObjectNode;
&nbsp;import com.google.common.util.concurrent.FutureCallback;
&nbsp;import com.google.common.util.concurrent.Futures;
&nbsp;import com.google.common.util.concurrent.ListenableFuture;
&nbsp;import com.google.common.util.concurrent.ListeningExecutorService;
&nbsp;import com.google.common.util.concurrent.MoreExecutors;
&nbsp;import com.google.gson.JsonElement;
&nbsp;import jakarta.annotation.PostConstruct;
&nbsp;import jakarta.annotation.PreDestroy;
&nbsp;import lombok.Data;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.apache.commons.lang3.function.TriConsumer;
&nbsp;import org.thingsboard.common.util.DonAsynchron;
&nbsp;import org.thingsboard.common.util.JacksonUtil;
&nbsp;import org.thingsboard.common.util.ThingsBoardExecutors;
&nbsp;import org.thingsboard.rule.engine.api.AttributesSaveRequest;
&nbsp;import org.thingsboard.rule.engine.api.AttributesSaveRequest.Strategy;
&nbsp;import org.thingsboard.rule.engine.api.TimeseriesSaveRequest;
&nbsp;import org.thingsboard.server.actors.calculatedField.MultipleTbCallback;
&nbsp;import org.thingsboard.server.cluster.TbClusterService;
&nbsp;import org.thingsboard.server.common.adaptor.JsonConverter;
&nbsp;import org.thingsboard.server.common.data.AttributeScope;
&nbsp;import org.thingsboard.server.common.data.cf.CalculatedField;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.Argument;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.ArgumentType;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.AttributesImmediateOutputStrategy;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.OutputStrategy;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.OutputType;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.RelationPathQueryDynamicSourceConfiguration;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.TimeSeriesImmediateOutputStrategy;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.aggregation.AggFunction;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.aggregation.AggMetric;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.aggregation.RelatedEntitiesAggregationCalculatedFieldConfiguration;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.aggregation.single.EntityAggregationCalculatedFieldConfiguration;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.aggregation.single.interval.AggInterval;
&nbsp;import org.thingsboard.server.common.data.id.CalculatedFieldId;
&nbsp;import org.thingsboard.server.common.data.id.EntityId;
&nbsp;import org.thingsboard.server.common.data.id.TenantId;
&nbsp;import org.thingsboard.server.common.data.kv.Aggregation;
&nbsp;import org.thingsboard.server.common.data.kv.AttributeKvEntry;
&nbsp;import org.thingsboard.server.common.data.kv.BaseReadTsKvQuery;
&nbsp;import org.thingsboard.server.common.data.kv.KvEntry;
&nbsp;import org.thingsboard.server.common.data.kv.ReadTsKvQuery;
&nbsp;import org.thingsboard.server.common.data.kv.TsKvEntry;
&nbsp;import org.thingsboard.server.common.data.relation.EntityRelation;
&nbsp;import org.thingsboard.server.common.data.relation.EntityRelationPathQuery;
&nbsp;import org.thingsboard.server.common.data.relation.RelationPathLevel;
&nbsp;import org.thingsboard.server.common.data.tenant.profile.DefaultTenantProfileConfiguration;
&nbsp;import org.thingsboard.server.common.msg.TbMsg;
&nbsp;import org.thingsboard.server.common.msg.TbMsgMetaData;
&nbsp;import org.thingsboard.server.common.msg.queue.TbCallback;
&nbsp;import org.thingsboard.server.dao.attributes.AttributesService;
&nbsp;import org.thingsboard.server.dao.relation.RelationService;
&nbsp;import org.thingsboard.server.dao.timeseries.TimeseriesService;
&nbsp;import org.thingsboard.server.dao.usagerecord.ApiLimitService;
&nbsp;import org.thingsboard.server.queue.TbQueueCallback;
&nbsp;import org.thingsboard.server.queue.TbQueueMsgMetadata;
&nbsp;import org.thingsboard.server.service.cf.ctx.state.ArgumentEntry;
&nbsp;import org.thingsboard.server.service.cf.ctx.state.CalculatedFieldCtx;
&nbsp;import org.thingsboard.server.service.cf.ctx.state.aggregation.single.AggIntervalEntry;
&nbsp;import org.thingsboard.server.service.telemetry.TelemetrySubscriptionService;
&nbsp;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import java.util.concurrent.ExecutionException;
&nbsp;import java.util.function.Function;
&nbsp;import java.util.function.Predicate;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;import static org.thingsboard.server.common.data.DataConstants.CF_NAME_METADATA_KEY;
&nbsp;import static org.thingsboard.server.common.data.DataConstants.SCOPE;
&nbsp;import static org.thingsboard.server.common.data.cf.CalculatedFieldType.PROPAGATION;
&nbsp;import static org.thingsboard.server.common.data.cf.configuration.PropagationCalculatedFieldConfiguration.PROPAGATION_CONFIG_ARGUMENT;
&nbsp;import static org.thingsboard.server.common.data.cf.configuration.geofencing.EntityCoordinates.ENTITY_ID_LATITUDE_ARGUMENT_KEY;
&nbsp;import static org.thingsboard.server.common.data.cf.configuration.geofencing.EntityCoordinates.ENTITY_ID_LONGITUDE_ARGUMENT_KEY;
&nbsp;import static org.thingsboard.server.common.data.msg.TbMsgType.ATTRIBUTES_UPDATED;
&nbsp;import static org.thingsboard.server.dao.util.KvUtils.filterChangedAttr;
&nbsp;import static org.thingsboard.server.dao.util.KvUtils.toTsKvEntryList;
&nbsp;import static org.thingsboard.server.utils.CalculatedFieldArgumentUtils.createDefaultAttributeEntry;
&nbsp;import static org.thingsboard.server.utils.CalculatedFieldArgumentUtils.createDefaultTsKvEntry;
&nbsp;import static org.thingsboard.server.utils.CalculatedFieldArgumentUtils.transformAggMetricArgument;
&nbsp;import static org.thingsboard.server.utils.CalculatedFieldArgumentUtils.transformAggregationArgument;
&nbsp;import static org.thingsboard.server.utils.CalculatedFieldArgumentUtils.transformSingleValueArgument;
&nbsp;import static org.thingsboard.server.utils.CalculatedFieldArgumentUtils.transformTsRollingArgument;
&nbsp;
&nbsp;@Data
<b class="nc">&nbsp;@Slf4j</b>
&nbsp;public abstract class AbstractCalculatedFieldProcessingService {
&nbsp;
&nbsp;    protected final AttributesService attributesService;
&nbsp;    protected final TimeseriesService timeseriesService;
&nbsp;    protected final TelemetrySubscriptionService tsSubService;
&nbsp;    protected final ApiLimitService apiLimitService;
&nbsp;    protected final RelationService relationService;
&nbsp;    protected final OwnerService ownerService;
&nbsp;    protected final TbClusterService clusterService;
&nbsp;
&nbsp;    protected ListeningExecutorService calculatedFieldCallbackExecutor;
&nbsp;
&nbsp;    @PostConstruct
&nbsp;    public void init() {
<b class="nc">&nbsp;        calculatedFieldCallbackExecutor = MoreExecutors.listeningDecorator(ThingsBoardExecutors.newWorkStealingPool(</b>
<b class="nc">&nbsp;                Math.max(4, Runtime.getRuntime().availableProcessors()), getExecutorNamePrefix()));</b>
&nbsp;    }
&nbsp;
&nbsp;    @PreDestroy
&nbsp;    public void stop() {
<b class="nc">&nbsp;        if (calculatedFieldCallbackExecutor != null) {</b>
<b class="nc">&nbsp;            calculatedFieldCallbackExecutor.shutdownNow();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected abstract String getExecutorNamePrefix();
&nbsp;
&nbsp;    protected ListenableFuture&lt;Map&lt;String, ArgumentEntry&gt;&gt; fetchArguments(CalculatedFieldCtx ctx, EntityId entityId, long ts) {
<b class="nc">&nbsp;        Map&lt;String, ListenableFuture&lt;ArgumentEntry&gt;&gt; argFutures = switch (ctx.getCfType()) {</b>
<b class="nc">&nbsp;            case GEOFENCING -&gt; fetchGeofencingCalculatedFieldArguments(ctx, entityId, false, ts);</b>
<b class="nc">&nbsp;            case SIMPLE, SCRIPT, ALARM, PROPAGATION -&gt; getBaseCalculatedFieldArguments(ctx, entityId, ts);</b>
<b class="nc">&nbsp;            case RELATED_ENTITIES_AGGREGATION -&gt; fetchRelatedEntitiesAggArguments(ctx, entityId, ts);</b>
<b class="nc">&nbsp;            case ENTITY_AGGREGATION -&gt; fetchEntityAggArguments(ctx, entityId, ts);</b>
&nbsp;        };
<b class="nc">&nbsp;        if (ctx.getCfType() == PROPAGATION) {</b>
<b class="nc">&nbsp;            argFutures.put(PROPAGATION_CONFIG_ARGUMENT, fetchPropagationCalculatedFieldArgument(ctx, entityId));</b>
&nbsp;        }
<b class="nc">&nbsp;        return Futures.whenAllComplete(argFutures.values())</b>
<b class="nc">&nbsp;                .call(() -&gt; resolveArgumentFutures(argFutures),</b>
<b class="nc">&nbsp;                        MoreExecutors.directExecutor());</b>
&nbsp;    }
&nbsp;
&nbsp;    private Map&lt;String, ListenableFuture&lt;ArgumentEntry&gt;&gt; getBaseCalculatedFieldArguments(CalculatedFieldCtx ctx, EntityId entityId, long ts) {
<b class="nc">&nbsp;        Map&lt;String, ListenableFuture&lt;ArgumentEntry&gt;&gt; futures = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        for (var entry : ctx.getArguments().entrySet()) {</b>
<b class="nc">&nbsp;            var argEntityId = resolveEntityId(ctx.getTenantId(), entityId, entry.getValue());</b>
<b class="nc">&nbsp;            var argValueFuture = fetchArgumentValue(ctx.getTenantId(), argEntityId, entry.getValue(), ts);</b>
<b class="nc">&nbsp;            futures.put(entry.getKey(), argValueFuture);</b>
&nbsp;        }
<b class="nc">&nbsp;        return futures;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected EntityId resolveEntityId(TenantId tenantId, EntityId entityId, Argument argument) {
<b class="nc">&nbsp;        if (argument.getRefEntityId() != null) {</b>
<b class="nc">&nbsp;            return argument.getRefEntityId();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (!argument.hasOwnerSource()) {</b>
<b class="nc">&nbsp;            return entityId;</b>
&nbsp;        }
<b class="nc">&nbsp;        return resolveOwnerArgument(tenantId, entityId);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected Map&lt;String, ArgumentEntry&gt; resolveArgumentFutures(Map&lt;String, ListenableFuture&lt;ArgumentEntry&gt;&gt; argFutures) {
<b class="nc">&nbsp;        return argFutures.entrySet().stream()</b>
<b class="nc">&nbsp;                .collect(Collectors.toMap(</b>
&nbsp;                        Map.Entry::getKey, // Keep the key as is
<b class="nc">&nbsp;                        entry -&gt; resolveArgumentValue(entry.getKey(), entry.getValue())</b>
&nbsp;                ));
&nbsp;    }
&nbsp;
&nbsp;    protected ArgumentEntry resolveArgumentValue(String key, ListenableFuture&lt;ArgumentEntry&gt; future) {
&nbsp;        try {
<b class="nc">&nbsp;            return future.get();</b>
&nbsp;        } catch (ExecutionException e) {
<b class="nc">&nbsp;            Throwable cause = e.getCause();</b>
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Failed to fetch &#39;&quot; + key + &quot;&#39; argument: &quot; + cause.getMessage(), cause);</b>
&nbsp;        } catch (InterruptedException e) {
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Failed to fetch &#39;&quot; + key + &quot;&#39; argument!&quot;, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected ListenableFuture&lt;ArgumentEntry&gt; fetchPropagationCalculatedFieldArgument(CalculatedFieldCtx ctx, EntityId entityId) {
<b class="nc">&nbsp;        ListenableFuture&lt;List&lt;EntityId&gt;&gt; propagationEntityIds = fromDynamicSource(ctx.getTenantId(), entityId, ctx.getPropagationArgument());</b>
<b class="nc">&nbsp;        return Futures.transform(propagationEntityIds, ArgumentEntry::createPropagationArgument, MoreExecutors.directExecutor());</b>
&nbsp;    }
&nbsp;
&nbsp;    protected Map&lt;String, ListenableFuture&lt;ArgumentEntry&gt;&gt; fetchGeofencingCalculatedFieldArguments(CalculatedFieldCtx ctx, EntityId entityId, boolean dynamicArgumentsOnly, long startTs) {
<b class="nc">&nbsp;        Map&lt;String, ListenableFuture&lt;ArgumentEntry&gt;&gt; argFutures = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        Set&lt;Map.Entry&lt;String, Argument&gt;&gt; entries = ctx.getArguments().entrySet();</b>
<b class="nc">&nbsp;        if (dynamicArgumentsOnly) {</b>
<b class="nc">&nbsp;            entries = entries.stream()</b>
<b class="nc">&nbsp;                    .filter(entry -&gt; entry.getValue().hasRelationQuerySource())</b>
<b class="nc">&nbsp;                    .collect(Collectors.toSet());</b>
&nbsp;        }
<b class="nc">&nbsp;        for (var entry : entries) {</b>
<b class="nc">&nbsp;            switch (entry.getKey()) {</b>
&nbsp;                case ENTITY_ID_LATITUDE_ARGUMENT_KEY, ENTITY_ID_LONGITUDE_ARGUMENT_KEY -&gt;
<b class="nc">&nbsp;                        argFutures.put(entry.getKey(), fetchArgumentValue(ctx.getTenantId(), entityId, entry.getValue(), startTs));</b>
&nbsp;                default -&gt; {
<b class="nc">&nbsp;                    var resolvedEntityIdsFuture = resolveGeofencingEntityIds(ctx.getTenantId(), entityId, entry);</b>
<b class="nc">&nbsp;                    argFutures.put(entry.getKey(), Futures.transformAsync(resolvedEntityIdsFuture, resolvedEntityIds -&gt;</b>
<b class="nc">&nbsp;                            fetchGeofencingArgumentValue(ctx.getTenantId(), resolvedEntityIds, entry.getValue(), startTs), MoreExecutors.directExecutor()));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return argFutures;</b>
&nbsp;    }
&nbsp;
&nbsp;    private Map&lt;String, ListenableFuture&lt;ArgumentEntry&gt;&gt; fetchRelatedEntitiesAggArguments(CalculatedFieldCtx ctx, EntityId entityId, long ts) {
<b class="nc">&nbsp;        if (!(ctx.getCalculatedField().getConfiguration() instanceof RelatedEntitiesAggregationCalculatedFieldConfiguration config)) {</b>
<b class="nc">&nbsp;            return Collections.emptyMap();</b>
&nbsp;        }
<b class="nc">&nbsp;        ListenableFuture&lt;List&lt;EntityId&gt;&gt; relatedEntitiesFut = resolveRelatedEntities(ctx.getTenantId(), entityId, config.getRelation());</b>
&nbsp;
<b class="nc">&nbsp;        return config.getArguments().entrySet().stream()</b>
<b class="nc">&nbsp;                .collect(Collectors.toMap(</b>
&nbsp;                        Map.Entry::getKey,
<b class="nc">&nbsp;                        entry -&gt; Futures.transformAsync(relatedEntitiesFut, relatedEntities -&gt; fetchRelatedEntitiesArgumentEntry(ctx.getTenantId(), relatedEntities, entry.getValue(), ts), MoreExecutors.directExecutor())</b>
&nbsp;                ));
&nbsp;    }
&nbsp;
&nbsp;    private Map&lt;String, ListenableFuture&lt;ArgumentEntry&gt;&gt; fetchEntityAggArguments(CalculatedFieldCtx ctx, EntityId entityId, long ts) {
<b class="nc">&nbsp;        if (!(ctx.getCalculatedField().getConfiguration() instanceof EntityAggregationCalculatedFieldConfiguration config)) {</b>
<b class="nc">&nbsp;            return Collections.emptyMap();</b>
&nbsp;        }
<b class="nc">&nbsp;        return config.getArguments().entrySet().stream()</b>
<b class="nc">&nbsp;                .collect(Collectors.toMap(</b>
&nbsp;                        Map.Entry::getKey,
<b class="nc">&nbsp;                        entry -&gt; fetchTimeSeries(ctx.getTenantId(), entityId, entry.getValue(), config.getInterval(), ts)</b>
&nbsp;                ));
&nbsp;    }
&nbsp;
&nbsp;    protected ListenableFuture&lt;List&lt;EntityId&gt;&gt; resolveRelatedEntities(TenantId tenantId, EntityId entityId, RelationPathLevel relation) {
<b class="nc">&nbsp;        Predicate&lt;EntityRelation&gt; filter = entityRelation -&gt; CalculatedField.isSupportedRefEntity(entityRelation.getFrom()) &amp;&amp; CalculatedField.isSupportedRefEntity(entityRelation.getTo());</b>
<b class="nc">&nbsp;        ListenableFuture&lt;List&lt;EntityRelation&gt;&gt; relationsFut = relationService.findFilteredRelationsByPathQueryAsync(tenantId, new EntityRelationPathQuery(entityId, List.of(relation)), filter);</b>
&nbsp;
<b class="nc">&nbsp;        return Futures.transform(relationsFut, relations -&gt; {</b>
<b class="nc">&nbsp;            if (relations == null) {</b>
<b class="nc">&nbsp;                return Collections.emptyList();</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return switch (relation.direction()) {</b>
<b class="nc">&nbsp;                case FROM -&gt; relations.stream().map(EntityRelation::getTo).toList();</b>
<b class="nc">&nbsp;                case TO -&gt; relations.stream().map(EntityRelation::getFrom).toList();</b>
&nbsp;            };
&nbsp;        }, calculatedFieldCallbackExecutor);
&nbsp;    }
&nbsp;
&nbsp;    private ListenableFuture&lt;List&lt;EntityId&gt;&gt; resolveGeofencingEntityIds(TenantId tenantId, EntityId entityId, Map.Entry&lt;String, Argument&gt; entry) {
<b class="nc">&nbsp;        Argument value = entry.getValue();</b>
<b class="nc">&nbsp;        if (value.getRefEntityId() != null) {</b>
<b class="nc">&nbsp;            return Futures.immediateFuture(List.of(value.getRefEntityId()));</b>
&nbsp;        }
<b class="nc">&nbsp;        if (!value.hasDynamicSource()) {</b>
<b class="nc">&nbsp;            return Futures.immediateFuture(List.of(entityId));</b>
&nbsp;        }
<b class="nc">&nbsp;        return fromDynamicSource(tenantId, entityId, value);</b>
&nbsp;    }
&nbsp;
&nbsp;    private ListenableFuture&lt;List&lt;EntityId&gt;&gt; fromDynamicSource(TenantId tenantId, EntityId entityId, Argument value) {
<b class="nc">&nbsp;        var refDynamicSourceConfiguration = value.getRefDynamicSourceConfiguration();</b>
<b class="nc">&nbsp;        return switch (refDynamicSourceConfiguration.getType()) {</b>
<b class="nc">&nbsp;            case CURRENT_OWNER -&gt; Futures.immediateFuture(List.of(resolveOwnerArgument(tenantId, entityId)));</b>
&nbsp;            case RELATION_PATH_QUERY -&gt; {
<b class="nc">&nbsp;                var configuration = (RelationPathQueryDynamicSourceConfiguration) refDynamicSourceConfiguration;</b>
<b class="nc">&nbsp;                Predicate&lt;EntityRelation&gt; filter = entityRelation -&gt; CalculatedField.isSupportedRefEntity(entityRelation.getFrom()) &amp;&amp; CalculatedField.isSupportedRefEntity(entityRelation.getTo());</b>
<b class="nc">&nbsp;                yield Futures.transform(relationService.findFilteredRelationsByPathQueryAsync(tenantId, configuration.toRelationPathQuery(entityId), filter),</b>
<b class="nc">&nbsp;                        configuration::resolveEntityIds, calculatedFieldCallbackExecutor);</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    private EntityId resolveOwnerArgument(TenantId tenantId, EntityId entityId) {
<b class="nc">&nbsp;        return ownerService.getOwner(tenantId, entityId);</b>
&nbsp;    }
&nbsp;
&nbsp;    private ListenableFuture&lt;ArgumentEntry&gt; fetchGeofencingArgumentValue(TenantId tenantId, List&lt;EntityId&gt; geofencingEntities, Argument argument, long startTs) {
<b class="nc">&nbsp;        if (argument.getRefEntityKey().getType() != ArgumentType.ATTRIBUTE) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Unsupported argument key type: &quot; + argument.getRefEntityKey().getType());</b>
&nbsp;        }
<b class="nc">&nbsp;        var geofencingEntityIdToKvEntryMapFutures = Futures.allAsList(fetchGeofencingEntityIdToKvEntriesFutures(tenantId, geofencingEntities, argument, startTs));</b>
<b class="nc">&nbsp;        return Futures.transform(geofencingEntityIdToKvEntryMapFutures, entries -&gt; ArgumentEntry.createGeofencingValueArgument(entries.stream()</b>
<b class="nc">&nbsp;                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))), MoreExecutors.directExecutor());</b>
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;ListenableFuture&lt;Map.Entry&lt;EntityId, AttributeKvEntry&gt;&gt;&gt; fetchGeofencingEntityIdToKvEntriesFutures(TenantId tenantId, List&lt;EntityId&gt; geofencingEntities, Argument argument, long startTs) {
<b class="nc">&nbsp;        return geofencingEntities.stream()</b>
<b class="nc">&nbsp;                .map(entityId -&gt; {</b>
<b class="nc">&nbsp;                    AttributeScope scope = argument.getRefEntityKey().getScope();</b>
<b class="nc">&nbsp;                    String key = argument.getRefEntityKey().getKey();</b>
<b class="nc">&nbsp;                    var attributesFuture = attributesService.find(tenantId, entityId, scope, key);</b>
<b class="nc">&nbsp;                    return Futures.transform(attributesFuture, resultOpt -&gt;</b>
<b class="nc">&nbsp;                                    Map.entry(entityId, resultOpt.orElseGet(() -&gt; createDefaultAttributeEntry(argument, startTs))),</b>
&nbsp;                            calculatedFieldCallbackExecutor);
<b class="nc">&nbsp;                }).collect(Collectors.toList());</b>
&nbsp;    }
&nbsp;
&nbsp;    private ListenableFuture&lt;ArgumentEntry&gt; fetchRelatedEntitiesArgumentEntry(TenantId tenantId, List&lt;EntityId&gt; aggEntities, Argument argument, long startTs) {
<b class="nc">&nbsp;        List&lt;ListenableFuture&lt;Map.Entry&lt;EntityId, ArgumentEntry&gt;&gt;&gt; futures = aggEntities.stream()</b>
<b class="nc">&nbsp;                .map(entityId -&gt; {</b>
<b class="nc">&nbsp;                    ListenableFuture&lt;ArgumentEntry&gt; argumentEntryFut = fetchArgumentValue(tenantId, entityId, argument, startTs);</b>
<b class="nc">&nbsp;                    return Futures.transform(argumentEntryFut, argumentEntry -&gt; Map.entry(entityId, ArgumentEntry.createSingleValueArgument(entityId, argumentEntry)), MoreExecutors.directExecutor());</b>
&nbsp;                })
<b class="nc">&nbsp;                .toList();</b>
&nbsp;
<b class="nc">&nbsp;        ListenableFuture&lt;List&lt;Map.Entry&lt;EntityId, ? extends ArgumentEntry&gt;&gt;&gt; allFutures = Futures.allAsList(futures);</b>
&nbsp;
<b class="nc">&nbsp;        return Futures.transform(allFutures,</b>
<b class="nc">&nbsp;                entries -&gt; ArgumentEntry.createAggArgument(</b>
<b class="nc">&nbsp;                        entries.stream().collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))</b>
&nbsp;                ),
<b class="nc">&nbsp;                MoreExecutors.directExecutor());</b>
&nbsp;    }
&nbsp;
&nbsp;    protected ListenableFuture&lt;ArgumentEntry&gt; fetchArgumentValue(TenantId tenantId, EntityId entityId, Argument argument, long startTs) {
<b class="nc">&nbsp;        return switch (argument.getRefEntityKey().getType()) {</b>
<b class="nc">&nbsp;            case TS_ROLLING -&gt; fetchTsRolling(tenantId, entityId, argument, startTs);</b>
<b class="nc">&nbsp;            case ATTRIBUTE -&gt; fetchAttribute(tenantId, entityId, argument, startTs);</b>
<b class="nc">&nbsp;            case TS_LATEST -&gt; fetchTsLatest(tenantId, entityId, argument, startTs);</b>
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    protected ArgumentEntry fetchMetricDuringInterval(TenantId tenantId, EntityId entityId, String argKey, AggMetric metric, AggIntervalEntry interval) {
<b class="nc">&nbsp;        AggFunction function = metric.getFunction();</b>
<b class="nc">&nbsp;        long intervalMs = interval.getEndTs() - interval.getStartTs();</b>
<b class="nc">&nbsp;        BaseReadTsKvQuery query = new BaseReadTsKvQuery(argKey, interval.getStartTs(), interval.getEndTs(), intervalMs, 1, Aggregation.valueOf(function.name()));</b>
<b class="nc">&nbsp;        ListenableFuture&lt;ArgumentEntry&gt; argumentEntryFut = fetchTimeSeriesInternal(tenantId, entityId, query, timeSeries -&gt; transformAggMetricArgument(timeSeries, argKey, metric));</b>
<b class="nc">&nbsp;        return resolveArgumentValue(argKey, argumentEntryFut);</b>
&nbsp;    }
&nbsp;
&nbsp;    private ListenableFuture&lt;ArgumentEntry&gt; fetchTimeSeries(TenantId tenantId, EntityId entityId, Argument argument, AggInterval interval, long queryEndTs) {
<b class="nc">&nbsp;        long intervalStartTs = interval.getCurrentIntervalStartTs();</b>
<b class="nc">&nbsp;        long intervalEndTs = interval.getCurrentIntervalEndTs();</b>
<b class="nc">&nbsp;        ReadTsKvQuery query = new BaseReadTsKvQuery(argument.getRefEntityKey().getKey(), intervalStartTs, queryEndTs, 0, 1, Aggregation.NONE);</b>
<b class="nc">&nbsp;        return fetchTimeSeriesInternal(tenantId, entityId, query, timeSeries -&gt; transformAggregationArgument(timeSeries, intervalStartTs, intervalEndTs));</b>
&nbsp;    }
&nbsp;
&nbsp;    private ListenableFuture&lt;ArgumentEntry&gt; fetchTsRolling(TenantId tenantId, EntityId entityId, Argument argument, long queryEndTs) {
<b class="nc">&nbsp;        long argTimeWindow = argument.getTimeWindow() == 0 ? queryEndTs : argument.getTimeWindow();</b>
<b class="nc">&nbsp;        long startInterval = queryEndTs - argTimeWindow;</b>
<b class="nc">&nbsp;        ReadTsKvQuery query = buildTsRollingQuery(tenantId, argument, startInterval, queryEndTs);</b>
<b class="nc">&nbsp;        return fetchTimeSeriesInternal(tenantId, entityId, query, tsRolling -&gt; transformTsRollingArgument(tsRolling, query.getLimit(), argTimeWindow));</b>
&nbsp;    }
&nbsp;
&nbsp;    private ListenableFuture&lt;ArgumentEntry&gt; fetchAttribute(TenantId tenantId, EntityId entityId, Argument argument, long defaultLastUpdateTs) {
<b class="nc">&nbsp;        log.trace(&quot;[{}][{}] Fetching attribute for key {}&quot;, tenantId, entityId, argument.getRefEntityKey());</b>
<b class="nc">&nbsp;        var attributeOptFuture = attributesService.find(tenantId, entityId, argument.getRefEntityKey().getScope(), argument.getRefEntityKey().getKey());</b>
&nbsp;
<b class="nc">&nbsp;        return Futures.transform(attributeOptFuture, attrOpt -&gt; {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}][{}] Fetched attribute for key {}: {}&quot;, tenantId, entityId, argument.getRefEntityKey(), attrOpt);</b>
<b class="nc">&nbsp;            return transformSingleValueArgument(attrOpt.orElseGet(() -&gt; createDefaultAttributeEntry(argument, defaultLastUpdateTs)));</b>
&nbsp;        }, calculatedFieldCallbackExecutor);
&nbsp;    }
&nbsp;
&nbsp;    private ListenableFuture&lt;ArgumentEntry&gt; fetchTsLatest(TenantId tenantId, EntityId entityId, Argument argument, long defaultTs) {
<b class="nc">&nbsp;        String timeseriesKey = argument.getRefEntityKey().getKey();</b>
<b class="nc">&nbsp;        log.trace(&quot;[{}][{}] Fetching latest timeseries {}&quot;, tenantId, entityId, timeseriesKey);</b>
<b class="nc">&nbsp;        return Futures.transform(timeseriesService.findLatest(tenantId, entityId, timeseriesKey), result -&gt; {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}][{}] Fetched latest timeseries {}: {}&quot;, tenantId, entityId, timeseriesKey, result);</b>
<b class="nc">&nbsp;            return transformSingleValueArgument(result.orElseGet(() -&gt; createDefaultTsKvEntry(argument, defaultTs)));</b>
&nbsp;        }, calculatedFieldCallbackExecutor);
&nbsp;    }
&nbsp;
&nbsp;    private ListenableFuture&lt;ArgumentEntry&gt; fetchTimeSeriesInternal(TenantId tenantId, EntityId entityId, ReadTsKvQuery query, Function&lt;List&lt;TsKvEntry&gt;, ArgumentEntry&gt; transformArgument) {
<b class="nc">&nbsp;        log.trace(&quot;[{}][{}] Fetching timeseries for query {}&quot;, tenantId, entityId, query);</b>
<b class="nc">&nbsp;        ListenableFuture&lt;List&lt;TsKvEntry&gt;&gt; tsRollingFuture = timeseriesService.findAll(tenantId, entityId, List.of(query));</b>
<b class="nc">&nbsp;        return Futures.transform(tsRollingFuture, tsRolling -&gt; {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}][{}] Fetched {} timeseries for query {}&quot;, tenantId, entityId, tsRolling == null ? 0 : tsRolling.size(), query);</b>
<b class="nc">&nbsp;            return transformArgument.apply(tsRolling);</b>
&nbsp;        }, calculatedFieldCallbackExecutor);
&nbsp;    }
&nbsp;
&nbsp;    private ReadTsKvQuery buildTsRollingQuery(TenantId tenantId, Argument argument, long startTs, long endTs) {
<b class="nc">&nbsp;        long maxDataPoints = apiLimitService.getLimit(</b>
&nbsp;                tenantId, DefaultTenantProfileConfiguration::getMaxDataPointsPerRollingArg);
<b class="nc">&nbsp;        int argumentLimit = argument.getLimit();</b>
<b class="nc">&nbsp;        int limit = argumentLimit == 0 || argumentLimit &gt; maxDataPoints ? (int) maxDataPoints : argumentLimit;</b>
<b class="nc">&nbsp;        return new BaseReadTsKvQuery(argument.getRefEntityKey().getKey(), startTs, endTs, 0, limit, Aggregation.NONE);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void handlePropagationResults(PropagationCalculatedFieldResult propagationResult, TbCallback callback,
&nbsp;                                          TriConsumer&lt;EntityId, TelemetryCalculatedFieldResult, TbCallback&gt; telemetryResultHandler) {
<b class="nc">&nbsp;        List&lt;EntityId&gt; propagationEntityIds = propagationResult.getEntityIds();</b>
<b class="nc">&nbsp;        if (propagationEntityIds.isEmpty()) {</b>
<b class="nc">&nbsp;            callback.onSuccess();</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        if (propagationEntityIds.size() == 1) {</b>
<b class="nc">&nbsp;            EntityId propagationEntityId = propagationEntityIds.get(0);</b>
<b class="nc">&nbsp;            telemetryResultHandler.accept(propagationEntityId, propagationResult.getResult(), callback);</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        MultipleTbCallback multipleTbCallback = new MultipleTbCallback(propagationEntityIds.size(), callback);</b>
<b class="nc">&nbsp;        for (var propagationEntityId : propagationEntityIds) {</b>
<b class="nc">&nbsp;            telemetryResultHandler.accept(propagationEntityId, propagationResult.getResult(), multipleTbCallback);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected void sendMsgToRuleEngine(TenantId tenantId, EntityId entityId, TbCallback callback, TbMsg msg) {
&nbsp;        try {
<b class="nc">&nbsp;            clusterService.pushMsgToRuleEngine(tenantId, entityId, msg, new TbQueueCallback() {</b>
&nbsp;                @Override
&nbsp;                public void onSuccess(TbQueueMsgMetadata metadata) {
<b class="nc">&nbsp;                    log.trace(&quot;[{}][{}] Pushed message to rule engine: {} &quot;, tenantId, entityId, msg);</b>
<b class="nc">&nbsp;                    callback.onSuccess();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onFailure(Throwable t) {
<b class="nc">&nbsp;                    callback.onFailure(t);</b>
&nbsp;                }
&nbsp;            });
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.warn(&quot;[{}][{}] Failed to push message to rule engine: {}&quot;, tenantId, entityId, msg, e);</b>
<b class="nc">&nbsp;            callback.onFailure(e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected void saveTelemetryResult(TenantId tenantId, EntityId entityId, String cfName, TelemetryCalculatedFieldResult cfResult, List&lt;CalculatedFieldId&gt; cfIds, TbCallback callback) {
<b class="nc">&nbsp;        OutputType type = cfResult.getType();</b>
<b class="nc">&nbsp;        JsonElement jsonResult = cfResult.toJsonElement();</b>
&nbsp;
<b class="nc">&nbsp;        log.trace(&quot;[{}][{}] Saving CF result: {}&quot;, tenantId, entityId, jsonResult);</b>
<b class="nc">&nbsp;        switch (type) {</b>
<b class="nc">&nbsp;            case ATTRIBUTES -&gt; saveAttributes(tenantId, entityId, jsonResult, cfResult.getOutputStrategy(), cfResult.getScope(), cfName, cfIds, callback);</b>
<b class="nc">&nbsp;            case TIME_SERIES -&gt; saveTimeSeries(tenantId, entityId, jsonResult, cfResult.getOutputStrategy(), cfIds, System.currentTimeMillis(), callback);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void saveAttributes(TenantId tenantId, EntityId entityId, JsonElement jsonResult, OutputStrategy outputStrategy, AttributeScope scope, String cfName, List&lt;CalculatedFieldId&gt; cfIds, TbCallback callback) {
<b class="nc">&nbsp;        if (!(outputStrategy instanceof AttributesImmediateOutputStrategy attOutputStrategy)) {</b>
<b class="nc">&nbsp;            callback.onFailure(new IllegalArgumentException(&quot;Only AttributeImmediateOutputStrategy is supported.&quot;));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            AttributesSaveRequest.Strategy strategy = new Strategy(attOutputStrategy.isSaveAttribute(), attOutputStrategy.isSendWsUpdate(), attOutputStrategy.isProcessCfs());</b>
<b class="nc">&nbsp;            List&lt;AttributeKvEntry&gt; newAttributes = JsonConverter.convertToAttributes(jsonResult);</b>
&nbsp;
<b class="nc">&nbsp;            if (!attOutputStrategy.isUpdateAttributesOnlyOnValueChange()) {</b>
<b class="nc">&nbsp;                saveAttributesInternal(tenantId, entityId, scope, cfName, cfIds, newAttributes, strategy, attOutputStrategy.isSendAttributesUpdatedNotification(), callback);</b>
&nbsp;                return;
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            List&lt;String&gt; keys = newAttributes.stream().map(KvEntry::getKey).collect(Collectors.toList());</b>
<b class="nc">&nbsp;            ListenableFuture&lt;List&lt;AttributeKvEntry&gt;&gt; findFuture = attributesService.find(tenantId, entityId, scope, keys);</b>
&nbsp;
<b class="nc">&nbsp;            DonAsynchron.withCallback(findFuture,</b>
&nbsp;                    existingAttributes -&gt; {
<b class="nc">&nbsp;                        List&lt;AttributeKvEntry&gt; changed = filterChangedAttr(existingAttributes, newAttributes);</b>
<b class="nc">&nbsp;                        if (changed.isEmpty()) {</b>
<b class="nc">&nbsp;                            callback.onSuccess();</b>
&nbsp;                            return;
&nbsp;                        }
<b class="nc">&nbsp;                        saveAttributesInternal(tenantId, entityId, scope, cfName, cfIds, changed, strategy, attOutputStrategy.isSendAttributesUpdatedNotification(), callback);</b>
&nbsp;                    },
<b class="nc">&nbsp;                    callback::onFailure,</b>
<b class="nc">&nbsp;                    MoreExecutors.directExecutor());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void saveAttributesInternal(TenantId tenantId, EntityId entityId,
&nbsp;                                        AttributeScope scope,
&nbsp;                                        String cfName,
&nbsp;                                        List&lt;CalculatedFieldId&gt; cfIds,
&nbsp;                                        List&lt;AttributeKvEntry&gt; entries,
&nbsp;                                        AttributesSaveRequest.Strategy strategy,
&nbsp;                                        boolean sendAttributesUpdatedNotification,
&nbsp;                                        TbCallback callback) {
<b class="nc">&nbsp;        tsSubService.saveAttributes(AttributesSaveRequest.builder()</b>
<b class="nc">&nbsp;                .tenantId(tenantId)</b>
<b class="nc">&nbsp;                .entityId(entityId)</b>
<b class="nc">&nbsp;                .scope(scope)</b>
<b class="nc">&nbsp;                .entries(entries)</b>
<b class="nc">&nbsp;                .strategy(strategy)</b>
<b class="nc">&nbsp;                .previousCalculatedFieldIds(cfIds)</b>
<b class="nc">&nbsp;                .callback(new FutureCallback&lt;&gt;() {</b>
&nbsp;                    @Override
&nbsp;                    public void onSuccess(Void result) {
<b class="nc">&nbsp;                        if (sendAttributesUpdatedNotification) {</b>
<b class="nc">&nbsp;                            sendAttributesUpdatedMsg(tenantId, entityId, scope, cfName, entries);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        callback.onSuccess();</b>
<b class="nc">&nbsp;                        log.debug(&quot;[{}][{}] Saved CF result: {}&quot;, tenantId, entityId, entries);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void onFailure(Throwable t) {
<b class="nc">&nbsp;                        callback.onFailure(t);</b>
<b class="nc">&nbsp;                        log.error(&quot;[{}][{}] Failed to save CF result {}&quot;, tenantId, entityId, entries, t);</b>
&nbsp;                    }
&nbsp;                })
<b class="nc">&nbsp;                .build());</b>
&nbsp;    }
&nbsp;
&nbsp;    private void saveTimeSeries(TenantId tenantId, EntityId entityId, JsonElement jsonResult, OutputStrategy outputStrategy, List&lt;CalculatedFieldId&gt; cfIds, long ts, TbCallback callback) {
<b class="nc">&nbsp;        if (!(outputStrategy instanceof TimeSeriesImmediateOutputStrategy tsOutputStrategy)) {</b>
<b class="nc">&nbsp;            callback.onFailure(new IllegalArgumentException(&quot;Only TimeSeriesImmediateOutputStrategy is supported.&quot;));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            TimeseriesSaveRequest.Strategy strategy = new TimeseriesSaveRequest.Strategy(tsOutputStrategy.isSaveTimeSeries(), tsOutputStrategy.isSaveLatest(), tsOutputStrategy.isSendWsUpdate(), tsOutputStrategy.isProcessCfs());</b>
<b class="nc">&nbsp;            saveTimeSeriesInternal(tenantId, entityId, jsonResult, tsOutputStrategy.getTtl(), cfIds, ts, strategy, callback);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void saveTimeSeriesInternal(TenantId tenantId, EntityId entityId, JsonElement jsonResult, Long ttl, List&lt;CalculatedFieldId&gt; cfIds, long ts, TimeseriesSaveRequest.Strategy strategy, TbCallback callback) {
<b class="nc">&nbsp;        Map&lt;Long, List&lt;KvEntry&gt;&gt; tsKvMap = JsonConverter.convertToTelemetry(jsonResult, ts);</b>
<b class="nc">&nbsp;        if (tsKvMap.isEmpty()) {</b>
<b class="nc">&nbsp;            callback.onSuccess();</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        List&lt;TsKvEntry&gt; tsEntries = toTsKvEntryList(tsKvMap);</b>
<b class="nc">&nbsp;        TimeseriesSaveRequest.Builder builder = TimeseriesSaveRequest.builder()</b>
<b class="nc">&nbsp;                .tenantId(tenantId)</b>
<b class="nc">&nbsp;                .entityId(entityId)</b>
<b class="nc">&nbsp;                .entries(tsEntries)</b>
<b class="nc">&nbsp;                .strategy(strategy)</b>
<b class="nc">&nbsp;                .callback(new FutureCallback&lt;&gt;() {</b>
&nbsp;                    @Override
&nbsp;                    public void onSuccess(Void result) {
<b class="nc">&nbsp;                        callback.onSuccess();</b>
<b class="nc">&nbsp;                        log.debug(&quot;[{}][{}] Saved CF result: {}&quot;, tenantId, entityId, tsEntries);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void onFailure(Throwable t) {
<b class="nc">&nbsp;                        callback.onFailure(t);</b>
<b class="nc">&nbsp;                        log.error(&quot;[{}][{}] Failed to save CF result {}&quot;, tenantId, entityId, tsEntries, t);</b>
&nbsp;                    }
&nbsp;                });
<b class="nc">&nbsp;        if (ttl != null) {</b>
<b class="nc">&nbsp;            builder.ttl(ttl);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (cfIds != null &amp;&amp; !cfIds.isEmpty()) {</b>
<b class="nc">&nbsp;            builder.previousCalculatedFieldIds(cfIds);</b>
&nbsp;        }
<b class="nc">&nbsp;        tsSubService.saveTimeseries(builder.build());</b>
&nbsp;    }
&nbsp;
&nbsp;    private void sendAttributesUpdatedMsg(TenantId tenantId, EntityId entityId,
&nbsp;                                          AttributeScope scope,
&nbsp;                                          String cfName,
&nbsp;                                          List&lt;AttributeKvEntry&gt; entries) {
<b class="nc">&nbsp;        ObjectNode entityNode = JacksonUtil.newObjectNode();</b>
<b class="nc">&nbsp;        if (entries != null) {</b>
<b class="nc">&nbsp;            entries.forEach(attributeKvEntry -&gt; JacksonUtil.addKvEntry(entityNode, attributeKvEntry));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        TbMsg attributesUpdatedMsg = TbMsg.newMsg()</b>
<b class="nc">&nbsp;                .type(ATTRIBUTES_UPDATED)</b>
<b class="nc">&nbsp;                .originator(entityId)</b>
<b class="nc">&nbsp;                .data(JacksonUtil.toString(entityNode))</b>
<b class="nc">&nbsp;                .metaData(new TbMsgMetaData(Map.of(</b>
&nbsp;                        CF_NAME_METADATA_KEY, cfName,
<b class="nc">&nbsp;                        SCOPE, scope.name()</b>
&nbsp;                )))
<b class="nc">&nbsp;                .build();</b>
&nbsp;
<b class="nc">&nbsp;        sendMsgToRuleEngine(tenantId, entityId, TbCallback.EMPTY, attributesUpdatedMsg);</b>
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
