<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > CalculatedFieldEntityMessageProcessor</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.server.actors.calculatedField</a>
</div>

<h1>Coverage Summary for Class: CalculatedFieldEntityMessageProcessor (org.thingsboard.server.actors.calculatedField)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">CalculatedFieldEntityMessageProcessor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/56)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/202)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/369)
  </span>
</td>
</tr>
  <tr>
    <td class="name">CalculatedFieldEntityMessageProcessor$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CalculatedFieldEntityMessageProcessor$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/60)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/202)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/373)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.server.actors.calculatedField;
&nbsp;
&nbsp;import com.google.common.util.concurrent.ListenableFuture;
&nbsp;import lombok.SneakyThrows;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.thingsboard.common.util.DebugModeUtil;
&nbsp;import org.thingsboard.server.actors.ActorSystemContext;
&nbsp;import org.thingsboard.server.actors.TbActorCtx;
&nbsp;import org.thingsboard.server.actors.calculatedField.EntityInitCalculatedFieldMsg.StateAction;
&nbsp;import org.thingsboard.server.actors.shared.AbstractContextAwareMsgProcessor;
&nbsp;import org.thingsboard.server.common.data.AttributeScope;
&nbsp;import org.thingsboard.server.common.data.DataConstants;
&nbsp;import org.thingsboard.server.common.data.StringUtils;
&nbsp;import org.thingsboard.server.common.data.alarm.Alarm;
&nbsp;import org.thingsboard.server.common.data.cf.CalculatedFieldEventType;
&nbsp;import org.thingsboard.server.common.data.cf.CalculatedFieldType;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.Argument;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.ArgumentType;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.ReferencedEntityKey;
&nbsp;import org.thingsboard.server.common.data.id.CalculatedFieldId;
&nbsp;import org.thingsboard.server.common.data.id.EntityId;
&nbsp;import org.thingsboard.server.common.data.id.TenantId;
&nbsp;import org.thingsboard.server.common.data.kv.StringDataEntry;
&nbsp;import org.thingsboard.server.common.data.msg.TbMsgType;
&nbsp;import org.thingsboard.server.common.data.util.CollectionsUtil;
&nbsp;import org.thingsboard.server.common.msg.CalculatedFieldStatePartitionRestoreMsg;
&nbsp;import org.thingsboard.server.common.msg.cf.CalculatedFieldPartitionChangeMsg;
&nbsp;import org.thingsboard.server.common.msg.queue.ServiceType;
&nbsp;import org.thingsboard.server.common.msg.queue.TbCallback;
&nbsp;import org.thingsboard.server.common.util.ProtoUtils;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.AttributeScopeProto;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.AttributeValueProto;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.CalculatedFieldTelemetryMsgProto;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.TsKvProto;
&nbsp;import org.thingsboard.server.service.cf.CalculatedFieldProcessingService;
&nbsp;import org.thingsboard.server.service.cf.CalculatedFieldResult;
&nbsp;import org.thingsboard.server.service.cf.CalculatedFieldStateService;
&nbsp;import org.thingsboard.server.service.cf.ctx.CalculatedFieldEntityCtxId;
&nbsp;import org.thingsboard.server.service.cf.ctx.state.ArgumentEntry;
&nbsp;import org.thingsboard.server.service.cf.ctx.state.CalculatedFieldCtx;
&nbsp;import org.thingsboard.server.service.cf.ctx.state.CalculatedFieldState;
&nbsp;import org.thingsboard.server.service.cf.ctx.state.SingleValueArgumentEntry;
&nbsp;import org.thingsboard.server.service.cf.ctx.state.TsRollingArgumentEntry;
&nbsp;import org.thingsboard.server.service.cf.ctx.state.aggregation.RelatedEntitiesAggregationCalculatedFieldState;
&nbsp;import org.thingsboard.server.service.cf.ctx.state.alarm.AlarmCalculatedFieldState;
&nbsp;import org.thingsboard.server.service.cf.ctx.state.geofencing.GeofencingArgumentEntry;
&nbsp;import org.thingsboard.server.service.cf.ctx.state.geofencing.GeofencingCalculatedFieldState;
&nbsp;import org.thingsboard.server.service.cf.ctx.state.propagation.PropagationArgumentEntry;
&nbsp;import org.thingsboard.server.service.cf.ctx.state.propagation.PropagationCalculatedFieldState;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.LinkedList;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import java.util.UUID;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;import static org.thingsboard.server.common.data.cf.configuration.PropagationCalculatedFieldConfiguration.PROPAGATION_CONFIG_ARGUMENT;
&nbsp;import static org.thingsboard.server.service.cf.ctx.state.TsRollingArgumentEntry.getValueForTsRecord;
&nbsp;import static org.thingsboard.server.utils.CalculatedFieldArgumentUtils.createStateByType;
&nbsp;
&nbsp;/**
&nbsp; * @author Andrew Shvayka
&nbsp; */
<b class="nc">&nbsp;@Slf4j</b>
&nbsp;public class CalculatedFieldEntityMessageProcessor extends AbstractContextAwareMsgProcessor {
&nbsp;    // (1 for result persistence + 1 for the state persistence)
&nbsp;    public static final int CALLBACKS_PER_CF = 2;
&nbsp;
&nbsp;    final TenantId tenantId;
&nbsp;    final EntityId entityId;
&nbsp;    final CalculatedFieldProcessingService cfService;
&nbsp;    final CalculatedFieldStateService cfStateService;
&nbsp;
&nbsp;    TbActorCtx actorCtx;
<b class="nc">&nbsp;    Map&lt;CalculatedFieldId, CalculatedFieldState&gt; states = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;    CalculatedFieldEntityMessageProcessor(ActorSystemContext systemContext, TenantId tenantId, EntityId entityId) {
<b class="nc">&nbsp;        super(systemContext);</b>
<b class="nc">&nbsp;        this.tenantId = tenantId;</b>
<b class="nc">&nbsp;        this.entityId = entityId;</b>
<b class="nc">&nbsp;        this.cfService = systemContext.getCalculatedFieldProcessingService();</b>
<b class="nc">&nbsp;        this.cfStateService = systemContext.getCalculatedFieldStateService();</b>
&nbsp;    }
&nbsp;
&nbsp;    void init(TbActorCtx ctx) {
<b class="nc">&nbsp;        this.actorCtx = ctx;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void stop(boolean partitionChanged) {
<b class="nc">&nbsp;        log.info(partitionChanged ?</b>
<b class="nc">&nbsp;                        &quot;[{}][{}] Stopping entity actor due to change partition event.&quot; :</b>
<b class="nc">&nbsp;                        &quot;[{}][{}] Stopping entity actor.&quot;,</b>
&nbsp;                tenantId, entityId);
<b class="nc">&nbsp;        states.values().forEach(this::closeState);</b>
<b class="nc">&nbsp;        states.clear();</b>
<b class="nc">&nbsp;        actorCtx.stop(actorCtx.getSelf());</b>
&nbsp;    }
&nbsp;
&nbsp;    public void process(CalculatedFieldPartitionChangeMsg msg) {
<b class="nc">&nbsp;        if (!systemContext.getPartitionService().resolve(ServiceType.TB_RULE_ENGINE, DataConstants.CF_QUEUE_NAME, tenantId, entityId).isMyPartition()) {</b>
<b class="nc">&nbsp;            stop(true);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void process(CalculatedFieldStateRestoreMsg msg) {
<b class="nc">&nbsp;        CalculatedFieldId cfId = msg.getId().cfId();</b>
<b class="nc">&nbsp;        log.debug(&quot;[{}] [{}] Processing CF state restore msg.&quot;, msg.getId().entityId(), cfId);</b>
<b class="nc">&nbsp;        CalculatedFieldState state = msg.getState();</b>
<b class="nc">&nbsp;        if (state != null) {</b>
<b class="nc">&nbsp;            state.setCtx(msg.getCtx(), actorCtx);</b>
<b class="nc">&nbsp;            state.setPartition(msg.getPartition());</b>
<b class="nc">&nbsp;            states.put(cfId, state);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            removeState(cfId);</b>
&nbsp;        }
<b class="nc">&nbsp;        msg.getCallback().onSuccess();</b>
&nbsp;    }
&nbsp;
&nbsp;    public void process(CalculatedFieldStatePartitionRestoreMsg msg) {
<b class="nc">&nbsp;        log.debug(&quot;Processing CF state partition restore msg: {}&quot;, msg);</b>
<b class="nc">&nbsp;        for (CalculatedFieldState state : states.values()) {</b>
<b class="nc">&nbsp;            if (msg.getPartition().equals(state.getPartition())) {</b>
<b class="nc">&nbsp;                state.init(true);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void process(EntityInitCalculatedFieldMsg msg) throws CalculatedFieldException {
<b class="nc">&nbsp;        log.debug(&quot;[{}] Processing entity init CF msg: {}&quot;, msg.getCtx().getCfId(), msg);</b>
<b class="nc">&nbsp;        var ctx = msg.getCtx();</b>
&nbsp;        CalculatedFieldState state;
<b class="nc">&nbsp;        if (msg.getStateAction() == StateAction.RECREATE) {</b>
<b class="nc">&nbsp;            removeState(ctx.getCfId());</b>
<b class="nc">&nbsp;            state = null;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            state = states.get(ctx.getCfId());</b>
&nbsp;        }
&nbsp;        try {
<b class="nc">&nbsp;            if (state == null) {</b>
<b class="nc">&nbsp;                state = createState(ctx);</b>
<b class="nc">&nbsp;            } else if (msg.getStateAction() == StateAction.REINIT) {</b>
<b class="nc">&nbsp;                log.debug(&quot;Force reinitialization of CF: [{}].&quot;, ctx.getCfId());</b>
<b class="nc">&nbsp;                state.reset();</b>
<b class="nc">&nbsp;                initState(state, ctx);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                state.setCtx(ctx, actorCtx);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (msg.getStateAction() != StateAction.REFRESH_CTX) {</b>
<b class="nc">&nbsp;                if (state.isSizeOk()) {</b>
<b class="nc">&nbsp;                    processStateIfReady(state, Collections.emptyMap(), ctx, Collections.singletonList(ctx.getCfId()), null, msg.getEventType().name(), msg.getCallback());</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    throw CalculatedFieldException.builder().ctx(ctx).eventEntity(entityId).errorMessage(ctx.getSizeExceedsLimitMessage()).build();</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                msg.getCallback().onSuccess();</b>
&nbsp;            }
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.debug(&quot;[{}][{}] Failed to initialize CF state&quot;, entityId, ctx.getCfId(), e);</b>
<b class="nc">&nbsp;            if (e instanceof CalculatedFieldException cfe) {</b>
&nbsp;                throw cfe;
&nbsp;            }
<b class="nc">&nbsp;            throw CalculatedFieldException.builder().ctx(ctx).eventEntity(entityId).cause(e).build();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void process(CalculatedFieldArgumentResetMsg msg) throws CalculatedFieldException {
<b class="nc">&nbsp;        log.debug(&quot;[{}] Processing CF argument reset msg.&quot;, entityId);</b>
<b class="nc">&nbsp;        var ctx = msg.getCtx();</b>
&nbsp;        try {
<b class="nc">&nbsp;            Map&lt;String, Argument&gt; dynamicSourceArgs = ctx.getArguments().entrySet().stream()</b>
<b class="nc">&nbsp;                    .filter(entry -&gt; entry.getValue().hasOwnerSource())</b>
<b class="nc">&nbsp;                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));</b>
&nbsp;
<b class="nc">&nbsp;            Map&lt;String, ArgumentEntry&gt; fetchedArgs = cfService.fetchArgsFromDb(tenantId, entityId, dynamicSourceArgs);</b>
<b class="nc">&nbsp;            fetchedArgs.values().forEach(arg -&gt; arg.setForceResetPrevious(true));</b>
&nbsp;
<b class="nc">&nbsp;            processArgumentValuesUpdate(ctx, Collections.singletonList(ctx.getCfId()), msg.getCallback(), fetchedArgs, null, msg.getEventType().name());</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            throw CalculatedFieldException.builder().ctx(ctx).eventEntity(entityId).cause(e).build();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void process(CalculatedFieldEntityDeleteMsg msg) throws CalculatedFieldException {
<b class="nc">&nbsp;        log.debug(&quot;[{}] Processing CF entity delete msg.&quot;, msg.getEntityId());</b>
<b class="nc">&nbsp;        if (this.entityId.equals(msg.getEntityId())) {</b>
<b class="nc">&nbsp;            if (states.isEmpty()) {</b>
<b class="nc">&nbsp;                msg.getCallback().onSuccess();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                MultipleTbCallback multipleTbCallback = new MultipleTbCallback(states.size(), msg.getCallback());</b>
<b class="nc">&nbsp;                states.forEach((cfId, state) -&gt; cfStateService.deleteState(new CalculatedFieldEntityCtxId(tenantId, cfId, entityId), multipleTbCallback));</b>
<b class="nc">&nbsp;                actorCtx.stop(actorCtx.getSelf());</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            var cfId = new CalculatedFieldId(msg.getEntityId().getId());</b>
<b class="nc">&nbsp;            var state = removeState(cfId);</b>
<b class="nc">&nbsp;            if (state != null) {</b>
<b class="nc">&nbsp;                cfStateService.deleteState(new CalculatedFieldEntityCtxId(tenantId, cfId, entityId), msg.getCallback());</b>
&nbsp;            } else {
<b class="nc">&nbsp;                msg.getCallback().onSuccess();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void process(CalculatedFieldRelationActionMsg msg) throws CalculatedFieldException {
<b class="nc">&nbsp;        log.debug(&quot;[{}] Processing CF {} related entity msg.&quot;, msg.getRelatedEntityId(), msg.getAction());</b>
<b class="nc">&nbsp;        switch (msg.getAction()) {</b>
<b class="nc">&nbsp;            case UPDATED -&gt; handleRelationUpdate(msg);</b>
<b class="nc">&nbsp;            case DELETED -&gt; handleRelationDelete(msg);</b>
<b class="nc">&nbsp;            default -&gt; msg.getCallback().onSuccess();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void handleRelationUpdate(CalculatedFieldRelationActionMsg msg) throws CalculatedFieldException {
<b class="nc">&nbsp;        CalculatedFieldCtx ctx = msg.getCalculatedField();</b>
<b class="nc">&nbsp;        var state = states.get(ctx.getCfId());</b>
&nbsp;        try {
<b class="nc">&nbsp;            Map&lt;String, ArgumentEntry&gt; updatedArgs = null;</b>
<b class="nc">&nbsp;            if (state == null) {</b>
<b class="nc">&nbsp;                state = createState(ctx);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                if (state instanceof RelatedEntitiesAggregationCalculatedFieldState relatedEntitiesAggState) {</b>
<b class="nc">&nbsp;                    Map&lt;String, ArgumentEntry&gt; fetchedArgs = cfService.fetchArgsFromDb(tenantId, msg.getRelatedEntityId(), ctx.getArguments());</b>
<b class="nc">&nbsp;                    updatedArgs = relatedEntitiesAggState.updateEntityData(setEntityIdToSingleEntityArguments(msg.getRelatedEntityId(), fetchedArgs));</b>
&nbsp;                }
<b class="nc">&nbsp;                if (state instanceof PropagationCalculatedFieldState propagationState) {</b>
<b class="nc">&nbsp;                    PropagationArgumentEntry entry = new PropagationArgumentEntry();</b>
<b class="nc">&nbsp;                    entry.setAdded(List.of(msg.getRelatedEntityId()));</b>
<b class="nc">&nbsp;                    updatedArgs = propagationState.update(Map.of(PROPAGATION_CONFIG_ARGUMENT, entry), ctx);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (CollectionsUtil.isEmpty(updatedArgs)) {</b>
<b class="nc">&nbsp;                    msg.getCallback().onSuccess();</b>
&nbsp;                    return;
&nbsp;                }
<b class="nc">&nbsp;                state.checkStateSize(new CalculatedFieldEntityCtxId(tenantId, ctx.getCfId(), entityId), ctx.getMaxStateSize());</b>
&nbsp;            }
<b class="nc">&nbsp;            if (state.isSizeOk()) {</b>
<b class="nc">&nbsp;                processStateIfReady(state, updatedArgs, ctx, Collections.singletonList(ctx.getCfId()), null, TbMsgType.RELATION_ADD_OR_UPDATE.name(), msg.getCallback());</b>
&nbsp;            } else {
<b class="nc">&nbsp;                throw CalculatedFieldException.builder().ctx(ctx).eventEntity(entityId).errorMessage(ctx.getSizeExceedsLimitMessage()).build();</b>
&nbsp;            }
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.debug(&quot;[{}][{}] Failed to handle relation update&quot;, entityId, ctx.getCfId(), e);</b>
<b class="nc">&nbsp;            if (e instanceof CalculatedFieldException cfe) {</b>
&nbsp;                throw cfe;
&nbsp;            }
<b class="nc">&nbsp;            throw CalculatedFieldException.builder().ctx(ctx).eventEntity(entityId).cause(e).build();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void handleRelationDelete(CalculatedFieldRelationActionMsg msg) throws CalculatedFieldException {
<b class="nc">&nbsp;        CalculatedFieldCtx ctx = msg.getCalculatedField();</b>
<b class="nc">&nbsp;        CalculatedFieldId cfId = ctx.getCfId();</b>
<b class="nc">&nbsp;        CalculatedFieldState state = states.get(cfId);</b>
&nbsp;        try {
<b class="nc">&nbsp;            if (state == null) {</b>
<b class="nc">&nbsp;                msg.getCallback().onSuccess();</b>
&nbsp;                return;
&nbsp;            }
<b class="nc">&nbsp;            if (state instanceof RelatedEntitiesAggregationCalculatedFieldState aggState) {</b>
<b class="nc">&nbsp;                aggState.cleanupEntityData(msg.getRelatedEntityId());</b>
&nbsp;
<b class="nc">&nbsp;                state.checkStateSize(new CalculatedFieldEntityCtxId(tenantId, ctx.getCfId(), entityId), ctx.getMaxStateSize());</b>
&nbsp;
<b class="nc">&nbsp;                if (state.isSizeOk()) {</b>
<b class="nc">&nbsp;                    processStateIfReady(state, Collections.emptyMap(), ctx, Collections.singletonList(ctx.getCfId()), null, TbMsgType.RELATION_DELETED.name(), msg.getCallback());</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    throw CalculatedFieldException.builder().ctx(ctx).eventEntity(entityId).errorMessage(ctx.getSizeExceedsLimitMessage()).build();</b>
&nbsp;                }
&nbsp;                return;
&nbsp;            }
<b class="nc">&nbsp;            if (state instanceof PropagationCalculatedFieldState propagationState) {</b>
<b class="nc">&nbsp;                PropagationArgumentEntry entry = new PropagationArgumentEntry();</b>
<b class="nc">&nbsp;                entry.setRemoved(msg.getRelatedEntityId());</b>
<b class="nc">&nbsp;                propagationState.update(Map.of(PROPAGATION_CONFIG_ARGUMENT, entry), ctx);</b>
<b class="nc">&nbsp;                if (DebugModeUtil.isDebugAllAvailable(ctx.getCalculatedField())) {</b>
<b class="nc">&nbsp;                    systemContext.persistCalculatedFieldDebugEvent(tenantId, ctx.getCfId(), entityId, state.getArgumentsJson(), null, TbMsgType.RELATION_DELETED.name(), null, null);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            msg.getCallback().onSuccess();</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.debug(&quot;[{}][{}] Failed to handle relation delete&quot;, entityId, ctx.getCfId(), e);</b>
<b class="nc">&nbsp;            if (e instanceof CalculatedFieldException cfe) {</b>
&nbsp;                throw cfe;
&nbsp;            }
<b class="nc">&nbsp;            throw CalculatedFieldException.builder().ctx(ctx).eventEntity(entityId).cause(e).build();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void process(EntityCalculatedFieldTelemetryMsg msg) throws CalculatedFieldException {
<b class="nc">&nbsp;        log.trace(&quot;[{}] Processing CF telemetry msg: {}&quot;, msg.getEntityId(), msg);</b>
<b class="nc">&nbsp;        var proto = msg.getProto();</b>
<b class="nc">&nbsp;        var numberOfCallbacks = msg.getEntityIdFields().size() + msg.getProfileIdFields().size();</b>
<b class="nc">&nbsp;        MultipleTbCallback callback = new MultipleTbCallback(numberOfCallbacks, msg.getCallback());</b>
<b class="nc">&nbsp;        List&lt;CalculatedFieldId&gt; cfIdList = getCalculatedFieldIds(proto);</b>
<b class="nc">&nbsp;        Set&lt;CalculatedFieldId&gt; cfIdSet = new HashSet&lt;&gt;(cfIdList);</b>
<b class="nc">&nbsp;        for (var ctx : msg.getEntityIdFields()) {</b>
<b class="nc">&nbsp;            process(ctx, proto, cfIdSet, cfIdList, callback);</b>
&nbsp;        }
<b class="nc">&nbsp;        for (var ctx : msg.getProfileIdFields()) {</b>
<b class="nc">&nbsp;            process(ctx, proto, cfIdSet, cfIdList, callback);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void process(EntityCalculatedFieldLinkedTelemetryMsg msg) throws CalculatedFieldException {
<b class="nc">&nbsp;        log.trace(&quot;[{}] Processing CF link telemetry msg: {}&quot;, msg.getEntityId(), msg);</b>
<b class="nc">&nbsp;        var proto = msg.getProto();</b>
<b class="nc">&nbsp;        var ctx = msg.getCtx();</b>
<b class="nc">&nbsp;        var callback = msg.getCallback();</b>
&nbsp;        try {
<b class="nc">&nbsp;            List&lt;CalculatedFieldId&gt; cfIds = getCalculatedFieldIds(proto);</b>
<b class="nc">&nbsp;            if (cfIds.contains(ctx.getCfId())) {</b>
<b class="nc">&nbsp;                callback.onSuccess();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                if (proto.getTsDataCount() &gt; 0) {</b>
<b class="nc">&nbsp;                    processArgumentValuesUpdate(ctx, cfIds, callback, mapToArguments(ctx, msg.getEntityId(), proto.getTsDataList()), toTbMsgId(proto), toMsgType(proto));</b>
<b class="nc">&nbsp;                } else if (proto.getAttrDataCount() &gt; 0) {</b>
<b class="nc">&nbsp;                    processArgumentValuesUpdate(ctx, cfIds, callback, mapToArguments(ctx, msg.getEntityId(), proto.getScope(), proto.getAttrDataList()), toTbMsgId(proto), toMsgType(proto));</b>
<b class="nc">&nbsp;                } else if (proto.getRemovedTsKeysCount() &gt; 0) {</b>
<b class="nc">&nbsp;                    processArgumentValuesUpdate(ctx, cfIds, callback, mapToArgumentsWithFetchedValue(ctx, msg.getEntityId(), proto.getRemovedTsKeysList()), toTbMsgId(proto), toMsgType(proto));</b>
<b class="nc">&nbsp;                } else if (proto.getRemovedAttrKeysCount() &gt; 0) {</b>
<b class="nc">&nbsp;                    processArgumentValuesUpdate(ctx, cfIds, callback, mapToArgumentsWithDefaultValue(ctx, msg.getEntityId(), proto.getScope(), proto.getRemovedAttrKeysList()), toTbMsgId(proto), toMsgType(proto));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    callback.onSuccess();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.debug(&quot;[{}][{}] Failed to process linked CF telemetry msg: {}&quot;, entityId, ctx.getCfId(), msg, e);</b>
<b class="nc">&nbsp;            if (e instanceof CalculatedFieldException cfe) {</b>
&nbsp;                throw cfe;
&nbsp;            }
<b class="nc">&nbsp;            throw CalculatedFieldException.builder().ctx(ctx).eventEntity(entityId).cause(e).build();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void process(CalculatedFieldCtx ctx, CalculatedFieldTelemetryMsgProto proto, Collection&lt;CalculatedFieldId&gt; cfIds, List&lt;CalculatedFieldId&gt; cfIdList, TbCallback callback) throws CalculatedFieldException {
&nbsp;        try {
<b class="nc">&nbsp;            if (cfIds.contains(ctx.getCfId())) {</b>
<b class="nc">&nbsp;                callback.onSuccess();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                if (proto.getTsDataCount() &gt; 0) {</b>
<b class="nc">&nbsp;                    processTelemetry(ctx, proto, cfIdList, callback);</b>
<b class="nc">&nbsp;                } else if (proto.getAttrDataCount() &gt; 0) {</b>
<b class="nc">&nbsp;                    processAttributes(ctx, proto, cfIdList, callback);</b>
<b class="nc">&nbsp;                } else if (proto.getRemovedTsKeysCount() &gt; 0) {</b>
<b class="nc">&nbsp;                    processRemovedTelemetry(ctx, proto, cfIdList, callback);</b>
<b class="nc">&nbsp;                } else if (proto.getRemovedAttrKeysCount() &gt; 0) {</b>
<b class="nc">&nbsp;                    processRemovedAttributes(ctx, proto, cfIdList, callback);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    callback.onSuccess();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.debug(&quot;[{}][{}] Failed to process CF telemetry msg: {}&quot;, entityId, ctx.getCfId(), proto, e);</b>
<b class="nc">&nbsp;            if (e instanceof CalculatedFieldException cfe) {</b>
<b class="nc">&nbsp;                if (DebugModeUtil.isDebugFailuresAvailable(cfe.getCtx().getCalculatedField())) {</b>
<b class="nc">&nbsp;                    systemContext.persistCalculatedFieldDebugError(cfe);</b>
&nbsp;                }
<b class="nc">&nbsp;                callback.onSuccess();</b>
&nbsp;                return;
&nbsp;            }
<b class="nc">&nbsp;            throw CalculatedFieldException.builder().ctx(ctx).eventEntity(entityId).cause(e).build();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void process(CalculatedFieldReevaluateMsg msg) throws CalculatedFieldException {
<b class="nc">&nbsp;        CalculatedFieldCtx ctx = msg.getCtx();</b>
<b class="nc">&nbsp;        CalculatedFieldId cfId = ctx.getCfId();</b>
<b class="nc">&nbsp;        CalculatedFieldState state = states.get(cfId);</b>
<b class="nc">&nbsp;        if (state == null) {</b>
<b class="nc">&nbsp;            log.warn(&quot;[{}][{}] Failed to find CF state (probably wasn&#39;t restored properly) for entity to handle {}&quot;, entityId, cfId, msg);</b>
<b class="nc">&nbsp;            state = createState(ctx);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (state.isSizeOk()) {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}][{}] Reevaluating CF state&quot;, entityId, cfId);</b>
<b class="nc">&nbsp;            processStateIfReady(state, null, ctx, Collections.singletonList(cfId), null, CalculatedFieldEventType.REEVALUATION_MSG.name(), msg.getCallback());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            throw CalculatedFieldException.builder().ctx(ctx).eventEntity(entityId).errorMessage(ctx.getSizeExceedsLimitMessage()).build();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void process(CalculatedFieldAlarmActionMsg msg) {
<b class="nc">&nbsp;        log.debug(&quot;[{}] Processing alarm action event msg: {}&quot;, entityId, msg);</b>
<b class="nc">&nbsp;        for (CalculatedFieldState state : states.values()) {</b>
<b class="nc">&nbsp;            if (state instanceof AlarmCalculatedFieldState alarmCfState) {</b>
<b class="nc">&nbsp;                Alarm stateAlarm = alarmCfState.getCurrentAlarm();</b>
<b class="nc">&nbsp;                if (stateAlarm != null &amp;&amp; stateAlarm.getId().equals(msg.getAlarm().getId())) {</b>
<b class="nc">&nbsp;                    alarmCfState.processAlarmAction(msg.getAlarm(), msg.getAction());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        msg.getCallback().onSuccess();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void processTelemetry(CalculatedFieldCtx ctx, CalculatedFieldTelemetryMsgProto proto, List&lt;CalculatedFieldId&gt; cfIdList, TbCallback callback) throws CalculatedFieldException {
<b class="nc">&nbsp;        processArgumentValuesUpdate(ctx, cfIdList, callback, mapToArguments(ctx, proto.getTsDataList()), toTbMsgId(proto), toMsgType(proto));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void processAttributes(CalculatedFieldCtx ctx, CalculatedFieldTelemetryMsgProto proto, List&lt;CalculatedFieldId&gt; cfIdList, TbCallback callback) throws CalculatedFieldException {
<b class="nc">&nbsp;        processArgumentValuesUpdate(ctx, cfIdList, callback, mapToArguments(ctx, proto.getScope(), proto.getAttrDataList()), toTbMsgId(proto), toMsgType(proto));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void processRemovedTelemetry(CalculatedFieldCtx ctx, CalculatedFieldTelemetryMsgProto proto, List&lt;CalculatedFieldId&gt; cfIdList, TbCallback callback) throws CalculatedFieldException {
<b class="nc">&nbsp;        processArgumentValuesUpdate(ctx, cfIdList, callback, mapToArgumentsWithFetchedValue(ctx, entityId, proto.getRemovedTsKeysList()), toTbMsgId(proto), toMsgType(proto));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void processRemovedAttributes(CalculatedFieldCtx ctx, CalculatedFieldTelemetryMsgProto proto, List&lt;CalculatedFieldId&gt; cfIdList, TbCallback callback) throws CalculatedFieldException {
<b class="nc">&nbsp;        processArgumentValuesUpdate(ctx, cfIdList, callback, mapToArgumentsWithDefaultValue(ctx, proto.getScope(), proto.getRemovedAttrKeysList()), toTbMsgId(proto), toMsgType(proto));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void processArgumentValuesUpdate(CalculatedFieldCtx ctx, List&lt;CalculatedFieldId&gt; cfIdList, TbCallback callback,
&nbsp;                                             Map&lt;String, ArgumentEntry&gt; newArgValues, UUID tbMsgId, String msgType) throws CalculatedFieldException {
<b class="nc">&nbsp;        if (newArgValues.isEmpty()) {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}] No new argument values to process for CF.&quot;, ctx.getCfId());</b>
<b class="nc">&nbsp;            callback.onSuccess();</b>
&nbsp;        }
<b class="nc">&nbsp;        CalculatedFieldState state = states.get(ctx.getCfId());</b>
<b class="nc">&nbsp;        boolean justRestored = false;</b>
<b class="nc">&nbsp;        if (state == null) {</b>
<b class="nc">&nbsp;            state = createState(ctx);</b>
<b class="nc">&nbsp;            justRestored = true;</b>
<b class="nc">&nbsp;        } else if (ctx.shouldFetchRelatedEntities(state)) {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}][{}] Going to update related entities for CF.&quot;, entityId, ctx.getCfId());</b>
&nbsp;            try {
<b class="nc">&nbsp;                if (state instanceof RelatedEntitiesAggregationCalculatedFieldState relatedEntitiesState) {</b>
<b class="nc">&nbsp;                    List&lt;EntityId&gt; relatedEntities = cfService.fetchRelatedEntities(ctx, entityId);</b>
<b class="nc">&nbsp;                    List&lt;EntityId&gt; missingEntities = relatedEntitiesState.checkRelatedEntities(relatedEntities);</b>
<b class="nc">&nbsp;                    if (!missingEntities.isEmpty()) {</b>
<b class="nc">&nbsp;                        missingEntities.forEach(missingEntityId -&gt; {</b>
<b class="nc">&nbsp;                            Map&lt;String, ArgumentEntry&gt; fetchedArgs = cfService.fetchArgsFromDb(tenantId, missingEntityId, ctx.getArguments());</b>
<b class="nc">&nbsp;                            relatedEntitiesState.updateEntityData(setEntityIdToSingleEntityArguments(missingEntityId, fetchedArgs));</b>
&nbsp;                        });
<b class="nc">&nbsp;                        justRestored = true;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                if (state instanceof GeofencingCalculatedFieldState geofencingCalculatedFieldState) {</b>
<b class="nc">&nbsp;                    Map&lt;String, ArgumentEntry&gt; dynamicArgsFromDb = cfService.fetchDynamicArgsFromDb(ctx, entityId);</b>
<b class="nc">&nbsp;                    dynamicArgsFromDb.forEach(newArgValues::putIfAbsent);</b>
<b class="nc">&nbsp;                    geofencingCalculatedFieldState.updateScheduledRefreshTs();</b>
&nbsp;                }
&nbsp;            } catch (Exception e) {
<b class="nc">&nbsp;                throw CalculatedFieldException.builder().ctx(ctx).eventEntity(entityId).cause(e).build();</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (state.isSizeOk()) {</b>
<b class="nc">&nbsp;            Map&lt;String, ArgumentEntry&gt; updatedArgs = state.update(newArgValues, ctx);</b>
<b class="nc">&nbsp;            if (!updatedArgs.isEmpty() || justRestored) {</b>
<b class="nc">&nbsp;                cfIdList = new ArrayList&lt;&gt;(cfIdList);</b>
<b class="nc">&nbsp;                cfIdList.add(ctx.getCfId());</b>
<b class="nc">&nbsp;                processStateIfReady(state, updatedArgs, ctx, cfIdList, tbMsgId, msgType, callback);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                callback.onSuccess();</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            throw CalculatedFieldException.builder().ctx(ctx).eventEntity(entityId).errorMessage(ctx.getSizeExceedsLimitMessage()).build();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private CalculatedFieldState createState(CalculatedFieldCtx ctx) {
<b class="nc">&nbsp;        CalculatedFieldState state = createStateByType(ctx, entityId);</b>
<b class="nc">&nbsp;        initState(state, ctx);</b>
<b class="nc">&nbsp;        return state;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void initState(CalculatedFieldState state, CalculatedFieldCtx ctx) {
<b class="nc">&nbsp;        state.setCtx(ctx, actorCtx);</b>
<b class="nc">&nbsp;        state.init(false);</b>
&nbsp;
<b class="nc">&nbsp;        if (ctx.getCfType() == CalculatedFieldType.GEOFENCING &amp;&amp; ctx.isCfHasRelationPathQuerySource()) {</b>
<b class="nc">&nbsp;            GeofencingCalculatedFieldState geofencingState = (GeofencingCalculatedFieldState) state;</b>
<b class="nc">&nbsp;            geofencingState.updateScheduledRefreshTs();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Map&lt;String, ArgumentEntry&gt; arguments = fetchArguments(ctx);</b>
<b class="nc">&nbsp;        state.update(arguments, ctx);</b>
&nbsp;
<b class="nc">&nbsp;        state.checkStateSize(new CalculatedFieldEntityCtxId(tenantId, ctx.getCfId(), entityId), ctx.getMaxStateSize());</b>
<b class="nc">&nbsp;        states.put(ctx.getCfId(), state);</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    @SneakyThrows</b>
&nbsp;    private Map&lt;String, ArgumentEntry&gt; fetchArguments(CalculatedFieldCtx ctx) {
<b class="nc">&nbsp;        ListenableFuture&lt;Map&lt;String, ArgumentEntry&gt;&gt; argumentsFuture = cfService.fetchArguments(ctx, entityId);</b>
&nbsp;        // Ugly but necessary. We do not expect to often fetch data from DB. Only once per &lt;Entity, CalculatedField&gt; pair lifetime.
&nbsp;        // This call happens while processing the CF pack from the queue consumer. So the timeout should be relatively low.
&nbsp;        // Alternatively, we can fetch the state outside the actor system and push separate command to create this actor,
&nbsp;        // but this will significantly complicate the code.
<b class="nc">&nbsp;        return argumentsFuture.get(1, TimeUnit.MINUTES);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void processStateIfReady(CalculatedFieldState state, Map&lt;String, ArgumentEntry&gt; updatedArgs, CalculatedFieldCtx ctx,
&nbsp;                                     List&lt;CalculatedFieldId&gt; cfIdList, UUID tbMsgId, String tbMsgType, TbCallback callback) throws CalculatedFieldException {
<b class="nc">&nbsp;        callback = new MultipleTbCallback(CALLBACKS_PER_CF, callback);</b>
<b class="nc">&nbsp;        log.trace(&quot;[{}][{}] Processing state if ready. Current args: {}, updated args: {}&quot;, entityId, ctx.getCfId(), state.getArguments(), updatedArgs);</b>
<b class="nc">&nbsp;        CalculatedFieldEntityCtxId ctxId = new CalculatedFieldEntityCtxId(tenantId, ctx.getCfId(), entityId);</b>
<b class="nc">&nbsp;        boolean stateSizeChecked = false;</b>
&nbsp;        try {
<b class="nc">&nbsp;            if (ctx.isInitialized() &amp;&amp; state.isReady()) {</b>
<b class="nc">&nbsp;                log.trace(&quot;[{}][{}] Performing calculation. Updated args: {}&quot;, entityId, ctx.getCfId(), updatedArgs);</b>
<b class="nc">&nbsp;                CalculatedFieldResult calculationResult = state.performCalculation(updatedArgs, ctx).get(systemContext.getCfCalculationResultTimeout(), TimeUnit.SECONDS);</b>
<b class="nc">&nbsp;                state.checkStateSize(ctxId, ctx.getMaxStateSize());</b>
<b class="nc">&nbsp;                stateSizeChecked = true;</b>
<b class="nc">&nbsp;                if (state.isSizeOk()) {</b>
<b class="nc">&nbsp;                    if (!calculationResult.isEmpty()) {</b>
<b class="nc">&nbsp;                        cfService.processResult(tenantId, entityId, ctx.getCfName(), calculationResult, cfIdList, callback);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        callback.onSuccess();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (DebugModeUtil.isDebugAllAvailable(ctx.getCalculatedField())) {</b>
<b class="nc">&nbsp;                        systemContext.persistCalculatedFieldDebugEvent(tenantId, ctx.getCfId(), entityId, state.getArgumentsJson(), tbMsgId, tbMsgType, calculationResult.stringValue(), null);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                if (DebugModeUtil.isDebugFailuresAvailable(ctx.getCalculatedField())) {</b>
<b class="nc">&nbsp;                    String errorMsg = ctx.isInitialized() ? state.getReadinessStatus().errorMsg() : &quot;Calculated field state is not initialized!&quot;;</b>
<b class="nc">&nbsp;                    systemContext.persistCalculatedFieldDebugEvent(tenantId, ctx.getCfId(), entityId, state.getArgumentsJson(), tbMsgId, tbMsgType, null, errorMsg);</b>
&nbsp;                }
<b class="nc">&nbsp;                callback.onSuccess();</b>
&nbsp;            }
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.debug(&quot;[{}][{}] Failed to process CF state&quot;, entityId, ctx.getCfId(), e);</b>
<b class="nc">&nbsp;            throw CalculatedFieldException.builder().ctx(ctx).eventEntity(entityId).msgId(tbMsgId).msgType(tbMsgType).arguments(state.getArgumentsJson()).cause(e).build();</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            if (!stateSizeChecked) {</b>
<b class="nc">&nbsp;                state.checkStateSize(ctxId, ctx.getMaxStateSize());</b>
&nbsp;            }
<b class="nc">&nbsp;            if (state.isSizeOk()) {</b>
<b class="nc">&nbsp;                cfStateService.persistState(ctxId, state, callback);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                deleteStateAndRaiseSizeException(ctxId, CalculatedFieldException.builder().ctx(ctx).eventEntity(entityId).errorMessage(ctx.getSizeExceedsLimitMessage()).build(), callback);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private CalculatedFieldState removeState(CalculatedFieldId cfId) {
<b class="nc">&nbsp;        CalculatedFieldState state = states.remove(cfId);</b>
<b class="nc">&nbsp;        closeState(state);</b>
<b class="nc">&nbsp;        return state;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void closeState(CalculatedFieldState state) {
<b class="nc">&nbsp;        if (state != null) {</b>
&nbsp;            try {
&nbsp;                state.close();
&nbsp;            } catch (Exception e) {
<b class="nc">&nbsp;                log.warn(&quot;[{}][{}] Failed to close CF state&quot;, tenantId, state.getEntityId(), e);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void deleteStateAndRaiseSizeException(CalculatedFieldEntityCtxId ctxId, CalculatedFieldException ex, TbCallback callback) throws CalculatedFieldException {
&nbsp;        // We remove the state, but remember that it is over-sized in a local map.
<b class="nc">&nbsp;        cfStateService.deleteState(ctxId, new TbCallback() {</b>
&nbsp;            @Override
&nbsp;            public void onSuccess() {
<b class="nc">&nbsp;                callback.onFailure(ex);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void onFailure(Throwable t) {
<b class="nc">&nbsp;                callback.onFailure(ex);</b>
&nbsp;            }
&nbsp;        });
&nbsp;        throw ex;
&nbsp;    }
&nbsp;
&nbsp;    private Map&lt;String, ArgumentEntry&gt; mapToArguments(CalculatedFieldCtx ctx, List&lt;TsKvProto&gt; data) {
<b class="nc">&nbsp;        return mapToArguments(entityId, ctx, ctx.getMainEntityArguments(), Collections.emptyMap(), data);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Map&lt;String, ArgumentEntry&gt; mapToArguments(CalculatedFieldCtx ctx, EntityId entityId, List&lt;TsKvProto&gt; data) {
<b class="nc">&nbsp;        return mapToArguments(entityId, ctx, ctx.getLinkedAndDynamicArgs(entityId), ctx.getRelatedEntityArguments(), data);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Map&lt;String, ArgumentEntry&gt; mapToArguments(EntityId originator, CalculatedFieldCtx ctx, Map&lt;ReferencedEntityKey, Set&lt;String&gt;&gt; args, Map&lt;ReferencedEntityKey, Set&lt;String&gt;&gt; relatedEntityArgs, List&lt;TsKvProto&gt; data) {
<b class="nc">&nbsp;        Map&lt;String, ArgumentEntry&gt; arguments = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        if (!relatedEntityArgs.isEmpty() || !args.isEmpty()) {</b>
<b class="nc">&nbsp;            for (TsKvProto item : data) {</b>
<b class="nc">&nbsp;                ReferencedEntityKey key = new ReferencedEntityKey(item.getKv().getKey(), ArgumentType.TS_LATEST, null);</b>
&nbsp;
<b class="nc">&nbsp;                SingleValueArgumentEntry relatedArgIncoming = new SingleValueArgumentEntry(originator, item);</b>
<b class="nc">&nbsp;                mapLatest(ctx, relatedArgIncoming, relatedEntityArgs.get(key), arguments);</b>
&nbsp;
<b class="nc">&nbsp;                SingleValueArgumentEntry incoming = new SingleValueArgumentEntry(item);</b>
<b class="nc">&nbsp;                mapLatest(ctx, incoming, args.get(key), arguments);</b>
&nbsp;
<b class="nc">&nbsp;                key = new ReferencedEntityKey(item.getKv().getKey(), ArgumentType.TS_ROLLING, null);</b>
<b class="nc">&nbsp;                mapRolling(item, args.get(key), arguments);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return arguments;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void mapLatest(CalculatedFieldCtx ctx,
&nbsp;                           SingleValueArgumentEntry incoming,
&nbsp;                           Set&lt;String&gt; argNames,
&nbsp;                           Map&lt;String, ArgumentEntry&gt; arguments) {
<b class="nc">&nbsp;        if (argNames != null) {</b>
<b class="nc">&nbsp;            argNames.forEach(argName -&gt; arguments.compute(argName, (name, existing) -&gt; {</b>
<b class="nc">&nbsp;                if (existing == null) {</b>
<b class="nc">&nbsp;                    return incoming;</b>
&nbsp;                }
<b class="nc">&nbsp;                existing.updateEntry(incoming, ctx);</b>
<b class="nc">&nbsp;                return existing;</b>
&nbsp;            }));
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void mapRolling(TsKvProto item,
&nbsp;                            Set&lt;String&gt; argNames,
&nbsp;                            Map&lt;String, ArgumentEntry&gt; arguments) {
<b class="nc">&nbsp;        if (argNames != null) {</b>
<b class="nc">&nbsp;            Double recordValue = getValueForTsRecord(ProtoUtils.fromProto(item.getKv()));</b>
<b class="nc">&nbsp;            argNames.forEach(argName -&gt; arguments.compute(argName, (name, existing) -&gt; {</b>
<b class="nc">&nbsp;                if (existing instanceof TsRollingArgumentEntry rolling) {</b>
<b class="nc">&nbsp;                    if (recordValue != null) {</b>
<b class="nc">&nbsp;                        rolling.getTsRecords().put(item.getTs(), recordValue);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return rolling;</b>
&nbsp;                }
<b class="nc">&nbsp;                TsRollingArgumentEntry rolling = new TsRollingArgumentEntry();</b>
<b class="nc">&nbsp;                if (recordValue != null) {</b>
<b class="nc">&nbsp;                    rolling.getTsRecords().put(item.getTs(), recordValue);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (existing instanceof SingleValueArgumentEntry single) {</b>
<b class="nc">&nbsp;                    Double existingValue = getValueForTsRecord(single.getKvEntryValue());</b>
<b class="nc">&nbsp;                    if (existingValue != null) {</b>
<b class="nc">&nbsp;                        rolling.getTsRecords().put(single.getTs(), existingValue);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                return rolling;</b>
&nbsp;            }));
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private Map&lt;String, ArgumentEntry&gt; mapToArguments(CalculatedFieldCtx ctx, AttributeScopeProto scope, List&lt;AttributeValueProto&gt; attrDataList) {
<b class="nc">&nbsp;        return mapToArguments(entityId, ctx.getMainEntityArguments(), ctx.getMainEntityGeofencingArgumentNames(), Collections.emptyMap(), scope, attrDataList);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Map&lt;String, ArgumentEntry&gt; mapToArguments(CalculatedFieldCtx ctx, EntityId entityId, AttributeScopeProto scope, List&lt;AttributeValueProto&gt; attrDataList) {
<b class="nc">&nbsp;        var args = ctx.getLinkedAndDynamicArgs(entityId);</b>
<b class="nc">&nbsp;        var relatedEntityArgs = ctx.getRelatedEntityArguments();</b>
<b class="nc">&nbsp;        List&lt;String&gt; geofencingArgumentNames = ctx.getLinkedEntityAndCurrentOwnerGeofencingArgumentNames();</b>
<b class="nc">&nbsp;        return mapToArguments(entityId, args, geofencingArgumentNames, relatedEntityArgs, scope, attrDataList);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Map&lt;String, ArgumentEntry&gt; mapToArguments(EntityId entityId, Map&lt;ReferencedEntityKey, Set&lt;String&gt;&gt; args, List&lt;String&gt; geofencingArgNames, Map&lt;ReferencedEntityKey, Set&lt;String&gt;&gt; relatedEntityArgs, AttributeScopeProto scope, List&lt;AttributeValueProto&gt; attrDataList) {
<b class="nc">&nbsp;        if (args.isEmpty() &amp;&amp; relatedEntityArgs.isEmpty()) {</b>
<b class="nc">&nbsp;            return Collections.emptyMap();</b>
&nbsp;        }
<b class="nc">&nbsp;        Map&lt;String, ArgumentEntry&gt; arguments = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        for (AttributeValueProto item : attrDataList) {</b>
<b class="nc">&nbsp;            ReferencedEntityKey key = new ReferencedEntityKey(item.getKey(), ArgumentType.ATTRIBUTE, AttributeScope.valueOf(scope.name()));</b>
<b class="nc">&nbsp;            Set&lt;String&gt; argNames = relatedEntityArgs.get(key);</b>
<b class="nc">&nbsp;            if (argNames != null) {</b>
<b class="nc">&nbsp;                argNames.forEach(argName -&gt; {</b>
<b class="nc">&nbsp;                    arguments.put(argName, new SingleValueArgumentEntry(entityId, item));</b>
&nbsp;                });
&nbsp;            }
<b class="nc">&nbsp;            argNames = args.get(key);</b>
<b class="nc">&nbsp;            if (argNames == null) {</b>
&nbsp;                continue;
&nbsp;            }
<b class="nc">&nbsp;            argNames.forEach(argName -&gt; {</b>
<b class="nc">&nbsp;                if (geofencingArgNames.contains(argName)) {</b>
<b class="nc">&nbsp;                    arguments.put(argName, new GeofencingArgumentEntry(entityId, item));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    arguments.put(argName, new SingleValueArgumentEntry(item));</b>
&nbsp;                }
&nbsp;            });
&nbsp;        }
<b class="nc">&nbsp;        return arguments;</b>
&nbsp;    }
&nbsp;
&nbsp;    private Map&lt;String, ArgumentEntry&gt; mapToArgumentsWithDefaultValue(CalculatedFieldCtx ctx, EntityId entityId, AttributeScopeProto scope, List&lt;String&gt; removedAttrKeys) {
<b class="nc">&nbsp;        var args = ctx.getLinkedAndDynamicArgs(entityId);</b>
<b class="nc">&nbsp;        var relatedEntityArgs = ctx.getRelatedEntityArguments();</b>
<b class="nc">&nbsp;        List&lt;String&gt; geofencingArgumentNames = ctx.getLinkedEntityAndCurrentOwnerGeofencingArgumentNames();</b>
<b class="nc">&nbsp;        return mapToArgumentsWithDefaultValue(entityId, args, ctx.getArguments(), geofencingArgumentNames, relatedEntityArgs, scope, removedAttrKeys);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Map&lt;String, ArgumentEntry&gt; mapToArgumentsWithDefaultValue(CalculatedFieldCtx ctx, AttributeScopeProto scope, List&lt;String&gt; removedAttrKeys) {
<b class="nc">&nbsp;        return mapToArgumentsWithDefaultValue(null, ctx.getMainEntityArguments(), ctx.getArguments(), ctx.getMainEntityGeofencingArgumentNames(), Collections.emptyMap(), scope, removedAttrKeys);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Map&lt;String, ArgumentEntry&gt; mapToArgumentsWithDefaultValue(EntityId msgEntityId,
&nbsp;                                                                      Map&lt;ReferencedEntityKey, Set&lt;String&gt;&gt; args,
&nbsp;                                                                      Map&lt;String, Argument&gt; configArguments,
&nbsp;                                                                      List&lt;String&gt; geofencingArgNames,
&nbsp;                                                                      Map&lt;ReferencedEntityKey, Set&lt;String&gt;&gt; relatedEntityArgs,
&nbsp;                                                                      AttributeScopeProto scope,
&nbsp;                                                                      List&lt;String&gt; removedAttrKeys) {
<b class="nc">&nbsp;        if (args.isEmpty() &amp;&amp; relatedEntityArgs.isEmpty()) {</b>
<b class="nc">&nbsp;            return Collections.emptyMap();</b>
&nbsp;        }
<b class="nc">&nbsp;        Map&lt;String, ArgumentEntry&gt; arguments = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        for (String removedKey : removedAttrKeys) {</b>
<b class="nc">&nbsp;            ReferencedEntityKey key = new ReferencedEntityKey(removedKey, ArgumentType.ATTRIBUTE, AttributeScope.valueOf(scope.name()));</b>
<b class="nc">&nbsp;            Set&lt;String&gt; argNames = relatedEntityArgs.get(key);</b>
<b class="nc">&nbsp;            if (argNames != null) {</b>
<b class="nc">&nbsp;                argNames.forEach(argName -&gt; {</b>
<b class="nc">&nbsp;                    String defaultValue = getDefaultValue(configArguments, argName);</b>
<b class="nc">&nbsp;                    SingleValueArgumentEntry argumentEntry = buildSingleValue(removedKey, defaultValue, System.currentTimeMillis());</b>
<b class="nc">&nbsp;                    arguments.put(argName, new SingleValueArgumentEntry(msgEntityId, argumentEntry));</b>
&nbsp;                });
&nbsp;            }
<b class="nc">&nbsp;            argNames = args.get(key);</b>
<b class="nc">&nbsp;            if (argNames == null) {</b>
&nbsp;                continue;
&nbsp;            }
<b class="nc">&nbsp;            argNames.forEach(argName -&gt; {</b>
<b class="nc">&nbsp;                if (geofencingArgNames.contains(argName)) {</b>
<b class="nc">&nbsp;                    arguments.put(argName, new GeofencingArgumentEntry());</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    String defaultValue = getDefaultValue(configArguments, argName);</b>
<b class="nc">&nbsp;                    SingleValueArgumentEntry argumentEntry = buildSingleValue(removedKey, defaultValue, System.currentTimeMillis());</b>
<b class="nc">&nbsp;                    arguments.put(argName, new SingleValueArgumentEntry(argumentEntry));</b>
&nbsp;                }
&nbsp;            });
&nbsp;        }
<b class="nc">&nbsp;        return arguments;</b>
&nbsp;    }
&nbsp;
&nbsp;    private String getDefaultValue(Map&lt;String, Argument&gt; configArguments, String argNames) {
<b class="nc">&nbsp;        Argument argument = configArguments.get(argNames);</b>
<b class="nc">&nbsp;        return argument != null ? argument.getDefaultValue() : null;</b>
&nbsp;    }
&nbsp;
&nbsp;    private SingleValueArgumentEntry buildSingleValue(String attrKey, String defaultValue, long ts) {
<b class="nc">&nbsp;        return StringUtils.isNotEmpty(defaultValue)</b>
<b class="nc">&nbsp;                ? new SingleValueArgumentEntry(ts, new StringDataEntry(attrKey, defaultValue), null)</b>
<b class="nc">&nbsp;                : new SingleValueArgumentEntry();</b>
&nbsp;    }
&nbsp;
&nbsp;    private Map&lt;String, ArgumentEntry&gt; mapToArgumentsWithFetchedValue(CalculatedFieldCtx ctx, EntityId entityId, List&lt;String&gt; removedTelemetryKeys) {
<b class="nc">&nbsp;        Map&lt;String, Argument&gt; deletedArguments = ctx.getArguments().entrySet().stream()</b>
<b class="nc">&nbsp;                .filter(entry -&gt; removedTelemetryKeys.contains(entry.getValue().getRefEntityKey().getKey()))</b>
<b class="nc">&nbsp;                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));</b>
&nbsp;
<b class="nc">&nbsp;        Map&lt;String, ArgumentEntry&gt; fetchedArgs = cfService.fetchArgsFromDb(tenantId, entityId, deletedArguments);</b>
&nbsp;
<b class="nc">&nbsp;        if (CalculatedFieldType.RELATED_ENTITIES_AGGREGATION.equals(ctx.getCfType())) {</b>
<b class="nc">&nbsp;            fetchedArgs = setEntityIdToSingleEntityArguments(entityId, fetchedArgs);</b>
&nbsp;        }
<b class="nc">&nbsp;        fetchedArgs.values().forEach(arg -&gt; arg.setForceResetPrevious(true));</b>
&nbsp;
<b class="nc">&nbsp;        return fetchedArgs;</b>
&nbsp;    }
&nbsp;
&nbsp;    private Map&lt;String, ArgumentEntry&gt; setEntityIdToSingleEntityArguments(EntityId relatedEntityId, Map&lt;String, ArgumentEntry&gt; fetchedArgs) {
<b class="nc">&nbsp;        return fetchedArgs.entrySet().stream()</b>
<b class="nc">&nbsp;                .collect(Collectors.toMap(</b>
&nbsp;                        Map.Entry::getKey,
<b class="nc">&nbsp;                        argEntry -&gt; new SingleValueArgumentEntry(relatedEntityId, argEntry.getValue())</b>
&nbsp;                ));
&nbsp;    }
&nbsp;
&nbsp;    private static List&lt;CalculatedFieldId&gt; getCalculatedFieldIds(CalculatedFieldTelemetryMsgProto proto) {
<b class="nc">&nbsp;        List&lt;CalculatedFieldId&gt; cfIds = new LinkedList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (var cfId : proto.getPreviousCalculatedFieldsList()) {</b>
<b class="nc">&nbsp;            cfIds.add(new CalculatedFieldId(new UUID(cfId.getCalculatedFieldIdMSB(), cfId.getCalculatedFieldIdLSB())));</b>
&nbsp;        }
<b class="nc">&nbsp;        return cfIds;</b>
&nbsp;    }
&nbsp;
&nbsp;    private UUID toTbMsgId(CalculatedFieldTelemetryMsgProto proto) {
<b class="nc">&nbsp;        if (proto.getTbMsgIdMSB() != 0 &amp;&amp; proto.getTbMsgIdLSB() != 0) {</b>
<b class="nc">&nbsp;            return new UUID(proto.getTbMsgIdMSB(), proto.getTbMsgIdLSB());</b>
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    private String toMsgType(CalculatedFieldTelemetryMsgProto proto) {
<b class="nc">&nbsp;        if (!proto.getTbMsgType().isEmpty()) {</b>
<b class="nc">&nbsp;            return proto.getTbMsgType();</b>
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
