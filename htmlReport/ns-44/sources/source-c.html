<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > CalculatedFieldManagerMessageProcessor</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.server.actors.calculatedField</a>
</div>

<h1>Coverage Summary for Class: CalculatedFieldManagerMessageProcessor (org.thingsboard.server.actors.calculatedField)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">CalculatedFieldManagerMessageProcessor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/66)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/189)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/431)
  </span>
</td>
</tr>
  <tr>
    <td class="name">CalculatedFieldManagerMessageProcessor$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CalculatedFieldManagerMessageProcessor$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CalculatedFieldManagerMessageProcessor$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/73)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/189)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/445)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.server.actors.calculatedField;
&nbsp;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.apache.commons.lang3.function.TriConsumer;
&nbsp;import org.thingsboard.common.util.DebugModeUtil;
&nbsp;import org.thingsboard.common.util.JacksonUtil;
&nbsp;import org.thingsboard.server.actors.ActorSystemContext;
&nbsp;import org.thingsboard.server.actors.TbActorCtx;
&nbsp;import org.thingsboard.server.actors.TbActorRef;
&nbsp;import org.thingsboard.server.actors.TbCalculatedFieldEntityActorId;
&nbsp;import org.thingsboard.server.actors.calculatedField.EntityInitCalculatedFieldMsg.StateAction;
&nbsp;import org.thingsboard.server.actors.service.DefaultActorService;
&nbsp;import org.thingsboard.server.actors.shared.AbstractContextAwareMsgProcessor;
&nbsp;import org.thingsboard.server.common.data.Customer;
&nbsp;import org.thingsboard.server.common.data.DataConstants;
&nbsp;import org.thingsboard.server.common.data.DeviceProfile;
&nbsp;import org.thingsboard.server.common.data.EntityType;
&nbsp;import org.thingsboard.server.common.data.ProfileEntityIdInfo;
&nbsp;import org.thingsboard.server.common.data.alarm.Alarm;
&nbsp;import org.thingsboard.server.common.data.asset.AssetProfile;
&nbsp;import org.thingsboard.server.common.data.audit.ActionType;
&nbsp;import org.thingsboard.server.common.data.cf.CalculatedField;
&nbsp;import org.thingsboard.server.common.data.cf.CalculatedFieldEventType;
&nbsp;import org.thingsboard.server.common.data.cf.CalculatedFieldLink;
&nbsp;import org.thingsboard.server.common.data.cf.CalculatedFieldType;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.HasRelationPathLevel;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.aggregation.RelatedEntitiesAggregationCalculatedFieldConfiguration;
&nbsp;import org.thingsboard.server.common.data.id.AssetId;
&nbsp;import org.thingsboard.server.common.data.id.CalculatedFieldId;
&nbsp;import org.thingsboard.server.common.data.id.DeviceId;
&nbsp;import org.thingsboard.server.common.data.id.EntityId;
&nbsp;import org.thingsboard.server.common.data.id.TenantId;
&nbsp;import org.thingsboard.server.common.data.msg.TbMsgType;
&nbsp;import org.thingsboard.server.common.data.page.PageDataIterable;
&nbsp;import org.thingsboard.server.common.data.plugin.ComponentLifecycleEvent;
&nbsp;import org.thingsboard.server.common.data.relation.EntityRelation;
&nbsp;import org.thingsboard.server.common.data.relation.EntityRelationPathQuery;
&nbsp;import org.thingsboard.server.common.data.relation.EntitySearchDirection;
&nbsp;import org.thingsboard.server.common.data.relation.RelationPathLevel;
&nbsp;import org.thingsboard.server.common.data.tenant.profile.DefaultTenantProfileConfiguration;
&nbsp;import org.thingsboard.server.common.msg.CalculatedFieldStatePartitionRestoreMsg;
&nbsp;import org.thingsboard.server.common.msg.cf.CalculatedFieldCacheInitMsg;
&nbsp;import org.thingsboard.server.common.msg.cf.CalculatedFieldEntityLifecycleMsg;
&nbsp;import org.thingsboard.server.common.msg.cf.CalculatedFieldPartitionChangeMsg;
&nbsp;import org.thingsboard.server.common.msg.plugin.ComponentLifecycleMsg;
&nbsp;import org.thingsboard.server.common.msg.queue.ServiceType;
&nbsp;import org.thingsboard.server.common.msg.queue.TbCallback;
&nbsp;import org.thingsboard.server.dao.asset.AssetService;
&nbsp;import org.thingsboard.server.dao.cf.CalculatedFieldService;
&nbsp;import org.thingsboard.server.dao.customer.CustomerService;
&nbsp;import org.thingsboard.server.dao.device.DeviceService;
&nbsp;import org.thingsboard.server.dao.relation.RelationService;
&nbsp;import org.thingsboard.server.queue.settings.TbQueueCalculatedFieldSettings;
&nbsp;import org.thingsboard.server.service.cf.CalculatedFieldProcessingService;
&nbsp;import org.thingsboard.server.service.cf.CalculatedFieldStateService;
&nbsp;import org.thingsboard.server.service.cf.OwnerService;
&nbsp;import org.thingsboard.server.service.cf.cache.TenantEntityProfileCache;
&nbsp;import org.thingsboard.server.service.cf.ctx.CalculatedFieldEntityCtxId;
&nbsp;import org.thingsboard.server.service.cf.ctx.state.CalculatedFieldCtx;
&nbsp;import org.thingsboard.server.service.profile.TbAssetProfileCache;
&nbsp;import org.thingsboard.server.service.profile.TbDeviceProfileCache;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Optional;
&nbsp;import java.util.Set;
&nbsp;import java.util.concurrent.CopyOnWriteArrayList;
&nbsp;import java.util.concurrent.ScheduledFuture;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.function.BiConsumer;
&nbsp;import java.util.function.Function;
&nbsp;import java.util.function.Predicate;
&nbsp;import java.util.stream.Stream;
&nbsp;
&nbsp;import static org.thingsboard.server.utils.CalculatedFieldUtils.fromProto;
&nbsp;
&nbsp;/**
&nbsp; * @author Andrew Shvayka
&nbsp; */
<b class="nc">&nbsp;@Slf4j</b>
&nbsp;public class CalculatedFieldManagerMessageProcessor extends AbstractContextAwareMsgProcessor {
&nbsp;
<b class="nc">&nbsp;    private final Map&lt;CalculatedFieldId, CalculatedFieldCtx&gt; calculatedFields = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;    private final Map&lt;EntityId, List&lt;CalculatedFieldCtx&gt;&gt; entityIdCalculatedFields = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;    private final Map&lt;EntityId, List&lt;CalculatedFieldLink&gt;&gt; entityIdCalculatedFieldLinks = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;    private final Map&lt;EntityId, Set&lt;EntityId&gt;&gt; ownerEntities = new HashMap&lt;&gt;();</b>
&nbsp;    private ScheduledFuture&lt;?&gt; cfsReevaluationTask;
&nbsp;
&nbsp;    private final CalculatedFieldProcessingService cfExecService;
&nbsp;    private final CalculatedFieldStateService cfStateService;
&nbsp;    private final CalculatedFieldService cfDaoService;
&nbsp;    private final DeviceService deviceService;
&nbsp;    private final AssetService assetService;
&nbsp;    private final CustomerService customerService;
&nbsp;    private final RelationService relationService;
&nbsp;    private final TbAssetProfileCache assetProfileCache;
&nbsp;    private final TbDeviceProfileCache deviceProfileCache;
&nbsp;    private final TenantEntityProfileCache entityProfileCache;
&nbsp;    private final OwnerService ownerService;
&nbsp;    private final TbQueueCalculatedFieldSettings cfSettings;
&nbsp;    protected final TenantId tenantId;
&nbsp;
&nbsp;    private long cfCheckInterval;
&nbsp;
&nbsp;    protected TbActorCtx ctx;
&nbsp;
&nbsp;    CalculatedFieldManagerMessageProcessor(ActorSystemContext systemContext, TenantId tenantId) {
<b class="nc">&nbsp;        super(systemContext);</b>
<b class="nc">&nbsp;        this.cfExecService = systemContext.getCalculatedFieldProcessingService();</b>
<b class="nc">&nbsp;        this.cfStateService = systemContext.getCalculatedFieldStateService();</b>
<b class="nc">&nbsp;        this.cfDaoService = systemContext.getCalculatedFieldService();</b>
<b class="nc">&nbsp;        this.deviceService = systemContext.getDeviceService();</b>
<b class="nc">&nbsp;        this.assetService = systemContext.getAssetService();</b>
<b class="nc">&nbsp;        this.customerService = systemContext.getCustomerService();</b>
<b class="nc">&nbsp;        this.relationService = systemContext.getRelationService();</b>
<b class="nc">&nbsp;        this.assetProfileCache = systemContext.getAssetProfileCache();</b>
<b class="nc">&nbsp;        this.deviceProfileCache = systemContext.getDeviceProfileCache();</b>
<b class="nc">&nbsp;        this.entityProfileCache = new TenantEntityProfileCache();</b>
<b class="nc">&nbsp;        this.ownerService = systemContext.getOwnerService();</b>
<b class="nc">&nbsp;        this.cfSettings = systemContext.getCalculatedFieldSettings();</b>
<b class="nc">&nbsp;        this.tenantId = tenantId;</b>
&nbsp;    }
&nbsp;
&nbsp;    void init(TbActorCtx ctx) {
<b class="nc">&nbsp;        this.ctx = ctx;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void stop() {
<b class="nc">&nbsp;        log.info(&quot;[{}] Stopping CF manager actor.&quot;, tenantId);</b>
<b class="nc">&nbsp;        calculatedFields.values().forEach(CalculatedFieldCtx::close);</b>
<b class="nc">&nbsp;        calculatedFields.clear();</b>
<b class="nc">&nbsp;        entityIdCalculatedFields.clear();</b>
<b class="nc">&nbsp;        entityIdCalculatedFieldLinks.clear();</b>
<b class="nc">&nbsp;        cancelReevaluationTask();</b>
<b class="nc">&nbsp;        ctx.stop(ctx.getSelf());</b>
&nbsp;    }
&nbsp;
&nbsp;    public void onCacheInitMsg(CalculatedFieldCacheInitMsg msg) {
<b class="nc">&nbsp;        log.debug(&quot;[{}] Processing CF actor init message.&quot;, msg.getTenantId().getId());</b>
<b class="nc">&nbsp;        initEntitiesCache();</b>
<b class="nc">&nbsp;        initCalculatedFields();</b>
<b class="nc">&nbsp;        cfCheckInterval = systemContext.getApiLimitService().getLimit(tenantId, DefaultTenantProfileConfiguration::getCfReevaluationCheckInterval);</b>
<b class="nc">&nbsp;        scheduleCfsReevaluation();</b>
<b class="nc">&nbsp;        msg.getCallback().onSuccess();</b>
&nbsp;    }
&nbsp;
&nbsp;    public void onStateRestoreMsg(CalculatedFieldStateRestoreMsg msg) {
<b class="nc">&nbsp;        var cfId = msg.getId().cfId();</b>
<b class="nc">&nbsp;        var ctx = calculatedFields.get(cfId);</b>
&nbsp;
<b class="nc">&nbsp;        if (ctx != null) {</b>
<b class="nc">&nbsp;            msg.setCtx(ctx);</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}] Pushing CF state restore msg to specific actor [{}]&quot;, tenantId, msg.getId().entityId());</b>
<b class="nc">&nbsp;            getOrCreateActor(msg.getId().entityId()).tellWithHighPriority(msg);</b>
<b class="nc">&nbsp;        } else if (msg.getState() != null) {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}] Received CF state restore msg for non-existing CF [{}]. Removing state&quot;, tenantId, cfId);</b>
<b class="nc">&nbsp;            cfStateService.deleteState(msg.getId(), msg.getCallback());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            msg.getCallback().onSuccess();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void onStatePartitionRestoreMsg(CalculatedFieldStatePartitionRestoreMsg msg) {
<b class="nc">&nbsp;        ctx.broadcastToChildren(msg, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void scheduleCfsReevaluation() {
<b class="nc">&nbsp;        cfsReevaluationTask = systemContext.getScheduler().scheduleWithFixedDelay(() -&gt; {</b>
&nbsp;            try {
<b class="nc">&nbsp;                calculatedFields.values().forEach(cf -&gt; {</b>
<b class="nc">&nbsp;                    if (cf.requiresScheduledReevaluation()) {</b>
<b class="nc">&nbsp;                        applyToTargetCfEntityActors(cf, TbCallback.EMPTY, (entityId, callback) -&gt; {</b>
<b class="nc">&nbsp;                            log.debug(&quot;[{}][{}] Pushing scheduled CF reevaluate msg&quot;, entityId, cf.getCfId());</b>
<b class="nc">&nbsp;                            getOrCreateActor(entityId).tell(new CalculatedFieldReevaluateMsg(tenantId, cf));</b>
&nbsp;                        });
&nbsp;                    }
&nbsp;                });
&nbsp;            } catch (Exception e) {
<b class="nc">&nbsp;                log.warn(&quot;[{}] Failed to trigger CFs reevaluation&quot;, tenantId, e);</b>
&nbsp;            }
&nbsp;        }, cfCheckInterval, cfCheckInterval, TimeUnit.SECONDS);
&nbsp;    }
&nbsp;
&nbsp;    public void onEntityLifecycleMsg(CalculatedFieldEntityLifecycleMsg msg) throws CalculatedFieldException {
<b class="nc">&nbsp;        var event = msg.getData().getEvent();</b>
<b class="nc">&nbsp;        if (ComponentLifecycleEvent.RELATION_UPDATED.equals(event) || ComponentLifecycleEvent.RELATION_DELETED.equals(event)) {</b>
<b class="nc">&nbsp;            log.debug(&quot;Processing relation [{}] event from entity: [{}]&quot;, event, msg.getData().getEntityId());</b>
<b class="nc">&nbsp;            onRelationChangedEvent(msg.getData(), msg.getCallback());</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        log.debug(&quot;Processing entity lifecycle event: [{}] for entity: [{}]&quot;, event, msg.getData().getEntityId());</b>
<b class="nc">&nbsp;        var entityType = msg.getData().getEntityId().getEntityType();</b>
<b class="nc">&nbsp;        switch (entityType) {</b>
&nbsp;            case CALCULATED_FIELD -&gt; {
<b class="nc">&nbsp;                switch (event) {</b>
<b class="nc">&nbsp;                    case CREATED -&gt; onCfCreated(msg.getData(), msg.getCallback());</b>
<b class="nc">&nbsp;                    case UPDATED -&gt; onCfUpdated(msg.getData(), msg.getCallback());</b>
<b class="nc">&nbsp;                    case DELETED -&gt; onCfDeleted(msg.getData(), msg.getCallback());</b>
<b class="nc">&nbsp;                    default -&gt; msg.getCallback().onSuccess();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case DEVICE, ASSET, CUSTOMER -&gt; {
<b class="nc">&nbsp;                switch (event) {</b>
<b class="nc">&nbsp;                    case CREATED -&gt; onEntityCreated(msg.getData(), msg.getCallback());</b>
<b class="nc">&nbsp;                    case UPDATED -&gt; onEntityUpdated(msg.getData(), msg.getCallback());</b>
<b class="nc">&nbsp;                    case DELETED -&gt; onEntityDeleted(msg.getData(), msg.getCallback());</b>
<b class="nc">&nbsp;                    default -&gt; msg.getCallback().onSuccess();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case DEVICE_PROFILE, ASSET_PROFILE -&gt; {
<b class="nc">&nbsp;                switch (event) {</b>
<b class="nc">&nbsp;                    case DELETED -&gt; onProfileDeleted(msg.getData(), msg.getCallback());</b>
<b class="nc">&nbsp;                    default -&gt; msg.getCallback().onSuccess();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case TENANT_PROFILE -&gt; {
<b class="nc">&nbsp;                switch (event) {</b>
<b class="nc">&nbsp;                    case UPDATED -&gt; onTenantProfileUpdated(msg.getData(), msg.getCallback());</b>
<b class="nc">&nbsp;                    default -&gt; msg.getCallback().onSuccess();</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            default -&gt; msg.getCallback().onSuccess();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void onEntityActionEventMsg(CalculatedFieldEntityActionEventMsg msg) {
<b class="nc">&nbsp;        switch (msg.getAction()) {</b>
&nbsp;            case ALARM_ACK, ALARM_CLEAR, ALARM_DELETE -&gt; {
<b class="nc">&nbsp;                Alarm alarm = JacksonUtil.treeToValue(msg.getEntity(), Alarm.class);</b>
<b class="nc">&nbsp;                CalculatedFieldAlarmActionMsg alarmActionMsg = CalculatedFieldAlarmActionMsg.builder()</b>
<b class="nc">&nbsp;                        .tenantId(tenantId)</b>
<b class="nc">&nbsp;                        .alarm(alarm)</b>
<b class="nc">&nbsp;                        .action(msg.getAction())</b>
<b class="nc">&nbsp;                        .callback(msg.getCallback())</b>
<b class="nc">&nbsp;                        .build();</b>
<b class="nc">&nbsp;                getOrCreateActor(alarm.getOriginator()).tellWithHighPriority(alarmActionMsg);</b>
&nbsp;            }
<b class="nc">&nbsp;            default -&gt; msg.getCallback().onSuccess();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void onProfileDeleted(ComponentLifecycleMsg msg, TbCallback callback) {
<b class="nc">&nbsp;        entityProfileCache.removeProfileId(msg.getEntityId());</b>
<b class="nc">&nbsp;        callback.onSuccess();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void onTenantProfileUpdated(ComponentLifecycleMsg msg, TbCallback callback) {
<b class="nc">&nbsp;        checkCfIntervalForUpdate();</b>
&nbsp;
<b class="nc">&nbsp;        long maxRelatedEntitiesPerCfArgument = systemContext.getApiLimitService().getLimit(tenantId, DefaultTenantProfileConfiguration::getMaxRelatedEntitiesToReturnPerCfArgument);</b>
<b class="nc">&nbsp;        List&lt;CalculatedFieldCtx&gt; cfsToReinit = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        Stream.concat(</b>
<b class="nc">&nbsp;                calculatedFields.values().stream(),</b>
<b class="nc">&nbsp;                entityIdCalculatedFields.values().stream().flatMap(Collection::stream)</b>
<b class="nc">&nbsp;        ).forEach(ctx -&gt; {</b>
<b class="nc">&nbsp;            if (ctx.hasRelatedEntities() &amp;&amp; ctx.getMaxRelatedEntitiesPerCfArgument() != maxRelatedEntitiesPerCfArgument) {</b>
<b class="nc">&nbsp;                cfsToReinit.add(ctx);</b>
&nbsp;            }
<b class="nc">&nbsp;            ctx.setTenantProfileProperties();</b>
&nbsp;        });
&nbsp;
<b class="nc">&nbsp;        if (!cfsToReinit.isEmpty()) {</b>
<b class="nc">&nbsp;            MultipleTbCallback cfsReinitCallback = new MultipleTbCallback(cfsToReinit.size(), callback);</b>
<b class="nc">&nbsp;            cfsToReinit.forEach(ctx -&gt; applyToTargetCfEntityActors(ctx, cfsReinitCallback, (id, cb) -&gt; initCfForEntity(id, ctx, StateAction.REINIT, CalculatedFieldEventType.TENANT_PROFILE_UPDATED, cb)));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            callback.onSuccess();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void checkCfIntervalForUpdate() {
<b class="nc">&nbsp;        long updatedCfCheckInterval = systemContext.getApiLimitService().getLimit(tenantId, DefaultTenantProfileConfiguration::getCfReevaluationCheckInterval);</b>
<b class="nc">&nbsp;        if (cfCheckInterval != updatedCfCheckInterval) {</b>
<b class="nc">&nbsp;            cfCheckInterval = updatedCfCheckInterval;</b>
<b class="nc">&nbsp;            cancelReevaluationTask();</b>
<b class="nc">&nbsp;            scheduleCfsReevaluation();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void onEntityCreated(ComponentLifecycleMsg msg, TbCallback callback) {
<b class="nc">&nbsp;        EntityId entityId = msg.getEntityId();</b>
<b class="nc">&nbsp;        EntityId profileId = getProfileId(tenantId, entityId);</b>
<b class="nc">&nbsp;        if (profileId != null) {</b>
<b class="nc">&nbsp;            entityProfileCache.add(profileId, entityId);</b>
&nbsp;        }
<b class="nc">&nbsp;        updateEntityOwner(entityId);</b>
&nbsp;
<b class="nc">&nbsp;        if (!isMyPartition(entityId, callback)) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        var entityIdFields = getCalculatedFieldsByEntityId(entityId);</b>
<b class="nc">&nbsp;        var profileIdFields = getCalculatedFieldsByEntityId(profileId);</b>
<b class="nc">&nbsp;        var fieldsCount = entityIdFields.size() + profileIdFields.size();</b>
<b class="nc">&nbsp;        if (fieldsCount &gt; 0) {</b>
<b class="nc">&nbsp;            MultipleTbCallback multiCallback = new MultipleTbCallback(fieldsCount, callback);</b>
<b class="nc">&nbsp;            entityIdFields.forEach(ctx -&gt; initCfForEntity(entityId, ctx, StateAction.INIT, CalculatedFieldEventType.INITIALIZED, multiCallback));</b>
<b class="nc">&nbsp;            profileIdFields.forEach(ctx -&gt; initCfForEntity(entityId, ctx, StateAction.INIT, CalculatedFieldEventType.INITIALIZED, multiCallback));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            callback.onSuccess();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void onEntityUpdated(ComponentLifecycleMsg msg, TbCallback callback) {
<b class="nc">&nbsp;        if (msg.getOldProfileId() != null &amp;&amp; !msg.getOldProfileId().equals(msg.getProfileId())) {</b>
<b class="nc">&nbsp;            entityProfileCache.update(msg.getOldProfileId(), msg.getProfileId(), msg.getEntityId());</b>
<b class="nc">&nbsp;            if (!isMyPartition(msg.getEntityId(), callback)) {</b>
&nbsp;                return;
&nbsp;            }
<b class="nc">&nbsp;            var oldProfileCfs = getCalculatedFieldsByEntityId(msg.getOldProfileId());</b>
<b class="nc">&nbsp;            var newProfileCfs = getCalculatedFieldsByEntityId(msg.getProfileId());</b>
<b class="nc">&nbsp;            var fieldsCount = oldProfileCfs.size() + newProfileCfs.size();</b>
<b class="nc">&nbsp;            if (fieldsCount &gt; 0) {</b>
<b class="nc">&nbsp;                MultipleTbCallback multiCallback = new MultipleTbCallback(fieldsCount, callback);</b>
<b class="nc">&nbsp;                var entityId = msg.getEntityId();</b>
<b class="nc">&nbsp;                oldProfileCfs.forEach(ctx -&gt; deleteCfForEntity(entityId, ctx.getCfId(), multiCallback));</b>
<b class="nc">&nbsp;                newProfileCfs.forEach(ctx -&gt; initCfForEntity(entityId, ctx, StateAction.INIT, CalculatedFieldEventType.INITIALIZED, multiCallback));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                callback.onSuccess();</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (msg.isOwnerChanged()) {</b>
<b class="nc">&nbsp;            onEntityOwnerChanged(msg, callback);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            callback.onSuccess();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void onEntityDeleted(ComponentLifecycleMsg msg, TbCallback callback) {
<b class="nc">&nbsp;        switch (msg.getEntityId().getEntityType()) {</b>
<b class="nc">&nbsp;            case DEVICE, ASSET -&gt; entityProfileCache.removeEntityId(msg.getEntityId());</b>
<b class="nc">&nbsp;            case CUSTOMER -&gt; ownerEntities.remove(msg.getEntityId());</b>
&nbsp;        }
<b class="nc">&nbsp;        ownerEntities.values().forEach(entities -&gt; entities.remove(msg.getEntityId()));</b>
<b class="nc">&nbsp;        if (isMyPartition(msg.getEntityId(), callback)) {</b>
<b class="nc">&nbsp;            log.debug(&quot;Pushing entity lifecycle msg to specific actor [{}]&quot;, msg.getEntityId());</b>
<b class="nc">&nbsp;            getOrCreateActor(msg.getEntityId()).tell(new CalculatedFieldEntityDeleteMsg(tenantId, msg.getEntityId(), callback));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void onRelationChangedEvent(ComponentLifecycleMsg msg, TbCallback callback) {
<b class="nc">&nbsp;        Function&lt;EntityId, TriConsumer&lt;EntityId, CalculatedFieldCtx, TbCallback&gt;&gt; relationAction = switch (msg.getEvent()) {</b>
<b class="nc">&nbsp;            case RELATION_UPDATED -&gt; relatedId -&gt; (entityId, ctx, cb) -&gt; initRelatedEntity(entityId, relatedId, ctx, cb);</b>
<b class="nc">&nbsp;            case RELATION_DELETED -&gt; relatedId -&gt; (entityId, ctx, cb) -&gt; deleteRelatedEntity(entityId, relatedId, ctx, cb);</b>
<b class="nc">&nbsp;            default -&gt; null;</b>
&nbsp;        };
&nbsp;
<b class="nc">&nbsp;        if (relationAction == null) {</b>
<b class="nc">&nbsp;            callback.onSuccess();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        EntityRelation entityRelation = JacksonUtil.treeToValue(msg.getInfo(), EntityRelation.class);</b>
<b class="nc">&nbsp;        EntityId toId = entityRelation.getTo();</b>
<b class="nc">&nbsp;        EntityId fromId = entityRelation.getFrom();</b>
<b class="nc">&nbsp;        String relationType = entityRelation.getType();</b>
&nbsp;
<b class="nc">&nbsp;        if (!(CalculatedField.isSupportedRefEntity(toId) || CalculatedField.isSupportedRefEntity(fromId))) {</b>
<b class="nc">&nbsp;            callback.onSuccess();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        MultipleTbCallback callbackForToAndFrom = new MultipleTbCallback(2, callback);</b>
<b class="nc">&nbsp;        processRelationByDirection(EntitySearchDirection.TO, relationType, toId, callbackForToAndFrom, relationAction.apply(fromId));</b>
<b class="nc">&nbsp;        processRelationByDirection(EntitySearchDirection.FROM, relationType, fromId, callbackForToAndFrom, relationAction.apply(toId));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void processRelationByDirection(EntitySearchDirection direction,
&nbsp;                                            String relationType,
&nbsp;                                            EntityId mainId,
&nbsp;                                            MultipleTbCallback parentCallback,
&nbsp;                                            TriConsumer&lt;EntityId, CalculatedFieldCtx, TbCallback&gt; relationAction) {
<b class="nc">&nbsp;        if (!isMyPartition(mainId, parentCallback)) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        List&lt;CalculatedFieldCtx&gt; cfsByEntityIdAndProfile = getCalculatedFieldsByEntityIdAndProfile(mainId);</b>
<b class="nc">&nbsp;        if (cfsByEntityIdAndProfile.isEmpty()) {</b>
<b class="nc">&nbsp;            parentCallback.onSuccess();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        List&lt;CalculatedFieldCtx&gt; matchingCfs = cfsByEntityIdAndProfile.stream()</b>
<b class="nc">&nbsp;                .filter(cf -&gt; {</b>
<b class="nc">&nbsp;                    if (cf.getCalculatedField().getConfiguration() instanceof HasRelationPathLevel config) {</b>
<b class="nc">&nbsp;                        RelationPathLevel relation = config.getRelation();</b>
<b class="nc">&nbsp;                        return direction.equals(relation.direction()) &amp;&amp; relationType.equals(relation.relationType());</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                })
<b class="nc">&nbsp;                .toList();</b>
&nbsp;
<b class="nc">&nbsp;        MultipleTbCallback directionCallback = new MultipleTbCallback(matchingCfs.size(), parentCallback);</b>
<b class="nc">&nbsp;        matchingCfs.forEach(ctx -&gt; relationAction.accept(mainId, ctx, directionCallback));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void onCfCreated(ComponentLifecycleMsg msg, TbCallback callback) throws CalculatedFieldException {
<b class="nc">&nbsp;        var cfId = new CalculatedFieldId(msg.getEntityId().getId());</b>
<b class="nc">&nbsp;        if (calculatedFields.containsKey(cfId)) {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}] CF was already initialized [{}]&quot;, tenantId, cfId);</b>
<b class="nc">&nbsp;            callback.onSuccess();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            var cf = cfDaoService.findById(msg.getTenantId(), cfId);</b>
<b class="nc">&nbsp;            if (cf == null) {</b>
<b class="nc">&nbsp;                log.debug(&quot;[{}] Failed to lookup CF by id [{}]&quot;, tenantId, cfId);</b>
<b class="nc">&nbsp;                callback.onSuccess();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                var cfCtx = getCfCtx(cf);</b>
&nbsp;                try {
<b class="nc">&nbsp;                    cfCtx.init();</b>
&nbsp;                } catch (Exception e) {
<b class="nc">&nbsp;                    throw CalculatedFieldException.builder().ctx(cfCtx).eventEntity(cf.getEntityId()).cause(e).errorMessage(e.getMessage()).build();</b>
&nbsp;                }
<b class="nc">&nbsp;                calculatedFields.put(cf.getId(), cfCtx);</b>
&nbsp;                // We use copy on write lists to safely pass the reference to another actor for the iteration.
&nbsp;                // Alternative approach would be to use any list but avoid modifications to the list (change the complete map value instead)
<b class="nc">&nbsp;                entityIdCalculatedFields.computeIfAbsent(cf.getEntityId(), id -&gt; new CopyOnWriteArrayList&lt;&gt;()).add(cfCtx);</b>
<b class="nc">&nbsp;                addLinks(cf);</b>
<b class="nc">&nbsp;                applyToTargetCfEntityActors(cfCtx, callback, (id, cb) -&gt; initCfForEntity(id, cfCtx, StateAction.INIT, CalculatedFieldEventType.INITIALIZED, cb));</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private CalculatedFieldCtx getCfCtx(CalculatedField cf) {
<b class="nc">&nbsp;        return new CalculatedFieldCtx(cf, systemContext);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void onCfUpdated(ComponentLifecycleMsg msg, TbCallback callback) throws CalculatedFieldException {
<b class="nc">&nbsp;        var cfId = new CalculatedFieldId(msg.getEntityId().getId());</b>
<b class="nc">&nbsp;        var oldCfCtx = calculatedFields.get(cfId);</b>
<b class="nc">&nbsp;        if (oldCfCtx == null) {</b>
<b class="nc">&nbsp;            onCfCreated(msg, callback);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            var newCf = cfDaoService.findById(msg.getTenantId(), cfId);</b>
<b class="nc">&nbsp;            if (newCf == null) {</b>
<b class="nc">&nbsp;                log.debug(&quot;[{}] Failed to lookup CF by id [{}]&quot;, tenantId, cfId);</b>
<b class="nc">&nbsp;                callback.onSuccess();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                var newCfCtx = getCfCtx(newCf);</b>
&nbsp;                try {
<b class="nc">&nbsp;                    newCfCtx.init();</b>
&nbsp;                } catch (Exception e) {
<b class="nc">&nbsp;                    throw CalculatedFieldException.builder().ctx(newCfCtx).eventEntity(newCfCtx.getEntityId()).cause(e).errorMessage(e.getMessage()).build();</b>
&nbsp;                } finally {
<b class="nc">&nbsp;                    calculatedFields.put(newCf.getId(), newCfCtx);</b>
<b class="nc">&nbsp;                    List&lt;CalculatedFieldCtx&gt; oldCfList = entityIdCalculatedFields.get(newCf.getEntityId());</b>
<b class="nc">&nbsp;                    List&lt;CalculatedFieldCtx&gt; newCfList = new CopyOnWriteArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;                    boolean found = false;</b>
<b class="nc">&nbsp;                    for (CalculatedFieldCtx oldCtx : oldCfList) {</b>
<b class="nc">&nbsp;                        if (oldCtx.getCfId().equals(newCf.getId())) {</b>
<b class="nc">&nbsp;                            newCfList.add(newCfCtx);</b>
<b class="nc">&nbsp;                            found = true;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            newCfList.add(oldCtx);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    if (!found) {</b>
<b class="nc">&nbsp;                        newCfList.add(newCfCtx);</b>
&nbsp;                    }
&nbsp;                    // We use copy on write lists to safely pass the reference to another actor for the iteration.
&nbsp;                    // Alternative approach would be to use any list but avoid modifications to the list (change the complete map value instead)
<b class="nc">&nbsp;                    entityIdCalculatedFields.put(newCf.getEntityId(), newCfList);</b>
<b class="nc">&nbsp;                    deleteLinks(oldCfCtx);</b>
<b class="nc">&nbsp;                    addLinks(newCf);</b>
&nbsp;                }
&nbsp;
&nbsp;                StateAction stateAction;
<b class="nc">&nbsp;                if (newCfCtx.getCfType() != oldCfCtx.getCfType()) {</b>
<b class="nc">&nbsp;                    stateAction = StateAction.RECREATE; // completely recreate state, then calculate</b>
<b class="nc">&nbsp;                } else if (newCfCtx.hasStateChanges(oldCfCtx)) {</b>
<b class="nc">&nbsp;                    stateAction = StateAction.REINIT; // refetch arguments, call state.init, then calculate</b>
<b class="nc">&nbsp;                } else if (newCfCtx.hasContextOnlyChanges(oldCfCtx)) {</b>
<b class="nc">&nbsp;                    stateAction = StateAction.REPROCESS; // call state.setCtx, then calculate</b>
<b class="nc">&nbsp;                } else if (newCfCtx.hasRefreshContextOnlyChanges(oldCfCtx)) {</b>
<b class="nc">&nbsp;                    stateAction = StateAction.REFRESH_CTX;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    callback.onSuccess();</b>
&nbsp;                    return;
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                applyToTargetCfEntityActors(newCfCtx, new TbCallback() {</b>
&nbsp;                    @Override
&nbsp;                    public void onSuccess() {
<b class="nc">&nbsp;                        oldCfCtx.close();</b>
<b class="nc">&nbsp;                        callback.onSuccess();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void onFailure(Throwable t) {
<b class="nc">&nbsp;                        oldCfCtx.close();</b>
<b class="nc">&nbsp;                        callback.onFailure(t);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }, (id, cb) -&gt; initCfForEntity(id, newCfCtx, stateAction, CalculatedFieldEventType.UPDATED, cb));</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void onCfDeleted(ComponentLifecycleMsg msg, TbCallback callback) {
<b class="nc">&nbsp;        var cfId = new CalculatedFieldId(msg.getEntityId().getId());</b>
<b class="nc">&nbsp;        var cfCtx = calculatedFields.remove(cfId);</b>
<b class="nc">&nbsp;        if (cfCtx == null) {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}] CF was already deleted [{}]&quot;, tenantId, cfId);</b>
<b class="nc">&nbsp;            callback.onSuccess();</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        entityIdCalculatedFields.get(cfCtx.getEntityId()).remove(cfCtx);</b>
<b class="nc">&nbsp;        deleteLinks(cfCtx);</b>
<b class="nc">&nbsp;        applyToTargetCfEntityActors(cfCtx, new TbCallback() {</b>
&nbsp;            @Override
&nbsp;            public void onSuccess() {
<b class="nc">&nbsp;                cfCtx.close();</b>
<b class="nc">&nbsp;                callback.onSuccess();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void onFailure(Throwable t) {
<b class="nc">&nbsp;                cfCtx.close();</b>
<b class="nc">&nbsp;                callback.onFailure(t);</b>
&nbsp;            }
<b class="nc">&nbsp;        }, (id, cb) -&gt; deleteCfForEntity(id, cfId, cb));</b>
&nbsp;    }
&nbsp;
&nbsp;    public void onTelemetryMsg(CalculatedFieldTelemetryMsg msg) {
<b class="nc">&nbsp;        EntityId entityId = msg.getEntityId();</b>
<b class="nc">&nbsp;        log.debug(&quot;Received telemetry msg from entity [{}]&quot;, entityId);</b>
&nbsp;        // 4 = 1 for CF processing + 1 for links processing + 1 for owner entity processing + 1 for aggregation processing
<b class="nc">&nbsp;        MultipleTbCallback callback = new MultipleTbCallback(4, msg.getCallback());</b>
&nbsp;        // process all cfs related to entity, or it&#39;s profile;
<b class="nc">&nbsp;        var entityIdFields = getCalculatedFieldsByEntityId(entityId);</b>
<b class="nc">&nbsp;        var profileIdFields = getCalculatedFieldsByEntityId(getProfileId(tenantId, entityId));</b>
<b class="nc">&nbsp;        if (!entityIdFields.isEmpty() || !profileIdFields.isEmpty()) {</b>
<b class="nc">&nbsp;            log.debug(&quot;Pushing telemetry msg to specific actor [{}]&quot;, entityId);</b>
<b class="nc">&nbsp;            getOrCreateActor(entityId).tell(new EntityCalculatedFieldTelemetryMsg(msg, entityIdFields, profileIdFields, callback));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            callback.onSuccess();</b>
&nbsp;        }
&nbsp;        // process all links (if any);
<b class="nc">&nbsp;        List&lt;CalculatedFieldEntityCtxId&gt; linkedCalculatedFields = filterCalculatedFieldLinks(msg);</b>
<b class="nc">&nbsp;        var linksSize = linkedCalculatedFields.size();</b>
<b class="nc">&nbsp;        if (linksSize &gt; 0) {</b>
<b class="nc">&nbsp;            cfExecService.pushMsgToLinks(msg, linkedCalculatedFields, callback);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            callback.onSuccess();</b>
&nbsp;        }
&nbsp;        // process all cfs related to owner entity
<b class="nc">&nbsp;        if (entityId.getEntityType().isOneOf(EntityType.TENANT, EntityType.CUSTOMER)) {</b>
<b class="nc">&nbsp;            List&lt;CalculatedFieldEntityCtxId&gt; ownedEntitiesCFs = filterOwnedEntitiesCFs(msg);</b>
<b class="nc">&nbsp;            if (!ownedEntitiesCFs.isEmpty()) {</b>
<b class="nc">&nbsp;                cfExecService.pushMsgToLinks(msg, ownedEntitiesCFs, callback);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                callback.onSuccess();</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            callback.onSuccess();</b>
&nbsp;        }
&nbsp;        // process all aggregation cfs (if any);
<b class="nc">&nbsp;        List&lt;CalculatedFieldEntityCtxId&gt; aggregationCalculatedFields = filterAggregationCfs(msg);</b>
<b class="nc">&nbsp;        if (!aggregationCalculatedFields.isEmpty()) {</b>
<b class="nc">&nbsp;            cfExecService.pushMsgToLinks(msg, aggregationCalculatedFields, callback);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            callback.onSuccess();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;CalculatedFieldEntityCtxId&gt; filterAggregationCfs(CalculatedFieldTelemetryMsg msg) {
<b class="nc">&nbsp;        EntityId entityId = msg.getEntityId();</b>
<b class="nc">&nbsp;        return calculatedFields.values().stream()</b>
<b class="nc">&nbsp;                .filter(cf -&gt; CalculatedFieldType.RELATED_ENTITIES_AGGREGATION.equals(cf.getCfType()))</b>
<b class="nc">&nbsp;                .filter(cf -&gt; cf.relatedEntityMatches(msg.getProto()))</b>
<b class="nc">&nbsp;                .flatMap(cf -&gt; findRelationsForCf(entityId, cf).stream())</b>
<b class="nc">&nbsp;                .toList();</b>
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;CalculatedFieldEntityCtxId&gt; findRelationsForCf(EntityId entityId, CalculatedFieldCtx cf) {
<b class="nc">&nbsp;        List&lt;CalculatedFieldEntityCtxId&gt; result = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        if (cf.getCalculatedField().getConfiguration() instanceof RelatedEntitiesAggregationCalculatedFieldConfiguration configuration) {</b>
<b class="nc">&nbsp;            RelationPathLevel relation = configuration.getRelation();</b>
<b class="nc">&nbsp;            EntitySearchDirection inverseDirection = switch (relation.direction()) {</b>
<b class="nc">&nbsp;                case FROM -&gt; EntitySearchDirection.TO;</b>
<b class="nc">&nbsp;                case TO -&gt; EntitySearchDirection.FROM;</b>
&nbsp;            };
<b class="nc">&nbsp;            RelationPathLevel inverseRelation = new RelationPathLevel(inverseDirection, relation.relationType());</b>
<b class="nc">&nbsp;            List&lt;EntityRelation&gt; byRelationPathQuery = relationService.findByRelationPathQuery(tenantId, new EntityRelationPathQuery(entityId, List.of(inverseRelation)));</b>
<b class="nc">&nbsp;            EntityId cfEntityId = cf.getEntityId();</b>
<b class="nc">&nbsp;            Predicate&lt;EntityId&gt; matchesCfEntity = relatedEntity -&gt; cfEntityId.equals(relatedEntity) || cfEntityId.equals(getProfileId(tenantId, relatedEntity));</b>
<b class="nc">&nbsp;            if (byRelationPathQuery != null &amp;&amp; !byRelationPathQuery.isEmpty()) {</b>
<b class="nc">&nbsp;                switch (relation.direction()) {</b>
<b class="nc">&nbsp;                    case FROM -&gt; byRelationPathQuery.stream()</b>
<b class="nc">&nbsp;                            .filter(entityRelation -&gt; matchesCfEntity.test(entityRelation.getFrom()))</b>
<b class="nc">&nbsp;                            .forEach(entityRelation -&gt; result.add(new CalculatedFieldEntityCtxId(tenantId, cf.getCfId(), entityRelation.getFrom())));</b>
<b class="nc">&nbsp;                    case TO -&gt; byRelationPathQuery.stream()</b>
<b class="nc">&nbsp;                            .filter(entityRelation -&gt; matchesCfEntity.test(entityRelation.getTo()))</b>
<b class="nc">&nbsp;                            .forEach(entityRelation -&gt; result.add(new CalculatedFieldEntityCtxId(tenantId, cf.getCfId(), entityRelation.getTo())));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void onLinkedTelemetryMsg(CalculatedFieldLinkedTelemetryMsg msg) {
<b class="nc">&nbsp;        EntityId sourceEntityId = msg.getEntityId();</b>
<b class="nc">&nbsp;        log.debug(&quot;Received linked telemetry msg from entity [{}]&quot;, sourceEntityId);</b>
<b class="nc">&nbsp;        var proto = msg.getProto();</b>
<b class="nc">&nbsp;        var callback = msg.getCallback();</b>
<b class="nc">&nbsp;        var linksList = proto.getLinksList();</b>
<b class="nc">&nbsp;        if (linksList.isEmpty()) {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}] No CF links to process new telemetry.&quot;, msg.getTenantId());</b>
<b class="nc">&nbsp;            callback.onSuccess();</b>
&nbsp;        }
<b class="nc">&nbsp;        for (var linkProto : linksList) {</b>
<b class="nc">&nbsp;            var link = fromProto(linkProto);</b>
<b class="nc">&nbsp;            var cf = calculatedFields.get(link.cfId());</b>
<b class="nc">&nbsp;            withTargetEntities(link.entityId(), callback, (ids, cb) -&gt; {</b>
<b class="nc">&nbsp;                var linkedTelemetryMsg = new EntityCalculatedFieldLinkedTelemetryMsg(tenantId, sourceEntityId, proto.getMsg(), cf, cb);</b>
<b class="nc">&nbsp;                ids.forEach(id -&gt; linkedTelemetryMsgForEntity(id, linkedTelemetryMsg));</b>
&nbsp;            });
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void onEntityOwnerChanged(ComponentLifecycleMsg msg, TbCallback msgCallback) {
<b class="nc">&nbsp;        EntityId entityId = msg.getEntityId();</b>
<b class="nc">&nbsp;        log.debug(&quot;Received changed owner msg from entity [{}]&quot;, entityId);</b>
<b class="nc">&nbsp;        updateEntityOwner(entityId);</b>
<b class="nc">&nbsp;        List&lt;CalculatedFieldCtx&gt; cfs = getCalculatedFieldsByEntityIdAndProfile(entityId);</b>
<b class="nc">&nbsp;        if (cfs.isEmpty()) {</b>
<b class="nc">&nbsp;            msgCallback.onSuccess();</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        MultipleTbCallback callback = new MultipleTbCallback(cfs.size(), msgCallback);</b>
<b class="nc">&nbsp;        cfs.forEach(cf -&gt; {</b>
<b class="nc">&nbsp;            if (isMyPartition(entityId, callback)) {</b>
<b class="nc">&nbsp;                if (cf.hasCurrentOwnerSourceArguments()) {</b>
<b class="nc">&nbsp;                    CalculatedFieldArgumentResetMsg argResetMsg = new CalculatedFieldArgumentResetMsg(tenantId, cf, CalculatedFieldEventType.OWNER_CHANGED, callback);</b>
<b class="nc">&nbsp;                    log.debug(&quot;Pushing CF argument reset msg to specific actor [{}]&quot;, entityId);</b>
<b class="nc">&nbsp;                    getOrCreateActor(entityId).tell(argResetMsg);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    callback.onSuccess();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;CalculatedFieldEntityCtxId&gt; filterCalculatedFieldLinks(CalculatedFieldTelemetryMsg msg) {
<b class="nc">&nbsp;        EntityId entityId = msg.getEntityId();</b>
<b class="nc">&nbsp;        var proto = msg.getProto();</b>
<b class="nc">&nbsp;        List&lt;CalculatedFieldEntityCtxId&gt; result = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (var link : getCalculatedFieldLinksByEntityId(entityId)) {</b>
<b class="nc">&nbsp;            CalculatedFieldCtx ctx = calculatedFields.get(link.calculatedFieldId());</b>
<b class="nc">&nbsp;            if (ctx.linkMatches(entityId, proto)) {</b>
<b class="nc">&nbsp;                result.add(ctx.toCalculatedFieldEntityCtxId());</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;CalculatedFieldEntityCtxId&gt; filterOwnedEntitiesCFs(CalculatedFieldTelemetryMsg msg) {
<b class="nc">&nbsp;        Set&lt;EntityId&gt; entities = getOwnedEntities(msg.getEntityId());</b>
<b class="nc">&nbsp;        var proto = msg.getProto();</b>
<b class="nc">&nbsp;        List&lt;CalculatedFieldEntityCtxId&gt; result = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (var entityId : entities) {</b>
<b class="nc">&nbsp;            var ownerEntityCFs = getCalculatedFieldsByEntityId(entityId);</b>
<b class="nc">&nbsp;            for (var ctx : ownerEntityCFs) {</b>
<b class="nc">&nbsp;                if (ctx.dynamicSourceMatches(proto)) {</b>
<b class="nc">&nbsp;                    result.add(new CalculatedFieldEntityCtxId(tenantId, ctx.getCfId(), entityId));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            var ownerEntityProfileCFs = getCalculatedFieldsByEntityId(getProfileId(tenantId, entityId));</b>
<b class="nc">&nbsp;            for (var ctx : ownerEntityProfileCFs) {</b>
<b class="nc">&nbsp;                if (ctx.dynamicSourceMatches(proto)) {</b>
<b class="nc">&nbsp;                    result.add(new CalculatedFieldEntityCtxId(tenantId, ctx.getCfId(), entityId));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;CalculatedFieldCtx&gt; getCalculatedFieldsByEntityId(EntityId entityId) {
<b class="nc">&nbsp;        if (entityId == null) {</b>
<b class="nc">&nbsp;            return Collections.emptyList();</b>
&nbsp;        }
<b class="nc">&nbsp;        var result = entityIdCalculatedFields.get(entityId);</b>
<b class="nc">&nbsp;        if (result == null) {</b>
<b class="nc">&nbsp;            result = Collections.emptyList();</b>
&nbsp;        }
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;CalculatedFieldCtx&gt; getCalculatedFieldsByEntityIdAndProfile(EntityId entityId) {
<b class="nc">&nbsp;        List&lt;CalculatedFieldCtx&gt; cfsByEntityIdAndProfile = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        cfsByEntityIdAndProfile.addAll(getCalculatedFieldsByEntityId(entityId));</b>
<b class="nc">&nbsp;        EntityId profileId = getProfileId(tenantId, entityId);</b>
<b class="nc">&nbsp;        if (profileId != null) {</b>
<b class="nc">&nbsp;            cfsByEntityIdAndProfile.addAll(getCalculatedFieldsByEntityId(profileId));</b>
&nbsp;        }
<b class="nc">&nbsp;        return cfsByEntityIdAndProfile;</b>
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;CalculatedFieldLink&gt; getCalculatedFieldLinksByEntityId(EntityId entityId) {
<b class="nc">&nbsp;        if (entityId == null) {</b>
<b class="nc">&nbsp;            return Collections.emptyList();</b>
&nbsp;        }
<b class="nc">&nbsp;        var result = entityIdCalculatedFieldLinks.get(entityId);</b>
<b class="nc">&nbsp;        if (result == null) {</b>
<b class="nc">&nbsp;            result = Collections.emptyList();</b>
&nbsp;        }
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    private Set&lt;EntityId&gt; getOwnedEntities(EntityId entityId) {
<b class="nc">&nbsp;        if (entityId == null) {</b>
<b class="nc">&nbsp;            return Collections.emptySet();</b>
&nbsp;        }
<b class="nc">&nbsp;        var result = ownerEntities.get(entityId);</b>
<b class="nc">&nbsp;        if (result == null) {</b>
<b class="nc">&nbsp;            result = Collections.emptySet();</b>
&nbsp;        }
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void linkedTelemetryMsgForEntity(EntityId entityId, EntityCalculatedFieldLinkedTelemetryMsg msg) {
<b class="nc">&nbsp;        log.debug(&quot;Pushing linked telemetry msg to specific actor [{}]&quot;, entityId);</b>
<b class="nc">&nbsp;        getOrCreateActor(entityId).tell(msg);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void deleteRelatedEntity(EntityId entityId, EntityId relatedEntityId, CalculatedFieldCtx cf, TbCallback callback) {
<b class="nc">&nbsp;        log.debug(&quot;Pushing delete related entity msg to specific actor [{}]&quot;, relatedEntityId);</b>
<b class="nc">&nbsp;        getOrCreateActor(entityId).tell(new CalculatedFieldRelationActionMsg(tenantId, relatedEntityId, ActionType.DELETED, cf, callback));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void initRelatedEntity(EntityId entityId, EntityId relatedEntityId, CalculatedFieldCtx cf, TbCallback callback) {
<b class="nc">&nbsp;        log.debug(&quot;Pushing init related entity msg to specific actor [{}]&quot;, relatedEntityId);</b>
<b class="nc">&nbsp;        getOrCreateActor(entityId).tell(new CalculatedFieldRelationActionMsg(tenantId, relatedEntityId, ActionType.UPDATED, cf, callback));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void deleteCfForEntity(EntityId entityId, CalculatedFieldId cfId, TbCallback callback) {
<b class="nc">&nbsp;        log.debug(&quot;Pushing delete CF msg to specific actor [{}]&quot;, entityId);</b>
<b class="nc">&nbsp;        getOrCreateActor(entityId).tell(new CalculatedFieldEntityDeleteMsg(tenantId, cfId, callback));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void initCfForEntity(EntityId entityId, CalculatedFieldCtx cfCtx, StateAction stateAction, CalculatedFieldEventType eventType, TbCallback callback) {
<b class="nc">&nbsp;        log.debug(&quot;Pushing entity init CF msg to specific actor [{}]&quot;, entityId);</b>
<b class="nc">&nbsp;        getOrCreateActor(entityId).tell(new EntityInitCalculatedFieldMsg(tenantId, cfCtx, stateAction, eventType, callback));</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean isMyPartition(EntityId entityId, TbCallback callback) {
<b class="nc">&nbsp;        if (!systemContext.getPartitionService().resolve(ServiceType.TB_RULE_ENGINE, DataConstants.CF_QUEUE_NAME, tenantId, entityId).isMyPartition()) {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}] Entity belongs to external partition.&quot;, entityId);</b>
<b class="nc">&nbsp;            callback.onSuccess();</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static boolean isProfileEntity(EntityType entityType) {
<b class="nc">&nbsp;        return EntityType.DEVICE_PROFILE.equals(entityType) || EntityType.ASSET_PROFILE.equals(entityType);</b>
&nbsp;    }
&nbsp;
&nbsp;    private EntityId getProfileId(TenantId tenantId, EntityId entityId) {
<b class="nc">&nbsp;        return switch (entityId.getEntityType()) {</b>
<b class="nc">&nbsp;            case ASSET -&gt; Optional.ofNullable(assetProfileCache.get(tenantId, (AssetId) entityId)).map(AssetProfile::getId).orElse(null);</b>
<b class="nc">&nbsp;            case DEVICE -&gt; Optional.ofNullable(deviceProfileCache.get(tenantId, (DeviceId) entityId)).map(DeviceProfile::getId).orElse(null);</b>
<b class="nc">&nbsp;            default -&gt; null;</b>
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    private TbActorRef getOrCreateActor(EntityId entityId) {
<b class="nc">&nbsp;        return ctx.getOrCreateChildActor(new TbCalculatedFieldEntityActorId(entityId),</b>
<b class="nc">&nbsp;                () -&gt; DefaultActorService.CF_ENTITY_DISPATCHER_NAME,</b>
<b class="nc">&nbsp;                () -&gt; new CalculatedFieldEntityActorCreator(systemContext, tenantId, entityId),</b>
<b class="nc">&nbsp;                () -&gt; true);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void addLinks(CalculatedField newCf) {
<b class="nc">&nbsp;        var newLinks = newCf.getConfiguration().buildCalculatedFieldLinks(tenantId, newCf.getEntityId(), newCf.getId());</b>
<b class="nc">&nbsp;        newLinks.forEach(link -&gt; entityIdCalculatedFieldLinks.computeIfAbsent(link.entityId(), id -&gt; new CopyOnWriteArrayList&lt;&gt;()).add(link));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void deleteLinks(CalculatedFieldCtx cfCtx) {
<b class="nc">&nbsp;        var oldCf = cfCtx.getCalculatedField();</b>
<b class="nc">&nbsp;        var oldLinks = oldCf.getConfiguration().buildCalculatedFieldLinks(tenantId, oldCf.getEntityId(), oldCf.getId());</b>
<b class="nc">&nbsp;        oldLinks.forEach(link -&gt; entityIdCalculatedFieldLinks.computeIfAbsent(link.entityId(), id -&gt; new CopyOnWriteArrayList&lt;&gt;()).remove(link));</b>
&nbsp;    }
&nbsp;
&nbsp;    public void onPartitionChange(CalculatedFieldPartitionChangeMsg msg) {
<b class="nc">&nbsp;        ctx.broadcastToChildren(msg, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void initCalculatedFields() {
<b class="nc">&nbsp;        PageDataIterable&lt;CalculatedField&gt; cfs = new PageDataIterable&lt;&gt;(pageLink -&gt; cfDaoService.findCalculatedFieldsByTenantId(tenantId, pageLink), cfSettings.getInitTenantFetchPackSize());</b>
<b class="nc">&nbsp;        cfs.forEach(cf -&gt; {</b>
<b class="nc">&nbsp;            log.trace(&quot;Processing calculated field record: {}&quot;, cf);</b>
&nbsp;            try {
<b class="nc">&nbsp;                initCalculatedField(cf);</b>
<b class="nc">&nbsp;                initCalculatedFieldLinks(cf);</b>
&nbsp;            } catch (CalculatedFieldException e) {
<b class="nc">&nbsp;                log.error(&quot;Failed to process calculated field record: {}&quot;, cf, e);</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    private void initCalculatedField(CalculatedField cf) throws CalculatedFieldException {
<b class="nc">&nbsp;        var cfCtx = new CalculatedFieldCtx(cf, systemContext);</b>
&nbsp;        try {
<b class="nc">&nbsp;            cfCtx.init();</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            throw CalculatedFieldException.builder().ctx(cfCtx).eventEntity(cf.getEntityId()).cause(e).errorMessage(e.getMessage()).build();</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            calculatedFields.put(cf.getId(), cfCtx);</b>
&nbsp;            // We use copy on write lists to safely pass the reference to another actor for the iteration.
&nbsp;            // Alternative approach would be to use any list but avoid modifications to the list (change the complete map value instead)
<b class="nc">&nbsp;            entityIdCalculatedFields.computeIfAbsent(cf.getEntityId(), id -&gt; new CopyOnWriteArrayList&lt;&gt;()).add(cfCtx);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void initCalculatedFieldLinks(CalculatedField cf) {
<b class="nc">&nbsp;        List&lt;CalculatedFieldLink&gt; links = cf.getConfiguration().buildCalculatedFieldLinks(cf.getTenantId(), cf.getEntityId(), cf.getId());</b>
<b class="nc">&nbsp;        for (CalculatedFieldLink link : links) {</b>
&nbsp;            // We use copy on write lists to safely pass the reference to another actor for the iteration.
&nbsp;            // Alternative approach would be to use any list but avoid modifications to the list (change the complete map value instead)
<b class="nc">&nbsp;            entityIdCalculatedFieldLinks.computeIfAbsent(link.entityId(), id -&gt; new CopyOnWriteArrayList&lt;&gt;()).add(link);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void initEntitiesCache() {
<b class="nc">&nbsp;        PageDataIterable&lt;ProfileEntityIdInfo&gt; deviceIdInfos = new PageDataIterable&lt;&gt;(pageLink -&gt; deviceService.findProfileEntityIdInfosByTenantId(tenantId, pageLink), cfSettings.getInitTenantFetchPackSize());</b>
<b class="nc">&nbsp;        for (ProfileEntityIdInfo idInfo : deviceIdInfos) {</b>
<b class="nc">&nbsp;            log.trace(&quot;Processing device record: {}&quot;, idInfo);</b>
&nbsp;            try {
<b class="nc">&nbsp;                entityProfileCache.add(idInfo.getProfileId(), idInfo.getEntityId());</b>
<b class="nc">&nbsp;                ownerEntities.computeIfAbsent(idInfo.getOwnerId(), __ -&gt; new HashSet&lt;&gt;()).add(idInfo.getEntityId());</b>
&nbsp;            } catch (Exception e) {
<b class="nc">&nbsp;                log.error(&quot;Failed to process device record: {}&quot;, idInfo, e);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        PageDataIterable&lt;ProfileEntityIdInfo&gt; assetIdInfos = new PageDataIterable&lt;&gt;(pageLink -&gt; assetService.findProfileEntityIdInfosByTenantId(tenantId, pageLink), cfSettings.getInitTenantFetchPackSize());</b>
<b class="nc">&nbsp;        for (ProfileEntityIdInfo idInfo : assetIdInfos) {</b>
<b class="nc">&nbsp;            log.trace(&quot;Processing asset record: {}&quot;, idInfo);</b>
&nbsp;            try {
<b class="nc">&nbsp;                entityProfileCache.add(idInfo.getProfileId(), idInfo.getEntityId());</b>
<b class="nc">&nbsp;                ownerEntities.computeIfAbsent(idInfo.getOwnerId(), __ -&gt; new HashSet&lt;&gt;()).add(idInfo.getEntityId());</b>
&nbsp;            } catch (Exception e) {
<b class="nc">&nbsp;                log.error(&quot;Failed to process asset record: {}&quot;, idInfo, e);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        PageDataIterable&lt;Customer&gt; customers = new PageDataIterable&lt;&gt;(pageLink -&gt; customerService.findCustomersByTenantId(tenantId, pageLink), cfSettings.getInitTenantFetchPackSize());</b>
<b class="nc">&nbsp;        for (Customer customer : customers) {</b>
<b class="nc">&nbsp;            log.trace(&quot;Processing customer record: {}&quot;, customer);</b>
&nbsp;            try {
<b class="nc">&nbsp;                ownerEntities.computeIfAbsent(customer.getTenantId(), __ -&gt; new HashSet&lt;&gt;()).add(customer.getId());</b>
&nbsp;            } catch (Exception e) {
<b class="nc">&nbsp;                log.error(&quot;Failed to process customer record: {}&quot;, customer, e);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void updateEntityOwner(EntityId entityId) {
<b class="nc">&nbsp;        ownerEntities.values().forEach(entities -&gt; entities.remove(entityId));</b>
<b class="nc">&nbsp;        EntityId owner = ownerService.getOwner(tenantId, entityId);</b>
<b class="nc">&nbsp;        ownerEntities.computeIfAbsent(owner, ownerId -&gt; new HashSet&lt;&gt;()).add(entityId);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void applyToTargetCfEntityActors(CalculatedFieldCtx ctx,
&nbsp;                                             TbCallback callback,
&nbsp;                                             BiConsumer&lt;EntityId, TbCallback&gt; action) {
<b class="nc">&nbsp;        withTargetEntities(ctx.getEntityId(), callback, (ids, cb) -&gt; ids.forEach(id -&gt; action.accept(id, cb)));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void withTargetEntities(EntityId entityId, TbCallback parentCallback, BiConsumer&lt;List&lt;EntityId&gt;, TbCallback&gt; consumer) {
<b class="nc">&nbsp;        if (isProfileEntity(entityId.getEntityType())) {</b>
<b class="nc">&nbsp;            var ids = entityProfileCache.getEntityIdsByProfileId(entityId);</b>
<b class="nc">&nbsp;            if (ids.isEmpty()) {</b>
<b class="nc">&nbsp;                parentCallback.onSuccess();</b>
&nbsp;                return;
&nbsp;            }
<b class="nc">&nbsp;            var multiCallback = new MultipleTbCallback(ids.size(), parentCallback);</b>
<b class="nc">&nbsp;            var profileEntityIds = ids.stream().filter(id -&gt; isMyPartition(id, multiCallback)).toList();</b>
<b class="nc">&nbsp;            if (profileEntityIds.isEmpty()) {</b>
&nbsp;                return;
&nbsp;            }
<b class="nc">&nbsp;            consumer.accept(profileEntityIds, multiCallback);</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        if (isMyPartition(entityId, parentCallback)) {</b>
<b class="nc">&nbsp;            consumer.accept(List.of(entityId), parentCallback);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void cancelReevaluationTask() {
<b class="nc">&nbsp;        if (cfsReevaluationTask != null) {</b>
<b class="nc">&nbsp;            cfsReevaluationTask.cancel(true);</b>
<b class="nc">&nbsp;            cfsReevaluationTask = null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
