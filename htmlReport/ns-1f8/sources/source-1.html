<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > DeviceApiController</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.server.transport.http</a>
</div>

<h1>Coverage Summary for Class: DeviceApiController (org.thingsboard.server.transport.http)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DeviceApiController</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/83)
  </span>
</td>
</tr>
  <tr>
    <td class="name">DeviceApiController$DeviceAuthCallback</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DeviceApiController$DeviceProvisionCallback</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DeviceApiController$GetOtaPackageCallback</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DeviceApiController$HttpOkCallback</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DeviceApiController$HttpSessionListener</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DeviceApiController$SessionCloseOnErrorCallback</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/43)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/32)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/139)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.server.transport.http;
&nbsp;
&nbsp;import com.google.gson.JsonObject;
&nbsp;import com.google.gson.JsonParseException;
&nbsp;import com.google.gson.JsonParser;
&nbsp;import io.swagger.v3.oas.annotations.Operation;
&nbsp;import io.swagger.v3.oas.annotations.Parameter;
&nbsp;import io.swagger.v3.oas.annotations.media.Schema;
&nbsp;import io.swagger.v3.oas.annotations.responses.ApiResponse;
&nbsp;import io.swagger.v3.oas.annotations.responses.ApiResponses;
&nbsp;import jakarta.servlet.http.HttpServletRequest;
&nbsp;import lombok.RequiredArgsConstructor;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.springframework.beans.factory.annotation.Autowired;
&nbsp;import org.springframework.boot.autoconfigure.condition.ConditionalOnExpression;
&nbsp;import org.springframework.core.io.ByteArrayResource;
&nbsp;import org.springframework.http.HttpHeaders;
&nbsp;import org.springframework.http.HttpStatus;
&nbsp;import org.springframework.http.MediaType;
&nbsp;import org.springframework.http.ResponseEntity;
&nbsp;import org.springframework.http.converter.HttpMessageNotReadableException;
&nbsp;import org.springframework.web.bind.annotation.PathVariable;
&nbsp;import org.springframework.web.bind.annotation.RequestBody;
&nbsp;import org.springframework.web.bind.annotation.RequestMapping;
&nbsp;import org.springframework.web.bind.annotation.RequestMethod;
&nbsp;import org.springframework.web.bind.annotation.RequestParam;
&nbsp;import org.springframework.web.bind.annotation.RestController;
&nbsp;import org.springframework.web.context.request.async.DeferredResult;
&nbsp;import org.thingsboard.server.common.adaptor.JsonConverter;
&nbsp;import org.thingsboard.server.common.data.DataConstants;
&nbsp;import org.thingsboard.server.common.data.DeviceTransportType;
&nbsp;import org.thingsboard.server.common.data.StringUtils;
&nbsp;import org.thingsboard.server.common.data.TbTransportService;
&nbsp;import org.thingsboard.server.common.data.id.DeviceId;
&nbsp;import org.thingsboard.server.common.data.ota.OtaPackageType;
&nbsp;import org.thingsboard.server.common.data.rpc.RpcStatus;
&nbsp;import org.thingsboard.server.common.transport.SessionMsgListener;
&nbsp;import org.thingsboard.server.common.transport.TransportContext;
&nbsp;import org.thingsboard.server.common.transport.TransportService;
&nbsp;import org.thingsboard.server.common.transport.TransportServiceCallback;
&nbsp;import org.thingsboard.server.common.transport.auth.SessionInfoCreator;
&nbsp;import org.thingsboard.server.common.transport.auth.ValidateDeviceCredentialsResponse;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.AttributeUpdateNotificationMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.GetAttributeRequestMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.GetAttributeResponseMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.GetOtaPackageResponseMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.ProvisionDeviceResponseMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.SessionCloseNotificationProto;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.SessionInfoProto;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.SubscribeToAttributeUpdatesMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.SubscribeToRPCMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.ToDeviceRpcRequestMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.ToDeviceRpcResponseMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.ToServerRpcRequestMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.ToServerRpcResponseMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.ValidateDeviceTokenRequestMsg;
&nbsp;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.List;
&nbsp;import java.util.UUID;
&nbsp;import java.util.function.Consumer;
&nbsp;
&nbsp;
&nbsp;/**
&nbsp; * @author Andrew Shvayka
&nbsp; */
&nbsp;@RestController
&nbsp;@ConditionalOnExpression(&quot;&#39;${service.type:null}&#39;==&#39;tb-transport&#39; || (&#39;${service.type:null}&#39;==&#39;monolith&#39; &amp;&amp; &#39;${transport.api_enabled:true}&#39;==&#39;true&#39; &amp;&amp; &#39;${transport.http.enabled}&#39;==&#39;true&#39;)&quot;)
&nbsp;@RequestMapping(&quot;/api/v1&quot;)
<b class="nc">&nbsp;@Slf4j</b>
<b class="nc">&nbsp;public class DeviceApiController implements TbTransportService {</b>
&nbsp;
&nbsp;    private static final String MARKDOWN_CODE_BLOCK_START = &quot;\n\n```json\n&quot;;
&nbsp;    private static final String MARKDOWN_CODE_BLOCK_END = &quot;\n```\n\n&quot;;
&nbsp;
&nbsp;    private static final String REQUIRE_ACCESS_TOKEN = &quot;The API call is designed to be used by device firmware and requires device access token (&#39;deviceToken&#39;). &quot; +
&nbsp;            &quot;It is not recommended to use this API call by third-party scripts, rule-engine or platform widgets (use &#39;Telemetry Controller&#39; instead).\n&quot;;
&nbsp;
&nbsp;    private static final String ATTRIBUTE_PAYLOAD_EXAMPLE = &quot;{\n&quot; +
&nbsp;            &quot; \&quot;stringKey\&quot;:\&quot;value1\&quot;, \n&quot; +
&nbsp;            &quot; \&quot;booleanKey\&quot;:true, \n&quot; +
&nbsp;            &quot; \&quot;doubleKey\&quot;:42.0, \n&quot; +
&nbsp;            &quot; \&quot;longKey\&quot;:73, \n&quot; +
&nbsp;            &quot; \&quot;jsonKey\&quot;: {\n&quot; +
&nbsp;            &quot;    \&quot;someNumber\&quot;: 42,\n&quot; +
&nbsp;            &quot;    \&quot;someArray\&quot;: [1,2,3],\n&quot; +
&nbsp;            &quot;    \&quot;someNestedObject\&quot;: {\&quot;key\&quot;: \&quot;value\&quot;}\n&quot; +
&nbsp;            &quot; }\n&quot; +
&nbsp;            &quot;}&quot;;
&nbsp;
&nbsp;    protected static final String TS_PAYLOAD = &quot;The request payload is a JSON document with three possible formats:\n\n&quot; +
&nbsp;            &quot;Simple format without timestamp. In such a case, current server time will be used: \n\n&quot; +
&nbsp;            MARKDOWN_CODE_BLOCK_START +
&nbsp;            &quot;{\n&quot; +
&nbsp;            &quot; \&quot;stringKey\&quot;:\&quot;value1\&quot;, \n&quot; +
&nbsp;            &quot; \&quot;booleanKey\&quot;:true, \n&quot; +
&nbsp;            &quot; \&quot;doubleKey\&quot;:42.0, \n&quot; +
&nbsp;            &quot; \&quot;longKey\&quot;:73, \n&quot; +
&nbsp;            &quot; \&quot;jsonKey\&quot;: {\n&quot; +
&nbsp;            &quot;    \&quot;someNumber\&quot;: 42,\n&quot; +
&nbsp;            &quot;    \&quot;someArray\&quot;: [1,2,3],\n&quot; +
&nbsp;            &quot;    \&quot;someNestedObject\&quot;: {\&quot;key\&quot;: \&quot;value\&quot;}\n&quot; +
&nbsp;            &quot; }\n&quot; +
&nbsp;            &quot;}&quot; +
&nbsp;            MARKDOWN_CODE_BLOCK_END +
&nbsp;            &quot;\n\n Single JSON object with timestamp: \n\n&quot; +
&nbsp;            MARKDOWN_CODE_BLOCK_START +
&nbsp;            &quot;{\&quot;ts\&quot;:1634712287000,\&quot;values\&quot;:{\&quot;temperature\&quot;:26, \&quot;humidity\&quot;:87}}&quot; +
&nbsp;            MARKDOWN_CODE_BLOCK_END +
&nbsp;            &quot;\n\n JSON array with timestamps: \n\n&quot; +
&nbsp;            MARKDOWN_CODE_BLOCK_START +
&nbsp;            &quot;[\n{\&quot;ts\&quot;:1634712287000,\&quot;values\&quot;:{\&quot;temperature\&quot;:26, \&quot;humidity\&quot;:87}}, \n{\&quot;ts\&quot;:1634712588000,\&quot;values\&quot;:{\&quot;temperature\&quot;:25, \&quot;humidity\&quot;:88}}\n]&quot; +
&nbsp;            MARKDOWN_CODE_BLOCK_END;
&nbsp;
&nbsp;    private static final String ACCESS_TOKEN_PARAM_DESCRIPTION = &quot;Your device access token.&quot;;
&nbsp;
&nbsp;    @Autowired
&nbsp;    private HttpTransportContext transportContext;
&nbsp;
&nbsp;    @Operation(summary = &quot;Get attributes (getDeviceAttributes)&quot;,
&nbsp;            description = &quot;Returns all attributes that belong to device. &quot;
&nbsp;                    + &quot;Use optional &#39;clientKeys&#39; and/or &#39;sharedKeys&#39; parameter to return specific attributes. &quot;
&nbsp;                    + &quot;\n Example of the result: &quot;
&nbsp;                    + MARKDOWN_CODE_BLOCK_START
&nbsp;                    + ATTRIBUTE_PAYLOAD_EXAMPLE
&nbsp;                    + MARKDOWN_CODE_BLOCK_END
&nbsp;                    + REQUIRE_ACCESS_TOKEN)
&nbsp;    @RequestMapping(value = &quot;/{deviceToken}/attributes&quot;, method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)
&nbsp;    public DeferredResult&lt;ResponseEntity&gt; getDeviceAttributes(
&nbsp;            @Parameter(description = ACCESS_TOKEN_PARAM_DESCRIPTION, required = true, schema = @Schema(defaultValue = &quot;YOUR_DEVICE_ACCESS_TOKEN&quot;))
&nbsp;            @PathVariable(&quot;deviceToken&quot;) String deviceToken,
&nbsp;            @Parameter(description = &quot;Comma separated key names for attribute with client scope&quot;, required = true , schema = @Schema(defaultValue = &quot;state&quot;))
&nbsp;            @RequestParam(value = &quot;clientKeys&quot;, required = false, defaultValue = &quot;&quot;) String clientKeys,
&nbsp;            @Parameter(description = &quot;Comma separated key names for attribute with shared scope&quot;, required = true , schema = @Schema(defaultValue = &quot;configuration&quot;))
&nbsp;            @RequestParam(value = &quot;sharedKeys&quot;, required = false, defaultValue = &quot;&quot;) String sharedKeys) {
<b class="nc">&nbsp;        DeferredResult&lt;ResponseEntity&gt; responseWriter = new DeferredResult&lt;&gt;();</b>
<b class="nc">&nbsp;        transportContext.getTransportService().process(DeviceTransportType.DEFAULT, ValidateDeviceTokenRequestMsg.newBuilder().setToken(deviceToken).build(),</b>
&nbsp;                new DeviceAuthCallback(transportContext, responseWriter, sessionInfo -&gt; {
<b class="nc">&nbsp;                    GetAttributeRequestMsg.Builder request = GetAttributeRequestMsg.newBuilder().setRequestId(0);</b>
<b class="nc">&nbsp;                    List&lt;String&gt; clientKeySet = !StringUtils.isEmpty(clientKeys) ? Arrays.asList(clientKeys.split(&quot;,&quot;)) : null;</b>
<b class="nc">&nbsp;                    List&lt;String&gt; sharedKeySet = !StringUtils.isEmpty(sharedKeys) ? Arrays.asList(sharedKeys.split(&quot;,&quot;)) : null;</b>
<b class="nc">&nbsp;                    if (clientKeySet != null) {</b>
<b class="nc">&nbsp;                        request.addAllClientAttributeNames(clientKeySet);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (sharedKeySet != null) {</b>
<b class="nc">&nbsp;                        request.addAllSharedAttributeNames(sharedKeySet);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    TransportService transportService = transportContext.getTransportService();</b>
<b class="nc">&nbsp;                    transportService.registerSyncSession(sessionInfo,</b>
<b class="nc">&nbsp;                            new HttpSessionListener(responseWriter, transportContext.getTransportService(), sessionInfo),</b>
<b class="nc">&nbsp;                            transportContext.getDefaultTimeout());</b>
<b class="nc">&nbsp;                    transportService.process(sessionInfo, request.build(), new SessionCloseOnErrorCallback(transportService, sessionInfo));</b>
&nbsp;                }));
<b class="nc">&nbsp;        return responseWriter;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Operation(summary = &quot;Post attributes (postDeviceAttributes)&quot;,
&nbsp;            description = &quot;Post client attribute updates on behalf of device. &quot;
&nbsp;                    + &quot;\n Example of the request: &quot;
&nbsp;                    + MARKDOWN_CODE_BLOCK_START
&nbsp;                    + ATTRIBUTE_PAYLOAD_EXAMPLE
&nbsp;                    + MARKDOWN_CODE_BLOCK_END
&nbsp;                    + REQUIRE_ACCESS_TOKEN)
&nbsp;    @RequestMapping(value = &quot;/{deviceToken}/attributes&quot;, method = RequestMethod.POST)
&nbsp;    public DeferredResult&lt;ResponseEntity&gt; postDeviceAttributes(
&nbsp;            @Parameter(description = ACCESS_TOKEN_PARAM_DESCRIPTION, required = true , schema = @Schema(defaultValue = &quot;YOUR_DEVICE_ACCESS_TOKEN&quot;))
&nbsp;            @PathVariable(&quot;deviceToken&quot;) String deviceToken,
&nbsp;            @io.swagger.v3.oas.annotations.parameters.RequestBody(description = &quot;JSON with attribute key-value pairs. See API call description for example.&quot;)
&nbsp;            @RequestBody String json) {
<b class="nc">&nbsp;        DeferredResult&lt;ResponseEntity&gt; responseWriter = new DeferredResult&lt;&gt;();</b>
<b class="nc">&nbsp;        transportContext.getTransportService().process(DeviceTransportType.DEFAULT, ValidateDeviceTokenRequestMsg.newBuilder().setToken(deviceToken).build(),</b>
&nbsp;                new DeviceAuthCallback(transportContext, responseWriter, sessionInfo -&gt; {
<b class="nc">&nbsp;                    TransportService transportService = transportContext.getTransportService();</b>
<b class="nc">&nbsp;                    transportService.process(sessionInfo, JsonConverter.convertToAttributesProto(JsonParser.parseString(json)),</b>
&nbsp;                            new HttpOkCallback(responseWriter));
&nbsp;                }));
<b class="nc">&nbsp;        return responseWriter;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Operation(summary = &quot;Post time series data (postTelemetry)&quot;,
&nbsp;            description = &quot;Post time series data on behalf of device. &quot;
&nbsp;                    + &quot;\n Example of the request: &quot;
&nbsp;                    + TS_PAYLOAD
&nbsp;                    + REQUIRE_ACCESS_TOKEN)
&nbsp;    @RequestMapping(value = &quot;/{deviceToken}/telemetry&quot;, method = RequestMethod.POST)
&nbsp;    public DeferredResult&lt;ResponseEntity&gt; postTelemetry(
&nbsp;            @Parameter(description = ACCESS_TOKEN_PARAM_DESCRIPTION, required = true , schema = @Schema(defaultValue = &quot;YOUR_DEVICE_ACCESS_TOKEN&quot;))
&nbsp;            @PathVariable(&quot;deviceToken&quot;) String deviceToken,
&nbsp;            @RequestBody String json, HttpServletRequest request) {
<b class="nc">&nbsp;        DeferredResult&lt;ResponseEntity&gt; responseWriter = new DeferredResult&lt;ResponseEntity&gt;();</b>
<b class="nc">&nbsp;        transportContext.getTransportService().process(DeviceTransportType.DEFAULT, ValidateDeviceTokenRequestMsg.newBuilder().setToken(deviceToken).build(),</b>
&nbsp;                new DeviceAuthCallback(transportContext, responseWriter, sessionInfo -&gt; {
<b class="nc">&nbsp;                    TransportService transportService = transportContext.getTransportService();</b>
<b class="nc">&nbsp;                    transportService.process(sessionInfo, JsonConverter.convertToTelemetryProto(JsonParser.parseString(json)),</b>
&nbsp;                            new HttpOkCallback(responseWriter));
&nbsp;                }));
<b class="nc">&nbsp;        return responseWriter;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Operation(summary = &quot;Save claiming information (claimDevice)&quot;,
&nbsp;            description = &quot;Saves the information required for user to claim the device. &quot; +
&nbsp;                    &quot;See more info about claiming in the corresponding &#39;Claiming devices&#39; platform documentation.&quot;
&nbsp;                    + &quot;\n Example of the request payload: &quot;
&nbsp;                    + MARKDOWN_CODE_BLOCK_START
&nbsp;                    + &quot;{\&quot;secretKey\&quot;:\&quot;value\&quot;, \&quot;durationMs\&quot;:60000}&quot;
&nbsp;                    + MARKDOWN_CODE_BLOCK_END
&nbsp;                    + &quot;Note: both &#39;secretKey&#39; and &#39;durationMs&#39; is optional parameters. &quot; +
&nbsp;                    &quot;In case the secretKey is not specified, the empty string as a default value is used. In case the durationMs is not specified, the system parameter device.claim.duration is used.\n\n&quot;
&nbsp;                    + REQUIRE_ACCESS_TOKEN)
&nbsp;    @RequestMapping(value = &quot;/{deviceToken}/claim&quot;, method = RequestMethod.POST)
&nbsp;    public DeferredResult&lt;ResponseEntity&gt; claimDevice(
&nbsp;            @Parameter(description = ACCESS_TOKEN_PARAM_DESCRIPTION, required = true , schema = @Schema(defaultValue = &quot;YOUR_DEVICE_ACCESS_TOKEN&quot;))
&nbsp;            @PathVariable(&quot;deviceToken&quot;) String deviceToken,
&nbsp;            @RequestBody(required = false) String json) {
<b class="nc">&nbsp;        DeferredResult&lt;ResponseEntity&gt; responseWriter = new DeferredResult&lt;&gt;();</b>
<b class="nc">&nbsp;        transportContext.getTransportService().process(DeviceTransportType.DEFAULT, ValidateDeviceTokenRequestMsg.newBuilder().setToken(deviceToken).build(),</b>
&nbsp;                new DeviceAuthCallback(transportContext, responseWriter, sessionInfo -&gt; {
<b class="nc">&nbsp;                    TransportService transportService = transportContext.getTransportService();</b>
<b class="nc">&nbsp;                    DeviceId deviceId = new DeviceId(new UUID(sessionInfo.getDeviceIdMSB(), sessionInfo.getDeviceIdLSB()));</b>
<b class="nc">&nbsp;                    transportService.process(sessionInfo, JsonConverter.convertToClaimDeviceProto(deviceId, json),</b>
&nbsp;                            new HttpOkCallback(responseWriter));
&nbsp;                }));
<b class="nc">&nbsp;        return responseWriter;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Operation(summary = &quot;Subscribe to RPC commands (subscribeToCommands) (Deprecated)&quot;,
&nbsp;            description = &quot;Subscribes to RPC commands using http long polling. &quot; +
&nbsp;                    &quot;Deprecated, since long polling is resource and network consuming. &quot; +
&nbsp;                    &quot;Consider using MQTT or CoAP protocol for light-weight real-time updates. \n\n&quot; +
&nbsp;                    REQUIRE_ACCESS_TOKEN)
&nbsp;    @RequestMapping(value = &quot;/{deviceToken}/rpc&quot;, method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)
&nbsp;    public DeferredResult&lt;ResponseEntity&gt; subscribeToCommands(
&nbsp;            @Parameter(description = ACCESS_TOKEN_PARAM_DESCRIPTION, required = true , schema = @Schema(defaultValue = &quot;YOUR_DEVICE_ACCESS_TOKEN&quot;))
&nbsp;            @PathVariable(&quot;deviceToken&quot;) String deviceToken,
&nbsp;            @Parameter(description = &quot;Optional timeout of the long poll. Typically less then 60 seconds, since limited on the server side.&quot;)
&nbsp;            @RequestParam(value = &quot;timeout&quot;, required = false, defaultValue = &quot;0&quot;) long timeout) {
<b class="nc">&nbsp;        DeferredResult&lt;ResponseEntity&gt; responseWriter = new DeferredResult&lt;&gt;();</b>
<b class="nc">&nbsp;        transportContext.getTransportService().process(DeviceTransportType.DEFAULT, ValidateDeviceTokenRequestMsg.newBuilder().setToken(deviceToken).build(),</b>
&nbsp;                new DeviceAuthCallback(transportContext, responseWriter, sessionInfo -&gt; {
<b class="nc">&nbsp;                    TransportService transportService = transportContext.getTransportService();</b>
<b class="nc">&nbsp;                    transportService.registerSyncSession(sessionInfo,</b>
<b class="nc">&nbsp;                            new HttpSessionListener(responseWriter, transportContext.getTransportService(), sessionInfo),</b>
<b class="nc">&nbsp;                            timeout == 0 ? transportContext.getDefaultTimeout() : timeout);</b>
<b class="nc">&nbsp;                    transportService.process(sessionInfo, SubscribeToRPCMsg.getDefaultInstance(),</b>
&nbsp;                            new SessionCloseOnErrorCallback(transportService, sessionInfo));
&nbsp;
&nbsp;                }));
<b class="nc">&nbsp;        return responseWriter;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Operation(summary = &quot;Reply to RPC commands (replyToCommand)&quot;,
&nbsp;            description = &quot;Replies to server originated RPC command identified by &#39;requestId&#39; parameter. The response is arbitrary JSON.\n\n&quot; +
&nbsp;                    REQUIRE_ACCESS_TOKEN)
&nbsp;    @ApiResponses(value = {
&nbsp;            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;RPC reply to command request was sent to Core.&quot;),
&nbsp;            @ApiResponse(responseCode = &quot;400&quot;, description = &quot;Invalid structure of the request.&quot;),
&nbsp;            @ApiResponse(responseCode = &quot;413&quot;, description = &quot;Request payload is too large.&quot;),
&nbsp;    })
&nbsp;    @RequestMapping(value = &quot;/{deviceToken}/rpc/{requestId}&quot;, method = RequestMethod.POST)
&nbsp;    public DeferredResult&lt;ResponseEntity&gt; replyToCommand(
&nbsp;            @Parameter(description = ACCESS_TOKEN_PARAM_DESCRIPTION, required = true , schema = @Schema(defaultValue = &quot;YOUR_DEVICE_ACCESS_TOKEN&quot;))
&nbsp;            @PathVariable(&quot;deviceToken&quot;) String deviceToken,
&nbsp;            @Parameter(description = &quot;RPC request id from the incoming RPC request&quot;, required = true , schema = @Schema(defaultValue = &quot;123&quot;))
&nbsp;            @PathVariable(&quot;requestId&quot;) Integer requestId,
&nbsp;            @io.swagger.v3.oas.annotations.parameters.RequestBody(description = &quot;Reply to the RPC request, JSON. For example: {\&quot;status\&quot;:\&quot;success\&quot;}&quot;, required = true)
&nbsp;            @RequestBody String json, HttpServletRequest httpServletRequest) {
<b class="nc">&nbsp;        DeferredResult&lt;ResponseEntity&gt; responseWriter = new DeferredResult&lt;ResponseEntity&gt;();</b>
<b class="nc">&nbsp;        transportContext.getTransportService().process(DeviceTransportType.DEFAULT, ValidateDeviceTokenRequestMsg.newBuilder().setToken(deviceToken).build(),</b>
&nbsp;                new DeviceAuthCallback(transportContext, responseWriter, sessionInfo -&gt; {
<b class="nc">&nbsp;                    TransportService transportService = transportContext.getTransportService();</b>
<b class="nc">&nbsp;                    transportService.process(sessionInfo, ToDeviceRpcResponseMsg.newBuilder().setRequestId(requestId).setPayload(json).build(), new HttpOkCallback(responseWriter));</b>
&nbsp;                }));
<b class="nc">&nbsp;        return responseWriter;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Operation(summary = &quot;Send the RPC command (postRpcRequest)&quot;,
&nbsp;            description = &quot;Send the RPC request to server. The request payload is a JSON document that contains &#39;method&#39; and &#39;params&#39;. For example:&quot; +
&nbsp;                    MARKDOWN_CODE_BLOCK_START +
&nbsp;                    &quot;{\&quot;method\&quot;: \&quot;sumOnServer\&quot;, \&quot;params\&quot;:{\&quot;a\&quot;:2, \&quot;b\&quot;:2}}&quot; +
&nbsp;                    MARKDOWN_CODE_BLOCK_END +
&nbsp;                    &quot;The response contains arbitrary JSON with the RPC reply. For example: &quot; +
&nbsp;                    MARKDOWN_CODE_BLOCK_START +
&nbsp;                    &quot;{\&quot;result\&quot;: 4}&quot; +
&nbsp;                    MARKDOWN_CODE_BLOCK_END +
&nbsp;                    REQUIRE_ACCESS_TOKEN)
&nbsp;    @ApiResponses(value = {
&nbsp;            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;RPC request to server was sent to Rule Engine.&quot;),
&nbsp;            @ApiResponse(responseCode = &quot;400&quot;, description = &quot;Invalid structure of the request.&quot;),
&nbsp;            @ApiResponse(responseCode = &quot;413&quot;, description = &quot;Request payload too large.&quot;),
&nbsp;    })
&nbsp;    @RequestMapping(value = &quot;/{deviceToken}/rpc&quot;, method = RequestMethod.POST)
&nbsp;    public DeferredResult&lt;ResponseEntity&gt; postRpcRequest(
&nbsp;            @Parameter(description = ACCESS_TOKEN_PARAM_DESCRIPTION, required = true , schema = @Schema(defaultValue = &quot;YOUR_DEVICE_ACCESS_TOKEN&quot;))
&nbsp;            @PathVariable(&quot;deviceToken&quot;) String deviceToken,
&nbsp;            @io.swagger.v3.oas.annotations.parameters.RequestBody(description = &quot;The RPC request JSON&quot;, required = true)
&nbsp;            @RequestBody String json, HttpServletRequest httpServletRequest) {
<b class="nc">&nbsp;        DeferredResult&lt;ResponseEntity&gt; responseWriter = new DeferredResult&lt;ResponseEntity&gt;();</b>
<b class="nc">&nbsp;        transportContext.getTransportService().process(DeviceTransportType.DEFAULT, ValidateDeviceTokenRequestMsg.newBuilder().setToken(deviceToken).build(),</b>
&nbsp;                new DeviceAuthCallback(transportContext, responseWriter, sessionInfo -&gt; {
<b class="nc">&nbsp;                    JsonObject request = JsonParser.parseString(json).getAsJsonObject();</b>
<b class="nc">&nbsp;                    TransportService transportService = transportContext.getTransportService();</b>
<b class="nc">&nbsp;                    transportService.registerSyncSession(sessionInfo,</b>
<b class="nc">&nbsp;                            new HttpSessionListener(responseWriter, transportContext.getTransportService(), sessionInfo),</b>
<b class="nc">&nbsp;                            transportContext.getDefaultTimeout());</b>
<b class="nc">&nbsp;                    transportService.process(sessionInfo, ToServerRpcRequestMsg.newBuilder().setRequestId(0)</b>
<b class="nc">&nbsp;                                    .setMethodName(request.get(&quot;method&quot;).getAsString())</b>
<b class="nc">&nbsp;                                    .setParams(request.get(&quot;params&quot;).toString()).build(),</b>
&nbsp;                            new SessionCloseOnErrorCallback(transportService, sessionInfo));
&nbsp;                }));
<b class="nc">&nbsp;        return responseWriter;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Operation(summary = &quot;Subscribe to attribute updates (subscribeToAttributes) (Deprecated)&quot;,
&nbsp;            description = &quot;Subscribes to client and shared scope attribute updates using http long polling. &quot; +
&nbsp;                    &quot;Deprecated, since long polling is resource and network consuming. &quot; +
&nbsp;                    &quot;Consider using MQTT or CoAP protocol for light-weight real-time updates. \n\n&quot; +
&nbsp;                    REQUIRE_ACCESS_TOKEN)
&nbsp;    @RequestMapping(value = &quot;/{deviceToken}/attributes/updates&quot;, method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)
&nbsp;    public DeferredResult&lt;ResponseEntity&gt; subscribeToAttributes(
&nbsp;            @Parameter(description = ACCESS_TOKEN_PARAM_DESCRIPTION, required = true , schema = @Schema(defaultValue = &quot;YOUR_DEVICE_ACCESS_TOKEN&quot;))
&nbsp;            @PathVariable(&quot;deviceToken&quot;) String deviceToken,
&nbsp;            @Parameter(description = &quot;Optional timeout of the long poll. Typically less then 60 seconds, since limited on the server side.&quot;)
&nbsp;            @RequestParam(value = &quot;timeout&quot;, required = false, defaultValue = &quot;0&quot;) long timeout) {
<b class="nc">&nbsp;        DeferredResult&lt;ResponseEntity&gt; responseWriter = new DeferredResult&lt;&gt;();</b>
<b class="nc">&nbsp;        transportContext.getTransportService().process(DeviceTransportType.DEFAULT, ValidateDeviceTokenRequestMsg.newBuilder().setToken(deviceToken).build(),</b>
&nbsp;                new DeviceAuthCallback(transportContext, responseWriter, sessionInfo -&gt; {
<b class="nc">&nbsp;                    TransportService transportService = transportContext.getTransportService();</b>
<b class="nc">&nbsp;                    transportService.registerSyncSession(sessionInfo,</b>
<b class="nc">&nbsp;                            new HttpSessionListener(responseWriter, transportContext.getTransportService(), sessionInfo),</b>
<b class="nc">&nbsp;                            timeout == 0 ? transportContext.getDefaultTimeout() : timeout);</b>
<b class="nc">&nbsp;                    transportService.process(sessionInfo, SubscribeToAttributeUpdatesMsg.getDefaultInstance(),</b>
&nbsp;                            new SessionCloseOnErrorCallback(transportService, sessionInfo));
&nbsp;
&nbsp;                }));
<b class="nc">&nbsp;        return responseWriter;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Operation(summary = &quot;Get Device Firmware (getFirmware)&quot;,
&nbsp;            description = &quot;Downloads the current firmware package.&quot; +
&nbsp;                    &quot;When the platform initiates firmware update, &quot; +
&nbsp;                    &quot;it informs the device by updating the &#39;fw_title&#39;, &#39;fw_version&#39;, &#39;fw_checksum&#39; and &#39;fw_checksum_algorithm&#39; shared attributes.&quot; +
&nbsp;                    &quot;The &#39;fw_title&#39; and &#39;fw_version&#39; parameters must be supplied in this request to double-check &quot; +
&nbsp;                    &quot;that the firmware that device is downloading matches the firmware it expects to download. &quot; +
&nbsp;                    &quot;This is important, since the administrator may change the firmware assignment while device is downloading the firmware. \n\n&quot; +
&nbsp;                    &quot;Optional &#39;chunk&#39; and &#39;size&#39; parameters may be used to download the firmware in chunks. &quot; +
&nbsp;                    &quot;For example, device may request first 16 KB of firmware using &#39;chunk&#39;=0 and &#39;size&#39;=16384. &quot; +
&nbsp;                    &quot;Next 16KB using &#39;chunk&#39;=1 and &#39;size&#39;=16384. The last chunk should have less bytes then requested using &#39;size&#39; parameter. \n\n&quot; +
&nbsp;                    REQUIRE_ACCESS_TOKEN)
&nbsp;    @RequestMapping(value = &quot;/{deviceToken}/firmware&quot;, method = RequestMethod.GET)
&nbsp;    public DeferredResult&lt;ResponseEntity&gt; getFirmware(
&nbsp;            @Parameter(description = ACCESS_TOKEN_PARAM_DESCRIPTION, required = true , schema = @Schema(defaultValue = &quot;YOUR_DEVICE_ACCESS_TOKEN&quot;))
&nbsp;            @PathVariable(&quot;deviceToken&quot;) String deviceToken,
&nbsp;            @Parameter(description = &quot;Title of the firmware, corresponds to the value of &#39;fw_title&#39; attribute.&quot;, required = true)
&nbsp;            @RequestParam(value = &quot;title&quot;) String title,
&nbsp;            @Parameter(description = &quot;Version of the firmware, corresponds to the value of &#39;fw_version&#39; attribute.&quot;, required = true)
&nbsp;            @RequestParam(value = &quot;version&quot;) String version,
&nbsp;            @Parameter(description = &quot;Size of the chunk. Optional. Omit to download the entire file without chunks.&quot;)
&nbsp;            @RequestParam(value = &quot;size&quot;, required = false, defaultValue = &quot;0&quot;) int size,
&nbsp;            @Parameter(description = &quot;Index of the chunk. Optional. Omit to download the entire file without chunks.&quot;)
&nbsp;            @RequestParam(value = &quot;chunk&quot;, required = false, defaultValue = &quot;0&quot;) int chunk) {
<b class="nc">&nbsp;        return getOtaPackageCallback(deviceToken, title, version, size, chunk, OtaPackageType.FIRMWARE);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Operation(summary = &quot;Get Device Software (getSoftware)&quot;,
&nbsp;            description = &quot;Downloads the current software package.&quot; +
&nbsp;                    &quot;When the platform initiates software update, &quot; +
&nbsp;                    &quot;it informs the device by updating the &#39;sw_title&#39;, &#39;sw_version&#39;, &#39;sw_checksum&#39; and &#39;sw_checksum_algorithm&#39; shared attributes.&quot; +
&nbsp;                    &quot;The &#39;sw_title&#39; and &#39;sw_version&#39; parameters must be supplied in this request to double-check &quot; +
&nbsp;                    &quot;that the software that device is downloading matches the software it expects to download. &quot; +
&nbsp;                    &quot;This is important, since the administrator may change the software assignment while device is downloading the software. \n\n&quot; +
&nbsp;                    &quot;Optional &#39;chunk&#39; and &#39;size&#39; parameters may be used to download the software in chunks. &quot; +
&nbsp;                    &quot;For example, device may request first 16 KB of software using &#39;chunk&#39;=0 and &#39;size&#39;=16384. &quot; +
&nbsp;                    &quot;Next 16KB using &#39;chunk&#39;=1 and &#39;size&#39;=16384. The last chunk should have less bytes then requested using &#39;size&#39; parameter. \n\n&quot; +
&nbsp;                    REQUIRE_ACCESS_TOKEN)
&nbsp;    @RequestMapping(value = &quot;/{deviceToken}/software&quot;, method = RequestMethod.GET)
&nbsp;    public DeferredResult&lt;ResponseEntity&gt; getSoftware(
&nbsp;            @Parameter(description = ACCESS_TOKEN_PARAM_DESCRIPTION, required = true , schema = @Schema(defaultValue = &quot;YOUR_DEVICE_ACCESS_TOKEN&quot;))
&nbsp;            @PathVariable(&quot;deviceToken&quot;) String deviceToken,
&nbsp;            @Parameter(description = &quot;Title of the software, corresponds to the value of &#39;sw_title&#39; attribute.&quot;, required = true)
&nbsp;            @RequestParam(value = &quot;title&quot;) String title,
&nbsp;            @Parameter(description = &quot;Version of the software, corresponds to the value of &#39;sw_version&#39; attribute.&quot;, required = true)
&nbsp;            @RequestParam(value = &quot;version&quot;) String version,
&nbsp;            @Parameter(description = &quot;Size of the chunk. Optional. Omit to download the entire file without using  chunks.&quot;)
&nbsp;            @RequestParam(value = &quot;size&quot;, required = false, defaultValue = &quot;0&quot;) int size,
&nbsp;            @Parameter(description = &quot;Index of the chunk. Optional. Omit to download the entire file without using chunks.&quot;)
&nbsp;            @RequestParam(value = &quot;chunk&quot;, required = false, defaultValue = &quot;0&quot;) int chunk) {
<b class="nc">&nbsp;        return getOtaPackageCallback(deviceToken, title, version, size, chunk, OtaPackageType.SOFTWARE);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Operation(summary = &quot;Provision new device (provisionDevice)&quot;,
&nbsp;            description = &quot;Exchange the provision request to the device credentials. &quot; +
&nbsp;                    &quot;See more info about provisioning in the corresponding &#39;Device provisioning&#39; platform documentation.&quot; +
&nbsp;                    &quot;Requires valid JSON request with the following format: &quot; +
&nbsp;                    MARKDOWN_CODE_BLOCK_START +
&nbsp;                    &quot;{\n&quot; +
&nbsp;                    &quot;  \&quot;deviceName\&quot;: \&quot;NEW_DEVICE_NAME\&quot;,\n&quot; +
&nbsp;                    &quot;  \&quot;provisionDeviceKey\&quot;: \&quot;u7piawkboq8v32dmcmpp\&quot;,\n&quot; +
&nbsp;                    &quot;  \&quot;provisionDeviceSecret\&quot;: \&quot;jpmwdn8ptlswmf4m29bw\&quot;\n&quot; +
&nbsp;                    &quot;}&quot; +
&nbsp;                    MARKDOWN_CODE_BLOCK_END +
&nbsp;                    &quot;Where &#39;deviceName&#39; is the name of enw or existing device which depends on the provisioning strategy. &quot; +
&nbsp;                    &quot;The &#39;provisionDeviceKey&#39; and &#39;provisionDeviceSecret&#39; matches info configured in one of the existing device profiles. &quot; +
&nbsp;                    &quot;The result of the successful call is the JSON object that contains new credentials:&quot; +
&nbsp;                    MARKDOWN_CODE_BLOCK_START + &quot;{\n&quot; +
&nbsp;                    &quot;  \&quot;credentialsType\&quot;:\&quot;ACCESS_TOKEN\&quot;,\n&quot; +
&nbsp;                    &quot;  \&quot;credentialsValue\&quot;:\&quot;DEVICE_ACCESS_TOKEN\&quot;,\n&quot; +
&nbsp;                    &quot;  \&quot;status\&quot;:\&quot;SUCCESS\&quot;\n&quot; +
&nbsp;                    &quot;}&quot; + MARKDOWN_CODE_BLOCK_END)
&nbsp;    @RequestMapping(value = &quot;/provision&quot;, method = RequestMethod.POST)
&nbsp;    public DeferredResult&lt;ResponseEntity&gt; provisionDevice(
&nbsp;            @io.swagger.v3.oas.annotations.parameters.RequestBody(description = &quot;JSON with provision request. See API call description for example.&quot;)
&nbsp;            @RequestBody String json) {
<b class="nc">&nbsp;        DeferredResult&lt;ResponseEntity&gt; responseWriter = new DeferredResult&lt;&gt;();</b>
<b class="nc">&nbsp;        transportContext.getTransportService().process(JsonConverter.convertToProvisionRequestMsg(json),</b>
&nbsp;                new DeviceProvisionCallback(responseWriter));
<b class="nc">&nbsp;        return responseWriter;</b>
&nbsp;    }
&nbsp;
&nbsp;    private DeferredResult&lt;ResponseEntity&gt; getOtaPackageCallback(String deviceToken, String title, String version, int size, int chunk, OtaPackageType firmwareType) {
<b class="nc">&nbsp;        DeferredResult&lt;ResponseEntity&gt; responseWriter = new DeferredResult&lt;&gt;();</b>
<b class="nc">&nbsp;        transportContext.getTransportService().process(DeviceTransportType.DEFAULT, ValidateDeviceTokenRequestMsg.newBuilder().setToken(deviceToken).build(),</b>
&nbsp;                new DeviceAuthCallback(transportContext, responseWriter, sessionInfo -&gt; {
<b class="nc">&nbsp;                    TransportProtos.GetOtaPackageRequestMsg requestMsg = TransportProtos.GetOtaPackageRequestMsg.newBuilder()</b>
<b class="nc">&nbsp;                            .setTenantIdMSB(sessionInfo.getTenantIdMSB())</b>
<b class="nc">&nbsp;                            .setTenantIdLSB(sessionInfo.getTenantIdLSB())</b>
<b class="nc">&nbsp;                            .setDeviceIdMSB(sessionInfo.getDeviceIdMSB())</b>
<b class="nc">&nbsp;                            .setDeviceIdLSB(sessionInfo.getDeviceIdLSB())</b>
<b class="nc">&nbsp;                            .setType(firmwareType.name()).build();</b>
<b class="nc">&nbsp;                    transportContext.getTransportService().process(sessionInfo, requestMsg, new GetOtaPackageCallback(transportContext, responseWriter, title, version, size, chunk));</b>
&nbsp;                }));
<b class="nc">&nbsp;        return responseWriter;</b>
&nbsp;    }
&nbsp;
&nbsp;    @RequiredArgsConstructor
&nbsp;    static class DeviceAuthCallback implements TransportServiceCallback&lt;ValidateDeviceCredentialsResponse&gt; {
&nbsp;        private final TransportContext transportContext;
&nbsp;        private final DeferredResult&lt;ResponseEntity&gt; responseWriter;
&nbsp;        private final Consumer&lt;SessionInfoProto&gt; onSuccess;
&nbsp;
&nbsp;        @Override
&nbsp;        public void onSuccess(ValidateDeviceCredentialsResponse msg) {
<b class="nc">&nbsp;            if (msg.hasDeviceInfo()) {</b>
<b class="nc">&nbsp;                onSuccess.accept(SessionInfoCreator.create(msg, transportContext, UUID.randomUUID()));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                responseWriter.setResult(new ResponseEntity&lt;&gt;(HttpStatus.UNAUTHORIZED));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onError(Throwable e) {
<b class="nc">&nbsp;            String body = null;</b>
<b class="nc">&nbsp;            if (e instanceof HttpMessageNotReadableException || e instanceof JsonParseException) {</b>
<b class="nc">&nbsp;                body = e.getMessage();</b>
<b class="nc">&nbsp;                log.debug(&quot;Failed to process request in DeviceAuthCallback: {}&quot;, body);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                log.warn(&quot;Failed to process request in DeviceAuthCallback&quot;, e);</b>
&nbsp;            }
<b class="nc">&nbsp;            responseWriter.setResult(new ResponseEntity&lt;&gt;(body, HttpStatus.INTERNAL_SERVER_ERROR));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @RequiredArgsConstructor
&nbsp;    static class DeviceProvisionCallback implements TransportServiceCallback&lt;ProvisionDeviceResponseMsg&gt; {
&nbsp;        private final DeferredResult&lt;ResponseEntity&gt; responseWriter;
&nbsp;
&nbsp;        @Override
&nbsp;        public void onSuccess(ProvisionDeviceResponseMsg msg) {
<b class="nc">&nbsp;            responseWriter.setResult(new ResponseEntity&lt;&gt;(JsonConverter.toJson(msg).toString(), HttpStatus.OK));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onError(Throwable e) {
<b class="nc">&nbsp;            String body = null;</b>
<b class="nc">&nbsp;            if (e instanceof HttpMessageNotReadableException || e instanceof JsonParseException) {</b>
<b class="nc">&nbsp;                body = e.getMessage();</b>
<b class="nc">&nbsp;                log.debug(&quot;Failed to process request in DeviceProvisionCallback: {}&quot;, body);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                log.warn(&quot;Failed to process request in DeviceProvisionCallback&quot;, e);</b>
&nbsp;            }
<b class="nc">&nbsp;            responseWriter.setResult(new ResponseEntity&lt;&gt;(body, HttpStatus.INTERNAL_SERVER_ERROR));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @RequiredArgsConstructor
&nbsp;    static class GetOtaPackageCallback implements TransportServiceCallback&lt;GetOtaPackageResponseMsg&gt; {
&nbsp;        private final TransportContext transportContext;
&nbsp;        private final DeferredResult&lt;ResponseEntity&gt; responseWriter;
&nbsp;        private final String title;
&nbsp;        private final String version;
&nbsp;        private final int chunkSize;
&nbsp;        private final int chunk;
&nbsp;
&nbsp;        @Override
&nbsp;        public void onSuccess(TransportProtos.GetOtaPackageResponseMsg otaPackageResponseMsg) {
<b class="nc">&nbsp;            if (!TransportProtos.ResponseStatus.SUCCESS.equals(otaPackageResponseMsg.getResponseStatus())) {</b>
<b class="nc">&nbsp;                responseWriter.setResult(new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND));</b>
<b class="nc">&nbsp;            } else if (title.equals(otaPackageResponseMsg.getTitle()) &amp;&amp; version.equals(otaPackageResponseMsg.getVersion())) {</b>
<b class="nc">&nbsp;                String otaPackageId = new UUID(otaPackageResponseMsg.getOtaPackageIdMSB(), otaPackageResponseMsg.getOtaPackageIdLSB()).toString();</b>
<b class="nc">&nbsp;                ByteArrayResource resource = new ByteArrayResource(transportContext.getOtaPackageDataCache().get(otaPackageId, chunkSize, chunk));</b>
<b class="nc">&nbsp;                ResponseEntity&lt;ByteArrayResource&gt; response = ResponseEntity.ok()</b>
<b class="nc">&nbsp;                        .header(HttpHeaders.CONTENT_DISPOSITION, &quot;attachment;filename=&quot; + otaPackageResponseMsg.getFileName())</b>
<b class="nc">&nbsp;                        .header(&quot;x-filename&quot;, otaPackageResponseMsg.getFileName())</b>
<b class="nc">&nbsp;                        .contentLength(resource.contentLength())</b>
<b class="nc">&nbsp;                        .contentType(parseMediaType(otaPackageResponseMsg.getContentType()))</b>
<b class="nc">&nbsp;                        .body(resource);</b>
<b class="nc">&nbsp;                responseWriter.setResult(response);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                responseWriter.setResult(new ResponseEntity&lt;&gt;(HttpStatus.BAD_REQUEST));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onError(Throwable e) {
<b class="nc">&nbsp;            String body = null;</b>
<b class="nc">&nbsp;            if (e instanceof HttpMessageNotReadableException || e instanceof JsonParseException) {</b>
<b class="nc">&nbsp;                body = e.getMessage();</b>
<b class="nc">&nbsp;                log.debug(&quot;Failed to process request in GetOtaPackageCallback: {}&quot;, body);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                log.warn(&quot;Failed to process request in GetOtaPackageCallback&quot;, e);</b>
&nbsp;            }
<b class="nc">&nbsp;            responseWriter.setResult(new ResponseEntity&lt;&gt;(body, HttpStatus.INTERNAL_SERVER_ERROR));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class SessionCloseOnErrorCallback implements TransportServiceCallback&lt;Void&gt; {
&nbsp;        private final TransportService transportService;
&nbsp;        private final SessionInfoProto sessionInfo;
&nbsp;
<b class="nc">&nbsp;        SessionCloseOnErrorCallback(TransportService transportService, SessionInfoProto sessionInfo) {</b>
<b class="nc">&nbsp;            this.transportService = transportService;</b>
<b class="nc">&nbsp;            this.sessionInfo = sessionInfo;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onSuccess(Void msg) {
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void onError(Throwable e) {
<b class="nc">&nbsp;            transportService.deregisterSession(sessionInfo);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class HttpOkCallback implements TransportServiceCallback&lt;Void&gt; {
&nbsp;        private final DeferredResult&lt;ResponseEntity&gt; responseWriter;
&nbsp;
<b class="nc">&nbsp;        public HttpOkCallback(DeferredResult&lt;ResponseEntity&gt; responseWriter) {</b>
<b class="nc">&nbsp;            this.responseWriter = responseWriter;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onSuccess(Void msg) {
<b class="nc">&nbsp;            responseWriter.setResult(new ResponseEntity&lt;&gt;(HttpStatus.OK));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onError(Throwable e) {
<b class="nc">&nbsp;            responseWriter.setResult(new ResponseEntity&lt;&gt;(HttpStatus.INTERNAL_SERVER_ERROR));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @RequiredArgsConstructor
&nbsp;    private static class HttpSessionListener implements SessionMsgListener {
&nbsp;
&nbsp;        private final DeferredResult&lt;ResponseEntity&gt; responseWriter;
&nbsp;        private final TransportService transportService;
&nbsp;        private final SessionInfoProto sessionInfo;
&nbsp;
&nbsp;        @Override
&nbsp;        public void onGetAttributesResponse(GetAttributeResponseMsg msg) {
<b class="nc">&nbsp;            responseWriter.setResult(new ResponseEntity&lt;&gt;(JsonConverter.toJson(msg).toString(), HttpStatus.OK));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onAttributeUpdate(UUID sessionId, AttributeUpdateNotificationMsg msg) {
<b class="nc">&nbsp;            log.trace(&quot;[{}] Received attributes update notification to device&quot;, sessionId);</b>
<b class="nc">&nbsp;            responseWriter.setResult(new ResponseEntity&lt;&gt;(JsonConverter.toJson(msg).toString(), HttpStatus.OK));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onRemoteSessionCloseCommand(UUID sessionId, SessionCloseNotificationProto sessionCloseNotification) {
<b class="nc">&nbsp;            log.trace(&quot;[{}] Received the remote command to close the session: {}&quot;, sessionId, sessionCloseNotification.getMessage());</b>
<b class="nc">&nbsp;            responseWriter.setResult(new ResponseEntity&lt;&gt;(HttpStatus.REQUEST_TIMEOUT));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onToDeviceRpcRequest(UUID sessionId, ToDeviceRpcRequestMsg msg) {
<b class="nc">&nbsp;            log.trace(&quot;[{}] Received RPC command to device&quot;, sessionId);</b>
<b class="nc">&nbsp;            responseWriter.setResult(new ResponseEntity&lt;&gt;(JsonConverter.toJson(msg, true).toString(), HttpStatus.OK));</b>
<b class="nc">&nbsp;            transportService.process(sessionInfo, msg, RpcStatus.DELIVERED, TransportServiceCallback.EMPTY);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onToServerRpcResponse(ToServerRpcResponseMsg msg) {
<b class="nc">&nbsp;            responseWriter.setResult(new ResponseEntity&lt;&gt;(JsonConverter.toJson(msg).toString(), HttpStatus.OK));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onDeviceDeleted(DeviceId deviceId) {
<b class="nc">&nbsp;            UUID sessionId = new UUID(sessionInfo.getSessionIdMSB(), sessionInfo.getSessionIdLSB());</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}] Received device deleted notification for device with id: {}&quot;,sessionId, deviceId);</b>
<b class="nc">&nbsp;            responseWriter.setResult(new ResponseEntity&lt;&gt;(&quot;Device was deleted!&quot;, HttpStatus.FORBIDDEN));</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    private static MediaType parseMediaType(String contentType) {
&nbsp;        try {
<b class="nc">&nbsp;            return MediaType.parseMediaType(contentType);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            return MediaType.APPLICATION_OCTET_STREAM;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getName() {
<b class="nc">&nbsp;        return DataConstants.HTTP_TRANSPORT_NAME;</b>
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
