<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > AbstractGatewaySessionHandler</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.server.transport.mqtt.session</a>
</div>

<h1>Coverage Summary for Class: AbstractGatewaySessionHandler (org.thingsboard.server.transport.mqtt.session)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AbstractGatewaySessionHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/85)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/84)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/348)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AbstractGatewaySessionHandler$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractGatewaySessionHandler$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractGatewaySessionHandler$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/23)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/94)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/100)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/392)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.server.transport.mqtt.session;
&nbsp;
&nbsp;import com.fasterxml.jackson.databind.JsonNode;
&nbsp;import com.google.common.util.concurrent.FutureCallback;
&nbsp;import com.google.common.util.concurrent.Futures;
&nbsp;import com.google.common.util.concurrent.ListenableFuture;
&nbsp;import com.google.common.util.concurrent.MoreExecutors;
&nbsp;import com.google.common.util.concurrent.SettableFuture;
&nbsp;import com.google.gson.JsonArray;
&nbsp;import com.google.gson.JsonElement;
&nbsp;import com.google.gson.JsonNull;
&nbsp;import com.google.gson.JsonObject;
&nbsp;import com.google.gson.JsonSyntaxException;
&nbsp;import com.google.protobuf.InvalidProtocolBufferException;
&nbsp;import com.google.protobuf.ProtocolStringList;
&nbsp;import io.netty.buffer.ByteBuf;
&nbsp;import io.netty.channel.ChannelFuture;
&nbsp;import io.netty.channel.ChannelHandlerContext;
&nbsp;import io.netty.handler.codec.mqtt.MqttMessage;
&nbsp;import io.netty.handler.codec.mqtt.MqttPublishMessage;
&nbsp;import io.netty.handler.codec.mqtt.MqttReasonCodes;
&nbsp;import io.netty.handler.codec.mqtt.MqttVersion;
&nbsp;import lombok.Getter;
&nbsp;import lombok.Setter;
&nbsp;import lombok.SneakyThrows;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.springframework.util.CollectionUtils;
&nbsp;import org.springframework.util.ConcurrentReferenceHashMap;
&nbsp;import org.thingsboard.common.util.DonAsynchron;
&nbsp;import org.thingsboard.server.common.adaptor.AdaptorException;
&nbsp;import org.thingsboard.server.common.adaptor.JsonConverter;
&nbsp;import org.thingsboard.server.common.adaptor.ProtoConverter;
&nbsp;import org.thingsboard.server.common.data.DataConstants;
&nbsp;import org.thingsboard.server.common.data.Device;
&nbsp;import org.thingsboard.server.common.data.DeviceProfile;
&nbsp;import org.thingsboard.server.common.data.StringUtils;
&nbsp;import org.thingsboard.server.common.data.id.DeviceId;
&nbsp;import org.thingsboard.server.common.data.util.TbPair;
&nbsp;import org.thingsboard.server.common.msg.gateway.metrics.GatewayMetadata;
&nbsp;import org.thingsboard.server.common.msg.tools.TbRateLimitsException;
&nbsp;import org.thingsboard.server.common.transport.TransportService;
&nbsp;import org.thingsboard.server.common.transport.TransportServiceCallback;
&nbsp;import org.thingsboard.server.common.transport.auth.GetOrCreateDeviceFromGatewayResponse;
&nbsp;import org.thingsboard.server.common.transport.auth.TransportDeviceInfo;
&nbsp;import org.thingsboard.server.gen.transport.TransportApiProtos;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.GetOrCreateDeviceFromGatewayRequestMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.SessionInfoProto;
&nbsp;import org.thingsboard.server.transport.mqtt.MqttTransportContext;
&nbsp;import org.thingsboard.server.transport.mqtt.MqttTransportHandler;
&nbsp;import org.thingsboard.server.transport.mqtt.adaptors.JsonMqttAdaptor;
&nbsp;import org.thingsboard.server.transport.mqtt.adaptors.MqttTransportAdaptor;
&nbsp;import org.thingsboard.server.transport.mqtt.adaptors.ProtoMqttAdaptor;
&nbsp;import org.thingsboard.server.transport.mqtt.gateway.GatewayMetricsService;
&nbsp;import org.thingsboard.server.transport.mqtt.util.sparkplug.SparkplugConnectionState;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Date;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Optional;
&nbsp;import java.util.Set;
&nbsp;import java.util.UUID;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.concurrent.ConcurrentMap;
&nbsp;import java.util.concurrent.atomic.AtomicBoolean;
&nbsp;import java.util.concurrent.atomic.AtomicInteger;
&nbsp;import java.util.concurrent.locks.Lock;
&nbsp;import java.util.concurrent.locks.ReentrantLock;
&nbsp;import java.util.function.Consumer;
&nbsp;
&nbsp;import static org.springframework.util.ConcurrentReferenceHashMap.ReferenceType;
&nbsp;import static org.thingsboard.server.common.data.DataConstants.DEFAULT_DEVICE_TYPE;
&nbsp;import static org.thingsboard.server.common.transport.service.DefaultTransportService.SESSION_EVENT_MSG_CLOSED;
&nbsp;import static org.thingsboard.server.common.transport.service.DefaultTransportService.SESSION_EVENT_MSG_OPEN;
&nbsp;import static org.thingsboard.server.common.transport.service.DefaultTransportService.SUBSCRIBE_TO_ATTRIBUTE_UPDATES_ASYNC_MSG;
&nbsp;import static org.thingsboard.server.common.transport.service.DefaultTransportService.SUBSCRIBE_TO_RPC_ASYNC_MSG;
&nbsp;import static org.thingsboard.server.transport.mqtt.util.sparkplug.SparkplugConnectionState.OFFLINE;
&nbsp;import static org.thingsboard.server.transport.mqtt.util.sparkplug.SparkplugMessageType.STATE;
&nbsp;import static org.thingsboard.server.transport.mqtt.util.sparkplug.SparkplugMessageType.messageName;
&nbsp;
<b class="nc">&nbsp;@Slf4j</b>
&nbsp;public abstract class AbstractGatewaySessionHandler&lt;T extends AbstractGatewayDeviceSessionContext&gt; {
&nbsp;
&nbsp;    private static final String CAN_T_PARSE_VALUE = &quot;Can&#39;t parse value: &quot;;
&nbsp;    private static final String DEVICE_PROPERTY = &quot;device&quot;;
&nbsp;    public static final String TELEMETRY = &quot;telemetry&quot;;
&nbsp;    public static final String CLAIMING = &quot;claiming&quot;;
&nbsp;    public static final String ATTRIBUTE = &quot;attribute&quot;;
&nbsp;    public static final String RPC_RESPONSE = &quot;Rpc response&quot;;
&nbsp;    public static final String CONNECT = &quot;connect&quot;;
&nbsp;    public static final String ATTRIBUTES_REQUEST = &quot;attributes request&quot;;
&nbsp;
&nbsp;    protected final MqttTransportContext context;
&nbsp;    protected final TransportService transportService;
&nbsp;    protected final TransportDeviceInfo gateway;
&nbsp;    @Getter
&nbsp;    protected final UUID sessionId;
&nbsp;    private final ConcurrentMap&lt;String, Lock&gt; deviceCreationLockMap;
&nbsp;    @Getter
&nbsp;    private final ConcurrentMap&lt;String, T&gt; devices;
&nbsp;    private final ConcurrentMap&lt;String, ListenableFuture&lt;T&gt;&gt; deviceFutures;
&nbsp;    protected final ConcurrentMap&lt;MqttTopicMatcher, Integer&gt; mqttQoSMap;
&nbsp;    @Getter
&nbsp;    protected final ChannelHandlerContext channel;
&nbsp;    protected final DeviceSessionCtx deviceSessionCtx;
&nbsp;    protected final GatewayMetricsService gatewayMetricsService;
&nbsp;
<b class="nc">&nbsp;    @Getter</b>
&nbsp;    @Setter
&nbsp;    private boolean overwriteDevicesActivity = false;
&nbsp;
<b class="nc">&nbsp;    public AbstractGatewaySessionHandler(DeviceSessionCtx deviceSessionCtx, UUID sessionId, boolean overwriteDevicesActivity) {</b>
<b class="nc">&nbsp;        log.debug(&quot;[{}] Gateway connect [{}] session [{}]&quot;, deviceSessionCtx.getTenantId(), deviceSessionCtx.getDeviceId(), sessionId);</b>
<b class="nc">&nbsp;        this.context = deviceSessionCtx.getContext();</b>
<b class="nc">&nbsp;        this.transportService = context.getTransportService();</b>
<b class="nc">&nbsp;        this.deviceSessionCtx = deviceSessionCtx;</b>
<b class="nc">&nbsp;        this.gateway = deviceSessionCtx.getDeviceInfo();</b>
<b class="nc">&nbsp;        this.sessionId = sessionId;</b>
<b class="nc">&nbsp;        this.devices = new ConcurrentHashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        this.deviceFutures = new ConcurrentHashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        this.deviceCreationLockMap = createWeakMap();</b>
<b class="nc">&nbsp;        this.mqttQoSMap = deviceSessionCtx.getMqttQoSMap();</b>
<b class="nc">&nbsp;        this.channel = deviceSessionCtx.getChannel();</b>
<b class="nc">&nbsp;        this.overwriteDevicesActivity = overwriteDevicesActivity;</b>
<b class="nc">&nbsp;        this.gatewayMetricsService = deviceSessionCtx.getContext().getGatewayMetricsService();</b>
&nbsp;    }
&nbsp;
&nbsp;    ConcurrentReferenceHashMap&lt;String, Lock&gt; createWeakMap() {
<b class="nc">&nbsp;        return new ConcurrentReferenceHashMap&lt;&gt;(16, ReferenceType.WEAK);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void onDeviceDisconnect(MqttPublishMessage mqttMsg) throws AdaptorException {
<b class="nc">&nbsp;        if (isJsonPayloadType()) {</b>
<b class="nc">&nbsp;            onDeviceDisconnectJson(mqttMsg);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            onGatewayDeviceDisconnectProto(mqttMsg);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void onDeviceClaim(MqttPublishMessage mqttMsg) throws AdaptorException {
<b class="nc">&nbsp;        int msgId = getMsgId(mqttMsg);</b>
<b class="nc">&nbsp;        ByteBuf payload = mqttMsg.payload();</b>
<b class="nc">&nbsp;        if (isJsonPayloadType()) {</b>
<b class="nc">&nbsp;            onDeviceClaimJson(msgId, payload);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            onDeviceClaimProto(msgId, payload);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void onDeviceAttributes(MqttPublishMessage mqttMsg) throws AdaptorException {
<b class="nc">&nbsp;        int msgId = getMsgId(mqttMsg);</b>
<b class="nc">&nbsp;        ByteBuf payload = mqttMsg.payload();</b>
<b class="nc">&nbsp;        if (isJsonPayloadType()) {</b>
<b class="nc">&nbsp;            onDeviceAttributesJson(msgId, payload);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            onDeviceAttributesProto(msgId, payload);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void onDeviceAttributesRequest(MqttPublishMessage mqttMsg) throws AdaptorException {
<b class="nc">&nbsp;        if (isJsonPayloadType()) {</b>
<b class="nc">&nbsp;            onDeviceAttributesRequestJson(mqttMsg);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            onDeviceAttributesRequestProto(mqttMsg);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void onDeviceRpcResponse(MqttPublishMessage mqttMsg) throws AdaptorException {
<b class="nc">&nbsp;        int msgId = getMsgId(mqttMsg);</b>
<b class="nc">&nbsp;        ByteBuf payload = mqttMsg.payload();</b>
<b class="nc">&nbsp;        if (isJsonPayloadType()) {</b>
<b class="nc">&nbsp;            onDeviceRpcResponseJson(msgId, payload);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            onDeviceRpcResponseProto(msgId, payload);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void onGatewayPing() {
<b class="nc">&nbsp;        if (overwriteDevicesActivity) {</b>
<b class="nc">&nbsp;            devices.forEach((deviceName, deviceSessionCtx) -&gt; transportService.recordActivity(deviceSessionCtx.getSessionInfo()));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void onDevicesDisconnect() {
<b class="nc">&nbsp;        log.debug(&quot;[{}] Gateway disconnect [{}]&quot;, gateway.getTenantId(), gateway.getDeviceId());</b>
&nbsp;        try {
<b class="nc">&nbsp;            deviceFutures.forEach((name, future) -&gt; {</b>
<b class="nc">&nbsp;                Futures.addCallback(future, new FutureCallback&lt;T&gt;() {</b>
&nbsp;                    @Override
&nbsp;                    public void onSuccess(T result) {
<b class="nc">&nbsp;                        log.debug(&quot;[{}] Gateway disconnect [{}] device deregister callback [{}]&quot;, gateway.getTenantId(), gateway.getDeviceId(), name);</b>
<b class="nc">&nbsp;                        deregisterSession(name, result);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void onFailure(Throwable t) {
&nbsp;
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }, MoreExecutors.directExecutor());</b>
&nbsp;            });
&nbsp;
<b class="nc">&nbsp;            devices.forEach(this::deregisterSession);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.error(&quot;Gateway disconnect failure&quot;, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void onDeviceDeleted(String deviceName) {
<b class="nc">&nbsp;        deregisterSession(deviceName);</b>
&nbsp;    }
&nbsp;
&nbsp;    public String getNodeId() {
<b class="nc">&nbsp;        return context.getNodeId();</b>
&nbsp;    }
&nbsp;
&nbsp;    public MqttTransportAdaptor getPayloadAdaptor() {
<b class="nc">&nbsp;        return deviceSessionCtx.getPayloadAdaptor();</b>
&nbsp;    }
&nbsp;
&nbsp;    void deregisterSession(String deviceName) {
<b class="nc">&nbsp;        MqttDeviceAwareSessionContext deviceSessionCtx = devices.remove(deviceName);</b>
<b class="nc">&nbsp;        if (deviceSessionCtx != null) {</b>
<b class="nc">&nbsp;            deregisterSession(deviceName, deviceSessionCtx);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            log.debug(&quot;[{}][{}][{}] Device [{}] was already removed from the gateway session&quot;, gateway.getTenantId(), gateway.getDeviceId(), sessionId, deviceName);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public ChannelFuture writeAndFlush(MqttMessage mqttMessage) {
<b class="nc">&nbsp;        return channel.writeAndFlush(mqttMessage);</b>
&nbsp;    }
&nbsp;
&nbsp;    int nextMsgId() {
<b class="nc">&nbsp;        return deviceSessionCtx.nextMsgId();</b>
&nbsp;    }
&nbsp;
&nbsp;    protected boolean isJsonPayloadType() {
<b class="nc">&nbsp;        return deviceSessionCtx.isJsonPayloadType();</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void processOnConnect(MqttPublishMessage msg, String deviceName, String deviceType) {
<b class="nc">&nbsp;        log.trace(&quot;[{}][{}][{}] onDeviceConnect: [{}]&quot;, gateway.getTenantId(), gateway.getDeviceId(), sessionId, deviceName);</b>
<b class="nc">&nbsp;        int msgId = getMsgId(msg);</b>
<b class="nc">&nbsp;        AtomicBoolean ackSent = new AtomicBoolean(false);</b>
<b class="nc">&nbsp;        process(onDeviceConnect(deviceName, deviceType),</b>
&nbsp;                result -&gt; {
<b class="nc">&nbsp;                    ack(msg, MqttReasonCodes.PubAck.SUCCESS);</b>
<b class="nc">&nbsp;                    log.trace(&quot;[{}][{}][{}] onDeviceConnectOk: [{}]&quot;, gateway.getTenantId(), gateway.getDeviceId(), sessionId, deviceName);</b>
&nbsp;                },
<b class="nc">&nbsp;                t -&gt; processFailure(msgId, deviceName, CONNECT, ackSent, t));</b>
&nbsp;    }
&nbsp;
&nbsp;    public void onDeviceUpdate(TransportProtos.SessionInfoProto sessionInfo, Device device, Optional&lt;DeviceProfile&gt; deviceProfileOpt) {
<b class="nc">&nbsp;        log.trace(&quot;[{}][{}] onDeviceUpdate: [{}]&quot;, gateway.getTenantId(), gateway.getDeviceId(), device);</b>
<b class="nc">&nbsp;        JsonNode deviceAdditionalInfo = device.getAdditionalInfo();</b>
<b class="nc">&nbsp;        if (deviceAdditionalInfo.has(DataConstants.GATEWAY_PARAMETER) &amp;&amp; deviceAdditionalInfo.has(DataConstants.OVERWRITE_ACTIVITY_TIME_PARAMETER)) {</b>
<b class="nc">&nbsp;            overwriteDevicesActivity = deviceAdditionalInfo.get(DataConstants.OVERWRITE_ACTIVITY_TIME_PARAMETER).asBoolean();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    ListenableFuture&lt;T&gt; onDeviceConnect(String deviceName, String deviceType) {
<b class="nc">&nbsp;        T result = devices.get(deviceName);</b>
<b class="nc">&nbsp;        if (result == null) {</b>
<b class="nc">&nbsp;            Lock deviceCreationLock = deviceCreationLockMap.computeIfAbsent(deviceName, s -&gt; new ReentrantLock());</b>
<b class="nc">&nbsp;            deviceCreationLock.lock();</b>
&nbsp;            try {
<b class="nc">&nbsp;                result = devices.get(deviceName);</b>
<b class="nc">&nbsp;                if (result == null) {</b>
<b class="nc">&nbsp;                    return getDeviceCreationFuture(deviceName, deviceType);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return Futures.immediateFuture(result);</b>
&nbsp;                }
&nbsp;            } finally {
<b class="nc">&nbsp;                deviceCreationLock.unlock();</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            return Futures.immediateFuture(result);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private ListenableFuture&lt;T&gt; getDeviceCreationFuture(String deviceName, String deviceType) {
<b class="nc">&nbsp;        final SettableFuture&lt;T&gt; futureToSet = SettableFuture.create();</b>
<b class="nc">&nbsp;        ListenableFuture&lt;T&gt; future = deviceFutures.putIfAbsent(deviceName, futureToSet);</b>
<b class="nc">&nbsp;        if (future != null) {</b>
<b class="nc">&nbsp;            return future;</b>
&nbsp;        }
&nbsp;        try {
<b class="nc">&nbsp;            transportService.process(gateway.getTenantId(),</b>
<b class="nc">&nbsp;                    GetOrCreateDeviceFromGatewayRequestMsg.newBuilder()</b>
<b class="nc">&nbsp;                            .setDeviceName(deviceName)</b>
<b class="nc">&nbsp;                            .setDeviceType(deviceType)</b>
<b class="nc">&nbsp;                            .setGatewayIdMSB(gateway.getDeviceId().getId().getMostSignificantBits())</b>
<b class="nc">&nbsp;                            .setGatewayIdLSB(gateway.getDeviceId().getId().getLeastSignificantBits())</b>
<b class="nc">&nbsp;                            .build(),</b>
<b class="nc">&nbsp;                    new TransportServiceCallback&lt;&gt;() {</b>
&nbsp;                        @Override
&nbsp;                        public void onSuccess(GetOrCreateDeviceFromGatewayResponse msg) {
<b class="nc">&nbsp;                            T deviceSessionCtx = newDeviceSessionCtx(msg);</b>
<b class="nc">&nbsp;                            if (devices.putIfAbsent(deviceName, deviceSessionCtx) == null) {</b>
<b class="nc">&nbsp;                                log.trace(&quot;[{}][{}][{}] First got or created device [{}], type [{}] for the gateway session&quot;, gateway.getTenantId(), gateway.getDeviceId(), sessionId, deviceName, deviceType);</b>
<b class="nc">&nbsp;                                SessionInfoProto deviceSessionInfo = deviceSessionCtx.getSessionInfo();</b>
<b class="nc">&nbsp;                                transportService.registerAsyncSession(deviceSessionInfo, deviceSessionCtx);</b>
&nbsp;                                /**
&nbsp;                                 *  3.0.0 Device Session Establishment:
&nbsp;                                 * dcmd-subscribe
&nbsp;                                 * [tck-id-message-flow-device-dcmd-subscribe] If the Device supports writing to outputs, the
&nbsp;                                 * MQTT client associated with the Device MUST subscribe to a topic of the form
&nbsp;                                 * spBv1.0/group_id/DCMD/edge_node_id/device_id where group_id is the Sparkplug Group ID
&nbsp;                                 * the edge_node_id is the Sparkplug Edge Node ID and the device_id is the Sparkplug Device ID
&nbsp;                                 * for this Device. It MUST subscribe on this topic with a QoS of 1
&nbsp;                                 */
<b class="nc">&nbsp;                                transportService.process(TransportProtos.TransportToDeviceActorMsg.newBuilder()</b>
<b class="nc">&nbsp;                                        .setSessionInfo(deviceSessionInfo)</b>
<b class="nc">&nbsp;                                        .setSessionEvent(SESSION_EVENT_MSG_OPEN)</b>
<b class="nc">&nbsp;                                        .setSubscribeToAttributes(SUBSCRIBE_TO_ATTRIBUTE_UPDATES_ASYNC_MSG)</b>
<b class="nc">&nbsp;                                        .setSubscribeToRPC(SUBSCRIBE_TO_RPC_ASYNC_MSG)</b>
<b class="nc">&nbsp;                                        .build(), null);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            futureToSet.set(devices.get(deviceName));</b>
<b class="nc">&nbsp;                            deviceFutures.remove(deviceName);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public void onError(Throwable t) {
<b class="nc">&nbsp;                            logDeviceCreationError(t, deviceName);</b>
<b class="nc">&nbsp;                            futureToSet.setException(t);</b>
<b class="nc">&nbsp;                            deviceFutures.remove(deviceName);</b>
&nbsp;                        }
&nbsp;                    });
<b class="nc">&nbsp;            return futureToSet;</b>
&nbsp;        } catch (Throwable e) {
<b class="nc">&nbsp;            deviceFutures.remove(deviceName);</b>
&nbsp;            throw e;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void logDeviceCreationError(Throwable t, String deviceName) {
<b class="nc">&nbsp;        if (DataConstants.MAXIMUM_NUMBER_OF_DEVICES_REACHED.equals(t.getMessage())) {</b>
<b class="nc">&nbsp;            log.info(&quot;[{}][{}][{}] Failed to process device connect command: [{}] due to [{}]&quot;, gateway.getTenantId(), gateway.getDeviceId(), sessionId, deviceName,</b>
&nbsp;                    DataConstants.MAXIMUM_NUMBER_OF_DEVICES_REACHED);
&nbsp;        } else {
<b class="nc">&nbsp;            log.warn(&quot;[{}][{}][{}] Failed to process device connect command: [{}]&quot;, gateway.getTenantId(), gateway.getDeviceId(), sessionId, deviceName, t);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected abstract T newDeviceSessionCtx(GetOrCreateDeviceFromGatewayResponse msg);
&nbsp;
&nbsp;    protected int getMsgId(MqttPublishMessage mqttMsg) {
<b class="nc">&nbsp;        return mqttMsg.variableHeader().packetId();</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void onDeviceConnectJson(MqttPublishMessage mqttMsg) throws AdaptorException {
<b class="nc">&nbsp;        JsonElement json = getJson(mqttMsg);</b>
<b class="nc">&nbsp;        String deviceName = checkDeviceName(getDeviceName(json));</b>
<b class="nc">&nbsp;        String deviceType = getDeviceType(json);</b>
<b class="nc">&nbsp;        processOnConnect(mqttMsg, deviceName, deviceType);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void onDeviceConnectProto(MqttPublishMessage mqttMsg) throws AdaptorException {
&nbsp;        try {
<b class="nc">&nbsp;            TransportApiProtos.ConnectMsg connectProto = TransportApiProtos.ConnectMsg.parseFrom(getBytes(mqttMsg.payload()));</b>
<b class="nc">&nbsp;            String deviceName = checkDeviceName(connectProto.getDeviceName());</b>
<b class="nc">&nbsp;            String deviceType = StringUtils.isEmpty(connectProto.getDeviceType()) ? DEFAULT_DEVICE_TYPE : connectProto.getDeviceType();</b>
<b class="nc">&nbsp;            processOnConnect(mqttMsg, deviceName, deviceType);</b>
&nbsp;        } catch (RuntimeException | InvalidProtocolBufferException e) {
<b class="nc">&nbsp;            throw new AdaptorException(e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void onDeviceDisconnectJson(MqttPublishMessage msg) throws AdaptorException {
<b class="nc">&nbsp;        String deviceName = checkDeviceName(getDeviceName(getJson(msg)));</b>
<b class="nc">&nbsp;        processOnDisconnect(msg, deviceName);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void onGatewayDeviceDisconnectProto(MqttPublishMessage mqttMsg) throws AdaptorException {
&nbsp;        try {
<b class="nc">&nbsp;            TransportApiProtos.DisconnectMsg connectProto = TransportApiProtos.DisconnectMsg.parseFrom(getBytes(mqttMsg.payload()));</b>
<b class="nc">&nbsp;            String deviceName = checkDeviceName(connectProto.getDeviceName());</b>
<b class="nc">&nbsp;            processOnDisconnect(mqttMsg, deviceName);</b>
&nbsp;        } catch (RuntimeException | InvalidProtocolBufferException e) {
<b class="nc">&nbsp;            throw new AdaptorException(e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    void processOnDisconnect(MqttPublishMessage msg, String deviceName) {
<b class="nc">&nbsp;        deregisterSession(deviceName);</b>
<b class="nc">&nbsp;        ack(msg, MqttReasonCodes.PubAck.SUCCESS);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void onDeviceTelemetryJson(int msgId, ByteBuf payload) throws AdaptorException {
<b class="nc">&nbsp;        JsonElement json = JsonMqttAdaptor.validateJsonPayload(sessionId, payload);</b>
<b class="nc">&nbsp;        validateJsonObject(json);</b>
&nbsp;
<b class="nc">&nbsp;        List&lt;Map.Entry&lt;String, JsonElement&gt;&gt; deviceEntries = json.getAsJsonObject().entrySet().stream()</b>
<b class="nc">&nbsp;                .filter(entry -&gt; {</b>
<b class="nc">&nbsp;                    final boolean isArray = entry.getValue().isJsonArray();</b>
<b class="nc">&nbsp;                    if (!isArray) {</b>
<b class="nc">&nbsp;                        log.warn(&quot;{} device=&#39;{}&#39; value={}&quot;, CAN_T_PARSE_VALUE, entry.getKey(), entry.getValue());</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return isArray;</b>
&nbsp;                })
<b class="nc">&nbsp;                .toList();</b>
&nbsp;
<b class="nc">&nbsp;        if (deviceEntries.isEmpty()) {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}][{}][{}] Devices telemetry message is empty&quot;, gateway.getTenantId(), gateway.getDeviceId(), sessionId);</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;[&quot; + sessionId + &quot;] Devices telemetry message is empty for [&quot; + gateway.getDeviceId() + &quot;]&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        AtomicInteger remaining = new AtomicInteger(deviceEntries.size());</b>
<b class="nc">&nbsp;        AtomicBoolean ackSent = new AtomicBoolean(false);</b>
&nbsp;
<b class="nc">&nbsp;        for (Map.Entry&lt;String, JsonElement&gt; deviceEntry : deviceEntries) {</b>
<b class="nc">&nbsp;            String deviceName = deviceEntry.getKey();</b>
<b class="nc">&nbsp;            process(deviceName, deviceCtx -&gt; processPostTelemetryMsg(deviceCtx, deviceEntry.getValue(), deviceName, msgId,</b>
&nbsp;                            remaining, ackSent),
<b class="nc">&nbsp;                    t -&gt; processFailure(msgId, deviceName, TELEMETRY, ackSent, t));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void processPostTelemetryMsg(T deviceCtx, JsonElement msg, String deviceName, int msgId, AtomicInteger remaining, AtomicBoolean ackSent) {
&nbsp;        try {
<b class="nc">&nbsp;            long systemTs = System.currentTimeMillis();</b>
<b class="nc">&nbsp;            TbPair&lt;TransportProtos.PostTelemetryMsg, List&lt;GatewayMetadata&gt;&gt; gatewayPayloadPair = JsonConverter.convertToGatewayTelemetry(msg.getAsJsonArray(), systemTs);</b>
<b class="nc">&nbsp;            TransportProtos.PostTelemetryMsg postTelemetryMsg = gatewayPayloadPair.getFirst();</b>
<b class="nc">&nbsp;            List&lt;GatewayMetadata&gt; metadata = gatewayPayloadPair.getSecond();</b>
<b class="nc">&nbsp;            if (!CollectionUtils.isEmpty(metadata)) {</b>
<b class="nc">&nbsp;                gatewayMetricsService.process(deviceSessionCtx.getSessionInfo(), gateway.getDeviceId(), metadata, systemTs);</b>
&nbsp;            }
<b class="nc">&nbsp;            transportService.process(deviceCtx.getSessionInfo(), postTelemetryMsg, getAggregatePubAckCallback(channel, msgId, deviceName, postTelemetryMsg, remaining, ackSent));</b>
&nbsp;        } catch (Throwable e) {
<b class="nc">&nbsp;            log.warn(&quot;[{}][{}][{}] Failed to convert telemetry: [{}]&quot;, gateway.getTenantId(), gateway.getDeviceId(), deviceName, msg, e);</b>
<b class="nc">&nbsp;            ackOrClose(msgId, ackSent);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected void onDeviceTelemetryProto(int msgId, ByteBuf payload) throws AdaptorException {
&nbsp;        try {
<b class="nc">&nbsp;            TransportApiProtos.GatewayTelemetryMsg telemetryMsgProto = TransportApiProtos.GatewayTelemetryMsg.parseFrom(getBytes(payload));</b>
<b class="nc">&nbsp;            List&lt;TransportApiProtos.TelemetryMsg&gt; deviceMsgList = telemetryMsgProto.getMsgList();</b>
<b class="nc">&nbsp;            if (CollectionUtils.isEmpty(deviceMsgList)) {</b>
<b class="nc">&nbsp;                log.debug(&quot;[{}][{}][{}] Devices telemetry messages is empty&quot;, gateway.getTenantId(), gateway.getDeviceId(), sessionId);</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;[&quot; + sessionId + &quot;] Devices telemetry messages is empty for [&quot; + gateway.getDeviceId() + &quot;]&quot;);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            AtomicInteger remaining = new AtomicInteger(deviceMsgList.size());</b>
<b class="nc">&nbsp;            AtomicBoolean ackSent = new AtomicBoolean(false);</b>
&nbsp;
<b class="nc">&nbsp;            deviceMsgList.forEach(telemetryMsg -&gt; {</b>
<b class="nc">&nbsp;                String deviceName = checkDeviceName(telemetryMsg.getDeviceName());</b>
<b class="nc">&nbsp;                process(deviceName, deviceCtx -&gt; processPostTelemetryMsg(deviceCtx, telemetryMsg.getMsg(), deviceName, msgId,</b>
&nbsp;                                remaining, ackSent),
<b class="nc">&nbsp;                        t -&gt; processFailure(msgId, deviceName, TELEMETRY, ackSent, t));</b>
&nbsp;            });
&nbsp;        } catch (RuntimeException | InvalidProtocolBufferException e) {
<b class="nc">&nbsp;            throw new AdaptorException(e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected void processPostTelemetryMsg(MqttDeviceAwareSessionContext deviceCtx, TransportProtos.PostTelemetryMsg msg, String deviceName, int msgId,
&nbsp;                                           AtomicInteger remaining, AtomicBoolean ackSent) {
&nbsp;        try {
<b class="nc">&nbsp;            TransportProtos.PostTelemetryMsg postTelemetryMsg = ProtoConverter.validatePostTelemetryMsg(msg.toByteArray());</b>
<b class="nc">&nbsp;            transportService.process(deviceCtx.getSessionInfo(), postTelemetryMsg, getAggregatePubAckCallback(channel, msgId, deviceName, postTelemetryMsg, remaining, ackSent));</b>
&nbsp;        } catch (Throwable e) {
<b class="nc">&nbsp;            log.warn(&quot;[{}][{}][{}] Failed to convert telemetry: [{}]&quot;, gateway.getTenantId(), gateway.getDeviceId(), deviceName, msg, e);</b>
<b class="nc">&nbsp;            ackOrClose(msgId, ackSent);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public TransportProtos.PostTelemetryMsg postTelemetryMsgCreated(TransportProtos.KeyValueProto keyValueProto, long ts) {
<b class="nc">&nbsp;        List&lt;TransportProtos.KeyValueProto&gt; result = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        result.add(keyValueProto);</b>
<b class="nc">&nbsp;        TransportProtos.PostTelemetryMsg.Builder request = TransportProtos.PostTelemetryMsg.newBuilder();</b>
<b class="nc">&nbsp;        TransportProtos.TsKvListProto.Builder builder = TransportProtos.TsKvListProto.newBuilder();</b>
<b class="nc">&nbsp;        builder.setTs(ts);</b>
<b class="nc">&nbsp;        builder.addAllKv(result);</b>
<b class="nc">&nbsp;        request.addTsKvList(builder.build());</b>
<b class="nc">&nbsp;        return request.build();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void onDeviceClaimJson(int msgId, ByteBuf payload) throws AdaptorException {
<b class="nc">&nbsp;        JsonElement json = JsonMqttAdaptor.validateJsonPayload(sessionId, payload);</b>
<b class="nc">&nbsp;        validateJsonObject(json);</b>
&nbsp;
<b class="nc">&nbsp;        List&lt;Map.Entry&lt;String, JsonElement&gt;&gt; deviceEntries = json.getAsJsonObject().entrySet().stream()</b>
<b class="nc">&nbsp;                .filter(entry -&gt; {</b>
<b class="nc">&nbsp;                    boolean isJsonObject = entry.getValue().isJsonObject();</b>
<b class="nc">&nbsp;                    if (!isJsonObject) {</b>
<b class="nc">&nbsp;                        log.warn(&quot;{} device=&#39;{}&#39; value={}&quot;, CAN_T_PARSE_VALUE, entry.getKey(), entry.getValue());</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return isJsonObject;</b>
&nbsp;                })
<b class="nc">&nbsp;                .toList();</b>
&nbsp;
<b class="nc">&nbsp;        if (deviceEntries.isEmpty()) {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}][{}][{}] Devices claim message is empty&quot;, gateway.getTenantId(), gateway.getDeviceId(), sessionId);</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;[&quot; + sessionId + &quot;] Devices claim message is empty for [&quot; + gateway.getDeviceId() + &quot;]&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        AtomicInteger remaining = new AtomicInteger(deviceEntries.size());</b>
<b class="nc">&nbsp;        AtomicBoolean ackSent = new AtomicBoolean(false);</b>
&nbsp;
<b class="nc">&nbsp;        for (Map.Entry&lt;String, JsonElement&gt; deviceEntry : deviceEntries) {</b>
<b class="nc">&nbsp;            String deviceName = deviceEntry.getKey();</b>
<b class="nc">&nbsp;            process(deviceName, deviceCtx -&gt; processClaimDeviceMsg(deviceCtx, deviceEntry.getValue(), deviceName, msgId,</b>
&nbsp;                            remaining, ackSent),
<b class="nc">&nbsp;                    t -&gt; processFailure(msgId, deviceName, CLAIMING, ackSent, t));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void processClaimDeviceMsg(MqttDeviceAwareSessionContext deviceCtx, JsonElement claimRequest, String deviceName, int msgId,
&nbsp;                                       AtomicInteger remaining, AtomicBoolean ackSent) {
&nbsp;        try {
<b class="nc">&nbsp;            DeviceId deviceId = deviceCtx.getDeviceId();</b>
<b class="nc">&nbsp;            TransportProtos.ClaimDeviceMsg claimDeviceMsg = JsonConverter.convertToClaimDeviceProto(deviceId, claimRequest);</b>
<b class="nc">&nbsp;            transportService.process(deviceCtx.getSessionInfo(), claimDeviceMsg, getAggregatePubAckCallback(channel, msgId, deviceName, claimDeviceMsg, remaining, ackSent));</b>
&nbsp;        } catch (Throwable e) {
<b class="nc">&nbsp;            log.warn(&quot;[{}][{}][{}] Failed to convert claim message: [{}]&quot;, gateway.getTenantId(), gateway.getDeviceId(), deviceName, claimRequest, e);</b>
<b class="nc">&nbsp;            ackOrClose(msgId, ackSent);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void onDeviceClaimProto(int msgId, ByteBuf payload) throws AdaptorException {
&nbsp;        try {
<b class="nc">&nbsp;            TransportApiProtos.GatewayClaimMsg claimMsgProto = TransportApiProtos.GatewayClaimMsg.parseFrom(getBytes(payload));</b>
<b class="nc">&nbsp;            List&lt;TransportApiProtos.ClaimDeviceMsg&gt; claimMsgList = claimMsgProto.getMsgList();</b>
<b class="nc">&nbsp;            if (CollectionUtils.isEmpty(claimMsgList)) {</b>
<b class="nc">&nbsp;                log.debug(&quot;[{}][{}][{}] Devices claim messages is empty&quot;, gateway.getTenantId(), gateway.getDeviceId(), sessionId);</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;[&quot; + sessionId + &quot;] Devices claim messages is empty for [&quot; + gateway.getDeviceId() + &quot;]&quot;);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            AtomicInteger remaining = new AtomicInteger(claimMsgList.size());</b>
<b class="nc">&nbsp;            AtomicBoolean ackSent = new AtomicBoolean(false);</b>
&nbsp;
<b class="nc">&nbsp;            claimMsgList.forEach(claimDeviceMsg -&gt; {</b>
<b class="nc">&nbsp;                String deviceName = checkDeviceName(claimDeviceMsg.getDeviceName());</b>
<b class="nc">&nbsp;                process(deviceName, deviceCtx -&gt; processClaimDeviceMsg(deviceCtx, claimDeviceMsg.getClaimRequest(), deviceName, msgId,</b>
&nbsp;                                remaining, ackSent),
<b class="nc">&nbsp;                        t -&gt; processFailure(msgId, deviceName, CLAIMING, ackSent, t));</b>
&nbsp;            });
&nbsp;        } catch (RuntimeException | InvalidProtocolBufferException e) {
<b class="nc">&nbsp;            throw new AdaptorException(e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void processClaimDeviceMsg(MqttDeviceAwareSessionContext deviceCtx, TransportApiProtos.ClaimDevice claimRequest, String deviceName, int msgId,
&nbsp;                                       AtomicInteger remaining, AtomicBoolean ackSent) {
&nbsp;        try {
<b class="nc">&nbsp;            DeviceId deviceId = deviceCtx.getDeviceId();</b>
<b class="nc">&nbsp;            TransportProtos.ClaimDeviceMsg claimDeviceMsg = ProtoConverter.convertToClaimDeviceProto(deviceId, claimRequest.toByteArray());</b>
<b class="nc">&nbsp;            transportService.process(deviceCtx.getSessionInfo(), claimDeviceMsg, getAggregatePubAckCallback(channel, msgId, deviceName, claimDeviceMsg, remaining, ackSent));</b>
&nbsp;        } catch (Throwable e) {
<b class="nc">&nbsp;            log.warn(&quot;[{}][{}][{}] Failed to convert claim message: [{}]&quot;, gateway.getTenantId(), gateway.getDeviceId(), deviceName, claimRequest, e);</b>
<b class="nc">&nbsp;            ackOrClose(msgId, ackSent);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void onDeviceAttributesJson(int msgId, ByteBuf payload) throws AdaptorException {
<b class="nc">&nbsp;        JsonElement json = JsonMqttAdaptor.validateJsonPayload(sessionId, payload);</b>
<b class="nc">&nbsp;        validateJsonObject(json);</b>
&nbsp;
<b class="nc">&nbsp;        List&lt;Map.Entry&lt;String, JsonElement&gt;&gt; deviceEntries = json.getAsJsonObject().entrySet().stream()</b>
<b class="nc">&nbsp;                .filter(entry -&gt; {</b>
<b class="nc">&nbsp;                    boolean isJsonObject = entry.getValue().isJsonObject();</b>
<b class="nc">&nbsp;                    if (!isJsonObject) {</b>
<b class="nc">&nbsp;                        log.warn(&quot;{} device=&#39;{}&#39; value={}&quot;, CAN_T_PARSE_VALUE, entry.getKey(), entry.getValue());</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return isJsonObject;</b>
&nbsp;                })
<b class="nc">&nbsp;                .toList();</b>
&nbsp;
<b class="nc">&nbsp;        if (deviceEntries.isEmpty()) {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}][{}][{}] Devices attribute message is empty&quot;, gateway.getTenantId(), gateway.getDeviceId(), sessionId);</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;[&quot; + sessionId + &quot;] Devices attribute message is empty for [&quot; + gateway.getDeviceId() + &quot;]&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        AtomicInteger remaining = new AtomicInteger(deviceEntries.size());</b>
<b class="nc">&nbsp;        AtomicBoolean ackSent = new AtomicBoolean(false);</b>
&nbsp;
<b class="nc">&nbsp;        for (Map.Entry&lt;String, JsonElement&gt; deviceEntry : deviceEntries) {</b>
<b class="nc">&nbsp;            String deviceName = deviceEntry.getKey();</b>
<b class="nc">&nbsp;            process(deviceName, deviceCtx -&gt; processPostAttributesMsg(deviceCtx, deviceEntry.getValue(), deviceName, msgId,</b>
&nbsp;                            remaining, ackSent),
<b class="nc">&nbsp;                    t -&gt; processFailure(msgId, deviceName, ATTRIBUTE, ackSent, t));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void processPostAttributesMsg(MqttDeviceAwareSessionContext deviceCtx, JsonElement msg, String deviceName, int msgId,
&nbsp;                                          AtomicInteger remaining, AtomicBoolean ackSent) {
&nbsp;        try {
<b class="nc">&nbsp;            TransportProtos.PostAttributeMsg postAttributeMsg = JsonConverter.convertToAttributesProto(msg.getAsJsonObject());</b>
<b class="nc">&nbsp;            transportService.process(deviceCtx.getSessionInfo(), postAttributeMsg, getAggregatePubAckCallback(channel, msgId, deviceName, postAttributeMsg, remaining, ackSent));</b>
&nbsp;        } catch (Throwable e) {
<b class="nc">&nbsp;            log.warn(&quot;[{}][{}][{}] Failed to process device attributes command: [{}]&quot;, gateway.getTenantId(), gateway.getDeviceId(), deviceName, msg, e);</b>
<b class="nc">&nbsp;            ackOrClose(msgId, ackSent);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void onDeviceAttributesProto(int msgId, ByteBuf payload) throws AdaptorException {
&nbsp;        try {
<b class="nc">&nbsp;            TransportApiProtos.GatewayAttributesMsg attributesMsgProto = TransportApiProtos.GatewayAttributesMsg.parseFrom(getBytes(payload));</b>
<b class="nc">&nbsp;            List&lt;TransportApiProtos.AttributesMsg&gt; attributesMsgList = attributesMsgProto.getMsgList();</b>
<b class="nc">&nbsp;            if (CollectionUtils.isEmpty(attributesMsgList)) {</b>
<b class="nc">&nbsp;                log.debug(&quot;[{}][{}][{}] Devices attributes keys list is empty&quot;, gateway.getTenantId(), gateway.getDeviceId(), sessionId);</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;[&quot; + sessionId + &quot;] Devices attributes keys list is empty for [&quot; + gateway.getDeviceId() + &quot;]&quot;);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            AtomicInteger remaining = new AtomicInteger(attributesMsgList.size());</b>
<b class="nc">&nbsp;            AtomicBoolean ackSent = new AtomicBoolean(false);</b>
&nbsp;
<b class="nc">&nbsp;            attributesMsgList.forEach(attributesMsg -&gt; {</b>
<b class="nc">&nbsp;                String deviceName = checkDeviceName(attributesMsg.getDeviceName());</b>
<b class="nc">&nbsp;                process(deviceName, deviceCtx -&gt; processPostAttributesMsg(deviceCtx, attributesMsg.getMsg(), deviceName, msgId,</b>
&nbsp;                                remaining, ackSent),
<b class="nc">&nbsp;                        t -&gt; processFailure(msgId, deviceName, ATTRIBUTE, ackSent, t));</b>
&nbsp;            });
&nbsp;        } catch (RuntimeException | InvalidProtocolBufferException e) {
<b class="nc">&nbsp;            throw new AdaptorException(e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected void processPostAttributesMsg(MqttDeviceAwareSessionContext deviceCtx, TransportProtos.PostAttributeMsg kvListProto, String deviceName, int msgId,
&nbsp;                                            AtomicInteger remaining, AtomicBoolean ackSent) {
&nbsp;        try {
<b class="nc">&nbsp;            TransportProtos.PostAttributeMsg postAttributeMsg = ProtoConverter.validatePostAttributeMsg(kvListProto);</b>
<b class="nc">&nbsp;            transportService.process(deviceCtx.getSessionInfo(), postAttributeMsg, getAggregatePubAckCallback(channel, msgId, deviceName, postAttributeMsg, remaining, ackSent));</b>
&nbsp;        } catch (Throwable e) {
<b class="nc">&nbsp;            log.warn(&quot;[{}][{}][{}] Failed to process device attributes command: [{}]&quot;, gateway.getTenantId(), gateway.getDeviceId(), deviceName, kvListProto, e);</b>
<b class="nc">&nbsp;            ackOrClose(msgId, ackSent);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void onDeviceAttributesRequestJson(MqttPublishMessage msg) throws AdaptorException {
<b class="nc">&nbsp;        JsonElement json = JsonMqttAdaptor.validateJsonPayload(sessionId, msg.payload());</b>
<b class="nc">&nbsp;        validateJsonObject(json);</b>
<b class="nc">&nbsp;        JsonObject jsonObj = json.getAsJsonObject();</b>
<b class="nc">&nbsp;        int requestId = jsonObj.get(&quot;id&quot;).getAsInt();</b>
<b class="nc">&nbsp;        String deviceName = jsonObj.get(DEVICE_PROPERTY).getAsString();</b>
<b class="nc">&nbsp;        boolean clientScope = jsonObj.get(&quot;client&quot;).getAsBoolean();</b>
&nbsp;        Set&lt;String&gt; keys;
<b class="nc">&nbsp;        if (jsonObj.has(&quot;key&quot;)) {</b>
<b class="nc">&nbsp;            keys = Collections.singleton(jsonObj.get(&quot;key&quot;).getAsString());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            JsonArray keysArray = jsonObj.get(&quot;keys&quot;).getAsJsonArray();</b>
<b class="nc">&nbsp;            keys = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;            for (JsonElement keyObj : keysArray) {</b>
<b class="nc">&nbsp;                keys.add(keyObj.getAsString());</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        TransportProtos.GetAttributeRequestMsg requestMsg = toGetAttributeRequestMsg(requestId, clientScope, keys);</b>
<b class="nc">&nbsp;        processGetAttributeRequestMessage(msg, deviceName, requestMsg);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void onDeviceAttributesRequestProto(MqttPublishMessage mqttMsg) throws AdaptorException {
&nbsp;        try {
<b class="nc">&nbsp;            TransportApiProtos.GatewayAttributesRequestMsg gatewayAttributesRequestMsg = TransportApiProtos.GatewayAttributesRequestMsg.parseFrom(getBytes(mqttMsg.payload()));</b>
<b class="nc">&nbsp;            String deviceName = checkDeviceName(gatewayAttributesRequestMsg.getDeviceName());</b>
<b class="nc">&nbsp;            int requestId = gatewayAttributesRequestMsg.getId();</b>
<b class="nc">&nbsp;            boolean clientScope = gatewayAttributesRequestMsg.getClient();</b>
<b class="nc">&nbsp;            ProtocolStringList keysList = gatewayAttributesRequestMsg.getKeysList();</b>
<b class="nc">&nbsp;            Set&lt;String&gt; keys = new HashSet&lt;&gt;(keysList);</b>
<b class="nc">&nbsp;            TransportProtos.GetAttributeRequestMsg requestMsg = toGetAttributeRequestMsg(requestId, clientScope, keys);</b>
<b class="nc">&nbsp;            processGetAttributeRequestMessage(mqttMsg, deviceName, requestMsg);</b>
&nbsp;        } catch (RuntimeException | InvalidProtocolBufferException e) {
<b class="nc">&nbsp;            throw new AdaptorException(e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void onDeviceRpcResponseJson(int msgId, ByteBuf payload) throws AdaptorException {
<b class="nc">&nbsp;        JsonElement json = JsonMqttAdaptor.validateJsonPayload(sessionId, payload);</b>
<b class="nc">&nbsp;        validateJsonObject(json);</b>
<b class="nc">&nbsp;        JsonObject jsonObj = json.getAsJsonObject();</b>
<b class="nc">&nbsp;        String deviceName = jsonObj.get(DEVICE_PROPERTY).getAsString();</b>
<b class="nc">&nbsp;        Integer requestId = jsonObj.get(&quot;id&quot;).getAsInt();</b>
<b class="nc">&nbsp;        String data = jsonObj.get(&quot;data&quot;).toString();</b>
<b class="nc">&nbsp;        onDeviceRpcResponse(requestId, data, deviceName, msgId);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static void validateJsonObject(JsonElement json) {
<b class="nc">&nbsp;        if (!json.isJsonObject()) {</b>
<b class="nc">&nbsp;            throw new JsonSyntaxException(CAN_T_PARSE_VALUE + json);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void onDeviceRpcResponseProto(int msgId, ByteBuf payload) throws AdaptorException {
&nbsp;        try {
<b class="nc">&nbsp;            TransportApiProtos.GatewayRpcResponseMsg gatewayRpcResponseMsg = TransportApiProtos.GatewayRpcResponseMsg.parseFrom(getBytes(payload));</b>
<b class="nc">&nbsp;            String deviceName = checkDeviceName(gatewayRpcResponseMsg.getDeviceName());</b>
<b class="nc">&nbsp;            Integer requestId = gatewayRpcResponseMsg.getId();</b>
<b class="nc">&nbsp;            String data = gatewayRpcResponseMsg.getData();</b>
<b class="nc">&nbsp;            onDeviceRpcResponse(requestId, data, deviceName, msgId);</b>
&nbsp;        } catch (RuntimeException | InvalidProtocolBufferException e) {
<b class="nc">&nbsp;            throw new AdaptorException(e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void onDeviceRpcResponse(Integer requestId, String data, String deviceName, int msgId) {
<b class="nc">&nbsp;        AtomicInteger remaining = new AtomicInteger(1);</b>
<b class="nc">&nbsp;        AtomicBoolean ackSent = new AtomicBoolean(false);</b>
<b class="nc">&nbsp;        process(deviceName, deviceCtx -&gt; processRpcResponseMsg(deviceCtx, requestId, data, deviceName, msgId, remaining, ackSent),</b>
<b class="nc">&nbsp;                t -&gt; processFailure(msgId, deviceName, RPC_RESPONSE, ackSent, t));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void processRpcResponseMsg(MqttDeviceAwareSessionContext deviceCtx, Integer requestId, String data, String deviceName,
&nbsp;                                       int msgId, AtomicInteger remaining, AtomicBoolean ackSent) {
<b class="nc">&nbsp;        TransportProtos.ToDeviceRpcResponseMsg rpcResponseMsg = TransportProtos.ToDeviceRpcResponseMsg.newBuilder()</b>
<b class="nc">&nbsp;                .setRequestId(requestId).setPayload(data).build();</b>
<b class="nc">&nbsp;        transportService.process(deviceCtx.getSessionInfo(), rpcResponseMsg,</b>
<b class="nc">&nbsp;                getAggregatePubAckCallback(channel, msgId, deviceName, rpcResponseMsg, remaining, ackSent));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void processGetAttributeRequestMessage(MqttPublishMessage mqttMsg, String deviceName, TransportProtos.GetAttributeRequestMsg requestMsg) {
<b class="nc">&nbsp;        int msgId = getMsgId(mqttMsg);</b>
<b class="nc">&nbsp;        AtomicInteger remaining = new AtomicInteger(1);</b>
<b class="nc">&nbsp;        AtomicBoolean ackSent = new AtomicBoolean(false);</b>
<b class="nc">&nbsp;        process(deviceName, deviceCtx -&gt; {</b>
<b class="nc">&nbsp;                    processGetAttributeRequestMessage(deviceCtx, requestMsg, deviceName, msgId, remaining, ackSent);</b>
&nbsp;                },
<b class="nc">&nbsp;                t -&gt; processFailure(msgId, deviceName, ATTRIBUTES_REQUEST, ackSent, MqttReasonCodes.PubAck.IMPLEMENTATION_SPECIFIC_ERROR, t));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void processGetAttributeRequestMessage(T deviceCtx, TransportProtos.GetAttributeRequestMsg requestMsg,
&nbsp;                                                   String deviceName, int msgId, AtomicInteger remaining, AtomicBoolean ackSent) {
<b class="nc">&nbsp;        transportService.process(deviceCtx.getSessionInfo(), requestMsg,</b>
<b class="nc">&nbsp;                getAggregatePubAckCallback(channel, msgId, deviceName, requestMsg, remaining, ackSent));</b>
&nbsp;    }
&nbsp;
&nbsp;    private TransportProtos.GetAttributeRequestMsg toGetAttributeRequestMsg(int requestId, boolean clientScope, Set&lt;String&gt; keys) {
<b class="nc">&nbsp;        TransportProtos.GetAttributeRequestMsg.Builder result = TransportProtos.GetAttributeRequestMsg.newBuilder();</b>
<b class="nc">&nbsp;        result.setRequestId(requestId);</b>
&nbsp;
<b class="nc">&nbsp;        if (clientScope) {</b>
<b class="nc">&nbsp;            result.addAllClientAttributeNames(keys);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            result.addAllSharedAttributeNames(keys);</b>
&nbsp;        }
<b class="nc">&nbsp;        return result.build();</b>
&nbsp;    }
&nbsp;
&nbsp;    protected String checkDeviceName(String deviceName) {
<b class="nc">&nbsp;        if (StringUtils.isEmpty(deviceName)) {</b>
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Device name is empty!&quot;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return deviceName;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private String getDeviceName(JsonElement json) {
<b class="nc">&nbsp;        return json.getAsJsonObject().get(DEVICE_PROPERTY).getAsString();</b>
&nbsp;    }
&nbsp;
&nbsp;    private String getDeviceType(JsonElement json) {
<b class="nc">&nbsp;        JsonElement type = json.getAsJsonObject().get(&quot;type&quot;);</b>
<b class="nc">&nbsp;        return type == null || type instanceof JsonNull ? DEFAULT_DEVICE_TYPE : type.getAsString();</b>
&nbsp;    }
&nbsp;
&nbsp;    private JsonElement getJson(MqttPublishMessage mqttMsg) throws AdaptorException {
<b class="nc">&nbsp;        return JsonMqttAdaptor.validateJsonPayload(sessionId, mqttMsg.payload());</b>
&nbsp;    }
&nbsp;
&nbsp;    protected byte[] getBytes(ByteBuf payload) {
<b class="nc">&nbsp;        return ProtoMqttAdaptor.toBytes(payload);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void ack(MqttPublishMessage msg, MqttReasonCodes.PubAck returnCode) {
<b class="nc">&nbsp;        int msgId = getMsgId(msg);</b>
<b class="nc">&nbsp;        ack(msgId, returnCode);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void ack(int msgId, MqttReasonCodes.PubAck returnCode) {
<b class="nc">&nbsp;        if (msgId &gt; 0) {</b>
<b class="nc">&nbsp;            writeAndFlush(MqttTransportHandler.createMqttPubAckMsg(deviceSessionCtx, msgId, returnCode.byteValue()));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected void ackOrClose(int msgId, AtomicBoolean ackSent) {
<b class="nc">&nbsp;        if (MqttVersion.MQTT_5.equals(deviceSessionCtx.getMqttVersion())) {</b>
<b class="nc">&nbsp;            if (ackSent.compareAndSet(false, true)) {</b>
<b class="nc">&nbsp;                ack(msgId, MqttReasonCodes.PubAck.PAYLOAD_FORMAT_INVALID);</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            channel.close();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void deregisterSession(String deviceName, MqttDeviceAwareSessionContext deviceSessionCtx) {
<b class="nc">&nbsp;        if (this.deviceSessionCtx.isSparkplug()) {</b>
<b class="nc">&nbsp;            sendSparkplugStateOnTelemetry(deviceSessionCtx.getSessionInfo(),</b>
<b class="nc">&nbsp;                    deviceSessionCtx.getDeviceInfo().getDeviceName(), OFFLINE, new Date().getTime());</b>
&nbsp;        }
<b class="nc">&nbsp;        transportService.deregisterSession(deviceSessionCtx.getSessionInfo());</b>
<b class="nc">&nbsp;        transportService.process(deviceSessionCtx.getSessionInfo(), SESSION_EVENT_MSG_CLOSED, null);</b>
<b class="nc">&nbsp;        log.debug(&quot;[{}][{}][{}] Removed device [{}] from the gateway session&quot;, gateway.getTenantId(), gateway.getDeviceId(), sessionId, deviceName);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void sendSparkplugStateOnTelemetry(TransportProtos.SessionInfoProto sessionInfo, String deviceName, SparkplugConnectionState connectionState, long ts) {
<b class="nc">&nbsp;        TransportProtos.KeyValueProto.Builder keyValueProtoBuilder = TransportProtos.KeyValueProto.newBuilder();</b>
<b class="nc">&nbsp;        keyValueProtoBuilder.setKey(messageName(STATE));</b>
<b class="nc">&nbsp;        keyValueProtoBuilder.setType(TransportProtos.KeyValueType.STRING_V);</b>
<b class="nc">&nbsp;        keyValueProtoBuilder.setStringV(connectionState.name());</b>
<b class="nc">&nbsp;        TransportProtos.PostTelemetryMsg postTelemetryMsg = postTelemetryMsgCreated(keyValueProtoBuilder.build(), ts);</b>
<b class="nc">&nbsp;        TransportServiceCallback&lt;Void&gt; pubAckCallback = getAggregatePubAckCallback(channel, -1, deviceName, postTelemetryMsg,</b>
&nbsp;                new AtomicInteger(1), new AtomicBoolean(false));
<b class="nc">&nbsp;        transportService.process(sessionInfo, postTelemetryMsg, pubAckCallback);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected &lt;T&gt; TransportServiceCallback&lt;Void&gt; getAggregatePubAckCallback(
&nbsp;            final ChannelHandlerContext ctx,
&nbsp;            final int msgId,
&nbsp;            final String deviceName,
&nbsp;            final T msg,
&nbsp;            final AtomicInteger remaining,
&nbsp;            final AtomicBoolean ackSent) {
&nbsp;
<b class="nc">&nbsp;        return new TransportServiceCallback&lt;Void&gt;() {</b>
&nbsp;            @Override
&nbsp;            public void onSuccess(Void dummy) {
<b class="nc">&nbsp;                log.trace(&quot;[{}][{}][{}][{}] Published msg: [{}]&quot;, gateway.getTenantId(), gateway.getDeviceId(), sessionId, deviceName, msg);</b>
<b class="nc">&nbsp;                if (remaining.decrementAndGet() == 0 &amp;&amp; ackSent.compareAndSet(false, true)) {</b>
<b class="nc">&nbsp;                    if (msgId &gt; 0) {</b>
<b class="nc">&nbsp;                        ctx.writeAndFlush(MqttTransportHandler.createMqttPubAckMsg(</b>
<b class="nc">&nbsp;                                deviceSessionCtx, msgId, MqttReasonCodes.PubAck.SUCCESS.byteValue()));</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        log.trace(&quot;[{}][{}][{}] Wrong msg id: [{}]&quot;, gateway.getTenantId(), gateway.getDeviceId(), sessionId, msgId);</b>
<b class="nc">&nbsp;                        ctx.writeAndFlush(MqttTransportHandler.createMqttPubAckMsg(</b>
<b class="nc">&nbsp;                                deviceSessionCtx, msgId, MqttReasonCodes.PubAck.UNSPECIFIED_ERROR.byteValue()));</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                if (msgId &lt;= 0) {</b>
<b class="nc">&nbsp;                    closeDeviceSession(deviceName, MqttReasonCodes.Disconnect.MALFORMED_PACKET);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void onError(Throwable e) {
<b class="nc">&nbsp;                log.trace(&quot;[{}][{}][{}] Failed to publish msg: [{}] for device: [{}]&quot;, gateway.getTenantId(), gateway.getDeviceId(), sessionId, msg, deviceName, e);</b>
<b class="nc">&nbsp;                if (e instanceof TbRateLimitsException) {</b>
<b class="nc">&nbsp;                    if (ackSent.compareAndSet(false, true)) {</b>
<b class="nc">&nbsp;                        ctx.writeAndFlush(MqttTransportHandler.createMqttPubAckMsg(</b>
<b class="nc">&nbsp;                                deviceSessionCtx, msgId, MqttReasonCodes.PubAck.QUOTA_EXCEEDED.byteValue()));</b>
<b class="nc">&nbsp;                        ctx.close();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    closeDeviceSession(deviceName, MqttReasonCodes.Disconnect.MESSAGE_RATE_TOO_HIGH);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    if (ackSent.compareAndSet(false, true)) {</b>
<b class="nc">&nbsp;                        ctx.writeAndFlush(MqttTransportHandler.createMqttPubAckMsg(</b>
<b class="nc">&nbsp;                                deviceSessionCtx, msgId, MqttReasonCodes.PubAck.UNSPECIFIED_ERROR.byteValue()));</b>
<b class="nc">&nbsp;                        ctx.close();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    closeDeviceSession(deviceName, MqttReasonCodes.Disconnect.UNSPECIFIED_ERROR);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    protected void process(String deviceName, Consumer&lt;T&gt; onSuccess, Consumer&lt;Throwable&gt; onFailure) {
<b class="nc">&nbsp;        ListenableFuture&lt;T&gt; deviceCtxFuture = onDeviceConnect(deviceName, DEFAULT_DEVICE_TYPE);</b>
<b class="nc">&nbsp;        process(deviceCtxFuture, onSuccess, onFailure);</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    @SneakyThrows</b>
&nbsp;    protected &lt;T&gt; void process(ListenableFuture&lt;T&gt; deviceCtxFuture, Consumer&lt;T&gt; onSuccess, Consumer&lt;Throwable&gt; onFailure) {
<b class="nc">&nbsp;        if (deviceCtxFuture.isDone()) {</b>
<b class="nc">&nbsp;            onSuccess.accept(deviceCtxFuture.get());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            DonAsynchron.withCallback(deviceCtxFuture, onSuccess, onFailure, context.getExecutor());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected void processFailure(int msgId, String deviceName, String msgType, AtomicBoolean ackSent, Throwable t) {
<b class="nc">&nbsp;        if (DataConstants.MAXIMUM_NUMBER_OF_DEVICES_REACHED.equals(t.getMessage())) {</b>
<b class="nc">&nbsp;            processFailure(msgId, deviceName, msgType, ackSent, MqttReasonCodes.PubAck.QUOTA_EXCEEDED, t);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            processFailure(msgId, deviceName, msgType, ackSent, MqttReasonCodes.PubAck.UNSPECIFIED_ERROR, t);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected void processFailure(int msgId, String deviceName, String msgType, AtomicBoolean ackSent, MqttReasonCodes.PubAck pubAck, Throwable t) {
<b class="nc">&nbsp;        log.debug(&quot;[{}][{}][{}] Failed to process device {} command: [{}]&quot;, gateway.getTenantId(), gateway.getDeviceId(), sessionId, msgType, deviceName, t);</b>
<b class="nc">&nbsp;        if (ackSent.compareAndSet(false, true)) {</b>
<b class="nc">&nbsp;            ack(msgId, pubAck);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void closeDeviceSession(String deviceName, MqttReasonCodes.Disconnect returnCode) {
&nbsp;        try {
<b class="nc">&nbsp;            if (MqttVersion.MQTT_5.equals(deviceSessionCtx.getMqttVersion())) {</b>
<b class="nc">&nbsp;                MqttTransportAdaptor adaptor = deviceSessionCtx.getPayloadAdaptor();</b>
<b class="nc">&nbsp;                int returnCodeValue = returnCode.byteValue() &amp; 0xFF;</b>
<b class="nc">&nbsp;                Optional&lt;MqttMessage&gt; deviceDisconnectPublishMsg = adaptor.convertToGatewayDeviceDisconnectPublish(deviceSessionCtx, deviceName, returnCodeValue);</b>
<b class="nc">&nbsp;                deviceDisconnectPublishMsg.ifPresent(deviceSessionCtx.getChannel()::writeAndFlush);</b>
&nbsp;            }
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.trace(&quot;Failed to send device disconnect to gateway session&quot;, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
