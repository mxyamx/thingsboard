<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > CalculatedFieldCtx</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.server.service.cf.ctx.state</a>
</div>

<h1>Coverage Summary for Class: CalculatedFieldCtx (org.thingsboard.server.service.cf.ctx.state)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">CalculatedFieldCtx</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/60)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/262)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/369)
  </span>
</td>
</tr>
  <tr>
    <td class="name">CalculatedFieldCtx$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/61)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/262)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/371)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.server.service.cf.ctx.state;
&nbsp;
&nbsp;import com.google.common.util.concurrent.ListenableFuture;
&nbsp;import lombok.Data;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import net.objecthunter.exp4j.Expression;
&nbsp;import org.mvel2.MVEL;
&nbsp;import org.thingsboard.common.util.ExpressionUtils;
&nbsp;import org.thingsboard.script.api.tbel.TbelCfArg;
&nbsp;import org.thingsboard.script.api.tbel.TbelCfCtx;
&nbsp;import org.thingsboard.script.api.tbel.TbelCfSingleValueArg;
&nbsp;import org.thingsboard.script.api.tbel.TbelInvokeService;
&nbsp;import org.thingsboard.server.actors.ActorSystemContext;
&nbsp;import org.thingsboard.server.actors.TbActorRef;
&nbsp;import org.thingsboard.server.actors.calculatedField.CalculatedFieldReevaluateMsg;
&nbsp;import org.thingsboard.server.common.data.AttributeScope;
&nbsp;import org.thingsboard.server.common.data.TenantProfile;
&nbsp;import org.thingsboard.server.common.data.alarm.rule.AlarmRule;
&nbsp;import org.thingsboard.server.common.data.alarm.rule.condition.expression.TbelAlarmConditionExpression;
&nbsp;import org.thingsboard.server.common.data.cf.CalculatedField;
&nbsp;import org.thingsboard.server.common.data.cf.CalculatedFieldType;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.AlarmCalculatedFieldConfiguration;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.Argument;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.ArgumentType;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.ArgumentsBasedCalculatedFieldConfiguration;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.ExpressionBasedCalculatedFieldConfiguration;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.HasUseLatestTsConfig;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.Output;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.PropagationCalculatedFieldConfiguration;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.ReferencedEntityKey;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.ScheduledUpdateSupportedCalculatedFieldConfiguration;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.SimpleCalculatedFieldConfiguration;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.aggregation.AggFunctionInput;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.aggregation.RelatedEntitiesAggregationCalculatedFieldConfiguration;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.aggregation.single.EntityAggregationCalculatedFieldConfiguration;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.aggregation.single.interval.Watermark;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.geofencing.GeofencingCalculatedFieldConfiguration;
&nbsp;import org.thingsboard.server.common.data.id.CalculatedFieldId;
&nbsp;import org.thingsboard.server.common.data.id.EntityId;
&nbsp;import org.thingsboard.server.common.data.id.TenantId;
&nbsp;import org.thingsboard.server.common.data.kv.AttributeKvEntry;
&nbsp;import org.thingsboard.server.common.data.kv.BasicKvEntry;
&nbsp;import org.thingsboard.server.common.data.kv.TsKvEntry;
&nbsp;import org.thingsboard.server.common.data.util.CollectionsUtil;
&nbsp;import org.thingsboard.server.common.util.ProtoUtils;
&nbsp;import org.thingsboard.server.dao.relation.RelationService;
&nbsp;import org.thingsboard.server.dao.util.TimeUtils;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.CalculatedFieldTelemetryMsgProto;
&nbsp;import org.thingsboard.server.service.cf.CalculatedFieldProcessingService;
&nbsp;import org.thingsboard.server.service.cf.ctx.CalculatedFieldEntityCtxId;
&nbsp;import org.thingsboard.server.service.cf.ctx.state.geofencing.ScheduledRefreshSupported;
&nbsp;import org.thingsboard.server.service.telemetry.AlarmSubscriptionService;
&nbsp;
&nbsp;import java.io.Closeable;
&nbsp;import java.time.ZonedDateTime;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Objects;
&nbsp;import java.util.Set;
&nbsp;import java.util.concurrent.ScheduledFuture;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;import static org.thingsboard.server.service.cf.ctx.state.BaseCalculatedFieldState.DEFAULT_LAST_UPDATE_TS;
&nbsp;
&nbsp;@Data
<b class="nc">&nbsp;@Slf4j</b>
&nbsp;public class CalculatedFieldCtx implements Closeable {
&nbsp;
&nbsp;    public static final long DISABLED_INTERVAL_VALUE = -1L;
&nbsp;
&nbsp;    private CalculatedField calculatedField;
&nbsp;
&nbsp;    private CalculatedFieldId cfId;
&nbsp;    private String cfName;
&nbsp;    private TenantId tenantId;
&nbsp;    private EntityId entityId;
&nbsp;    private CalculatedFieldType cfType;
&nbsp;    private final Map&lt;String, Argument&gt; arguments;
&nbsp;    private final Map&lt;ReferencedEntityKey, Set&lt;String&gt;&gt; mainEntityArguments;
&nbsp;    private final Map&lt;EntityId, Map&lt;ReferencedEntityKey, Set&lt;String&gt;&gt;&gt; linkedEntityArguments;
&nbsp;    private final Map&lt;ReferencedEntityKey, Set&lt;String&gt;&gt; dynamicEntityArguments;
&nbsp;    private final Map&lt;ReferencedEntityKey, Set&lt;String&gt;&gt; relatedEntityArguments;
&nbsp;    private final List&lt;String&gt; argNames;
&nbsp;    private Output output;
&nbsp;    private String expression;
&nbsp;    private boolean useLatestTs;
&nbsp;
&nbsp;    private long lastReevaluationTs;
&nbsp;
&nbsp;    private ActorSystemContext systemContext;
&nbsp;    private TbelInvokeService tbelInvokeService;
&nbsp;    private RelationService relationService;
&nbsp;    private AlarmSubscriptionService alarmService;
&nbsp;    private CalculatedFieldProcessingService cfProcessingService;
&nbsp;
&nbsp;    private Map&lt;String, CalculatedFieldScriptEngine&gt; tbelExpressions;
&nbsp;    private Map&lt;String, ThreadLocal&lt;Expression&gt;&gt; simpleExpressions;
&nbsp;
&nbsp;    private boolean initialized;
&nbsp;
&nbsp;    private long maxStateSize;
&nbsp;    private long maxSingleValueArgumentSize;
&nbsp;    private long intermediateAggregationIntervalMillis;
&nbsp;
&nbsp;    private boolean cfHasRelationPathQuerySource;
&nbsp;    private List&lt;String&gt; mainEntityGeofencingArgumentNames;
&nbsp;    private List&lt;String&gt; linkedEntityAndCurrentOwnerGeofencingArgumentNames;
&nbsp;    private List&lt;String&gt; relatedEntityArgumentNames;
&nbsp;
&nbsp;    private long scheduledUpdateIntervalMillis;
&nbsp;    private long cfCheckReevaluationIntervalMillis;
&nbsp;    private long alarmReevaluationIntervalMillis;
&nbsp;    private long maxRelatedEntitiesPerCfArgument;
&nbsp;    private long minScheduledUpdateIntervalMillis;
&nbsp;    private long minDeduplicationIntervalMillis;
&nbsp;
&nbsp;    private Argument propagationArgument;
&nbsp;    private boolean applyExpressionForResolvedArguments;
&nbsp;
&nbsp;    public CalculatedFieldCtx(CalculatedField calculatedField,
<b class="nc">&nbsp;                              ActorSystemContext systemContext) {</b>
<b class="nc">&nbsp;        this.calculatedField = calculatedField;</b>
&nbsp;
<b class="nc">&nbsp;        this.cfId = calculatedField.getId();</b>
<b class="nc">&nbsp;        this.cfName = calculatedField.getName();</b>
<b class="nc">&nbsp;        this.tenantId = calculatedField.getTenantId();</b>
<b class="nc">&nbsp;        this.entityId = calculatedField.getEntityId();</b>
<b class="nc">&nbsp;        this.cfType = calculatedField.getType();</b>
<b class="nc">&nbsp;        this.arguments = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        this.mainEntityArguments = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        this.linkedEntityArguments = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        this.dynamicEntityArguments = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        this.relatedEntityArguments = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        this.argNames = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        this.mainEntityGeofencingArgumentNames = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        this.linkedEntityAndCurrentOwnerGeofencingArgumentNames = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        this.relatedEntityArgumentNames = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        this.output = calculatedField.getConfiguration().getOutput();</b>
<b class="nc">&nbsp;        if (calculatedField.getConfiguration() instanceof ArgumentsBasedCalculatedFieldConfiguration argBasedConfig) {</b>
<b class="nc">&nbsp;            this.arguments.putAll(argBasedConfig.getArguments());</b>
<b class="nc">&nbsp;            for (Map.Entry&lt;String, Argument&gt; entry : arguments.entrySet()) {</b>
<b class="nc">&nbsp;                var refId = entry.getValue().getRefEntityId();</b>
<b class="nc">&nbsp;                var refKey = entry.getValue().getRefEntityKey();</b>
<b class="nc">&nbsp;                if (refId == null) {</b>
<b class="nc">&nbsp;                    if (CalculatedFieldType.RELATED_ENTITIES_AGGREGATION.equals(cfType)) {</b>
<b class="nc">&nbsp;                        relatedEntityArguments.compute(refKey, (key, existingNames) -&gt; CollectionsUtil.addToSet(existingNames, entry.getKey()));</b>
<b class="nc">&nbsp;                        cfHasRelationPathQuerySource = true;</b>
&nbsp;                        continue;
&nbsp;                    }
<b class="nc">&nbsp;                    if (entry.getValue().hasRelationQuerySource()) {</b>
<b class="nc">&nbsp;                        cfHasRelationPathQuerySource = true;</b>
&nbsp;                        continue;
&nbsp;                    }
<b class="nc">&nbsp;                    if (entry.getValue().hasOwnerSource()) {</b>
<b class="nc">&nbsp;                        dynamicEntityArguments.compute(refKey, (key, existingNames) -&gt; CollectionsUtil.addToSet(existingNames, entry.getKey()));</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        mainEntityArguments.compute(refKey, (key, existingNames) -&gt; CollectionsUtil.addToSet(existingNames, entry.getKey()));</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (refId.equals(calculatedField.getEntityId())) {</b>
<b class="nc">&nbsp;                    mainEntityArguments.compute(refKey, (key, existingNames) -&gt; CollectionsUtil.addToSet(existingNames, entry.getKey()));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    linkedEntityArguments.computeIfAbsent(refId, key -&gt; new HashMap&lt;&gt;())</b>
<b class="nc">&nbsp;                            .compute(refKey, (key, existingNames) -&gt; CollectionsUtil.addToSet(existingNames, entry.getKey()));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            this.argNames.addAll(arguments.keySet());</b>
<b class="nc">&nbsp;            this.relatedEntityArgumentNames = relatedEntityArguments.values().stream()</b>
<b class="nc">&nbsp;                    .flatMap(Set::stream)</b>
<b class="nc">&nbsp;                    .collect(Collectors.toList());</b>
<b class="nc">&nbsp;            if (argBasedConfig instanceof ExpressionBasedCalculatedFieldConfiguration expressionBasedConfig) {</b>
<b class="nc">&nbsp;                this.expression = expressionBasedConfig.getExpression();</b>
&nbsp;            }
<b class="nc">&nbsp;            if (calculatedField.getConfiguration() instanceof GeofencingCalculatedFieldConfiguration geofencingConfig) {</b>
<b class="nc">&nbsp;                geofencingConfig.getZoneGroups().forEach((zoneGroupName, config) -&gt; {</b>
<b class="nc">&nbsp;                    if (config.isCfEntitySource(entityId)) {</b>
<b class="nc">&nbsp;                        mainEntityGeofencingArgumentNames.add(zoneGroupName);</b>
&nbsp;                        return;
&nbsp;                    }
<b class="nc">&nbsp;                    if (config.isLinkedCfEntitySource(entityId) || config.hasCurrentOwnerSource()) {</b>
<b class="nc">&nbsp;                        linkedEntityAndCurrentOwnerGeofencingArgumentNames.add(zoneGroupName);</b>
&nbsp;                    }
&nbsp;                });
&nbsp;            }
<b class="nc">&nbsp;            if (calculatedField.getConfiguration() instanceof PropagationCalculatedFieldConfiguration propagationConfig) {</b>
<b class="nc">&nbsp;                propagationArgument = propagationConfig.toPropagationArgument();</b>
<b class="nc">&nbsp;                applyExpressionForResolvedArguments = propagationConfig.isApplyExpressionToResolvedArguments();</b>
<b class="nc">&nbsp;                cfHasRelationPathQuerySource = true;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (calculatedField.getConfiguration() instanceof ScheduledUpdateSupportedCalculatedFieldConfiguration scheduledConfig) {</b>
<b class="nc">&nbsp;            this.scheduledUpdateIntervalMillis = scheduledConfig.isScheduledUpdateEnabled() ? TimeUnit.SECONDS.toMillis(scheduledConfig.getScheduledUpdateInterval()) : DISABLED_INTERVAL_VALUE;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (calculatedField.getConfiguration() instanceof HasUseLatestTsConfig hasUseLatestTsConfig) {</b>
<b class="nc">&nbsp;            this.useLatestTs = hasUseLatestTsConfig.isUseLatestTs();</b>
&nbsp;        }
<b class="nc">&nbsp;        this.systemContext = systemContext;</b>
<b class="nc">&nbsp;        this.tbelInvokeService = systemContext.getTbelInvokeService();</b>
<b class="nc">&nbsp;        this.relationService = systemContext.getRelationService();</b>
<b class="nc">&nbsp;        this.alarmService = systemContext.getAlarmService();</b>
<b class="nc">&nbsp;        this.cfProcessingService = systemContext.getCalculatedFieldProcessingService();</b>
&nbsp;
<b class="nc">&nbsp;        setTenantProfileProperties();</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean requiresScheduledReevaluation() {
<b class="nc">&nbsp;        long now = System.currentTimeMillis();</b>
<b class="nc">&nbsp;        if (calculatedField.getConfiguration() instanceof EntityAggregationCalculatedFieldConfiguration entityAggregationConfig) {</b>
<b class="nc">&nbsp;            Watermark watermark = entityAggregationConfig.getWatermark();</b>
<b class="nc">&nbsp;            if (watermark != null &amp;&amp; watermark.getDuration() &gt; 0) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (lastReevaluationTs == 0) {</b>
<b class="nc">&nbsp;                lastReevaluationTs = now;</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (entityAggregationConfig.isProduceIntermediateResult()) {</b>
<b class="nc">&nbsp;                if (now - lastReevaluationTs &gt;= intermediateAggregationIntervalMillis) {</b>
<b class="nc">&nbsp;                    lastReevaluationTs = now;</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            ZonedDateTime lastReevaluationTime = TimeUtils.toZonedDateTime(lastReevaluationTs, entityAggregationConfig.getInterval().getZoneId());</b>
<b class="nc">&nbsp;            long previousIntervalEndTs = entityAggregationConfig.getInterval().getDateTimeIntervalEndTs(lastReevaluationTime);</b>
<b class="nc">&nbsp;            if (now &gt;= previousIntervalEndTs) {</b>
<b class="nc">&nbsp;                lastReevaluationTs = now;</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        boolean requiresScheduledReevaluation = calculatedField.getConfiguration().requiresScheduledReevaluation();</b>
<b class="nc">&nbsp;        if (calculatedField.getConfiguration() instanceof AlarmCalculatedFieldConfiguration) {</b>
<b class="nc">&nbsp;            if (requiresScheduledReevaluation) {</b>
<b class="nc">&nbsp;                if (now - lastReevaluationTs &gt;= alarmReevaluationIntervalMillis) {</b>
<b class="nc">&nbsp;                    lastReevaluationTs = now;</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return requiresScheduledReevaluation;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void init() {
<b class="nc">&nbsp;        switch (cfType) {</b>
&nbsp;            case SCRIPT -&gt; {
<b class="nc">&nbsp;                initTbelExpression(expression);</b>
<b class="nc">&nbsp;                initialized = true;</b>
&nbsp;            }
<b class="nc">&nbsp;            case GEOFENCING -&gt; initialized = true;</b>
&nbsp;            case SIMPLE -&gt; {
<b class="nc">&nbsp;                initSimpleExpression(expression);</b>
<b class="nc">&nbsp;                initialized = true;</b>
&nbsp;            }
&nbsp;            case ALARM -&gt; {
<b class="nc">&nbsp;                AlarmCalculatedFieldConfiguration configuration = (AlarmCalculatedFieldConfiguration) calculatedField.getConfiguration();</b>
<b class="nc">&nbsp;                configuration.getAllRules().map(rule -&gt; rule.getValue().getCondition().getExpression())</b>
<b class="nc">&nbsp;                        .forEach(expression -&gt; {</b>
<b class="nc">&nbsp;                            if (expression instanceof TbelAlarmConditionExpression tbelExpression) {</b>
<b class="nc">&nbsp;                                initTbelExpression(tbelExpression.getExpression());</b>
&nbsp;                            }
&nbsp;                        });
<b class="nc">&nbsp;                initialized = true;</b>
&nbsp;            }
&nbsp;            case PROPAGATION -&gt; {
<b class="nc">&nbsp;                if (applyExpressionForResolvedArguments) {</b>
<b class="nc">&nbsp;                    initTbelExpression(expression);</b>
&nbsp;                }
<b class="nc">&nbsp;                initialized = true;</b>
&nbsp;            }
&nbsp;            case RELATED_ENTITIES_AGGREGATION -&gt; {
<b class="nc">&nbsp;                RelatedEntitiesAggregationCalculatedFieldConfiguration configuration = (RelatedEntitiesAggregationCalculatedFieldConfiguration) calculatedField.getConfiguration();</b>
<b class="nc">&nbsp;                configuration.getMetrics().forEach((key, metric) -&gt; {</b>
<b class="nc">&nbsp;                    if (metric.getInput() instanceof AggFunctionInput functionInput) {</b>
<b class="nc">&nbsp;                        initTbelExpression(functionInput.getFunction());</b>
&nbsp;                    }
<b class="nc">&nbsp;                    String filter = metric.getFilter();</b>
<b class="nc">&nbsp;                    if (filter != null &amp;&amp; !filter.isEmpty()) {</b>
<b class="nc">&nbsp;                        initTbelExpression(filter);</b>
&nbsp;                    }
&nbsp;                });
<b class="nc">&nbsp;                initialized = true;</b>
&nbsp;            }
<b class="nc">&nbsp;            case ENTITY_AGGREGATION -&gt; initialized = true;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void setTenantProfileProperties() {
<b class="nc">&nbsp;        TenantProfile tenantProfile = systemContext.getTenantProfileCache().get(tenantId);</b>
<b class="nc">&nbsp;        if (tenantProfile == null) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Tenant Profile not found for tenant: &quot; + tenantId);</b>
&nbsp;        }
<b class="nc">&nbsp;        tenantProfile.getProfileConfiguration().ifPresent(config -&gt; {</b>
<b class="nc">&nbsp;            this.maxStateSize = config.getMaxStateSizeInKBytes() * 1024L;</b>
<b class="nc">&nbsp;            this.maxSingleValueArgumentSize = config.getMaxSingleValueArgumentSizeInKBytes() * 1024L;</b>
<b class="nc">&nbsp;            this.intermediateAggregationIntervalMillis = TimeUnit.SECONDS.toMillis(config.getIntermediateAggregationIntervalInSecForCF());</b>
<b class="nc">&nbsp;            this.cfCheckReevaluationIntervalMillis = TimeUnit.SECONDS.toMillis(config.getCfReevaluationCheckInterval());</b>
<b class="nc">&nbsp;            this.alarmReevaluationIntervalMillis = TimeUnit.SECONDS.toMillis(config.getAlarmsReevaluationInterval());</b>
<b class="nc">&nbsp;            this.maxRelatedEntitiesPerCfArgument = config.getMaxRelatedEntitiesToReturnPerCfArgument();</b>
<b class="nc">&nbsp;            this.minScheduledUpdateIntervalMillis = TimeUnit.SECONDS.toMillis(config.getMinAllowedScheduledUpdateIntervalInSecForCF());</b>
<b class="nc">&nbsp;            this.minDeduplicationIntervalMillis = TimeUnit.SECONDS.toMillis(config.getMinAllowedDeduplicationIntervalInSecForCF());</b>
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    public double evaluateSimpleExpression(Expression expression, CalculatedFieldState state) {
<b class="nc">&nbsp;        for (Map.Entry&lt;String, ArgumentEntry&gt; entry : state.getArguments().entrySet()) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                BasicKvEntry kvEntry = ((SingleValueArgumentEntry) entry.getValue()).getKvEntryValue();</b>
<b class="nc">&nbsp;                double value = switch (kvEntry.getDataType()) {</b>
<b class="nc">&nbsp;                    case LONG -&gt; kvEntry.getLongValue().map(Long::doubleValue).orElseThrow();</b>
<b class="nc">&nbsp;                    case DOUBLE -&gt; kvEntry.getDoubleValue().orElseThrow();</b>
<b class="nc">&nbsp;                    case BOOLEAN -&gt; kvEntry.getBooleanValue().map(b -&gt; b ? 1.0 : 0.0).orElseThrow();</b>
<b class="nc">&nbsp;                    case STRING, JSON -&gt; Double.parseDouble(kvEntry.getValueAsString());</b>
&nbsp;                };
<b class="nc">&nbsp;                expression.setVariable(entry.getKey(), value);</b>
&nbsp;            } catch (NumberFormatException e) {
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Argument &#39;&quot; + entry.getKey() + &quot;&#39; is not a number.&quot;);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return expression.evaluate();</b>
&nbsp;    }
&nbsp;
&nbsp;    public ListenableFuture&lt;Object&gt; evaluateTbelExpression(String expression, CalculatedFieldState state) {
<b class="nc">&nbsp;        return evaluateTbelExpression(tbelExpressions.get(expression), state.getArguments(), state.getLatestTimestamp());</b>
&nbsp;    }
&nbsp;
&nbsp;    public ListenableFuture&lt;Object&gt; evaluateTbelExpression(CalculatedFieldScriptEngine expression, CalculatedFieldState state) {
<b class="nc">&nbsp;        return evaluateTbelExpression(expression, state.getArguments(), state.getLatestTimestamp());</b>
&nbsp;    }
&nbsp;
&nbsp;    public ListenableFuture&lt;Object&gt; evaluateTbelExpression(String expression, Map&lt;String, ArgumentEntry&gt; entries, long latestTimestamp) {
<b class="nc">&nbsp;        return evaluateTbelExpression(tbelExpressions.get(expression), entries, latestTimestamp);</b>
&nbsp;    }
&nbsp;
&nbsp;    public ListenableFuture&lt;Object&gt; evaluateTbelExpression(CalculatedFieldScriptEngine expression, Map&lt;String, ArgumentEntry&gt; entries, long latestTimestamp) {
<b class="nc">&nbsp;        Map&lt;String, TbelCfArg&gt; arguments = new LinkedHashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        List&lt;Object&gt; args = new ArrayList&lt;&gt;(argNames.size() + 1);</b>
<b class="nc">&nbsp;        args.add(new Object()); // first element is a ctx, but we will set it later;</b>
<b class="nc">&nbsp;        for (String argName : argNames) {</b>
<b class="nc">&nbsp;            var arg = toTbelArgument(argName, entries);</b>
<b class="nc">&nbsp;            arguments.put(argName, arg);</b>
<b class="nc">&nbsp;            if (arg instanceof TbelCfSingleValueArg svArg) {</b>
<b class="nc">&nbsp;                args.add(svArg.getValue());</b>
&nbsp;            } else {
<b class="nc">&nbsp;                args.add(arg);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        args.set(0, new TbelCfCtx(arguments, latestTimestamp));</b>
&nbsp;
<b class="nc">&nbsp;        return expression.executeScriptAsync(args.toArray());</b>
&nbsp;    }
&nbsp;
&nbsp;    public ScheduledFuture&lt;?&gt; scheduleReevaluation(long delayMs, TbActorRef actorCtx) {
<b class="nc">&nbsp;        log.debug(&quot;[{}] Scheduling CF reevaluation in {} ms&quot;, cfId, delayMs);</b>
<b class="nc">&nbsp;        return systemContext.scheduleMsgWithDelay(actorCtx, new CalculatedFieldReevaluateMsg(tenantId, this), delayMs);</b>
&nbsp;    }
&nbsp;
&nbsp;    private TbelCfArg toTbelArgument(String key, Map&lt;String, ArgumentEntry&gt; arguments) {
<b class="nc">&nbsp;        return arguments.get(key).toTbelCfArg();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void initTbelExpression(String expression) {
<b class="nc">&nbsp;        if (tbelExpressions == null) {</b>
<b class="nc">&nbsp;            tbelExpressions = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        } else if (tbelExpressions.containsKey(expression)) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;        try {
<b class="nc">&nbsp;            CalculatedFieldScriptEngine engine = initEngine(tenantId, expression, tbelInvokeService);</b>
<b class="nc">&nbsp;            tbelExpressions.put(expression, engine);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            initialized = false;</b>
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Failed to initialize CF context. The script expression is invalid. Please check for syntax errors or unsupported functions.&quot;, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void initSimpleExpression(String expression) {
<b class="nc">&nbsp;        if (simpleExpressions == null) {</b>
<b class="nc">&nbsp;            simpleExpressions = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        } else if (simpleExpressions.containsKey(expression)) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        if (isValidExpression(expression)) {</b>
<b class="nc">&nbsp;            ThreadLocal&lt;Expression&gt; compiledExpression = ThreadLocal.withInitial(() -&gt;</b>
<b class="nc">&nbsp;                    ExpressionUtils.createExpression(expression, this.arguments.keySet())</b>
&nbsp;            );
<b class="nc">&nbsp;            simpleExpressions.put(expression, compiledExpression);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            initialized = false;</b>
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Failed to initialize CF context. The expression has invalid syntax or unknown variables. Ensure all mathematical operators are correct.&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private CalculatedFieldScriptEngine initEngine(TenantId tenantId, String expression, TbelInvokeService tbelInvokeService) {
<b class="nc">&nbsp;        if (tbelInvokeService == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;TBEL script engine is disabled!&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        List&lt;String&gt; ctxAndArgNames = new ArrayList&lt;&gt;(argNames.size() + 1);</b>
<b class="nc">&nbsp;        ctxAndArgNames.add(&quot;ctx&quot;);</b>
<b class="nc">&nbsp;        ctxAndArgNames.addAll(argNames);</b>
<b class="nc">&nbsp;        return new CalculatedFieldTbelScriptEngine(</b>
&nbsp;                tenantId,
&nbsp;                tbelInvokeService,
&nbsp;                expression,
<b class="nc">&nbsp;                ctxAndArgNames.toArray(String[]::new)</b>
&nbsp;        );
&nbsp;    }
&nbsp;
&nbsp;    private boolean isValidExpression(String expression) {
&nbsp;        try {
<b class="nc">&nbsp;            MVEL.compileExpression(expression);</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public boolean matches(List&lt;AttributeKvEntry&gt; values, AttributeScope scope) {
<b class="nc">&nbsp;        return matchesAttributes(mainEntityArguments, values, scope);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean linkMatches(EntityId entityId, List&lt;AttributeKvEntry&gt; values, AttributeScope scope) {
<b class="nc">&nbsp;        var map = linkedEntityArguments.get(entityId);</b>
<b class="nc">&nbsp;        return map != null &amp;&amp; matchesAttributes(map, values, scope);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean matches(List&lt;TsKvEntry&gt; values) {
<b class="nc">&nbsp;        return matchesTimeSeries(mainEntityArguments, values);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean linkMatches(EntityId entityId, List&lt;TsKvEntry&gt; values) {
<b class="nc">&nbsp;        var map = linkedEntityArguments.get(entityId);</b>
<b class="nc">&nbsp;        return map != null &amp;&amp; matchesTimeSeries(map, values);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean dynamicSourceMatches(List&lt;TsKvEntry&gt; values) {
<b class="nc">&nbsp;        return matchesTimeSeries(dynamicEntityArguments, values);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean dynamicSourceMatches(List&lt;AttributeKvEntry&gt; values, AttributeScope scope) {
<b class="nc">&nbsp;        return matchesAttributes(dynamicEntityArguments, values, scope);</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean matchesAttributes(Map&lt;ReferencedEntityKey, Set&lt;String&gt;&gt; argMap, List&lt;AttributeKvEntry&gt; values, AttributeScope scope) {
<b class="nc">&nbsp;        if (argMap.isEmpty() || values.isEmpty()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (AttributeKvEntry attrKv : values) {</b>
<b class="nc">&nbsp;            if (argMap.containsKey(new ReferencedEntityKey(attrKv.getKey(), ArgumentType.ATTRIBUTE, scope))) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean matchesTimeSeries(Map&lt;ReferencedEntityKey, Set&lt;String&gt;&gt; argMap, List&lt;TsKvEntry&gt; values) {
<b class="nc">&nbsp;        if (argMap.isEmpty() || values.isEmpty()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (TsKvEntry tsKv : values) {</b>
&nbsp;
<b class="nc">&nbsp;            ReferencedEntityKey latestKey = new ReferencedEntityKey(tsKv.getKey(), ArgumentType.TS_LATEST, null);</b>
<b class="nc">&nbsp;            if (argMap.containsKey(latestKey)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            ReferencedEntityKey rollingKey = new ReferencedEntityKey(tsKv.getKey(), ArgumentType.TS_ROLLING, null);</b>
<b class="nc">&nbsp;            if (argMap.containsKey(rollingKey)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean matchesKeys(List&lt;String&gt; keys, AttributeScope scope) {
<b class="nc">&nbsp;        return matchesAttributesKeys(mainEntityArguments, keys, scope);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean matchesKeys(List&lt;String&gt; keys) {
<b class="nc">&nbsp;        return matchesTimeSeriesKeys(mainEntityArguments, keys);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean matchesDynamicSourceKeys(List&lt;String&gt; keys, AttributeScope scope) {
<b class="nc">&nbsp;        return matchesAttributesKeys(dynamicEntityArguments, keys, scope);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean matchesDynamicSourceKeys(List&lt;String&gt; keys) {
<b class="nc">&nbsp;        return matchesTimeSeriesKeys(dynamicEntityArguments, keys);</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean matchesAttributesKeys(Map&lt;ReferencedEntityKey, Set&lt;String&gt;&gt; argMap, List&lt;String&gt; keys, AttributeScope scope) {
<b class="nc">&nbsp;        if (argMap.isEmpty() || keys.isEmpty()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (String key : keys) {</b>
<b class="nc">&nbsp;            ReferencedEntityKey attrKey = new ReferencedEntityKey(key, ArgumentType.ATTRIBUTE, scope);</b>
<b class="nc">&nbsp;            if (argMap.containsKey(attrKey)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean matchesTimeSeriesKeys(Map&lt;ReferencedEntityKey, Set&lt;String&gt;&gt; argMap, List&lt;String&gt; keys) {
<b class="nc">&nbsp;        if (argMap.isEmpty() || keys.isEmpty()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (String key : keys) {</b>
&nbsp;
<b class="nc">&nbsp;            ReferencedEntityKey latestKey = new ReferencedEntityKey(key, ArgumentType.TS_LATEST, null);</b>
<b class="nc">&nbsp;            if (argMap.containsKey(latestKey)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            ReferencedEntityKey rollingKey = new ReferencedEntityKey(key, ArgumentType.TS_ROLLING, null);</b>
<b class="nc">&nbsp;            if (argMap.containsKey(rollingKey)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean linkMatchesAttrKeys(EntityId entityId, List&lt;String&gt; keys, AttributeScope scope) {
<b class="nc">&nbsp;        var map = linkedEntityArguments.get(entityId);</b>
<b class="nc">&nbsp;        return map != null &amp;&amp; matchesAttributesKeys(map, keys, scope);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean linkMatchesTsKeys(EntityId entityId, List&lt;String&gt; keys) {
<b class="nc">&nbsp;        var map = linkedEntityArguments.get(entityId);</b>
<b class="nc">&nbsp;        return map != null &amp;&amp; matchesTimeSeriesKeys(map, keys);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean relatedEntityMatches(List&lt;TsKvEntry&gt; values) {
<b class="nc">&nbsp;        return matchesTimeSeries(relatedEntityArguments, values);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean relatedEntityMatches(List&lt;AttributeKvEntry&gt; values, AttributeScope scope) {
<b class="nc">&nbsp;        return matchesAttributes(relatedEntityArguments, values, scope);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean matchesRelatedEntityKeys(List&lt;String&gt; keys, AttributeScope scope) {
<b class="nc">&nbsp;        return matchesAttributesKeys(relatedEntityArguments, keys, scope);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean matchesRelatedEntityKeys(List&lt;String&gt; keys) {
<b class="nc">&nbsp;        return matchesTimeSeriesKeys(relatedEntityArguments, keys);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean relatedEntityMatches(CalculatedFieldTelemetryMsgProto proto) {
<b class="nc">&nbsp;        if (!proto.getTsDataList().isEmpty()) {</b>
<b class="nc">&nbsp;            List&lt;TsKvEntry&gt; updatedTelemetry = proto.getTsDataList().stream()</b>
<b class="nc">&nbsp;                    .map(ProtoUtils::fromProto)</b>
<b class="nc">&nbsp;                    .toList();</b>
<b class="nc">&nbsp;            return relatedEntityMatches(updatedTelemetry);</b>
<b class="nc">&nbsp;        } else if (!proto.getAttrDataList().isEmpty()) {</b>
<b class="nc">&nbsp;            AttributeScope scope = AttributeScope.valueOf(proto.getScope().name());</b>
<b class="nc">&nbsp;            List&lt;AttributeKvEntry&gt; updatedTelemetry = proto.getAttrDataList().stream()</b>
<b class="nc">&nbsp;                    .map(ProtoUtils::fromProto)</b>
<b class="nc">&nbsp;                    .toList();</b>
<b class="nc">&nbsp;            return relatedEntityMatches(updatedTelemetry, scope);</b>
<b class="nc">&nbsp;        } else if (!proto.getRemovedTsKeysList().isEmpty()) {</b>
<b class="nc">&nbsp;            return matchesRelatedEntityKeys(proto.getRemovedTsKeysList());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return matchesRelatedEntityKeys(proto.getRemovedAttrKeysList(), AttributeScope.valueOf(proto.getScope().name()));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public boolean dynamicSourceMatches(CalculatedFieldTelemetryMsgProto proto) {
<b class="nc">&nbsp;        if (!proto.getTsDataList().isEmpty()) {</b>
<b class="nc">&nbsp;            List&lt;TsKvEntry&gt; updatedTelemetry = proto.getTsDataList().stream()</b>
<b class="nc">&nbsp;                    .map(ProtoUtils::fromProto)</b>
<b class="nc">&nbsp;                    .toList();</b>
<b class="nc">&nbsp;            return dynamicSourceMatches(updatedTelemetry);</b>
<b class="nc">&nbsp;        } else if (!proto.getAttrDataList().isEmpty()) {</b>
<b class="nc">&nbsp;            AttributeScope scope = AttributeScope.valueOf(proto.getScope().name());</b>
<b class="nc">&nbsp;            List&lt;AttributeKvEntry&gt; updatedTelemetry = proto.getAttrDataList().stream()</b>
<b class="nc">&nbsp;                    .map(ProtoUtils::fromProto)</b>
<b class="nc">&nbsp;                    .toList();</b>
<b class="nc">&nbsp;            return dynamicSourceMatches(updatedTelemetry, scope);</b>
<b class="nc">&nbsp;        } else if (!proto.getRemovedTsKeysList().isEmpty()) {</b>
<b class="nc">&nbsp;            return matchesDynamicSourceKeys(proto.getRemovedTsKeysList());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return matchesDynamicSourceKeys(proto.getRemovedAttrKeysList(), AttributeScope.valueOf(proto.getScope().name()));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public boolean linkMatches(EntityId entityId, CalculatedFieldTelemetryMsgProto proto) {
<b class="nc">&nbsp;        if (!proto.getTsDataList().isEmpty()) {</b>
<b class="nc">&nbsp;            List&lt;TsKvEntry&gt; updatedTelemetry = proto.getTsDataList().stream()</b>
<b class="nc">&nbsp;                    .map(ProtoUtils::fromProto)</b>
<b class="nc">&nbsp;                    .toList();</b>
<b class="nc">&nbsp;            return linkMatches(entityId, updatedTelemetry);</b>
<b class="nc">&nbsp;        } else if (!proto.getAttrDataList().isEmpty()) {</b>
<b class="nc">&nbsp;            AttributeScope scope = AttributeScope.valueOf(proto.getScope().name());</b>
<b class="nc">&nbsp;            List&lt;AttributeKvEntry&gt; updatedTelemetry = proto.getAttrDataList().stream()</b>
<b class="nc">&nbsp;                    .map(ProtoUtils::fromProto)</b>
<b class="nc">&nbsp;                    .toList();</b>
<b class="nc">&nbsp;            return linkMatches(entityId, updatedTelemetry, scope);</b>
<b class="nc">&nbsp;        } else if (!proto.getRemovedTsKeysList().isEmpty()) {</b>
<b class="nc">&nbsp;            return linkMatchesTsKeys(entityId, proto.getRemovedTsKeysList());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return linkMatchesAttrKeys(entityId, proto.getRemovedAttrKeysList(), AttributeScope.valueOf(proto.getScope().name()));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public Map&lt;ReferencedEntityKey, Set&lt;String&gt;&gt; getLinkedAndDynamicArgs(EntityId entityId) {
<b class="nc">&nbsp;        var argNames = new HashMap&lt;ReferencedEntityKey, Set&lt;String&gt;&gt;();</b>
<b class="nc">&nbsp;        var linkedArgNames = linkedEntityArguments.get(entityId);</b>
<b class="nc">&nbsp;        if (linkedArgNames != null &amp;&amp; !linkedArgNames.isEmpty()) {</b>
<b class="nc">&nbsp;            argNames.putAll(linkedArgNames);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (dynamicEntityArguments != null &amp;&amp; !dynamicEntityArguments.isEmpty()) {</b>
<b class="nc">&nbsp;            argNames.putAll(dynamicEntityArguments);</b>
&nbsp;        }
<b class="nc">&nbsp;        return argNames;</b>
&nbsp;    }
&nbsp;
&nbsp;    public CalculatedFieldEntityCtxId toCalculatedFieldEntityCtxId() {
<b class="nc">&nbsp;        return new CalculatedFieldEntityCtxId(tenantId, cfId, entityId);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasRefreshContextOnlyChanges(CalculatedFieldCtx other) { // has changes that do not require state recalculation
<b class="nc">&nbsp;        if (output != null) {</b>
<b class="nc">&nbsp;            var thisOutputStrategy = output.getStrategy();</b>
<b class="nc">&nbsp;            var otherOutputStrategy = other.getCalculatedField().getConfiguration().getOutput().getStrategy();</b>
<b class="nc">&nbsp;            if (thisOutputStrategy.hasRefreshContextOnlyChanges(otherOutputStrategy)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (calculatedField.getConfiguration() instanceof EntityAggregationCalculatedFieldConfiguration thisConfig</b>
<b class="nc">&nbsp;                &amp;&amp; other.getCalculatedField().getConfiguration() instanceof EntityAggregationCalculatedFieldConfiguration otherConfig) {</b>
<b class="nc">&nbsp;            if (thisConfig.isProduceIntermediateResult() != otherConfig.isProduceIntermediateResult()) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasContextOnlyChanges(CalculatedFieldCtx other) { // has changes that do not require state reinit and will be picked up by the state on the fly
<b class="nc">&nbsp;        if (calculatedField.getConfiguration() instanceof ExpressionBasedCalculatedFieldConfiguration &amp;&amp; !Objects.equals(expression, other.expression)) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (output != null &amp;&amp; output.hasContextOnlyChanges(other.output)) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (calculatedField.getConfiguration() instanceof SimpleCalculatedFieldConfiguration thisConfig</b>
<b class="nc">&nbsp;                &amp;&amp; other.calculatedField.getConfiguration() instanceof SimpleCalculatedFieldConfiguration otherConfig</b>
<b class="nc">&nbsp;                &amp;&amp; thisConfig.isUseLatestTs() != otherConfig.isUseLatestTs()) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (cfType == CalculatedFieldType.ALARM) {</b>
<b class="nc">&nbsp;            if (!calculatedField.getName().equals(other.getCalculatedField().getName())) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            var thisConfig = (AlarmCalculatedFieldConfiguration) calculatedField.getConfiguration();</b>
<b class="nc">&nbsp;            var otherConfig = (AlarmCalculatedFieldConfiguration) other.getCalculatedField().getConfiguration();</b>
<b class="nc">&nbsp;            if (!thisConfig.rulesEqual(otherConfig, AlarmRule::equals)) {</b>
&nbsp;                // if the rules have any changes not tracked by hasStateChanges
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (!thisConfig.propagationSettingsEqual(otherConfig)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (scheduledUpdateIntervalMillis != other.scheduledUpdateIntervalMillis) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (calculatedField.getConfiguration() instanceof RelatedEntitiesAggregationCalculatedFieldConfiguration thisConfig</b>
<b class="nc">&nbsp;                &amp;&amp; other.getCalculatedField().getConfiguration() instanceof RelatedEntitiesAggregationCalculatedFieldConfiguration otherConfig</b>
<b class="nc">&nbsp;                &amp;&amp; (thisConfig.getDeduplicationIntervalInSec() != otherConfig.getDeduplicationIntervalInSec()</b>
<b class="nc">&nbsp;                || !thisConfig.getMetrics().equals(otherConfig.getMetrics())</b>
<b class="nc">&nbsp;                || thisConfig.isUseLatestTs() != otherConfig.isUseLatestTs())) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (calculatedField.getConfiguration() instanceof EntityAggregationCalculatedFieldConfiguration thisConfig</b>
<b class="nc">&nbsp;                &amp;&amp; other.getCalculatedField().getConfiguration() instanceof EntityAggregationCalculatedFieldConfiguration otherConfig) {</b>
<b class="nc">&nbsp;            boolean metricsChanged = !Objects.equals(thisConfig.getMetrics(), otherConfig.getMetrics());</b>
<b class="nc">&nbsp;            boolean watermarkChanged = !Objects.equals(thisConfig.getWatermark(), otherConfig.getWatermark());</b>
<b class="nc">&nbsp;            if (metricsChanged || watermarkChanged) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasStateChanges(CalculatedFieldCtx other) {
<b class="nc">&nbsp;        if (!arguments.equals(other.arguments)) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (cfType == CalculatedFieldType.ALARM) {</b>
<b class="nc">&nbsp;            var thisConfig = (AlarmCalculatedFieldConfiguration) calculatedField.getConfiguration();</b>
<b class="nc">&nbsp;            var otherConfig = (AlarmCalculatedFieldConfiguration) other.getCalculatedField().getConfiguration();</b>
<b class="nc">&nbsp;            if (!thisConfig.rulesEqual(otherConfig, (thisRule, otherRule) -&gt; {</b>
<b class="nc">&nbsp;                return thisRule.getCondition().getType() == otherRule.getCondition().getType();</b>
&nbsp;            })) {
&nbsp;                // reinitializing only if the rule list changed, or if a condition type changed for any rule
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (cfType == CalculatedFieldType.PROPAGATION &amp;&amp; !propagationArgument.equals(other.propagationArgument)) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hasGeofencingZoneGroupConfigurationChanges(other)) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hasRelatedEntitiesAggregationConfigurationChanges(other)) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (hasEntityAggregationConfigurationChanges(other)) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean hasGeofencingZoneGroupConfigurationChanges(CalculatedFieldCtx other) {
<b class="nc">&nbsp;        if (calculatedField.getConfiguration() instanceof GeofencingCalculatedFieldConfiguration thisConfig</b>
<b class="nc">&nbsp;                &amp;&amp; other.calculatedField.getConfiguration() instanceof GeofencingCalculatedFieldConfiguration otherConfig) {</b>
<b class="nc">&nbsp;            return !thisConfig.getZoneGroups().equals(otherConfig.getZoneGroups());</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean hasRelatedEntitiesAggregationConfigurationChanges(CalculatedFieldCtx other) {
<b class="nc">&nbsp;        if (calculatedField.getConfiguration() instanceof RelatedEntitiesAggregationCalculatedFieldConfiguration thisConfig</b>
<b class="nc">&nbsp;                &amp;&amp; other.calculatedField.getConfiguration() instanceof RelatedEntitiesAggregationCalculatedFieldConfiguration otherConfig) {</b>
<b class="nc">&nbsp;            return !thisConfig.getRelation().equals(otherConfig.getRelation());</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean hasEntityAggregationConfigurationChanges(CalculatedFieldCtx other) {
<b class="nc">&nbsp;        if (calculatedField.getConfiguration() instanceof EntityAggregationCalculatedFieldConfiguration thisConfig</b>
<b class="nc">&nbsp;                &amp;&amp; other.calculatedField.getConfiguration() instanceof EntityAggregationCalculatedFieldConfiguration otherConfig) {</b>
<b class="nc">&nbsp;            return !thisConfig.getInterval().equals(otherConfig.getInterval());</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean isScheduledUpdateDisabled() {
<b class="nc">&nbsp;        return scheduledUpdateIntervalMillis == DISABLED_INTERVAL_VALUE;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasRelatedEntities() {
<b class="nc">&nbsp;        return cfHasRelationPathQuerySource;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean shouldFetchRelatedEntities(CalculatedFieldState state) {
<b class="nc">&nbsp;        if (!cfHasRelationPathQuerySource) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (isScheduledUpdateDisabled()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (!(state instanceof ScheduledRefreshSupported scheduledRefreshSupported)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (scheduledRefreshSupported.getLastScheduledRefreshTs() == DEFAULT_LAST_UPDATE_TS) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return scheduledRefreshSupported.getLastScheduledRefreshTs() &lt; System.currentTimeMillis() - Math.max(scheduledUpdateIntervalMillis, minScheduledUpdateIntervalMillis);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void close() {
&nbsp;        try {
<b class="nc">&nbsp;            if (tbelExpressions != null) {</b>
<b class="nc">&nbsp;                tbelExpressions.values().forEach(CalculatedFieldScriptEngine::destroy);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (simpleExpressions != null) {</b>
<b class="nc">&nbsp;                simpleExpressions.values().forEach(ThreadLocal::remove);</b>
&nbsp;            }
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.warn(&quot;Failed to stop {}&quot;, this, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public String getSizeExceedsLimitMessage() {
<b class="nc">&nbsp;        return &quot;State size exceeds limit of &quot; + (maxStateSize / 1024) + &quot;Kb!&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasCurrentOwnerSourceArguments() {
<b class="nc">&nbsp;        return !dynamicEntityArguments.isEmpty();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="nc">&nbsp;        return &quot;CalculatedFieldCtx{&quot; +</b>
&nbsp;                &quot;cfId=&quot; + cfId +
&nbsp;                &quot;, cfType=&quot; + cfType +
&nbsp;                &quot;, entityId=&quot; + entityId +
&nbsp;                &#39;}&#39;;
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
