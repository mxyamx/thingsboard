<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > MqttClientImpl</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.mqtt</a>
</div>

<h1>Coverage Summary for Class: MqttClientImpl (org.thingsboard.mqtt)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MqttClientImpl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/32)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/82)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/199)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MqttClientImpl$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MqttClientImpl$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MqttClientImpl$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MqttClientImpl$MqttChannelInitializer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/46)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/84)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/233)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.mqtt;
&nbsp;
&nbsp;import com.google.common.collect.HashMultimap;
&nbsp;import com.google.common.collect.ImmutableSet;
&nbsp;import com.google.common.collect.Sets;
&nbsp;import io.netty.bootstrap.Bootstrap;
&nbsp;import io.netty.buffer.ByteBuf;
&nbsp;import io.netty.channel.Channel;
&nbsp;import io.netty.channel.ChannelFuture;
&nbsp;import io.netty.channel.ChannelFutureListener;
&nbsp;import io.netty.channel.ChannelInitializer;
&nbsp;import io.netty.channel.EventLoopGroup;
&nbsp;import io.netty.channel.nio.NioEventLoopGroup;
&nbsp;import io.netty.channel.socket.SocketChannel;
&nbsp;import io.netty.handler.codec.mqtt.MqttDecoder;
&nbsp;import io.netty.handler.codec.mqtt.MqttEncoder;
&nbsp;import io.netty.handler.codec.mqtt.MqttFixedHeader;
&nbsp;import io.netty.handler.codec.mqtt.MqttMessage;
&nbsp;import io.netty.handler.codec.mqtt.MqttMessageIdVariableHeader;
&nbsp;import io.netty.handler.codec.mqtt.MqttMessageType;
&nbsp;import io.netty.handler.codec.mqtt.MqttPublishMessage;
&nbsp;import io.netty.handler.codec.mqtt.MqttPublishVariableHeader;
&nbsp;import io.netty.handler.codec.mqtt.MqttQoS;
&nbsp;import io.netty.handler.codec.mqtt.MqttSubscribeMessage;
&nbsp;import io.netty.handler.codec.mqtt.MqttSubscribePayload;
&nbsp;import io.netty.handler.codec.mqtt.MqttTopicSubscription;
&nbsp;import io.netty.handler.codec.mqtt.MqttUnsubscribeMessage;
&nbsp;import io.netty.handler.codec.mqtt.MqttUnsubscribePayload;
&nbsp;import io.netty.handler.ssl.SslContext;
&nbsp;import io.netty.handler.timeout.IdleStateHandler;
&nbsp;import io.netty.util.concurrent.DefaultPromise;
&nbsp;import io.netty.util.concurrent.Future;
&nbsp;import io.netty.util.concurrent.Promise;
&nbsp;import lombok.AccessLevel;
&nbsp;import lombok.Getter;
&nbsp;import lombok.Setter;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.thingsboard.common.util.ListeningExecutor;
&nbsp;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Map;
&nbsp;import java.util.Optional;
&nbsp;import java.util.Set;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.concurrent.ConcurrentMap;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.concurrent.atomic.AtomicInteger;
&nbsp;
&nbsp;/**
&nbsp; * Represents an MqttClientImpl connected to a single MQTT server. Will try to keep the connection going at all times
&nbsp; */
&nbsp;@SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;})
<b class="nc">&nbsp;@Slf4j</b>
&nbsp;final class MqttClientImpl implements MqttClient {
&nbsp;
<b class="nc">&nbsp;    @Getter(AccessLevel.PACKAGE)</b>
&nbsp;    private final Set&lt;String&gt; serverSubscriptions = new HashSet&lt;&gt;();
<b class="nc">&nbsp;    @Getter(AccessLevel.PACKAGE)</b>
&nbsp;    private final ConcurrentMap&lt;Integer, MqttPendingUnsubscription&gt; pendingServerUnsubscribes = new ConcurrentHashMap&lt;&gt;();
<b class="nc">&nbsp;    @Getter(AccessLevel.PACKAGE)</b>
&nbsp;    private final ConcurrentMap&lt;Integer, MqttIncomingQos2Publish&gt; qos2PendingIncomingPublishes = new ConcurrentHashMap&lt;&gt;();
<b class="nc">&nbsp;    @Getter(AccessLevel.PACKAGE)</b>
&nbsp;    private final ConcurrentMap&lt;Integer, MqttPendingPublish&gt; pendingPublishes = new ConcurrentHashMap&lt;&gt;();
<b class="nc">&nbsp;    @Getter(AccessLevel.PACKAGE)</b>
<b class="nc">&nbsp;    private final HashMultimap&lt;String, MqttSubscription&gt; subscriptions = HashMultimap.create();</b>
<b class="nc">&nbsp;    @Getter(AccessLevel.PACKAGE)</b>
&nbsp;    private final ConcurrentMap&lt;Integer, MqttPendingSubscription&gt; pendingSubscriptions = new ConcurrentHashMap&lt;&gt;();
<b class="nc">&nbsp;    @Getter(AccessLevel.PACKAGE)</b>
&nbsp;    private final Set&lt;String&gt; pendingSubscribeTopics = new HashSet&lt;&gt;();
<b class="nc">&nbsp;    @Getter(AccessLevel.PACKAGE)</b>
<b class="nc">&nbsp;    private final HashMultimap&lt;MqttHandler, MqttSubscription&gt; handlerToSubscription = HashMultimap.create();</b>
<b class="nc">&nbsp;    private final AtomicInteger nextMessageId = new AtomicInteger(1);</b>
&nbsp;
&nbsp;    @Getter
&nbsp;    private final MqttClientConfig clientConfig;
&nbsp;
&nbsp;    @Getter(AccessLevel.PACKAGE)
&nbsp;    private final MqttHandler defaultHandler;
&nbsp;
&nbsp;    private final ReconnectStrategy reconnectStrategy;
&nbsp;
&nbsp;    private EventLoopGroup eventLoop;
&nbsp;
&nbsp;    private volatile Channel channel;
&nbsp;
<b class="nc">&nbsp;    private volatile boolean disconnected = false;</b>
<b class="nc">&nbsp;    @Getter</b>
&nbsp;    private volatile boolean reconnect = false;
&nbsp;    private String host;
&nbsp;    private int port;
&nbsp;    @Getter
&nbsp;    @Setter
&nbsp;    private MqttClientCallback callback;
&nbsp;
&nbsp;    @Getter
&nbsp;    private final ListeningExecutor handlerExecutor;
&nbsp;
&nbsp;    private final static int DISCONNECT_FALLBACK_DELAY_SECS = 1;
&nbsp;
&nbsp;    /**
&nbsp;     * Construct the MqttClientImpl with default config
&nbsp;     */
&nbsp;    public MqttClientImpl(MqttHandler defaultHandler, ListeningExecutor handlerExecutor) {
<b class="nc">&nbsp;        this(new MqttClientConfig(), defaultHandler, handlerExecutor);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Construct the MqttClientImpl with additional config.
&nbsp;     * This config can also be changed using the {@link #getClientConfig()} function
&nbsp;     *
&nbsp;     * @param clientConfig The config object to use while looking for settings
&nbsp;     */
<b class="nc">&nbsp;    public MqttClientImpl(MqttClientConfig clientConfig, MqttHandler defaultHandler, ListeningExecutor handlerExecutor) {</b>
<b class="nc">&nbsp;        this.clientConfig = clientConfig;</b>
<b class="nc">&nbsp;        this.defaultHandler = defaultHandler;</b>
<b class="nc">&nbsp;        this.handlerExecutor = handlerExecutor;</b>
<b class="nc">&nbsp;        this.reconnectStrategy = new ReconnectStrategyExponential(getClientConfig().getReconnectDelay());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Connect to the specified hostname/ip. By default uses port 1883.
&nbsp;     * If you want to change the port number, see {@link #connect(String, int)}
&nbsp;     *
&nbsp;     * @param host The ip address or host to connect to
&nbsp;     * @return A future which will be completed when the connection is opened and we received an CONNACK
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Promise&lt;MqttConnectResult&gt; connect(String host) {
<b class="nc">&nbsp;        return connect(host, 1883);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Connect to the specified hostname/ip using the specified port
&nbsp;     *
&nbsp;     * @param host The ip address or host to connect to
&nbsp;     * @param port The tcp port to connect to
&nbsp;     * @return A future which will be completed when the connection is opened and we received an CONNACK
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Promise&lt;MqttConnectResult&gt; connect(String host, int port) {
<b class="nc">&nbsp;        return connect(host, port, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Promise&lt;MqttConnectResult&gt; connect(String host, int port, boolean reconnect) {
<b class="nc">&nbsp;        log.trace(&quot;[{}] Connecting to server, isReconnect - {}&quot;, channel != null ? channel.id() : &quot;UNKNOWN&quot;, reconnect);</b>
<b class="nc">&nbsp;        if (this.eventLoop == null) {</b>
<b class="nc">&nbsp;            this.eventLoop = new NioEventLoopGroup();</b>
&nbsp;        }
<b class="nc">&nbsp;        this.host = host;</b>
<b class="nc">&nbsp;        this.port = port;</b>
<b class="nc">&nbsp;        Promise&lt;MqttConnectResult&gt; connectFuture = new DefaultPromise&lt;&gt;(this.eventLoop.next());</b>
<b class="nc">&nbsp;        Bootstrap bootstrap = new Bootstrap();</b>
<b class="nc">&nbsp;        bootstrap.group(this.eventLoop);</b>
<b class="nc">&nbsp;        bootstrap.channel(clientConfig.getChannelClass());</b>
<b class="nc">&nbsp;        bootstrap.remoteAddress(host, port);</b>
<b class="nc">&nbsp;        bootstrap.handler(new MqttChannelInitializer(connectFuture, host, port, clientConfig.getSslContext()));</b>
<b class="nc">&nbsp;        ChannelFuture future = bootstrap.connect();</b>
&nbsp;
<b class="nc">&nbsp;        future.addListener((ChannelFutureListener) f -&gt; {</b>
<b class="nc">&nbsp;            if (f.isSuccess()) {</b>
<b class="nc">&nbsp;                MqttClientImpl.this.channel = f.channel();</b>
<b class="nc">&nbsp;                log.debug(&quot;[{}][{}] Connected successfully {}!&quot;, host, port, this.channel.id());</b>
<b class="nc">&nbsp;                MqttClientImpl.this.channel.closeFuture().addListener((ChannelFutureListener) channelFuture -&gt; {</b>
<b class="nc">&nbsp;                    if (isConnected()) {</b>
&nbsp;                        return;
&nbsp;                    }
<b class="nc">&nbsp;                    log.debug(&quot;[{}][{}] Channel is closed {}!&quot;, host, port, this.channel.id());</b>
<b class="nc">&nbsp;                    ChannelClosedException e = new ChannelClosedException(&quot;Channel is closed!&quot;);</b>
<b class="nc">&nbsp;                    if (callback != null) {</b>
<b class="nc">&nbsp;                        callback.connectionLost(e);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    pendingSubscriptions.forEach((id, mqttPendingSubscription) -&gt; mqttPendingSubscription.onChannelClosed());</b>
<b class="nc">&nbsp;                    pendingSubscriptions.clear();</b>
<b class="nc">&nbsp;                    serverSubscriptions.clear();</b>
<b class="nc">&nbsp;                    subscriptions.clear();</b>
<b class="nc">&nbsp;                    pendingServerUnsubscribes.forEach((id, mqttPendingServerUnsubscribes) -&gt; mqttPendingServerUnsubscribes.onChannelClosed());</b>
<b class="nc">&nbsp;                    pendingServerUnsubscribes.clear();</b>
<b class="nc">&nbsp;                    qos2PendingIncomingPublishes.clear();</b>
<b class="nc">&nbsp;                    pendingPublishes.forEach((id, mqttPendingPublish) -&gt; mqttPendingPublish.onChannelClosed());</b>
<b class="nc">&nbsp;                    pendingPublishes.clear();</b>
<b class="nc">&nbsp;                    pendingSubscribeTopics.clear();</b>
<b class="nc">&nbsp;                    handlerToSubscription.clear();</b>
<b class="nc">&nbsp;                    scheduleConnectIfRequired(host, port, true);</b>
&nbsp;                });
&nbsp;            } else {
<b class="nc">&nbsp;                log.debug(&quot;[{}][{}] Connect failed, trying reconnect!&quot;, host, port);</b>
<b class="nc">&nbsp;                scheduleConnectIfRequired(host, port, reconnect);</b>
&nbsp;            }
&nbsp;        });
<b class="nc">&nbsp;        return connectFuture;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void scheduleConnectIfRequired(String host, int port, boolean reconnect) {
<b class="nc">&nbsp;        log.trace(&quot;[{}][{}][{}] Scheduling connect to server, isReconnect - {}&quot;, host, port, channel != null ? channel.id() : &quot;UNKNOWN&quot;, reconnect);</b>
<b class="nc">&nbsp;        if (clientConfig.isReconnect() &amp;&amp; !disconnected) {</b>
<b class="nc">&nbsp;            if (reconnect) {</b>
<b class="nc">&nbsp;                this.reconnect = true;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            final long nextReconnectDelay = reconnectStrategy.getNextReconnectDelay();</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}][{}][{}] Scheduling reconnect in [{}] sec&quot;, host, port, channel != null ? channel.id() : &quot;UNKNOWN&quot;, nextReconnectDelay);</b>
<b class="nc">&nbsp;            eventLoop.schedule((Runnable) () -&gt; connect(host, port, reconnect), nextReconnectDelay, TimeUnit.SECONDS);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isConnected() {
<b class="nc">&nbsp;        return !disconnected &amp;&amp; channel != null &amp;&amp; channel.isActive();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Promise&lt;MqttConnectResult&gt; reconnect() {
<b class="nc">&nbsp;        log.trace(&quot;[{}] Reconnecting to server, isReconnect - {}&quot;, channel != null ? channel.id() : &quot;UNKNOWN&quot;, reconnect);</b>
<b class="nc">&nbsp;        if (host == null) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Cannot reconnect. Call connect() first&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return connect(host, port);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Retrieve the netty {@link EventLoopGroup} we are using
&nbsp;     *
&nbsp;     * @return The netty {@link EventLoopGroup} we use for the connection
&nbsp;     */
&nbsp;    @Override
&nbsp;    public EventLoopGroup getEventLoop() {
<b class="nc">&nbsp;        return eventLoop;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * By default we use the netty {@link NioEventLoopGroup}.
&nbsp;     * If you change the EventLoopGroup to another type, make sure to change the {@link Channel} class using {@link MqttClientConfig#setChannelClass(Class)}
&nbsp;     * If you want to force the MqttClient to use another {@link EventLoopGroup}, call this function before calling {@link #connect(String, int)}
&nbsp;     *
&nbsp;     * @param eventLoop The new eventloop to use
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void setEventLoop(EventLoopGroup eventLoop) {
<b class="nc">&nbsp;        this.eventLoop = eventLoop;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Subscribe on the given topic. When a message is received, MqttClient will invoke the {@link MqttHandler#onMessage(String, ByteBuf)} function of the given handler
&nbsp;     *
&nbsp;     * @param topic   The topic filter to subscribe to
&nbsp;     * @param handler The handler to invoke when we receive a message
&nbsp;     * @return A future which will be completed when the server acknowledges our subscribe request
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Future&lt;Void&gt; on(String topic, MqttHandler handler) {
<b class="nc">&nbsp;        return on(topic, handler, MqttQoS.AT_MOST_ONCE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Subscribe on the given topic, with the given qos. When a message is received, MqttClient will invoke the {@link MqttHandler#onMessage(String, ByteBuf)} function of the given handler
&nbsp;     *
&nbsp;     * @param topic   The topic filter to subscribe to
&nbsp;     * @param handler The handler to invoke when we receive a message
&nbsp;     * @param qos     The qos to request to the server
&nbsp;     * @return A future which will be completed when the server acknowledges our subscribe request
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Future&lt;Void&gt; on(String topic, MqttHandler handler, MqttQoS qos) {
<b class="nc">&nbsp;        return createSubscription(topic, handler, false, qos);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Subscribe on the given topic. When a message is received, MqttClient will invoke the {@link MqttHandler#onMessage(String, ByteBuf)} function of the given handler
&nbsp;     * This subscription is only once. If the MqttClient has received 1 message, the subscription will be removed
&nbsp;     *
&nbsp;     * @param topic   The topic filter to subscribe to
&nbsp;     * @param handler The handler to invoke when we receive a message
&nbsp;     * @return A future which will be completed when the server acknowledges our subscribe request
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Future&lt;Void&gt; once(String topic, MqttHandler handler) {
<b class="nc">&nbsp;        return once(topic, handler, MqttQoS.AT_MOST_ONCE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Subscribe on the given topic, with the given qos. When a message is received, MqttClient will invoke the {@link MqttHandler#onMessage(String, ByteBuf)} function of the given handler
&nbsp;     * This subscription is only once. If the MqttClient has received 1 message, the subscription will be removed
&nbsp;     *
&nbsp;     * @param topic   The topic filter to subscribe to
&nbsp;     * @param handler The handler to invoke when we receive a message
&nbsp;     * @param qos     The qos to request to the server
&nbsp;     * @return A future which will be completed when the server acknowledges our subscribe request
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Future&lt;Void&gt; once(String topic, MqttHandler handler, MqttQoS qos) {
<b class="nc">&nbsp;        return createSubscription(topic, handler, true, qos);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Remove the subscription for the given topic and handler
&nbsp;     * If you want to unsubscribe from all handlers known for this topic, use {@link #off(String)}
&nbsp;     *
&nbsp;     * @param topic   The topic to unsubscribe for
&nbsp;     * @param handler The handler to unsubscribe
&nbsp;     * @return A future which will be completed when the server acknowledges our unsubscribe request
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Future&lt;Void&gt; off(String topic, MqttHandler handler) {
<b class="nc">&nbsp;        log.trace(&quot;[{}] Unsubscribing from {}&quot;, channel != null ? channel.id() : &quot;UNKNOWN&quot;, topic);</b>
<b class="nc">&nbsp;        Promise&lt;Void&gt; future = new DefaultPromise&lt;&gt;(this.eventLoop.next());</b>
<b class="nc">&nbsp;        for (MqttSubscription subscription : this.handlerToSubscription.get(handler)) {</b>
<b class="nc">&nbsp;            this.subscriptions.remove(topic, subscription);</b>
&nbsp;        }
<b class="nc">&nbsp;        this.handlerToSubscription.removeAll(handler);</b>
<b class="nc">&nbsp;        this.checkSubscriptions(topic, future);</b>
<b class="nc">&nbsp;        return future;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Remove all subscriptions for the given topic.
&nbsp;     * If you want to specify which handler to unsubscribe, use {@link #off(String, MqttHandler)}
&nbsp;     *
&nbsp;     * @param topic The topic to unsubscribe for
&nbsp;     * @return A future which will be completed when the server acknowledges our unsubscribe request
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Future&lt;Void&gt; off(String topic) {
<b class="nc">&nbsp;        log.trace(&quot;[{}] Unsubscribing from {}&quot;, channel != null ? channel.id() : &quot;UNKNOWN&quot;, topic);</b>
<b class="nc">&nbsp;        Promise&lt;Void&gt; future = new DefaultPromise&lt;&gt;(this.eventLoop.next());</b>
<b class="nc">&nbsp;        ImmutableSet&lt;MqttSubscription&gt; subscriptions = ImmutableSet.copyOf(this.subscriptions.get(topic));</b>
<b class="nc">&nbsp;        for (MqttSubscription subscription : subscriptions) {</b>
<b class="nc">&nbsp;            for (MqttSubscription handSub : this.handlerToSubscription.get(subscription.getHandler())) {</b>
<b class="nc">&nbsp;                this.subscriptions.remove(topic, handSub);</b>
&nbsp;            }
<b class="nc">&nbsp;            this.handlerToSubscription.remove(subscription.getHandler(), subscription);</b>
&nbsp;        }
<b class="nc">&nbsp;        this.checkSubscriptions(topic, future);</b>
<b class="nc">&nbsp;        return future;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Publish a message to the given payload
&nbsp;     *
&nbsp;     * @param topic   The topic to publish to
&nbsp;     * @param payload The payload to send
&nbsp;     * @return A future which will be completed when the message is sent out of the MqttClient
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Future&lt;Void&gt; publish(String topic, ByteBuf payload) {
<b class="nc">&nbsp;        return publish(topic, payload, MqttQoS.AT_MOST_ONCE, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Publish a message to the given payload, using the given qos
&nbsp;     *
&nbsp;     * @param topic   The topic to publish to
&nbsp;     * @param payload The payload to send
&nbsp;     * @param qos     The qos to use while publishing
&nbsp;     * @return A future which will be completed when the message is delivered to the server
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Future&lt;Void&gt; publish(String topic, ByteBuf payload, MqttQoS qos) {
<b class="nc">&nbsp;        return publish(topic, payload, qos, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Publish a message to the given payload, using optional retain
&nbsp;     *
&nbsp;     * @param topic   The topic to publish to
&nbsp;     * @param payload The payload to send
&nbsp;     * @param retain  true if you want to retain the message on the server, false otherwise
&nbsp;     * @return A future which will be completed when the message is sent out of the MqttClient
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Future&lt;Void&gt; publish(String topic, ByteBuf payload, boolean retain) {
<b class="nc">&nbsp;        return publish(topic, payload, MqttQoS.AT_MOST_ONCE, retain);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Publish a message to the given payload, using the given qos and optional retain
&nbsp;     *
&nbsp;     * @param topic   The topic to publish to
&nbsp;     * @param payload The payload to send
&nbsp;     * @param qos     The qos to use while publishing
&nbsp;     * @param retain  true if you want to retain the message on the server, false otherwise
&nbsp;     * @return A future which will be completed when the message is delivered to the server
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Future&lt;Void&gt; publish(String topic, ByteBuf payload, MqttQoS qos, boolean retain) {
<b class="nc">&nbsp;        log.trace(&quot;[{}] Publishing message to {}&quot;, channel != null ? channel.id() : &quot;UNKNOWN&quot;, topic);</b>
<b class="nc">&nbsp;        Promise&lt;Void&gt; future = new DefaultPromise&lt;&gt;(this.eventLoop.next());</b>
<b class="nc">&nbsp;        MqttFixedHeader fixedHeader = new MqttFixedHeader(MqttMessageType.PUBLISH, false, qos, retain, 0);</b>
<b class="nc">&nbsp;        MqttPublishVariableHeader variableHeader = new MqttPublishVariableHeader(topic, getNewMessageId().messageId());</b>
<b class="nc">&nbsp;        MqttPublishMessage message = new MqttPublishMessage(fixedHeader, variableHeader, payload);</b>
&nbsp;
<b class="nc">&nbsp;        final var pendingPublish = MqttPendingPublish.builder()</b>
<b class="nc">&nbsp;                .messageId(variableHeader.packetId())</b>
<b class="nc">&nbsp;                .future(future)</b>
<b class="nc">&nbsp;                .payload(payload.retain())</b>
<b class="nc">&nbsp;                .message(message)</b>
<b class="nc">&nbsp;                .qos(qos)</b>
<b class="nc">&nbsp;                .ownerId(clientConfig.getOwnerId())</b>
<b class="nc">&nbsp;                .retransmissionConfig(clientConfig.getRetransmissionConfig())</b>
<b class="nc">&nbsp;                .pendingOperation(new PendingOperation() {</b>
&nbsp;                    @Override
&nbsp;                    public boolean isCancelled() {
<b class="nc">&nbsp;                        return !pendingPublishes.containsKey(variableHeader.packetId());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void onMaxRetransmissionAttemptsReached() {
<b class="nc">&nbsp;                        pendingPublishes.computeIfPresent(variableHeader.packetId(), (__, pendingPublish) -&gt; {</b>
<b class="nc">&nbsp;                            var message = &quot;Unable to deliver publish message due to max retransmission attempts (%s) being reached for client &#39;%s&#39; on topic &#39;%s&#39; (message ID: %d)&quot;</b>
<b class="nc">&nbsp;                                    .formatted(clientConfig.getRetransmissionConfig().maxAttempts(), clientConfig.getClientId(), topic, variableHeader.packetId());</b>
<b class="nc">&nbsp;                            pendingPublish.getFuture().tryFailure(new MaxRetransmissionsReachedException(message));</b>
<b class="nc">&nbsp;                            pendingPublish.getPayload().release();</b>
<b class="nc">&nbsp;                            return null;</b>
&nbsp;                        });
&nbsp;                    }
<b class="nc">&nbsp;                }).build();</b>
&nbsp;
<b class="nc">&nbsp;        this.pendingPublishes.put(pendingPublish.getMessageId(), pendingPublish);</b>
<b class="nc">&nbsp;        ChannelFuture channelFuture = this.sendAndFlushPacket(message);</b>
&nbsp;
<b class="nc">&nbsp;        if (channelFuture != null) {</b>
<b class="nc">&nbsp;            channelFuture.addListener(result -&gt; {</b>
<b class="nc">&nbsp;                pendingPublish.setSent(true);</b>
<b class="nc">&nbsp;                if (result.cause() != null) {</b>
<b class="nc">&nbsp;                    pendingPublishes.remove(pendingPublish.getMessageId());</b>
<b class="nc">&nbsp;                    future.setFailure(result.cause());</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    if (pendingPublish.isSent() &amp;&amp; pendingPublish.getQos() == MqttQoS.AT_MOST_ONCE) {</b>
<b class="nc">&nbsp;                        pendingPublishes.remove(pendingPublish.getMessageId());</b>
<b class="nc">&nbsp;                        pendingPublish.getFuture().setSuccess(null); //We don&#39;t get an ACK for QOS 0</b>
<b class="nc">&nbsp;                    } else if (pendingPublish.isSent()) {</b>
<b class="nc">&nbsp;                        pendingPublish.startPublishRetransmissionTimer(eventLoop.next(), MqttClientImpl.this::sendAndFlushPacket);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        pendingPublishes.remove(pendingPublish.getMessageId());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            });
&nbsp;        } else {
<b class="nc">&nbsp;            pendingPublishes.remove(pendingPublish.getMessageId());</b>
&nbsp;        }
<b class="nc">&nbsp;        return future;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void disconnect() {
<b class="nc">&nbsp;        if (disconnected) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        disconnected = true;</b>
<b class="nc">&nbsp;        log.trace(&quot;[{}] Disconnecting from server&quot;, channel != null ? channel.id() : &quot;UNKNOWN&quot;);</b>
<b class="nc">&nbsp;        if (this.channel != null) {</b>
<b class="nc">&nbsp;            MqttMessage message = new MqttMessage(new MqttFixedHeader(MqttMessageType.DISCONNECT, false, MqttQoS.AT_MOST_ONCE, false, 0));</b>
&nbsp;
<b class="nc">&nbsp;            sendAndFlushPacket(message).addListener((ChannelFutureListener) future -&gt; {</b>
<b class="nc">&nbsp;                future.channel().close();</b>
&nbsp;            });
<b class="nc">&nbsp;            eventLoop.schedule(() -&gt; {</b>
<b class="nc">&nbsp;                if (channel.isOpen()) {</b>
<b class="nc">&nbsp;                    log.trace(&quot;[{}] Channel still open after {} second; forcing close now&quot;, channel.id(), DISCONNECT_FALLBACK_DELAY_SECS);</b>
<b class="nc">&nbsp;                    this.channel.close();</b>
&nbsp;                }
&nbsp;            }, DISCONNECT_FALLBACK_DELAY_SECS, TimeUnit.SECONDS);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    ///////////////////////////////////////////// PRIVATE API /////////////////////////////////////////////
&nbsp;
&nbsp;    public void onSuccessfulReconnect() {
<b class="nc">&nbsp;        if (callback != null) {</b>
<b class="nc">&nbsp;            callback.onSuccessfulReconnect();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    ChannelFuture sendAndFlushPacket(Object message) {
<b class="nc">&nbsp;        if (this.channel == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (this.channel.isActive()) {</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}] Sending message {}&quot;, channel != null ? channel.id() : &quot;UNKNOWN&quot;, message);</b>
<b class="nc">&nbsp;            return this.channel.writeAndFlush(message);</b>
&nbsp;        }
<b class="nc">&nbsp;        return this.channel.newFailedFuture(new ChannelClosedException(&quot;Channel is closed!&quot;));</b>
&nbsp;    }
&nbsp;
&nbsp;    private MqttMessageIdVariableHeader getNewMessageId() {
&nbsp;        int messageId;
<b class="nc">&nbsp;        synchronized (this.nextMessageId) {</b>
<b class="nc">&nbsp;            this.nextMessageId.compareAndSet(0xffff, 1);</b>
<b class="nc">&nbsp;            messageId = this.nextMessageId.getAndIncrement();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return MqttMessageIdVariableHeader.from(messageId);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Future&lt;Void&gt; createSubscription(String topic, MqttHandler handler, boolean once, MqttQoS qos) {
<b class="nc">&nbsp;        log.trace(&quot;[{}] Creating subscription to {}&quot;, channel != null ? channel.id() : &quot;UNKNOWN&quot;, topic);</b>
<b class="nc">&nbsp;        if (this.pendingSubscribeTopics.contains(topic)) {</b>
<b class="nc">&nbsp;            Optional&lt;Map.Entry&lt;Integer, MqttPendingSubscription&gt;&gt; subscriptionEntry = this.pendingSubscriptions.entrySet().stream().filter((e) -&gt; e.getValue().getTopic().equals(topic)).findAny();</b>
<b class="nc">&nbsp;            if (subscriptionEntry.isPresent()) {</b>
<b class="nc">&nbsp;                subscriptionEntry.get().getValue().addHandler(handler, once);</b>
<b class="nc">&nbsp;                return subscriptionEntry.get().getValue().getFuture();</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (this.serverSubscriptions.contains(topic)) {</b>
<b class="nc">&nbsp;            MqttSubscription subscription = new MqttSubscription(topic, handler, once);</b>
<b class="nc">&nbsp;            this.subscriptions.put(topic, subscription);</b>
<b class="nc">&nbsp;            this.handlerToSubscription.put(handler, subscription);</b>
<b class="nc">&nbsp;            return this.channel.newSucceededFuture();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Promise&lt;Void&gt; future = new DefaultPromise&lt;&gt;(this.eventLoop.next());</b>
<b class="nc">&nbsp;        MqttFixedHeader fixedHeader = new MqttFixedHeader(MqttMessageType.SUBSCRIBE, false, MqttQoS.AT_LEAST_ONCE, false, 0);</b>
<b class="nc">&nbsp;        MqttTopicSubscription subscription = new MqttTopicSubscription(topic, qos);</b>
<b class="nc">&nbsp;        MqttMessageIdVariableHeader variableHeader = getNewMessageId();</b>
<b class="nc">&nbsp;        MqttSubscribePayload payload = new MqttSubscribePayload(Collections.singletonList(subscription));</b>
<b class="nc">&nbsp;        MqttSubscribeMessage message = new MqttSubscribeMessage(fixedHeader, variableHeader, payload);</b>
&nbsp;
<b class="nc">&nbsp;        final var pendingSubscription = MqttPendingSubscription.builder()</b>
<b class="nc">&nbsp;                .future(future)</b>
<b class="nc">&nbsp;                .topic(topic)</b>
<b class="nc">&nbsp;                .handlers(Sets.newHashSet(new MqttPendingSubscription.MqttPendingHandler(handler, once)))</b>
<b class="nc">&nbsp;                .subscribeMessage(message)</b>
<b class="nc">&nbsp;                .ownerId(clientConfig.getOwnerId())</b>
<b class="nc">&nbsp;                .retransmissionConfig(clientConfig.getRetransmissionConfig())</b>
<b class="nc">&nbsp;                .pendingOperation(new PendingOperation() {</b>
&nbsp;                    @Override
&nbsp;                    public boolean isCancelled() {
<b class="nc">&nbsp;                        return !pendingSubscriptions.containsKey(variableHeader.messageId());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void onMaxRetransmissionAttemptsReached() {
<b class="nc">&nbsp;                        pendingSubscriptions.computeIfPresent(variableHeader.messageId(), (__, pendingSubscription) -&gt; {</b>
<b class="nc">&nbsp;                            var message = &quot;Unable to deliver subscribe message due to max retransmission attempts (%s) being reached for client &#39;%s&#39; on topic &#39;%s&#39; (message ID: %d)&quot;</b>
<b class="nc">&nbsp;                                    .formatted(clientConfig.getRetransmissionConfig().maxAttempts(), clientConfig.getClientId(), topic, variableHeader.messageId());</b>
<b class="nc">&nbsp;                            pendingSubscription.getFuture().tryFailure(new MaxRetransmissionsReachedException(message));</b>
<b class="nc">&nbsp;                            return null;</b>
&nbsp;                        });
&nbsp;                    }
<b class="nc">&nbsp;                }).build();</b>
&nbsp;
<b class="nc">&nbsp;        this.pendingSubscriptions.put(variableHeader.messageId(), pendingSubscription);</b>
<b class="nc">&nbsp;        this.pendingSubscribeTopics.add(topic);</b>
<b class="nc">&nbsp;        pendingSubscription.setSent(this.sendAndFlushPacket(message) != null); //If not sent, we will send it when the connection is opened</b>
&nbsp;
<b class="nc">&nbsp;        pendingSubscription.startRetransmitTimer(this.eventLoop.next(), this::sendAndFlushPacket);</b>
&nbsp;
<b class="nc">&nbsp;        return future;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void checkSubscriptions(String topic, Promise&lt;Void&gt; promise) {
<b class="nc">&nbsp;        if (!(this.subscriptions.containsKey(topic) &amp;&amp; !this.subscriptions.get(topic).isEmpty()) &amp;&amp; this.serverSubscriptions.contains(topic)) {</b>
<b class="nc">&nbsp;            MqttFixedHeader fixedHeader = new MqttFixedHeader(MqttMessageType.UNSUBSCRIBE, false, MqttQoS.AT_LEAST_ONCE, false, 0);</b>
<b class="nc">&nbsp;            MqttMessageIdVariableHeader variableHeader = getNewMessageId();</b>
<b class="nc">&nbsp;            MqttUnsubscribePayload payload = new MqttUnsubscribePayload(Collections.singletonList(topic));</b>
<b class="nc">&nbsp;            MqttUnsubscribeMessage message = new MqttUnsubscribeMessage(fixedHeader, variableHeader, payload);</b>
&nbsp;
<b class="nc">&nbsp;            final var pendingUnsubscription = MqttPendingUnsubscription.builder()</b>
<b class="nc">&nbsp;                    .future(promise)</b>
<b class="nc">&nbsp;                    .topic(topic)</b>
<b class="nc">&nbsp;                    .unsubscribeMessage(message)</b>
<b class="nc">&nbsp;                    .ownerId(clientConfig.getOwnerId())</b>
<b class="nc">&nbsp;                    .retransmissionConfig(clientConfig.getRetransmissionConfig())</b>
<b class="nc">&nbsp;                    .pendingOperation(new PendingOperation() {</b>
&nbsp;                        @Override
&nbsp;                        public boolean isCancelled() {
<b class="nc">&nbsp;                            return !pendingServerUnsubscribes.containsKey(variableHeader.messageId());</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public void onMaxRetransmissionAttemptsReached() {
<b class="nc">&nbsp;                            pendingServerUnsubscribes.computeIfPresent(variableHeader.messageId(), (__, pendingUnsubscription) -&gt; {</b>
<b class="nc">&nbsp;                                var message = &quot;Unable to deliver unsubscribe message due to max retransmission attempts (%s) being reached for client &#39;%s&#39; on topic &#39;%s&#39; (message ID: %d)&quot;</b>
<b class="nc">&nbsp;                                        .formatted(clientConfig.getRetransmissionConfig().maxAttempts(), clientConfig.getClientId(), topic, variableHeader.messageId());</b>
<b class="nc">&nbsp;                                pendingUnsubscription.getFuture().tryFailure(new MaxRetransmissionsReachedException(message));</b>
<b class="nc">&nbsp;                                return null;</b>
&nbsp;                            });
&nbsp;                        }
<b class="nc">&nbsp;                    }).build();</b>
&nbsp;
<b class="nc">&nbsp;            this.pendingServerUnsubscribes.put(variableHeader.messageId(), pendingUnsubscription);</b>
<b class="nc">&nbsp;            pendingUnsubscription.startRetransmissionTimer(this.eventLoop.next(), this::sendAndFlushPacket);</b>
&nbsp;
<b class="nc">&nbsp;            this.sendAndFlushPacket(message);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            promise.setSuccess(null);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private class MqttChannelInitializer extends ChannelInitializer&lt;SocketChannel&gt; {
&nbsp;
&nbsp;        private final Promise&lt;MqttConnectResult&gt; connectFuture;
&nbsp;        private final String host;
&nbsp;        private final int port;
&nbsp;        private final SslContext sslContext;
&nbsp;
&nbsp;
<b class="nc">&nbsp;        public MqttChannelInitializer(Promise&lt;MqttConnectResult&gt; connectFuture, String host, int port, SslContext sslContext) {</b>
<b class="nc">&nbsp;            this.connectFuture = connectFuture;</b>
<b class="nc">&nbsp;            this.host = host;</b>
<b class="nc">&nbsp;            this.port = port;</b>
<b class="nc">&nbsp;            this.sslContext = sslContext;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected void initChannel(SocketChannel ch) throws Exception {
<b class="nc">&nbsp;            if (sslContext != null) {</b>
<b class="nc">&nbsp;                ch.pipeline().addLast(sslContext.newHandler(ch.alloc(), host, port));</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            ch.pipeline().addLast(&quot;mqttDecoder&quot;, new MqttDecoder(clientConfig.getMaxBytesInMessage()));</b>
<b class="nc">&nbsp;            ch.pipeline().addLast(&quot;mqttEncoder&quot;, MqttEncoder.INSTANCE);</b>
<b class="nc">&nbsp;            ch.pipeline().addLast(&quot;idleStateHandler&quot;, new IdleStateHandler(MqttClientImpl.this.clientConfig.getTimeoutSeconds(), MqttClientImpl.this.clientConfig.getTimeoutSeconds(), 0));</b>
<b class="nc">&nbsp;            ch.pipeline().addLast(&quot;mqttPingHandler&quot;, new MqttPingHandler(MqttClientImpl.this.clientConfig.getTimeoutSeconds()));</b>
<b class="nc">&nbsp;            ch.pipeline().addLast(&quot;mqttHandler&quot;, new MqttChannelHandler(MqttClientImpl.this, connectFuture));</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
