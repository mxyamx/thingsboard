<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > MqttPingHandler</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.mqtt</a>
</div>

<h1>Coverage Summary for Class: MqttPingHandler (org.thingsboard.mqtt)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MqttPingHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/34)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MqttPingHandler$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/35)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.mqtt;
&nbsp;
&nbsp;import io.netty.channel.Channel;
&nbsp;import io.netty.channel.ChannelFutureListener;
&nbsp;import io.netty.channel.ChannelHandlerContext;
&nbsp;import io.netty.channel.ChannelInboundHandlerAdapter;
&nbsp;import io.netty.handler.codec.mqtt.MqttFixedHeader;
&nbsp;import io.netty.handler.codec.mqtt.MqttMessage;
&nbsp;import io.netty.handler.codec.mqtt.MqttMessageType;
&nbsp;import io.netty.handler.codec.mqtt.MqttQoS;
&nbsp;import io.netty.handler.timeout.IdleStateEvent;
&nbsp;import io.netty.util.ReferenceCountUtil;
&nbsp;import io.netty.util.concurrent.ScheduledFuture;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;
<b class="nc">&nbsp;@Slf4j</b>
&nbsp;final class MqttPingHandler extends ChannelInboundHandlerAdapter {
&nbsp;
&nbsp;    private final int keepaliveSeconds;
&nbsp;
&nbsp;    private ScheduledFuture&lt;?&gt; pingRespTimeout;
&nbsp;
<b class="nc">&nbsp;    MqttPingHandler(int keepaliveSeconds) {</b>
<b class="nc">&nbsp;        this.keepaliveSeconds = keepaliveSeconds;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void channelRead(ChannelHandlerContext ctx, Object msg) {
<b class="nc">&nbsp;        if (!(msg instanceof MqttMessage message)) {</b>
<b class="nc">&nbsp;            ctx.fireChannelRead(msg);</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        if (message.fixedHeader().messageType() == MqttMessageType.PINGREQ) {</b>
<b class="nc">&nbsp;            this.handlePingReq(ctx.channel());</b>
<b class="nc">&nbsp;        } else if (message.fixedHeader().messageType() == MqttMessageType.PINGRESP) {</b>
<b class="nc">&nbsp;            this.handlePingResp(ctx.channel());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            ctx.fireChannelRead(ReferenceCountUtil.retain(msg));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
<b class="nc">&nbsp;        super.userEventTriggered(ctx, evt);</b>
&nbsp;
<b class="nc">&nbsp;        if (evt instanceof IdleStateEvent event) {</b>
<b class="nc">&nbsp;            switch (event.state()) {</b>
&nbsp;                case READER_IDLE:
<b class="nc">&nbsp;                    log.debug(&quot;[{}] No reads were performed for specified period for channel {}&quot;, event.state(), ctx.channel().id());</b>
<b class="nc">&nbsp;                    this.sendPingReq(ctx.channel(), event);</b>
&nbsp;                    break;
&nbsp;                case WRITER_IDLE:
<b class="nc">&nbsp;                    log.debug(&quot;[{}] No writes were performed for specified period for channel {}&quot;, event.state(), ctx.channel().id());</b>
<b class="nc">&nbsp;                    this.sendPingReq(ctx.channel(), event);</b>
&nbsp;                    break;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void sendPingReq(Channel channel, IdleStateEvent idleEvent) {
<b class="nc">&nbsp;        log.trace(&quot;[{}] Sending ping request&quot;, channel.id());</b>
<b class="nc">&nbsp;        MqttFixedHeader fixedHeader = new MqttFixedHeader(MqttMessageType.PINGREQ, false, MqttQoS.AT_MOST_ONCE, false, 0);</b>
<b class="nc">&nbsp;        channel.writeAndFlush(new MqttMessage(fixedHeader));</b>
&nbsp;
<b class="nc">&nbsp;        if (this.pingRespTimeout == null) {</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}] Scheduling disconnect due to {}&quot;, channel.id(), idleEvent);</b>
<b class="nc">&nbsp;            this.pingRespTimeout = channel.eventLoop().schedule(() -&gt; {</b>
<b class="nc">&nbsp;                log.trace(&quot;[{}] Sending disconnect due to {}&quot;, channel.id(), idleEvent);</b>
<b class="nc">&nbsp;                MqttFixedHeader fixedHeader2 = new MqttFixedHeader(MqttMessageType.DISCONNECT, false, MqttQoS.AT_MOST_ONCE, false, 0);</b>
<b class="nc">&nbsp;                channel.writeAndFlush(new MqttMessage(fixedHeader2)).addListener(ChannelFutureListener.CLOSE);</b>
&nbsp;                //TODO: what do when the connection is closed ?
&nbsp;            }, this.keepaliveSeconds, TimeUnit.SECONDS);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void handlePingReq(Channel channel) {
<b class="nc">&nbsp;        log.trace(&quot;[{}] Handling ping request&quot;, channel.id());</b>
<b class="nc">&nbsp;        MqttFixedHeader fixedHeader = new MqttFixedHeader(MqttMessageType.PINGRESP, false, MqttQoS.AT_MOST_ONCE, false, 0);</b>
<b class="nc">&nbsp;        channel.writeAndFlush(new MqttMessage(fixedHeader));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void handlePingResp(Channel channel) {
<b class="nc">&nbsp;        log.trace(&quot;[{}] Handling ping response&quot;, channel.id());</b>
<b class="nc">&nbsp;        if (this.pingRespTimeout != null &amp;&amp; !this.pingRespTimeout.isCancelled() &amp;&amp; !this.pingRespTimeout.isDone()) {</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}] Cancelling disconnect due to idle event because ping response was received&quot;, channel.id());</b>
<b class="nc">&nbsp;            this.pingRespTimeout.cancel(true);</b>
<b class="nc">&nbsp;            this.pingRespTimeout = null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
