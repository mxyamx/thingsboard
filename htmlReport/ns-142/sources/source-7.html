<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > DefaultTbQueueRequestTemplate</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.server.queue.common</a>
</div>

<h1>Coverage Summary for Class: DefaultTbQueueRequestTemplate (org.thingsboard.server.queue.common)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DefaultTbQueueRequestTemplate</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/32)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/99)
  </span>
</td>
</tr>
  <tr>
    <td class="name">DefaultTbQueueRequestTemplate$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultTbQueueRequestTemplate$ResponseMetaData</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/27)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/36)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/113)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.server.queue.common;
&nbsp;
&nbsp;import com.google.common.util.concurrent.Futures;
&nbsp;import com.google.common.util.concurrent.ListenableFuture;
&nbsp;import com.google.common.util.concurrent.SettableFuture;
&nbsp;import jakarta.annotation.Nullable;
&nbsp;import lombok.Builder;
&nbsp;import lombok.Getter;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.thingsboard.common.util.TbStopWatch;
&nbsp;import org.thingsboard.common.util.ThingsBoardThreadFactory;
&nbsp;import org.thingsboard.server.common.msg.queue.TopicPartitionInfo;
&nbsp;import org.thingsboard.server.common.stats.MessagesStats;
&nbsp;import org.thingsboard.server.queue.TbQueueAdmin;
&nbsp;import org.thingsboard.server.queue.TbQueueCallback;
&nbsp;import org.thingsboard.server.queue.TbQueueConsumer;
&nbsp;import org.thingsboard.server.queue.TbQueueMsg;
&nbsp;import org.thingsboard.server.queue.TbQueueMsgMetadata;
&nbsp;import org.thingsboard.server.queue.TbQueueProducer;
&nbsp;import org.thingsboard.server.queue.TbQueueRequestTemplate;
&nbsp;
&nbsp;import java.util.List;
&nbsp;import java.util.UUID;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.concurrent.ExecutorService;
&nbsp;import java.util.concurrent.Executors;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.concurrent.TimeoutException;
&nbsp;import java.util.concurrent.locks.Lock;
&nbsp;import java.util.concurrent.locks.LockSupport;
&nbsp;import java.util.concurrent.locks.ReentrantLock;
&nbsp;
<b class="nc">&nbsp;@Slf4j</b>
&nbsp;public class DefaultTbQueueRequestTemplate&lt;Request extends TbQueueMsg, Response extends TbQueueMsg&gt; extends AbstractTbQueueTemplate
&nbsp;        implements TbQueueRequestTemplate&lt;Request, Response&gt; {
&nbsp;
&nbsp;    private final TbQueueAdmin queueAdmin;
&nbsp;    private final TbQueueProducer&lt;Request&gt; requestTemplate;
&nbsp;    private final TbQueueConsumer&lt;Response&gt; responseTemplate;
<b class="nc">&nbsp;    final ConcurrentHashMap&lt;UUID, DefaultTbQueueRequestTemplate.ResponseMetaData&lt;Response&gt;&gt; pendingRequests = new ConcurrentHashMap&lt;&gt;();</b>
&nbsp;    final boolean internalExecutor;
&nbsp;    final ExecutorService executor;
&nbsp;    final long maxRequestTimeoutNs;
&nbsp;    final long maxRequestTimeout;
&nbsp;    final long maxPendingRequests;
&nbsp;    final long pollInterval;
<b class="nc">&nbsp;    volatile boolean stopped = false;</b>
<b class="nc">&nbsp;    long nextCleanupNs = 0L;</b>
<b class="nc">&nbsp;    private final Lock cleanerLock = new ReentrantLock();</b>
&nbsp;
&nbsp;    private MessagesStats messagesStats;
&nbsp;
&nbsp;    @Builder
&nbsp;    public DefaultTbQueueRequestTemplate(TbQueueAdmin queueAdmin,
&nbsp;                                         TbQueueProducer&lt;Request&gt; requestTemplate,
&nbsp;                                         TbQueueConsumer&lt;Response&gt; responseTemplate,
&nbsp;                                         long maxRequestTimeout,
&nbsp;                                         long maxPendingRequests,
&nbsp;                                         long pollInterval,
<b class="nc">&nbsp;                                         @Nullable ExecutorService executor) {</b>
<b class="nc">&nbsp;        this.queueAdmin = queueAdmin;</b>
<b class="nc">&nbsp;        this.requestTemplate = requestTemplate;</b>
<b class="nc">&nbsp;        this.responseTemplate = responseTemplate;</b>
<b class="nc">&nbsp;        this.maxRequestTimeoutNs = TimeUnit.MILLISECONDS.toNanos(maxRequestTimeout);</b>
<b class="nc">&nbsp;        this.maxRequestTimeout = maxRequestTimeout;</b>
<b class="nc">&nbsp;        this.maxPendingRequests = maxPendingRequests;</b>
<b class="nc">&nbsp;        this.pollInterval = pollInterval;</b>
<b class="nc">&nbsp;        this.internalExecutor = (executor == null);</b>
<b class="nc">&nbsp;        this.executor = internalExecutor ? createExecutor() : executor;</b>
&nbsp;    }
&nbsp;
&nbsp;    ExecutorService createExecutor() {
<b class="nc">&nbsp;        return Executors.newSingleThreadExecutor(ThingsBoardThreadFactory.forName(&quot;tb-queue-request-template-&quot; + responseTemplate.getTopic()));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void init() {
<b class="nc">&nbsp;        queueAdmin.createTopicIfNotExists(responseTemplate.getTopic());</b>
<b class="nc">&nbsp;        responseTemplate.subscribe();</b>
<b class="nc">&nbsp;        executor.submit(this::mainLoop);</b>
&nbsp;    }
&nbsp;
&nbsp;    void mainLoop() {
<b class="nc">&nbsp;        while (!stopped) {</b>
<b class="nc">&nbsp;            TbStopWatch sw = TbStopWatch.create();</b>
&nbsp;            try {
<b class="nc">&nbsp;                fetchAndProcessResponses();</b>
&nbsp;            } catch (Throwable e) {
<b class="nc">&nbsp;                long sleepNanos = TimeUnit.MILLISECONDS.toNanos(this.pollInterval) - sw.stopAndGetTotalTimeNanos();</b>
<b class="nc">&nbsp;                log.warn(&quot;Failed to obtain and process responses from queue. Going to sleep &quot; + sleepNanos + &quot;ns&quot;, e);</b>
<b class="nc">&nbsp;                sleep(sleepNanos);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    void fetchAndProcessResponses() {
<b class="nc">&nbsp;        final long pendingRequestsCount = pendingRequests.mappingCount();</b>
<b class="nc">&nbsp;        log.trace(&quot;Starting template pool topic {}, for pendingRequests {}&quot;, responseTemplate.getTopic(), pendingRequestsCount);</b>
<b class="nc">&nbsp;        List&lt;Response&gt; responses = doPoll(); //poll js responses</b>
<b class="nc">&nbsp;        log.trace(&quot;Completed template poll topic {}, for pendingRequests [{}], received [{}] responses&quot;, responseTemplate.getTopic(), pendingRequestsCount, responses.size());</b>
<b class="nc">&nbsp;        responses.forEach(this::processResponse); //this can take a long time</b>
<b class="nc">&nbsp;        responseTemplate.commit();</b>
<b class="nc">&nbsp;        tryCleanStaleRequests();</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean tryCleanStaleRequests() {
<b class="nc">&nbsp;        if (!cleanerLock.tryLock()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        try {
<b class="nc">&nbsp;            log.trace(&quot;tryCleanStaleRequest...&quot;);</b>
<b class="nc">&nbsp;            final long currentNs = getCurrentClockNs();</b>
<b class="nc">&nbsp;            if (nextCleanupNs &lt; currentNs) {</b>
<b class="nc">&nbsp;                pendingRequests.forEach((key, value) -&gt; {</b>
<b class="nc">&nbsp;                    if (value.expTime &lt; currentNs) {</b>
<b class="nc">&nbsp;                        ResponseMetaData&lt;Response&gt; staleRequest = pendingRequests.remove(key);</b>
<b class="nc">&nbsp;                        if (staleRequest != null) {</b>
<b class="nc">&nbsp;                            setTimeoutException(key, staleRequest, currentNs);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                });
<b class="nc">&nbsp;                setupNextCleanup();</b>
&nbsp;            }
&nbsp;        } finally {
<b class="nc">&nbsp;            cleanerLock.unlock();</b>
&nbsp;        }
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    void setupNextCleanup() {
<b class="nc">&nbsp;        nextCleanupNs = getCurrentClockNs() + maxRequestTimeoutNs;</b>
<b class="nc">&nbsp;        log.trace(&quot;setupNextCleanup {}&quot;, nextCleanupNs);</b>
&nbsp;    }
&nbsp;
&nbsp;    List&lt;Response&gt; doPoll() {
<b class="nc">&nbsp;        return responseTemplate.poll(pollInterval);</b>
&nbsp;    }
&nbsp;
&nbsp;    void sleep(long nanos) {
<b class="nc">&nbsp;        LockSupport.parkNanos(nanos);</b>
&nbsp;    }
&nbsp;
&nbsp;    void setTimeoutException(UUID key, ResponseMetaData&lt;Response&gt; staleRequest, long currentNs) {
<b class="nc">&nbsp;        if (currentNs &gt;= staleRequest.getSubmitTime() + staleRequest.getTimeout()) {</b>
<b class="nc">&nbsp;            log.debug(&quot;Request timeout detected, currentNs [{}], {}, key [{}]&quot;, currentNs, staleRequest, key);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            log.info(&quot;Request timeout detected, currentNs [{}], {}, key [{}]&quot;, currentNs, staleRequest, key);</b>
&nbsp;        }
<b class="nc">&nbsp;        staleRequest.future.setException(new TimeoutException());</b>
&nbsp;    }
&nbsp;
&nbsp;    void processResponse(Response response) {
<b class="nc">&nbsp;        byte[] requestIdHeader = response.getHeaders().get(REQUEST_ID_HEADER);</b>
&nbsp;        UUID requestId;
<b class="nc">&nbsp;        if (requestIdHeader == null) {</b>
<b class="nc">&nbsp;            log.error(&quot;[{}] Missing requestId in header and body&quot;, response);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            requestId = bytesToUuid(requestIdHeader);</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}] Response received: {}&quot;, requestId, response);</b>
<b class="nc">&nbsp;            ResponseMetaData&lt;Response&gt; expectedResponse = pendingRequests.remove(requestId);</b>
<b class="nc">&nbsp;            if (expectedResponse == null) {</b>
<b class="nc">&nbsp;                log.debug(&quot;[{}] Invalid or stale request, response: {}&quot;, requestId, String.valueOf(response).replace(&quot;\n&quot;, &quot; &quot;));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                expectedResponse.future.set(response);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void stop() {
<b class="nc">&nbsp;        stopped = true;</b>
&nbsp;
<b class="nc">&nbsp;        if (responseTemplate != null) {</b>
<b class="nc">&nbsp;            responseTemplate.unsubscribe();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (requestTemplate != null) {</b>
<b class="nc">&nbsp;            requestTemplate.stop();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (internalExecutor) {</b>
<b class="nc">&nbsp;            executor.shutdownNow();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void setMessagesStats(MessagesStats messagesStats) {
<b class="nc">&nbsp;        this.messagesStats = messagesStats;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ListenableFuture&lt;Response&gt; send(Request request) {
<b class="nc">&nbsp;        return send(request, this.maxRequestTimeoutNs);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ListenableFuture&lt;Response&gt; send(Request request, long requestTimeoutNs) {
<b class="nc">&nbsp;        return send(request, requestTimeoutNs, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ListenableFuture&lt;Response&gt; send(Request request, Integer partition) {
<b class="nc">&nbsp;        return send(request, this.maxRequestTimeoutNs, partition);</b>
&nbsp;    }
&nbsp;
&nbsp;    private ListenableFuture&lt;Response&gt; send(Request request, long requestTimeoutNs, Integer partition) {
<b class="nc">&nbsp;        if (pendingRequests.mappingCount() &gt;= maxPendingRequests) {</b>
<b class="nc">&nbsp;            log.warn(&quot;Pending request map is full [{}]! Consider to increase maxPendingRequests or increase processing performance. Request is {}&quot;, maxPendingRequests, request);</b>
<b class="nc">&nbsp;            return Futures.immediateFailedFuture(new RuntimeException(&quot;Pending request map is full!&quot;));</b>
&nbsp;        }
<b class="nc">&nbsp;        UUID requestId = UUID.randomUUID();</b>
<b class="nc">&nbsp;        request.getHeaders().put(REQUEST_ID_HEADER, uuidToBytes(requestId));</b>
<b class="nc">&nbsp;        request.getHeaders().put(RESPONSE_TOPIC_HEADER, stringToBytes(responseTemplate.getTopic()));</b>
<b class="nc">&nbsp;        request.getHeaders().put(EXPIRE_TS_HEADER, longToBytes(getCurrentTimeMs() + maxRequestTimeout));</b>
<b class="nc">&nbsp;        long currentClockNs = getCurrentClockNs();</b>
<b class="nc">&nbsp;        SettableFuture&lt;Response&gt; future = SettableFuture.create();</b>
<b class="nc">&nbsp;        ResponseMetaData&lt;Response&gt; responseMetaData = new ResponseMetaData&lt;&gt;(currentClockNs + requestTimeoutNs, future, currentClockNs, requestTimeoutNs);</b>
<b class="nc">&nbsp;        log.trace(&quot;pending {}&quot;, responseMetaData);</b>
<b class="nc">&nbsp;        if (pendingRequests.putIfAbsent(requestId, responseMetaData) != null) {</b>
<b class="nc">&nbsp;            log.warn(&quot;Pending request already exists [{}]!&quot;, maxPendingRequests);</b>
<b class="nc">&nbsp;            return Futures.immediateFailedFuture(new RuntimeException(&quot;Pending request already exists !&quot; + requestId));</b>
&nbsp;        }
<b class="nc">&nbsp;        sendToRequestTemplate(request, requestId, partition, future, responseMetaData);</b>
<b class="nc">&nbsp;        return future;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * MONOTONIC clock instead jumping wall clock.
&nbsp;     * Wrapped into the method for the test purposes to travel through the time
&nbsp;     * */
&nbsp;    long getCurrentClockNs() {
<b class="nc">&nbsp;        return System.nanoTime();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Wall clock to send timestamp to an external service
&nbsp;     * */
&nbsp;    long getCurrentTimeMs() {
<b class="nc">&nbsp;        return System.currentTimeMillis();</b>
&nbsp;    }
&nbsp;
&nbsp;    void sendToRequestTemplate(Request request, UUID requestId, Integer partition, SettableFuture&lt;Response&gt; future, ResponseMetaData&lt;Response&gt; responseMetaData) {
<b class="nc">&nbsp;        log.trace(&quot;[{}] Sending request, key [{}], expTime [{}], request {}&quot;, requestId, request.getKey(), responseMetaData.expTime, request);</b>
<b class="nc">&nbsp;        if (messagesStats != null) {</b>
<b class="nc">&nbsp;            messagesStats.incrementTotal();</b>
&nbsp;        }
<b class="nc">&nbsp;        TopicPartitionInfo tpi = TopicPartitionInfo.builder()</b>
<b class="nc">&nbsp;                .topic(requestTemplate.getDefaultTopic())</b>
<b class="nc">&nbsp;                .partition(partition)</b>
<b class="nc">&nbsp;                .build();</b>
<b class="nc">&nbsp;        requestTemplate.send(tpi, request, new TbQueueCallback() {</b>
&nbsp;            @Override
&nbsp;            public void onSuccess(TbQueueMsgMetadata metadata) {
<b class="nc">&nbsp;                if (messagesStats != null) {</b>
<b class="nc">&nbsp;                    messagesStats.incrementSuccessful();</b>
&nbsp;                }
<b class="nc">&nbsp;                log.trace(&quot;[{}] Request sent: {}, request {}&quot;, requestId, metadata, request);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void onFailure(Throwable t) {
<b class="nc">&nbsp;                if (messagesStats != null) {</b>
<b class="nc">&nbsp;                    messagesStats.incrementFailed();</b>
&nbsp;                }
<b class="nc">&nbsp;                pendingRequests.remove(requestId);</b>
<b class="nc">&nbsp;                future.setException(t);</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    @Getter
&nbsp;    static class ResponseMetaData&lt;T&gt; {
&nbsp;        private final long submitTime;
&nbsp;        private final long timeout;
&nbsp;        private final long expTime;
&nbsp;        private final SettableFuture&lt;T&gt; future;
&nbsp;
<b class="nc">&nbsp;        ResponseMetaData(long ts, SettableFuture&lt;T&gt; future, long submitTime, long timeout) {</b>
<b class="nc">&nbsp;            this.submitTime = submitTime;</b>
<b class="nc">&nbsp;            this.timeout = timeout;</b>
<b class="nc">&nbsp;            this.expTime = ts;</b>
<b class="nc">&nbsp;            this.future = future;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return &quot;ResponseMetaData{&quot; +</b>
&nbsp;                    &quot;submitTime=&quot; + submitTime +
&nbsp;                    &quot;, calculatedExpTime=&quot; + (submitTime + timeout) +
&nbsp;                    &quot;, deltaMs=&quot; + (expTime - submitTime) +
&nbsp;                    &quot;, expTime=&quot; + expTime +
&nbsp;                    &quot;, future=&quot; + future +
&nbsp;                    &#39;}&#39;;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
