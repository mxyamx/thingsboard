<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > DefaultWebSocketService</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.server.service.ws</a>
</div>

<h1>Coverage Summary for Class: DefaultWebSocketService (org.thingsboard.server.service.ws)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DefaultWebSocketService</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/63)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/143)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/305)
  </span>
</td>
</tr>
  <tr>
    <td class="name">DefaultWebSocketService$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/32)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultWebSocketService$10</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultWebSocketService$11</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultWebSocketService$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultWebSocketService$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/27)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultWebSocketService$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultWebSocketService$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultWebSocketService$6</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultWebSocketService$7</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultWebSocketService$8</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultWebSocketService$9</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultWebSocketService$WsCmdHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/97)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/163)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/427)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.server.service.ws;
&nbsp;
&nbsp;import com.fasterxml.jackson.core.JsonProcessingException;
&nbsp;import com.google.common.base.Function;
&nbsp;import com.google.common.util.concurrent.FutureCallback;
&nbsp;import com.google.common.util.concurrent.Futures;
&nbsp;import com.google.common.util.concurrent.ListenableFuture;
&nbsp;import com.google.common.util.concurrent.MoreExecutors;
&nbsp;import jakarta.annotation.Nullable;
&nbsp;import jakarta.annotation.PostConstruct;
&nbsp;import jakarta.annotation.PreDestroy;
&nbsp;import lombok.Getter;
&nbsp;import lombok.RequiredArgsConstructor;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.apache.commons.collections4.CollectionUtils;
&nbsp;import org.springframework.beans.factory.annotation.Value;
&nbsp;import org.springframework.stereotype.Service;
&nbsp;import org.springframework.web.socket.CloseStatus;
&nbsp;import org.thingsboard.common.util.JacksonUtil;
&nbsp;import org.thingsboard.common.util.ThingsBoardExecutors;
&nbsp;import org.thingsboard.server.common.data.AttributeScope;
&nbsp;import org.thingsboard.server.common.data.StringUtils;
&nbsp;import org.thingsboard.server.common.data.TenantProfile;
&nbsp;import org.thingsboard.server.common.data.exception.RateLimitExceededException;
&nbsp;import org.thingsboard.server.common.data.id.CustomerId;
&nbsp;import org.thingsboard.server.common.data.id.EntityId;
&nbsp;import org.thingsboard.server.common.data.id.EntityIdFactory;
&nbsp;import org.thingsboard.server.common.data.id.TenantId;
&nbsp;import org.thingsboard.server.common.data.id.UserId;
&nbsp;import org.thingsboard.server.common.data.kv.Aggregation;
&nbsp;import org.thingsboard.server.common.data.kv.AttributeKvEntry;
&nbsp;import org.thingsboard.server.common.data.kv.BaseReadTsKvQuery;
&nbsp;import org.thingsboard.server.common.data.kv.BasicTsKvEntry;
&nbsp;import org.thingsboard.server.common.data.kv.ReadTsKvQuery;
&nbsp;import org.thingsboard.server.common.data.kv.TsKvEntry;
&nbsp;import org.thingsboard.server.common.data.tenant.profile.DefaultTenantProfileConfiguration;
&nbsp;import org.thingsboard.server.common.msg.tools.TbRateLimitsException;
&nbsp;import org.thingsboard.server.dao.attributes.AttributesService;
&nbsp;import org.thingsboard.server.dao.tenant.TbTenantProfileCache;
&nbsp;import org.thingsboard.server.dao.timeseries.TimeseriesService;
&nbsp;import org.thingsboard.server.exception.UnauthorizedException;
&nbsp;import org.thingsboard.server.queue.discovery.TbServiceInfoProvider;
&nbsp;import org.thingsboard.server.queue.util.TbCoreComponent;
&nbsp;import org.thingsboard.server.service.security.AccessValidator;
&nbsp;import org.thingsboard.server.service.security.ValidationCallback;
&nbsp;import org.thingsboard.server.service.security.ValidationResult;
&nbsp;import org.thingsboard.server.service.security.ValidationResultCode;
&nbsp;import org.thingsboard.server.service.security.model.UserPrincipal;
&nbsp;import org.thingsboard.server.service.security.permission.Operation;
&nbsp;import org.thingsboard.server.service.subscription.SubscriptionErrorCode;
&nbsp;import org.thingsboard.server.service.subscription.TbAttributeSubscription;
&nbsp;import org.thingsboard.server.service.subscription.TbAttributeSubscriptionScope;
&nbsp;import org.thingsboard.server.service.subscription.TbEntityDataSubscriptionService;
&nbsp;import org.thingsboard.server.service.subscription.TbLocalSubscriptionService;
&nbsp;import org.thingsboard.server.service.subscription.TbTimeSeriesSubscription;
&nbsp;import org.thingsboard.server.service.ws.notification.NotificationCommandsHandler;
&nbsp;import org.thingsboard.server.service.ws.telemetry.cmd.v1.AttributesSubscriptionCmd;
&nbsp;import org.thingsboard.server.service.ws.telemetry.cmd.v1.GetHistoryCmd;
&nbsp;import org.thingsboard.server.service.ws.telemetry.cmd.v1.SubscriptionCmd;
&nbsp;import org.thingsboard.server.service.ws.telemetry.cmd.v1.TelemetryPluginCmd;
&nbsp;import org.thingsboard.server.service.ws.telemetry.cmd.v1.TimeseriesSubscriptionCmd;
&nbsp;import org.thingsboard.server.service.ws.telemetry.cmd.v2.AlarmCountCmd;
&nbsp;import org.thingsboard.server.service.ws.telemetry.cmd.v2.AlarmDataCmd;
&nbsp;import org.thingsboard.server.service.ws.telemetry.cmd.v2.AlarmStatusCmd;
&nbsp;import org.thingsboard.server.service.ws.telemetry.cmd.v2.CmdUpdate;
&nbsp;import org.thingsboard.server.service.ws.telemetry.cmd.v2.EntityCountCmd;
&nbsp;import org.thingsboard.server.service.ws.telemetry.cmd.v2.EntityDataCmd;
&nbsp;import org.thingsboard.server.service.ws.telemetry.cmd.v2.EntityDataUpdate;
&nbsp;import org.thingsboard.server.service.ws.telemetry.cmd.v2.UnsubscribeCmd;
&nbsp;import org.thingsboard.server.service.ws.telemetry.sub.TelemetrySubscriptionUpdate;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collections;
&nbsp;import java.util.EnumMap;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Optional;
&nbsp;import java.util.Set;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.concurrent.ConcurrentMap;
&nbsp;import java.util.concurrent.ExecutorService;
&nbsp;import java.util.concurrent.ScheduledExecutorService;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.concurrent.locks.Lock;
&nbsp;import java.util.concurrent.locks.ReentrantLock;
&nbsp;import java.util.function.BiConsumer;
&nbsp;import java.util.function.Consumer;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;import static org.thingsboard.server.common.data.DataConstants.LATEST_TELEMETRY_SCOPE;
&nbsp;
&nbsp;/**
&nbsp; * Created by ashvayka on 27.03.18.
&nbsp; */
&nbsp;@Service
&nbsp;@TbCoreComponent
<b class="nc">&nbsp;@Slf4j</b>
&nbsp;@RequiredArgsConstructor
&nbsp;public class DefaultWebSocketService implements WebSocketService {
&nbsp;
&nbsp;    public static final int NUMBER_OF_PING_ATTEMPTS = 3;
&nbsp;
&nbsp;    private static final int DEFAULT_LIMIT = 100;
<b class="nc">&nbsp;    private static final Aggregation DEFAULT_AGGREGATION = Aggregation.NONE;</b>
&nbsp;    private static final int UNKNOWN_SUBSCRIPTION_ID = 0;
&nbsp;    private static final String PROCESSING_MSG = &quot;[{}] Processing: {}&quot;;
&nbsp;    private static final String FAILED_TO_FETCH_DATA = &quot;Failed to fetch data!&quot;;
&nbsp;    private static final String FAILED_TO_FETCH_ATTRIBUTES = &quot;Failed to fetch attributes!&quot;;
&nbsp;    private static final String SESSION_META_DATA_NOT_FOUND = &quot;Session meta-data not found!&quot;;
&nbsp;
&nbsp;    private final ConcurrentMap&lt;String, WsSessionMetaData&gt; wsSessionsMap = new ConcurrentHashMap&lt;&gt;();
&nbsp;
&nbsp;    private final TbLocalSubscriptionService oldSubService;
&nbsp;    private final TbEntityDataSubscriptionService entityDataSubService;
&nbsp;    private final NotificationCommandsHandler notificationCmdsHandler;
&nbsp;    private final WebSocketMsgEndpoint msgEndpoint;
&nbsp;    private final AccessValidator accessValidator;
&nbsp;    private final AttributesService attributesService;
&nbsp;    private final TimeseriesService tsService;
&nbsp;    private final TbServiceInfoProvider serviceInfoProvider;
&nbsp;    private final TbTenantProfileCache tenantProfileCache;
&nbsp;
&nbsp;    @Value(&quot;${server.ws.ping_timeout:30000}&quot;)
&nbsp;    private long pingTimeout;
&nbsp;
&nbsp;    private final ConcurrentMap&lt;TenantId, Set&lt;String&gt;&gt; tenantSubscriptionsMap = new ConcurrentHashMap&lt;&gt;();
&nbsp;    private final ConcurrentMap&lt;CustomerId, Set&lt;String&gt;&gt; customerSubscriptionsMap = new ConcurrentHashMap&lt;&gt;();
&nbsp;    private final ConcurrentMap&lt;UserId, Set&lt;String&gt;&gt; regularUserSubscriptionsMap = new ConcurrentHashMap&lt;&gt;();
&nbsp;    private final ConcurrentMap&lt;UserId, Set&lt;String&gt;&gt; publicUserSubscriptionsMap = new ConcurrentHashMap&lt;&gt;();
&nbsp;    private final ConcurrentMap&lt;String, Map&lt;Integer, Integer&gt;&gt; sessionCmdMap = new ConcurrentHashMap&lt;&gt;();
&nbsp;
&nbsp;    private ExecutorService executor;
&nbsp;    private ScheduledExecutorService pingExecutor;
&nbsp;    private String serviceId;
&nbsp;
&nbsp;    private Map&lt;WsCmdType, WsCmdHandler&lt;? extends WsCmd&gt;&gt; cmdsHandlers;
&nbsp;
&nbsp;    @PostConstruct
&nbsp;    public void init() {
<b class="nc">&nbsp;        serviceId = serviceInfoProvider.getServiceId();</b>
<b class="nc">&nbsp;        executor = ThingsBoardExecutors.newWorkStealingPool(50, getClass());</b>
&nbsp;
<b class="nc">&nbsp;        pingExecutor = ThingsBoardExecutors.newSingleThreadScheduledExecutor(&quot;telemetry-web-socket-ping&quot;);</b>
<b class="nc">&nbsp;        pingExecutor.scheduleWithFixedDelay(this::sendPing, pingTimeout / NUMBER_OF_PING_ATTEMPTS, pingTimeout / NUMBER_OF_PING_ATTEMPTS, TimeUnit.MILLISECONDS);</b>
&nbsp;
<b class="nc">&nbsp;        cmdsHandlers = new EnumMap&lt;&gt;(WsCmdType.class);</b>
<b class="nc">&nbsp;        cmdsHandlers.put(WsCmdType.ATTRIBUTES, newCmdHandler(this::handleWsAttributesSubscriptionCmd));</b>
<b class="nc">&nbsp;        cmdsHandlers.put(WsCmdType.TIMESERIES, newCmdHandler(this::handleWsTimeseriesSubscriptionCmd));</b>
<b class="nc">&nbsp;        cmdsHandlers.put(WsCmdType.TIMESERIES_HISTORY, newCmdHandler(this::handleWsHistoryCmd));</b>
<b class="nc">&nbsp;        cmdsHandlers.put(WsCmdType.ENTITY_DATA, newCmdHandler(this::handleWsEntityDataCmd));</b>
<b class="nc">&nbsp;        cmdsHandlers.put(WsCmdType.ALARM_DATA, newCmdHandler(this::handleWsAlarmDataCmd));</b>
<b class="nc">&nbsp;        cmdsHandlers.put(WsCmdType.ENTITY_COUNT, newCmdHandler(this::handleWsEntityCountCmd));</b>
<b class="nc">&nbsp;        cmdsHandlers.put(WsCmdType.ALARM_COUNT, newCmdHandler(this::handleWsAlarmCountCmd));</b>
<b class="nc">&nbsp;        cmdsHandlers.put(WsCmdType.ALARM_STATUS, newCmdHandler(this::handleWsAlarmsStatusCmd));</b>
<b class="nc">&nbsp;        cmdsHandlers.put(WsCmdType.ENTITY_DATA_UNSUBSCRIBE, newCmdHandler(this::handleWsDataUnsubscribeCmd));</b>
<b class="nc">&nbsp;        cmdsHandlers.put(WsCmdType.ALARM_DATA_UNSUBSCRIBE, newCmdHandler(this::handleWsDataUnsubscribeCmd));</b>
<b class="nc">&nbsp;        cmdsHandlers.put(WsCmdType.ENTITY_COUNT_UNSUBSCRIBE, newCmdHandler(this::handleWsDataUnsubscribeCmd));</b>
<b class="nc">&nbsp;        cmdsHandlers.put(WsCmdType.ALARM_COUNT_UNSUBSCRIBE, newCmdHandler(this::handleWsDataUnsubscribeCmd));</b>
<b class="nc">&nbsp;        cmdsHandlers.put(WsCmdType.ALARM_STATUS_UNSUBSCRIBE, newCmdHandler(this::handleWsDataUnsubscribeCmd));</b>
<b class="nc">&nbsp;        cmdsHandlers.put(WsCmdType.NOTIFICATIONS, newCmdHandler(notificationCmdsHandler::handleUnreadNotificationsSubCmd));</b>
<b class="nc">&nbsp;        cmdsHandlers.put(WsCmdType.NOTIFICATIONS_COUNT, newCmdHandler(notificationCmdsHandler::handleUnreadNotificationsCountSubCmd));</b>
<b class="nc">&nbsp;        cmdsHandlers.put(WsCmdType.MARK_NOTIFICATIONS_AS_READ, newCmdHandler(notificationCmdsHandler::handleMarkAsReadCmd));</b>
<b class="nc">&nbsp;        cmdsHandlers.put(WsCmdType.MARK_ALL_NOTIFICATIONS_AS_READ, newCmdHandler(notificationCmdsHandler::handleMarkAllAsReadCmd));</b>
<b class="nc">&nbsp;        cmdsHandlers.put(WsCmdType.NOTIFICATIONS_UNSUBSCRIBE, newCmdHandler(notificationCmdsHandler::handleUnsubCmd));</b>
&nbsp;    }
&nbsp;
&nbsp;    @PreDestroy
&nbsp;    public void shutdownExecutor() {
<b class="nc">&nbsp;        if (pingExecutor != null) {</b>
<b class="nc">&nbsp;            pingExecutor.shutdownNow();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (executor != null) {</b>
<b class="nc">&nbsp;            executor.shutdownNow();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void handleSessionEvent(WebSocketSessionRef sessionRef, SessionEvent event) {
<b class="nc">&nbsp;        String sessionId = sessionRef.getSessionId();</b>
<b class="nc">&nbsp;        TenantId tenantId = sessionRef.getSecurityCtx().getTenantId();</b>
<b class="nc">&nbsp;        log.debug(PROCESSING_MSG, sessionId, event);</b>
<b class="nc">&nbsp;        switch (event.getEventType()) {</b>
&nbsp;            case ESTABLISHED:
<b class="nc">&nbsp;                wsSessionsMap.put(sessionId, new WsSessionMetaData(sessionRef));</b>
&nbsp;                break;
&nbsp;            case ERROR:
<b class="nc">&nbsp;                log.debug(&quot;[{}][{}] Unknown websocket session error: &quot;, tenantId, sessionId,</b>
<b class="nc">&nbsp;                        event.getError().orElse(new RuntimeException(&quot;No error specified&quot;)));</b>
&nbsp;                break;
&nbsp;            case CLOSED:
<b class="nc">&nbsp;                cleanupSessionById(tenantId, sessionId);</b>
<b class="nc">&nbsp;                processSessionClose(sessionRef);</b>
&nbsp;                break;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void handleCommands(WebSocketSessionRef sessionRef, WsCommandsWrapper commandsWrapper) {
<b class="nc">&nbsp;        if (commandsWrapper == null || CollectionUtils.isEmpty(commandsWrapper.getCmds())) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        String sessionId = sessionRef.getSessionId();</b>
<b class="nc">&nbsp;        if (!validateSessionMetadata(sessionRef, UNKNOWN_SUBSCRIPTION_ID, sessionId)) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (WsCmd cmd : commandsWrapper.getCmds()) {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}][{}][{}] Processing cmd: {}&quot;, sessionId, cmd.getType(), cmd.getCmdId(), cmd);</b>
&nbsp;            try {
<b class="nc">&nbsp;                Optional.ofNullable(cmdsHandlers.get(cmd.getType()))</b>
<b class="nc">&nbsp;                        .ifPresent(cmdHandler -&gt; cmdHandler.handle(sessionRef, cmd));</b>
&nbsp;            } catch (TbRateLimitsException e) {
<b class="nc">&nbsp;                log.debug(&quot;{} Failed to handle WS cmd: {}&quot;, sessionRef, cmd, e);</b>
&nbsp;            } catch (Exception e) {
<b class="nc">&nbsp;                sendError(sessionRef, cmd.getCmdId(), SubscriptionErrorCode.INTERNAL_ERROR, e.getMessage());</b>
<b class="nc">&nbsp;                log.error(&quot;{} Failed to handle WS cmd: {}&quot;, sessionRef, cmd, e);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void handleWsEntityDataCmd(WebSocketSessionRef sessionRef, EntityDataCmd cmd) {
<b class="nc">&nbsp;        if (validateSubscriptionCmd(sessionRef, cmd)) {</b>
<b class="nc">&nbsp;            entityDataSubService.handleCmd(sessionRef, cmd);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void handleWsEntityCountCmd(WebSocketSessionRef sessionRef, EntityCountCmd cmd) {
<b class="nc">&nbsp;        if (validateSubscriptionCmd(sessionRef, cmd)) {</b>
<b class="nc">&nbsp;            entityDataSubService.handleCmd(sessionRef, cmd);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void handleWsAlarmDataCmd(WebSocketSessionRef sessionRef, AlarmDataCmd cmd) {
<b class="nc">&nbsp;        if (validateSubscriptionCmd(sessionRef, cmd)) {</b>
<b class="nc">&nbsp;            entityDataSubService.handleCmd(sessionRef, cmd);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void handleWsDataUnsubscribeCmd(WebSocketSessionRef sessionRef, UnsubscribeCmd cmd) {
<b class="nc">&nbsp;        entityDataSubService.cancelSubscription(sessionRef.getSessionId(), cmd);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void handleWsAlarmCountCmd(WebSocketSessionRef sessionRef, AlarmCountCmd cmd) {
<b class="nc">&nbsp;        if (validateCmd(sessionRef, cmd)) {</b>
<b class="nc">&nbsp;            entityDataSubService.handleCmd(sessionRef, cmd);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void handleWsAlarmsStatusCmd(WebSocketSessionRef sessionRef, AlarmStatusCmd cmd) {
<b class="nc">&nbsp;        if (validateCmd(sessionRef, cmd)) {</b>
<b class="nc">&nbsp;            entityDataSubService.handleCmd(sessionRef, cmd);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void sendUpdate(String sessionId, int cmdId, TelemetrySubscriptionUpdate update) {
&nbsp;        // We substitute the subscriptionId with cmdId for old-style subscriptions.
<b class="nc">&nbsp;        doSendUpdate(sessionId, cmdId, update.withSubscriptionId(cmdId));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void sendUpdate(String sessionId, CmdUpdate update) {
<b class="nc">&nbsp;        doSendUpdate(sessionId, update.getCmdId(), update);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void sendError(WebSocketSessionRef sessionRef, int subId, SubscriptionErrorCode errorCode, String errorMsg) {
<b class="nc">&nbsp;        TelemetrySubscriptionUpdate update = new TelemetrySubscriptionUpdate(subId, errorCode, errorMsg);</b>
<b class="nc">&nbsp;        sendUpdate(sessionRef, update);</b>
&nbsp;    }
&nbsp;
&nbsp;    private &lt;T&gt; void doSendUpdate(String sessionId, int cmdId, T update) {
<b class="nc">&nbsp;        WsSessionMetaData md = wsSessionsMap.get(sessionId);</b>
<b class="nc">&nbsp;        if (md != null) {</b>
<b class="nc">&nbsp;            sendUpdate(md.getSessionRef(), cmdId, update);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void close(String sessionId, CloseStatus status) {
<b class="nc">&nbsp;        WsSessionMetaData md = wsSessionsMap.get(sessionId);</b>
<b class="nc">&nbsp;        if (md != null) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                msgEndpoint.close(md.getSessionRef(), status);</b>
&nbsp;            } catch (IOException e) {
<b class="nc">&nbsp;                log.warn(&quot;[{}] Failed to send session close&quot;, sessionId, e);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void cleanupIfStale(TenantId tenantId, String sessionId) {
<b class="nc">&nbsp;        if (!msgEndpoint.isOpen(sessionId)) {</b>
<b class="nc">&nbsp;            log.info(&quot;[{}] Cleaning up stale session &quot;, sessionId);</b>
<b class="nc">&nbsp;            cleanupSessionById(tenantId, sessionId);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void processSessionClose(WebSocketSessionRef sessionRef) {
<b class="nc">&nbsp;        var tenantProfileConfiguration = getTenantProfileConfiguration(sessionRef);</b>
<b class="nc">&nbsp;        if (tenantProfileConfiguration != null) {</b>
<b class="nc">&nbsp;            String sessionId = &quot;[&quot; + sessionRef.getSessionId() + &quot;]&quot;;</b>
&nbsp;
<b class="nc">&nbsp;            if (tenantProfileConfiguration.getMaxWsSubscriptionsPerTenant() &gt; 0) {</b>
<b class="nc">&nbsp;                Set&lt;String&gt; tenantSubscriptions = tenantSubscriptionsMap.computeIfAbsent(sessionRef.getSecurityCtx().getTenantId(), id -&gt; ConcurrentHashMap.newKeySet());</b>
<b class="nc">&nbsp;                synchronized (tenantSubscriptions) {</b>
<b class="nc">&nbsp;                    tenantSubscriptions.removeIf(subId -&gt; subId.startsWith(sessionId));</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;            if (sessionRef.getSecurityCtx().isCustomerUser()) {</b>
<b class="nc">&nbsp;                if (tenantProfileConfiguration.getMaxWsSubscriptionsPerCustomer() &gt; 0) {</b>
<b class="nc">&nbsp;                    Set&lt;String&gt; customerSessions = customerSubscriptionsMap.computeIfAbsent(sessionRef.getSecurityCtx().getCustomerId(), id -&gt; ConcurrentHashMap.newKeySet());</b>
<b class="nc">&nbsp;                    synchronized (customerSessions) {</b>
<b class="nc">&nbsp;                        customerSessions.removeIf(subId -&gt; subId.startsWith(sessionId));</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
<b class="nc">&nbsp;                if (tenantProfileConfiguration.getMaxWsSubscriptionsPerRegularUser() &gt; 0 &amp;&amp; UserPrincipal.Type.USER_NAME.equals(sessionRef.getSecurityCtx().getUserPrincipal().getType())) {</b>
<b class="nc">&nbsp;                    Set&lt;String&gt; regularUserSessions = regularUserSubscriptionsMap.computeIfAbsent(sessionRef.getSecurityCtx().getId(), id -&gt; ConcurrentHashMap.newKeySet());</b>
<b class="nc">&nbsp;                    synchronized (regularUserSessions) {</b>
<b class="nc">&nbsp;                        regularUserSessions.removeIf(subId -&gt; subId.startsWith(sessionId));</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
<b class="nc">&nbsp;                if (tenantProfileConfiguration.getMaxWsSubscriptionsPerPublicUser() &gt; 0 &amp;&amp; UserPrincipal.Type.PUBLIC_ID.equals(sessionRef.getSecurityCtx().getUserPrincipal().getType())) {</b>
<b class="nc">&nbsp;                    Set&lt;String&gt; publicUserSessions = publicUserSubscriptionsMap.computeIfAbsent(sessionRef.getSecurityCtx().getId(), id -&gt; ConcurrentHashMap.newKeySet());</b>
<b class="nc">&nbsp;                    synchronized (publicUserSessions) {</b>
<b class="nc">&nbsp;                        publicUserSessions.removeIf(subId -&gt; subId.startsWith(sessionId));</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private boolean processSubscription(WebSocketSessionRef sessionRef, SubscriptionCmd cmd) {
<b class="nc">&nbsp;        var tenantProfileConfiguration = getTenantProfileConfiguration(sessionRef);</b>
<b class="nc">&nbsp;        if (tenantProfileConfiguration == null) return true;</b>
&nbsp;
<b class="nc">&nbsp;        String subId = &quot;[&quot; + sessionRef.getSessionId() + &quot;]:[&quot; + cmd.getCmdId() + &quot;]&quot;;</b>
&nbsp;        try {
<b class="nc">&nbsp;            if (tenantProfileConfiguration.getMaxWsSubscriptionsPerTenant() &gt; 0) {</b>
<b class="nc">&nbsp;                Set&lt;String&gt; tenantSubscriptions = tenantSubscriptionsMap.computeIfAbsent(sessionRef.getSecurityCtx().getTenantId(), id -&gt; ConcurrentHashMap.newKeySet());</b>
<b class="nc">&nbsp;                synchronized (tenantSubscriptions) {</b>
<b class="nc">&nbsp;                    if (cmd.isUnsubscribe()) {</b>
<b class="nc">&nbsp;                        tenantSubscriptions.remove(subId);</b>
<b class="nc">&nbsp;                    } else if (tenantSubscriptions.size() &lt; tenantProfileConfiguration.getMaxWsSubscriptionsPerTenant()) {</b>
<b class="nc">&nbsp;                        tenantSubscriptions.add(subId);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        log.info(&quot;[{}][{}][{}] Failed to start subscription. Max tenant subscriptions limit reached&quot;</b>
<b class="nc">&nbsp;                                , sessionRef.getSecurityCtx().getTenantId(), sessionRef.getSecurityCtx().getId(), subId);</b>
<b class="nc">&nbsp;                        msgEndpoint.close(sessionRef, CloseStatus.POLICY_VIOLATION.withReason(&quot;Max tenant subscriptions limit reached!&quot;));</b>
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (sessionRef.getSecurityCtx().isCustomerUser()) {</b>
<b class="nc">&nbsp;                if (tenantProfileConfiguration.getMaxWsSubscriptionsPerCustomer() &gt; 0) {</b>
<b class="nc">&nbsp;                    Set&lt;String&gt; customerSessions = customerSubscriptionsMap.computeIfAbsent(sessionRef.getSecurityCtx().getCustomerId(), id -&gt; ConcurrentHashMap.newKeySet());</b>
<b class="nc">&nbsp;                    synchronized (customerSessions) {</b>
<b class="nc">&nbsp;                        if (cmd.isUnsubscribe()) {</b>
<b class="nc">&nbsp;                            customerSessions.remove(subId);</b>
<b class="nc">&nbsp;                        } else if (customerSessions.size() &lt; tenantProfileConfiguration.getMaxWsSubscriptionsPerCustomer()) {</b>
<b class="nc">&nbsp;                            customerSessions.add(subId);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            log.info(&quot;[{}][{}][{}] Failed to start subscription. Max customer subscriptions limit reached&quot;</b>
<b class="nc">&nbsp;                                    , sessionRef.getSecurityCtx().getTenantId(), sessionRef.getSecurityCtx().getId(), subId);</b>
<b class="nc">&nbsp;                            msgEndpoint.close(sessionRef, CloseStatus.POLICY_VIOLATION.withReason(&quot;Max customer subscriptions limit reached&quot;));</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
<b class="nc">&nbsp;                if (tenantProfileConfiguration.getMaxWsSubscriptionsPerRegularUser() &gt; 0 &amp;&amp; UserPrincipal.Type.USER_NAME.equals(sessionRef.getSecurityCtx().getUserPrincipal().getType())) {</b>
<b class="nc">&nbsp;                    Set&lt;String&gt; regularUserSessions = regularUserSubscriptionsMap.computeIfAbsent(sessionRef.getSecurityCtx().getId(), id -&gt; ConcurrentHashMap.newKeySet());</b>
<b class="nc">&nbsp;                    synchronized (regularUserSessions) {</b>
<b class="nc">&nbsp;                        if (regularUserSessions.size() &lt; tenantProfileConfiguration.getMaxWsSubscriptionsPerRegularUser()) {</b>
<b class="nc">&nbsp;                            regularUserSessions.add(subId);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            log.info(&quot;[{}][{}][{}] Failed to start subscription. Max regular user subscriptions limit reached&quot;</b>
<b class="nc">&nbsp;                                    , sessionRef.getSecurityCtx().getTenantId(), sessionRef.getSecurityCtx().getId(), subId);</b>
<b class="nc">&nbsp;                            msgEndpoint.close(sessionRef, CloseStatus.POLICY_VIOLATION.withReason(&quot;Max regular user subscriptions limit reached&quot;));</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
<b class="nc">&nbsp;                if (tenantProfileConfiguration.getMaxWsSubscriptionsPerPublicUser() &gt; 0 &amp;&amp; UserPrincipal.Type.PUBLIC_ID.equals(sessionRef.getSecurityCtx().getUserPrincipal().getType())) {</b>
<b class="nc">&nbsp;                    Set&lt;String&gt; publicUserSessions = publicUserSubscriptionsMap.computeIfAbsent(sessionRef.getSecurityCtx().getId(), id -&gt; ConcurrentHashMap.newKeySet());</b>
<b class="nc">&nbsp;                    synchronized (publicUserSessions) {</b>
<b class="nc">&nbsp;                        if (publicUserSessions.size() &lt; tenantProfileConfiguration.getMaxWsSubscriptionsPerPublicUser()) {</b>
<b class="nc">&nbsp;                            publicUserSessions.add(subId);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            log.info(&quot;[{}][{}][{}] Failed to start subscription. Max public user subscriptions limit reached&quot;</b>
<b class="nc">&nbsp;                                    , sessionRef.getSecurityCtx().getTenantId(), sessionRef.getSecurityCtx().getId(), subId);</b>
<b class="nc">&nbsp;                            msgEndpoint.close(sessionRef, CloseStatus.POLICY_VIOLATION.withReason(&quot;Max public user subscriptions limit reached&quot;));</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;            }
&nbsp;        } catch (IOException e) {
<b class="nc">&nbsp;            log.warn(&quot;[{}] Failed to send session close:&quot;, sessionRef.getSessionId(), e);</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void handleWsAttributesSubscriptionCmd(WebSocketSessionRef sessionRef, AttributesSubscriptionCmd cmd) {
<b class="nc">&nbsp;        if (!processSubscription(sessionRef, cmd)) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        String sessionId = sessionRef.getSessionId();</b>
<b class="nc">&nbsp;        if (cmd.isUnsubscribe()) {</b>
<b class="nc">&nbsp;            unsubscribe(sessionRef, cmd, sessionId);</b>
<b class="nc">&nbsp;        } else if (validateSubscriptionCmd(sessionRef, cmd)) {</b>
<b class="nc">&nbsp;            EntityId entityId = EntityIdFactory.getByTypeAndId(cmd.getEntityType(), cmd.getEntityId());</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}] fetching latest attributes ({}) values for device: {}&quot;, sessionId, cmd.getKeys(), entityId);</b>
<b class="nc">&nbsp;            Optional&lt;Set&lt;String&gt;&gt; keysOptional = getKeys(cmd);</b>
<b class="nc">&nbsp;            if (keysOptional.isPresent()) {</b>
<b class="nc">&nbsp;                List&lt;String&gt; keys = new ArrayList&lt;&gt;(keysOptional.get());</b>
<b class="nc">&nbsp;                handleWsAttributesSubscriptionByKeys(sessionRef, cmd, sessionId, entityId, keys);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                handleWsAttributesSubscription(sessionRef, cmd, sessionId, entityId);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void handleWsAttributesSubscriptionByKeys(WebSocketSessionRef sessionRef,
&nbsp;                                                      AttributesSubscriptionCmd cmd, String sessionId, EntityId entityId,
&nbsp;                                                      List&lt;String&gt; keys) {
<b class="nc">&nbsp;        long queryTs = System.currentTimeMillis();</b>
<b class="nc">&nbsp;        FutureCallback&lt;List&lt;AttributeKvEntry&gt;&gt; callback = new FutureCallback&lt;&gt;() {</b>
&nbsp;            @Override
&nbsp;            public void onSuccess(List&lt;AttributeKvEntry&gt; data) {
<b class="nc">&nbsp;                List&lt;TsKvEntry&gt; attributesData = data.stream().map(d -&gt; new BasicTsKvEntry(d.getLastUpdateTs(), d)).collect(Collectors.toList());</b>
&nbsp;
<b class="nc">&nbsp;                Map&lt;String, Long&gt; subState = new HashMap&lt;&gt;(keys.size());</b>
<b class="nc">&nbsp;                keys.forEach(key -&gt; subState.put(key, 0L));</b>
<b class="nc">&nbsp;                attributesData.forEach(v -&gt; subState.put(v.getKey(), v.getTs()));</b>
&nbsp;
<b class="nc">&nbsp;                TbAttributeSubscriptionScope scope = StringUtils.isEmpty(cmd.getScope()) ? TbAttributeSubscriptionScope.ANY_SCOPE : TbAttributeSubscriptionScope.valueOf(cmd.getScope());</b>
&nbsp;
<b class="nc">&nbsp;                Lock subLock = new ReentrantLock();</b>
<b class="nc">&nbsp;                TbAttributeSubscription sub = TbAttributeSubscription.builder()</b>
<b class="nc">&nbsp;                        .serviceId(serviceId)</b>
<b class="nc">&nbsp;                        .sessionId(sessionId)</b>
<b class="nc">&nbsp;                        .subscriptionId(registerNewSessionSubId(sessionId, sessionRef, cmd.getCmdId()))</b>
<b class="nc">&nbsp;                        .tenantId(sessionRef.getSecurityCtx().getTenantId())</b>
<b class="nc">&nbsp;                        .entityId(entityId)</b>
<b class="nc">&nbsp;                        .queryTs(queryTs)</b>
<b class="nc">&nbsp;                        .allKeys(false)</b>
<b class="nc">&nbsp;                        .keyStates(subState)</b>
<b class="nc">&nbsp;                        .scope(scope)</b>
<b class="nc">&nbsp;                        .updateProcessor((subscription, update) -&gt; {</b>
<b class="nc">&nbsp;                            subLock.lock();</b>
&nbsp;                            try {
<b class="nc">&nbsp;                                sendUpdate(subscription.getSessionId(), cmd.getCmdId(), update);</b>
&nbsp;                            } finally {
<b class="nc">&nbsp;                                subLock.unlock();</b>
&nbsp;                            }
&nbsp;                        })
<b class="nc">&nbsp;                        .build();</b>
&nbsp;
<b class="nc">&nbsp;                subLock.lock();</b>
&nbsp;                try {
<b class="nc">&nbsp;                    oldSubService.addSubscription(sub, sessionRef);</b>
<b class="nc">&nbsp;                    sendUpdate(sessionRef, new TelemetrySubscriptionUpdate(cmd.getCmdId(), attributesData));</b>
&nbsp;                } finally {
<b class="nc">&nbsp;                    subLock.unlock();</b>
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void onFailure(Throwable e) {
<b class="nc">&nbsp;                log.error(FAILED_TO_FETCH_ATTRIBUTES, e);</b>
&nbsp;                TelemetrySubscriptionUpdate update;
<b class="nc">&nbsp;                if (e instanceof UnauthorizedException) {</b>
<b class="nc">&nbsp;                    update = new TelemetrySubscriptionUpdate(cmd.getCmdId(), SubscriptionErrorCode.UNAUTHORIZED,</b>
<b class="nc">&nbsp;                            SubscriptionErrorCode.UNAUTHORIZED.getDefaultMsg());</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    update = new TelemetrySubscriptionUpdate(cmd.getCmdId(), SubscriptionErrorCode.INTERNAL_ERROR,</b>
&nbsp;                            FAILED_TO_FETCH_ATTRIBUTES);
&nbsp;                }
<b class="nc">&nbsp;                sendUpdate(sessionRef, update);</b>
&nbsp;            }
&nbsp;        };
&nbsp;
<b class="nc">&nbsp;        if (StringUtils.isEmpty(cmd.getScope())) {</b>
<b class="nc">&nbsp;            accessValidator.validate(sessionRef.getSecurityCtx(), Operation.READ_ATTRIBUTES, entityId, getAttributesFetchCallback(sessionRef.getSecurityCtx().getTenantId(), entityId, keys, callback));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            accessValidator.validate(sessionRef.getSecurityCtx(), Operation.READ_ATTRIBUTES, entityId, getAttributesFetchCallback(sessionRef.getSecurityCtx().getTenantId(), entityId, cmd.getScope(), keys, callback));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private int registerNewSessionSubId(String sessionId, WebSocketSessionRef sessionRef, int cmdId) {
<b class="nc">&nbsp;        var cmdMap = sessionCmdMap.computeIfAbsent(sessionId, id -&gt; new ConcurrentHashMap&lt;&gt;());</b>
<b class="nc">&nbsp;        var subId = sessionRef.getSessionSubIdSeq().incrementAndGet();</b>
<b class="nc">&nbsp;        cmdMap.put(cmdId, subId);</b>
<b class="nc">&nbsp;        return subId;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void handleWsHistoryCmd(WebSocketSessionRef sessionRef, GetHistoryCmd cmd) {
<b class="nc">&nbsp;        if (!validateCmd(sessionRef, cmd, () -&gt; {</b>
<b class="nc">&nbsp;            if (cmd.getEntityId() == null || cmd.getEntityId().isEmpty() || cmd.getEntityType() == null || cmd.getEntityType().isEmpty()) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Device id is empty!&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (cmd.getKeys() == null || cmd.getKeys().isEmpty()) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Keys are empty!&quot;);</b>
&nbsp;            }
&nbsp;        })) return;
&nbsp;
<b class="nc">&nbsp;        EntityId entityId = EntityIdFactory.getByTypeAndId(cmd.getEntityType(), cmd.getEntityId());</b>
<b class="nc">&nbsp;        List&lt;String&gt; keys = new ArrayList&lt;&gt;(getKeys(cmd).orElse(Collections.emptySet()));</b>
<b class="nc">&nbsp;        List&lt;ReadTsKvQuery&gt; queries = keys.stream().map(key -&gt; new BaseReadTsKvQuery(key, cmd.getStartTs(), cmd.getEndTs(), cmd.getInterval(), getLimit(cmd.getLimit()), getAggregation(cmd.getAgg())))</b>
<b class="nc">&nbsp;                .collect(Collectors.toList());</b>
&nbsp;
<b class="nc">&nbsp;        FutureCallback&lt;List&lt;TsKvEntry&gt;&gt; callback = new FutureCallback&lt;List&lt;TsKvEntry&gt;&gt;() {</b>
&nbsp;            @Override
&nbsp;            public void onSuccess(List&lt;TsKvEntry&gt; data) {
<b class="nc">&nbsp;                sendUpdate(sessionRef, new TelemetrySubscriptionUpdate(cmd.getCmdId(), data));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void onFailure(Throwable e) {
&nbsp;                TelemetrySubscriptionUpdate update;
<b class="nc">&nbsp;                if (UnauthorizedException.class.isInstance(e)) {</b>
<b class="nc">&nbsp;                    update = new TelemetrySubscriptionUpdate(cmd.getCmdId(), SubscriptionErrorCode.UNAUTHORIZED,</b>
<b class="nc">&nbsp;                            SubscriptionErrorCode.UNAUTHORIZED.getDefaultMsg());</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    update = new TelemetrySubscriptionUpdate(cmd.getCmdId(), SubscriptionErrorCode.INTERNAL_ERROR,</b>
&nbsp;                            FAILED_TO_FETCH_DATA);
&nbsp;                }
<b class="nc">&nbsp;                sendUpdate(sessionRef, update);</b>
&nbsp;            }
&nbsp;        };
<b class="nc">&nbsp;        accessValidator.validate(sessionRef.getSecurityCtx(), Operation.READ_TELEMETRY, entityId,</b>
<b class="nc">&nbsp;                on(r -&gt; Futures.addCallback(tsService.findAll(sessionRef.getSecurityCtx().getTenantId(), entityId, queries), callback, executor), callback::onFailure));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void handleWsAttributesSubscription(WebSocketSessionRef sessionRef,
&nbsp;                                                AttributesSubscriptionCmd cmd,
&nbsp;                                                String sessionId,
&nbsp;                                                EntityId entityId) {
<b class="nc">&nbsp;        long queryTs = System.currentTimeMillis();</b>
<b class="nc">&nbsp;        FutureCallback&lt;List&lt;AttributeKvEntry&gt;&gt; callback = new FutureCallback&lt;&gt;() {</b>
&nbsp;            @Override
&nbsp;            public void onSuccess(List&lt;AttributeKvEntry&gt; data) {
<b class="nc">&nbsp;                List&lt;TsKvEntry&gt; attributesData = data.stream().map(d -&gt; new BasicTsKvEntry(d.getLastUpdateTs(), d)).collect(Collectors.toList());</b>
&nbsp;
<b class="nc">&nbsp;                Map&lt;String, Long&gt; subState = new HashMap&lt;&gt;(attributesData.size());</b>
<b class="nc">&nbsp;                attributesData.forEach(v -&gt; subState.put(v.getKey(), v.getTs()));</b>
&nbsp;
<b class="nc">&nbsp;                TbAttributeSubscriptionScope scope = StringUtils.isEmpty(cmd.getScope()) ? TbAttributeSubscriptionScope.ANY_SCOPE : TbAttributeSubscriptionScope.valueOf(cmd.getScope());</b>
&nbsp;
<b class="nc">&nbsp;                Lock subLock = new ReentrantLock();</b>
<b class="nc">&nbsp;                TbAttributeSubscription sub = TbAttributeSubscription.builder()</b>
<b class="nc">&nbsp;                        .serviceId(serviceId)</b>
<b class="nc">&nbsp;                        .sessionId(sessionId)</b>
<b class="nc">&nbsp;                        .subscriptionId(registerNewSessionSubId(sessionId, sessionRef, cmd.getCmdId()))</b>
<b class="nc">&nbsp;                        .tenantId(sessionRef.getSecurityCtx().getTenantId())</b>
<b class="nc">&nbsp;                        .entityId(entityId)</b>
<b class="nc">&nbsp;                        .queryTs(queryTs)</b>
<b class="nc">&nbsp;                        .allKeys(true)</b>
<b class="nc">&nbsp;                        .keyStates(subState)</b>
<b class="nc">&nbsp;                        .updateProcessor((subscription, update) -&gt; {</b>
<b class="nc">&nbsp;                            subLock.lock();</b>
&nbsp;                            try {
<b class="nc">&nbsp;                                sendUpdate(subscription.getSessionId(), cmd.getCmdId(), update);</b>
&nbsp;                            } finally {
<b class="nc">&nbsp;                                subLock.unlock();</b>
&nbsp;                            }
&nbsp;                        })
<b class="nc">&nbsp;                        .scope(scope)</b>
<b class="nc">&nbsp;                        .build();</b>
&nbsp;
<b class="nc">&nbsp;                subLock.lock();</b>
&nbsp;                try {
<b class="nc">&nbsp;                    oldSubService.addSubscription(sub, sessionRef);</b>
<b class="nc">&nbsp;                    sendUpdate(sessionRef, new TelemetrySubscriptionUpdate(cmd.getCmdId(), attributesData));</b>
&nbsp;                } finally {
<b class="nc">&nbsp;                    subLock.unlock();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void onFailure(Throwable e) {
<b class="nc">&nbsp;                log.error(FAILED_TO_FETCH_ATTRIBUTES, e);</b>
<b class="nc">&nbsp;                sendError(sessionRef, cmd.getCmdId(), SubscriptionErrorCode.INTERNAL_ERROR, FAILED_TO_FETCH_ATTRIBUTES);</b>
&nbsp;            }
&nbsp;        };
&nbsp;
&nbsp;
<b class="nc">&nbsp;        if (StringUtils.isEmpty(cmd.getScope())) {</b>
<b class="nc">&nbsp;            accessValidator.validate(sessionRef.getSecurityCtx(), Operation.READ_ATTRIBUTES, entityId, getAttributesFetchCallback(sessionRef.getSecurityCtx().getTenantId(), entityId, callback));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            accessValidator.validate(sessionRef.getSecurityCtx(), Operation.READ_ATTRIBUTES, entityId, getAttributesFetchCallback(sessionRef.getSecurityCtx().getTenantId(), entityId, cmd.getScope(), callback));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void handleWsTimeseriesSubscriptionCmd(WebSocketSessionRef sessionRef, TimeseriesSubscriptionCmd cmd) {
<b class="nc">&nbsp;        if (!processSubscription(sessionRef, cmd)) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        String sessionId = sessionRef.getSessionId();</b>
<b class="nc">&nbsp;        if (cmd.isUnsubscribe()) {</b>
<b class="nc">&nbsp;            unsubscribe(sessionRef, cmd, sessionId);</b>
<b class="nc">&nbsp;        } else if (validateSubscriptionCmd(sessionRef, cmd)) {</b>
<b class="nc">&nbsp;            EntityId entityId = EntityIdFactory.getByTypeAndId(cmd.getEntityType(), cmd.getEntityId());</b>
<b class="nc">&nbsp;            Optional&lt;Set&lt;String&gt;&gt; keysOptional = getKeys(cmd);</b>
&nbsp;
<b class="nc">&nbsp;            if (keysOptional.isPresent()) {</b>
<b class="nc">&nbsp;                handleWsTimeSeriesSubscriptionByKeys(sessionRef, cmd, sessionId, entityId);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                handleWsTimeSeriesSubscription(sessionRef, cmd, sessionId, entityId);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void handleWsTimeSeriesSubscriptionByKeys(WebSocketSessionRef sessionRef,
&nbsp;                                                      TimeseriesSubscriptionCmd cmd, String sessionId, EntityId entityId) {
&nbsp;        long startTs;
<b class="nc">&nbsp;        long queryTs = System.currentTimeMillis();</b>
<b class="nc">&nbsp;        if (cmd.getTimeWindow() &gt; 0) {</b>
<b class="nc">&nbsp;            List&lt;String&gt; keys = new ArrayList&lt;&gt;(getKeys(cmd).orElse(Collections.emptySet()));</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}] fetching timeseries data for last {} ms for keys: ({}) for device : {}&quot;, sessionId, cmd.getTimeWindow(), cmd.getKeys(), entityId);</b>
<b class="nc">&nbsp;            startTs = cmd.getStartTs();</b>
<b class="nc">&nbsp;            long endTs = cmd.getStartTs() + cmd.getTimeWindow();</b>
<b class="nc">&nbsp;            List&lt;ReadTsKvQuery&gt; queries = keys.stream().map(key -&gt; new BaseReadTsKvQuery(key, startTs, endTs, cmd.getInterval(),</b>
<b class="nc">&nbsp;                    getLimit(cmd.getLimit()), getAggregation(cmd.getAgg()))).collect(Collectors.toList());</b>
<b class="nc">&nbsp;            final FutureCallback&lt;List&lt;TsKvEntry&gt;&gt; callback = getSubscriptionCallback(sessionRef, cmd, sessionId, entityId, queryTs, startTs, keys);</b>
<b class="nc">&nbsp;            accessValidator.validate(sessionRef.getSecurityCtx(), Operation.READ_TELEMETRY, entityId,</b>
<b class="nc">&nbsp;                    on(r -&gt; Futures.addCallback(tsService.findAll(sessionRef.getSecurityCtx().getTenantId(), entityId, queries), callback, executor), callback::onFailure));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            List&lt;String&gt; keys = new ArrayList&lt;&gt;(getKeys(cmd).orElse(Collections.emptySet()));</b>
<b class="nc">&nbsp;            startTs = System.currentTimeMillis();</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}] fetching latest timeseries data for keys: ({}) for device : {}&quot;, sessionId, cmd.getKeys(), entityId);</b>
<b class="nc">&nbsp;            final FutureCallback&lt;List&lt;TsKvEntry&gt;&gt; callback = getSubscriptionCallback(sessionRef, cmd, sessionId, entityId, queryTs, startTs, keys);</b>
<b class="nc">&nbsp;            accessValidator.validate(sessionRef.getSecurityCtx(), Operation.READ_TELEMETRY, entityId,</b>
<b class="nc">&nbsp;                    on(r -&gt; Futures.addCallback(tsService.findLatest(sessionRef.getSecurityCtx().getTenantId(), entityId, keys), callback, executor), callback::onFailure));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void handleWsTimeSeriesSubscription(WebSocketSessionRef sessionRef,
&nbsp;                                                TimeseriesSubscriptionCmd cmd, String sessionId, EntityId entityId) {
<b class="nc">&nbsp;        long queryTs = System.currentTimeMillis();</b>
<b class="nc">&nbsp;        FutureCallback&lt;List&lt;TsKvEntry&gt;&gt; callback = new FutureCallback&lt;List&lt;TsKvEntry&gt;&gt;() {</b>
&nbsp;            @Override
&nbsp;            public void onSuccess(List&lt;TsKvEntry&gt; data) {
<b class="nc">&nbsp;                Map&lt;String, Long&gt; subState = new HashMap&lt;&gt;(data.size());</b>
<b class="nc">&nbsp;                data.forEach(v -&gt; subState.put(v.getKey(), v.getTs()));</b>
&nbsp;
<b class="nc">&nbsp;                Lock subLock = new ReentrantLock();</b>
<b class="nc">&nbsp;                TbTimeSeriesSubscription sub = getTsSubscription(subState, subLock, sessionId, sessionRef, cmd, entityId, queryTs, true);</b>
&nbsp;
<b class="nc">&nbsp;                subLock.lock();</b>
&nbsp;                try {
<b class="nc">&nbsp;                    oldSubService.addSubscription(sub, sessionRef);</b>
<b class="nc">&nbsp;                    sendUpdate(sessionRef, new TelemetrySubscriptionUpdate(cmd.getCmdId(), data));</b>
&nbsp;                } finally {
<b class="nc">&nbsp;                    subLock.unlock();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void onFailure(Throwable e) {
&nbsp;                TelemetrySubscriptionUpdate update;
<b class="nc">&nbsp;                if (UnauthorizedException.class.isInstance(e)) {</b>
<b class="nc">&nbsp;                    update = new TelemetrySubscriptionUpdate(cmd.getCmdId(), SubscriptionErrorCode.UNAUTHORIZED,</b>
<b class="nc">&nbsp;                            SubscriptionErrorCode.UNAUTHORIZED.getDefaultMsg());</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    update = new TelemetrySubscriptionUpdate(cmd.getCmdId(), SubscriptionErrorCode.INTERNAL_ERROR,</b>
&nbsp;                            FAILED_TO_FETCH_DATA);
&nbsp;                }
<b class="nc">&nbsp;                sendUpdate(sessionRef, update);</b>
&nbsp;            }
&nbsp;        };
<b class="nc">&nbsp;        accessValidator.validate(sessionRef.getSecurityCtx(), Operation.READ_TELEMETRY, entityId,</b>
<b class="nc">&nbsp;                on(r -&gt; Futures.addCallback(tsService.findAllLatest(sessionRef.getSecurityCtx().getTenantId(), entityId), callback, executor), callback::onFailure));</b>
&nbsp;    }
&nbsp;
&nbsp;    private TbTimeSeriesSubscription getTsSubscription(Map&lt;String, Long&gt; subState, Lock subLock, String sessionId, WebSocketSessionRef sessionRef, TimeseriesSubscriptionCmd cmd, EntityId entityId, long queryTs, boolean allKeys) {
<b class="nc">&nbsp;        return TbTimeSeriesSubscription.builder()</b>
<b class="nc">&nbsp;                .serviceId(serviceId)</b>
<b class="nc">&nbsp;                .sessionId(sessionId)</b>
<b class="nc">&nbsp;                .subscriptionId(registerNewSessionSubId(sessionId, sessionRef, cmd.getCmdId()))</b>
<b class="nc">&nbsp;                .tenantId(sessionRef.getSecurityCtx().getTenantId())</b>
<b class="nc">&nbsp;                .entityId(entityId)</b>
<b class="nc">&nbsp;                .updateProcessor((subscription, update) -&gt; {</b>
<b class="nc">&nbsp;                    subLock.lock();</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        sendUpdate(subscription.getSessionId(), cmd.getCmdId(), update);</b>
&nbsp;                    } finally {
<b class="nc">&nbsp;                        subLock.unlock();</b>
&nbsp;                    }
&nbsp;                })
<b class="nc">&nbsp;                .queryTs(queryTs)</b>
<b class="nc">&nbsp;                .allKeys(allKeys)</b>
<b class="nc">&nbsp;                .keyStates(subState)</b>
<b class="nc">&nbsp;                .latestValues(LATEST_TELEMETRY_SCOPE.equals(cmd.getScope()))</b>
<b class="nc">&nbsp;                .build();</b>
&nbsp;    }
&nbsp;
&nbsp;    private FutureCallback&lt;List&lt;TsKvEntry&gt;&gt; getSubscriptionCallback(final WebSocketSessionRef sessionRef, final TimeseriesSubscriptionCmd cmd,
&nbsp;                                                                    final String sessionId, final EntityId entityId, final long queryTs, final long startTs, final List&lt;String&gt; keys) {
<b class="nc">&nbsp;        return new FutureCallback&lt;&gt;() {</b>
&nbsp;            @Override
&nbsp;            public void onSuccess(List&lt;TsKvEntry&gt; data) {
<b class="nc">&nbsp;                Map&lt;String, Long&gt; subState = new HashMap&lt;&gt;(keys.size());</b>
<b class="nc">&nbsp;                keys.forEach(key -&gt; subState.put(key, startTs));</b>
<b class="nc">&nbsp;                data.forEach(v -&gt; subState.put(v.getKey(), v.getTs()));</b>
&nbsp;
<b class="nc">&nbsp;                Lock subLock = new ReentrantLock();</b>
<b class="nc">&nbsp;                TbTimeSeriesSubscription sub = getTsSubscription(subState, subLock, sessionId, sessionRef, cmd, entityId, queryTs, false);</b>
&nbsp;
<b class="nc">&nbsp;                subLock.lock();</b>
&nbsp;                try {
<b class="nc">&nbsp;                    oldSubService.addSubscription(sub, sessionRef);</b>
<b class="nc">&nbsp;                    sendUpdate(sessionRef, new TelemetrySubscriptionUpdate(cmd.getCmdId(), data));</b>
&nbsp;                } finally {
<b class="nc">&nbsp;                    subLock.unlock();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void onFailure(Throwable e) {
<b class="nc">&nbsp;                if (e instanceof RateLimitExceededException || e.getCause() instanceof RateLimitExceededException) {</b>
<b class="nc">&nbsp;                    log.trace(&quot;[{}] Tenant rate limit detected for subscription: [{}]:{}&quot;, sessionRef.getSecurityCtx().getTenantId(), entityId, cmd);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    log.info(FAILED_TO_FETCH_DATA, e);</b>
&nbsp;                }
<b class="nc">&nbsp;                sendError(sessionRef, cmd.getCmdId(), SubscriptionErrorCode.INTERNAL_ERROR, FAILED_TO_FETCH_DATA);</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    private void unsubscribe(WebSocketSessionRef sessionRef, SubscriptionCmd cmd, String sessionId) {
<b class="nc">&nbsp;        TenantId tenantId = sessionRef.getSecurityCtx().getTenantId();</b>
<b class="nc">&nbsp;        if (cmd.getEntityId() == null || cmd.getEntityId().isEmpty()) {</b>
<b class="nc">&nbsp;            log.warn(&quot;[{}][{}][{}] Cleanup session due to empty entity id.&quot;, tenantId, sessionId, cmd.getCmdId());</b>
<b class="nc">&nbsp;            cleanupSessionById(tenantId, sessionId);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            Integer subId = sessionCmdMap.getOrDefault(sessionId, Collections.emptyMap()).remove(cmd.getCmdId());</b>
<b class="nc">&nbsp;            if (subId == null) {</b>
<b class="nc">&nbsp;                log.trace(&quot;[{}][{}][{}] Failed to lookup subscription id mapping&quot;, tenantId, sessionId, cmd.getCmdId());</b>
<b class="nc">&nbsp;                subId = cmd.getCmdId();</b>
&nbsp;            }
<b class="nc">&nbsp;            oldSubService.cancelSubscription(tenantId, sessionId, subId);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void cleanupSessionById(TenantId tenantId, String sessionId) {
<b class="nc">&nbsp;        wsSessionsMap.remove(sessionId);</b>
<b class="nc">&nbsp;        oldSubService.cancelAllSessionSubscriptions(tenantId, sessionId);</b>
<b class="nc">&nbsp;        sessionCmdMap.remove(sessionId);</b>
<b class="nc">&nbsp;        entityDataSubService.cancelAllSessionSubscriptions(sessionId);</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean validateSubscriptionCmd(WebSocketSessionRef sessionRef, EntityDataCmd cmd) {
<b class="nc">&nbsp;        return validateCmd(sessionRef, cmd, () -&gt; {</b>
<b class="nc">&nbsp;            if (cmd.getQuery() == null &amp;&amp; !cmd.hasAnyCmd()) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Query is empty!&quot;);</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    private boolean validateSubscriptionCmd(WebSocketSessionRef sessionRef, EntityCountCmd cmd) {
<b class="nc">&nbsp;        return validateCmd(sessionRef, cmd, () -&gt; {</b>
<b class="nc">&nbsp;            if (cmd.getQuery() == null) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Query is empty!&quot;);</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    private boolean validateSubscriptionCmd(WebSocketSessionRef sessionRef, AlarmDataCmd cmd) {
<b class="nc">&nbsp;        return validateCmd(sessionRef, cmd, () -&gt; {</b>
<b class="nc">&nbsp;            if (cmd.getQuery() == null) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Query is empty!&quot;);</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    private boolean validateSubscriptionCmd(WebSocketSessionRef sessionRef, SubscriptionCmd cmd) {
<b class="nc">&nbsp;        return validateCmd(sessionRef, cmd, () -&gt; {</b>
<b class="nc">&nbsp;            if (cmd.getEntityId() == null || cmd.getEntityId().isEmpty()) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Device id is empty!&quot;);</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    private boolean validateSessionMetadata(WebSocketSessionRef sessionRef, int cmdId, String sessionId) {
<b class="nc">&nbsp;        WsSessionMetaData sessionMD = wsSessionsMap.get(sessionId);</b>
<b class="nc">&nbsp;        if (sessionMD == null) {</b>
<b class="nc">&nbsp;            log.warn(&quot;[{}] Session meta data not found. &quot;, sessionId);</b>
<b class="nc">&nbsp;            sendError(sessionRef, cmdId, SubscriptionErrorCode.INTERNAL_ERROR, SESSION_META_DATA_NOT_FOUND);</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private boolean validateCmd(WebSocketSessionRef sessionRef, WsCmd cmd) {
<b class="nc">&nbsp;        return validateCmd(sessionRef, cmd, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    private &lt;C extends WsCmd&gt; boolean validateCmd(WebSocketSessionRef sessionRef, C cmd, Runnable validator) {
<b class="nc">&nbsp;        if (cmd.getCmdId() &lt; 0) {</b>
<b class="nc">&nbsp;            sendError(sessionRef, cmd.getCmdId(), SubscriptionErrorCode.BAD_REQUEST, &quot;Cmd id is negative value!&quot;);</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        try {
<b class="nc">&nbsp;            if (validator != null) {</b>
<b class="nc">&nbsp;                validator.run();</b>
&nbsp;            }
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            sendError(sessionRef, cmd.getCmdId(), SubscriptionErrorCode.BAD_REQUEST, e.getMessage());</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void sendUpdate(WebSocketSessionRef sessionRef, EntityDataUpdate update) {
<b class="nc">&nbsp;        sendUpdate(sessionRef, update.getCmdId(), update);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void sendUpdate(WebSocketSessionRef sessionRef, TelemetrySubscriptionUpdate update) {
<b class="nc">&nbsp;        sendUpdate(sessionRef, update.getSubscriptionId(), update);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void sendUpdate(WebSocketSessionRef sessionRef, int cmdId, Object update) {
&nbsp;        try {
<b class="nc">&nbsp;            String msg = JacksonUtil.OBJECT_MAPPER.writeValueAsString(update);</b>
<b class="nc">&nbsp;            executor.submit(() -&gt; {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    msgEndpoint.send(sessionRef, cmdId, msg);</b>
&nbsp;                } catch (IOException e) {
<b class="nc">&nbsp;                    log.warn(&quot;[{}] Failed to send reply: {}&quot;, sessionRef.getSessionId(), update, e);</b>
&nbsp;                }
&nbsp;            });
&nbsp;        } catch (JsonProcessingException e) {
<b class="nc">&nbsp;            log.warn(&quot;[{}] Failed to encode reply: {}&quot;, sessionRef.getSessionId(), update, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void sendPing() {
<b class="nc">&nbsp;        long currentTime = System.currentTimeMillis();</b>
<b class="nc">&nbsp;        wsSessionsMap.values().forEach(md -&gt;</b>
<b class="nc">&nbsp;                executor.submit(() -&gt; {</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        msgEndpoint.sendPing(md.getSessionRef(), currentTime);</b>
&nbsp;                    } catch (IOException e) {
<b class="nc">&nbsp;                        log.warn(&quot;[{}] Failed to send ping:&quot;, md.getSessionRef().getSessionId(), e);</b>
&nbsp;                    }
&nbsp;                }));
&nbsp;    }
&nbsp;
&nbsp;    private static Optional&lt;Set&lt;String&gt;&gt; getKeys(TelemetryPluginCmd cmd) {
<b class="nc">&nbsp;        if (!StringUtils.isEmpty(cmd.getKeys())) {</b>
<b class="nc">&nbsp;            Set&lt;String&gt; keys = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;            Collections.addAll(keys, cmd.getKeys().split(&quot;,&quot;));</b>
<b class="nc">&nbsp;            return Optional.of(keys);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return Optional.empty();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private ListenableFuture&lt;List&lt;AttributeKvEntry&gt;&gt; mergeAllAttributesFutures(List&lt;ListenableFuture&lt;List&lt;AttributeKvEntry&gt;&gt;&gt; futures) {
<b class="nc">&nbsp;        return Futures.transform(Futures.successfulAsList(futures),</b>
&nbsp;                (Function&lt;? super List&lt;List&lt;AttributeKvEntry&gt;&gt;, ? extends List&lt;AttributeKvEntry&gt;&gt;) input -&gt; {
<b class="nc">&nbsp;                    List&lt;AttributeKvEntry&gt; tmp = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;                    if (input != null) {</b>
<b class="nc">&nbsp;                        input.forEach(tmp::addAll);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return tmp;</b>
&nbsp;                }, executor);
&nbsp;    }
&nbsp;
&nbsp;    private &lt;T&gt; FutureCallback&lt;ValidationResult&gt; getAttributesFetchCallback(final TenantId tenantId, final EntityId entityId, final List&lt;String&gt; keys, final FutureCallback&lt;List&lt;AttributeKvEntry&gt;&gt; callback) {
<b class="nc">&nbsp;        return new FutureCallback&lt;ValidationResult&gt;() {</b>
&nbsp;            @Override
&nbsp;            public void onSuccess(@Nullable ValidationResult result) {
<b class="nc">&nbsp;                List&lt;ListenableFuture&lt;List&lt;AttributeKvEntry&gt;&gt;&gt; futures = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;                for (AttributeScope scope : AttributeScope.values()) {</b>
<b class="nc">&nbsp;                    futures.add(attributesService.find(tenantId, entityId, scope, keys));</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                ListenableFuture&lt;List&lt;AttributeKvEntry&gt;&gt; future = mergeAllAttributesFutures(futures);</b>
<b class="nc">&nbsp;                Futures.addCallback(future, callback, MoreExecutors.directExecutor());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void onFailure(Throwable t) {
<b class="nc">&nbsp;                callback.onFailure(t);</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    private &lt;T&gt; FutureCallback&lt;ValidationResult&gt; getAttributesFetchCallback(final TenantId tenantId, final EntityId entityId, final String scope, final List&lt;String&gt; keys, final FutureCallback&lt;List&lt;AttributeKvEntry&gt;&gt; callback) {
<b class="nc">&nbsp;        return new FutureCallback&lt;ValidationResult&gt;() {</b>
&nbsp;            @Override
&nbsp;            public void onSuccess(@Nullable ValidationResult result) {
<b class="nc">&nbsp;                Futures.addCallback(attributesService.find(tenantId, entityId, AttributeScope.valueOf(scope), keys), callback, MoreExecutors.directExecutor());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void onFailure(Throwable t) {
<b class="nc">&nbsp;                callback.onFailure(t);</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    private &lt;T&gt; FutureCallback&lt;ValidationResult&gt; getAttributesFetchCallback(final TenantId tenantId, final EntityId entityId, final FutureCallback&lt;List&lt;AttributeKvEntry&gt;&gt; callback) {
<b class="nc">&nbsp;        return new FutureCallback&lt;ValidationResult&gt;() {</b>
&nbsp;            @Override
&nbsp;            public void onSuccess(@Nullable ValidationResult result) {
<b class="nc">&nbsp;                List&lt;ListenableFuture&lt;List&lt;AttributeKvEntry&gt;&gt;&gt; futures = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;                for (AttributeScope scope : AttributeScope.values()) {</b>
<b class="nc">&nbsp;                    futures.add(attributesService.findAll(tenantId, entityId, scope));</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                ListenableFuture&lt;List&lt;AttributeKvEntry&gt;&gt; future = mergeAllAttributesFutures(futures);</b>
<b class="nc">&nbsp;                Futures.addCallback(future, callback, MoreExecutors.directExecutor());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void onFailure(Throwable t) {
<b class="nc">&nbsp;                callback.onFailure(t);</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    private &lt;T&gt; FutureCallback&lt;ValidationResult&gt; getAttributesFetchCallback(final TenantId tenantId, final EntityId entityId, final String scope, final FutureCallback&lt;List&lt;AttributeKvEntry&gt;&gt; callback) {
<b class="nc">&nbsp;        return new FutureCallback&lt;ValidationResult&gt;() {</b>
&nbsp;            @Override
&nbsp;            public void onSuccess(@Nullable ValidationResult result) {
<b class="nc">&nbsp;                Futures.addCallback(attributesService.findAll(tenantId, entityId, AttributeScope.valueOf(scope)), callback, MoreExecutors.directExecutor());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void onFailure(Throwable t) {
<b class="nc">&nbsp;                callback.onFailure(t);</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    private FutureCallback&lt;ValidationResult&gt; on(Consumer&lt;Void&gt; success, Consumer&lt;Throwable&gt; failure) {
<b class="nc">&nbsp;        return new FutureCallback&lt;ValidationResult&gt;() {</b>
&nbsp;            @Override
&nbsp;            public void onSuccess(@Nullable ValidationResult result) {
<b class="nc">&nbsp;                ValidationResultCode resultCode = result.getResultCode();</b>
<b class="nc">&nbsp;                if (resultCode == ValidationResultCode.OK) {</b>
<b class="nc">&nbsp;                    success.accept(null);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    onFailure(ValidationCallback.getException(result));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void onFailure(Throwable t) {
<b class="nc">&nbsp;                failure.accept(t);</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    public static Aggregation getAggregation(String agg) {
<b class="nc">&nbsp;        return StringUtils.isEmpty(agg) ? DEFAULT_AGGREGATION : Aggregation.valueOf(agg);</b>
&nbsp;    }
&nbsp;
&nbsp;    private int getLimit(int limit) {
<b class="nc">&nbsp;        return limit == 0 ? DEFAULT_LIMIT : limit;</b>
&nbsp;    }
&nbsp;
&nbsp;    private DefaultTenantProfileConfiguration getTenantProfileConfiguration(WebSocketSessionRef sessionRef) {
<b class="nc">&nbsp;        return Optional.ofNullable(tenantProfileCache.get(sessionRef.getSecurityCtx().getTenantId()))</b>
<b class="nc">&nbsp;                .map(TenantProfile::getDefaultProfileConfiguration).orElse(null);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static &lt;C extends WsCmd&gt; WsCmdHandler&lt;C&gt; newCmdHandler(BiConsumer&lt;WebSocketSessionRef, C&gt; handler) {
<b class="nc">&nbsp;        return new WsCmdHandler&lt;&gt;(handler);</b>
&nbsp;    }
&nbsp;
&nbsp;    @RequiredArgsConstructor
&nbsp;    @Getter
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public static class WsCmdHandler&lt;C extends WsCmd&gt; {
&nbsp;        protected final BiConsumer&lt;WebSocketSessionRef, C&gt; handler;
&nbsp;
&nbsp;        public void handle(WebSocketSessionRef sessionRef, WsCmd cmd) {
<b class="nc">&nbsp;            handler.accept(sessionRef, (C) cmd);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
