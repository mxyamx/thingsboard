<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > CassandraBaseTimeseriesDao</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.server.dao.timeseries</a>
</div>

<h1>Coverage Summary for Class: CassandraBaseTimeseriesDao (org.thingsboard.server.dao.timeseries)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">CassandraBaseTimeseriesDao</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/45)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/124)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/298)
  </span>
</td>
</tr>
  <tr>
    <td class="name">CassandraBaseTimeseriesDao$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CassandraBaseTimeseriesDao$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CassandraBaseTimeseriesDao$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CassandraBaseTimeseriesDao$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CassandraBaseTimeseriesDao$4$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CassandraBaseTimeseriesDao$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CassandraBaseTimeseriesDao$6</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CassandraBaseTimeseriesDao$CacheCallback</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/66)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/134)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/336)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.server.dao.timeseries;
&nbsp;
&nbsp;import com.datastax.oss.driver.api.core.cql.AsyncResultSet;
&nbsp;import com.datastax.oss.driver.api.core.cql.BoundStatement;
&nbsp;import com.datastax.oss.driver.api.core.cql.BoundStatementBuilder;
&nbsp;import com.datastax.oss.driver.api.core.cql.PreparedStatement;
&nbsp;import com.datastax.oss.driver.api.core.cql.Row;
&nbsp;import com.datastax.oss.driver.api.querybuilder.QueryBuilder;
&nbsp;import com.datastax.oss.driver.api.querybuilder.select.Select;
&nbsp;import com.google.common.base.Function;
&nbsp;import com.google.common.util.concurrent.AsyncFunction;
&nbsp;import com.google.common.util.concurrent.FutureCallback;
&nbsp;import com.google.common.util.concurrent.Futures;
&nbsp;import com.google.common.util.concurrent.ListenableFuture;
&nbsp;import com.google.common.util.concurrent.MoreExecutors;
&nbsp;import jakarta.annotation.Nullable;
&nbsp;import jakarta.annotation.PostConstruct;
&nbsp;import jakarta.annotation.PreDestroy;
&nbsp;import lombok.Getter;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.springframework.beans.factory.annotation.Autowired;
&nbsp;import org.springframework.beans.factory.annotation.Value;
&nbsp;import org.springframework.core.env.Environment;
&nbsp;import org.springframework.core.env.Profiles;
&nbsp;import org.springframework.stereotype.Component;
&nbsp;import org.thingsboard.server.common.data.id.EntityId;
&nbsp;import org.thingsboard.server.common.data.id.TenantId;
&nbsp;import org.thingsboard.server.common.data.kv.Aggregation;
&nbsp;import org.thingsboard.server.common.data.kv.BaseReadTsKvQuery;
&nbsp;import org.thingsboard.server.common.data.kv.DataType;
&nbsp;import org.thingsboard.server.common.data.kv.DeleteTsKvQuery;
&nbsp;import org.thingsboard.server.common.data.kv.IntervalType;
&nbsp;import org.thingsboard.server.common.data.kv.KvEntry;
&nbsp;import org.thingsboard.server.common.data.kv.ReadTsKvQuery;
&nbsp;import org.thingsboard.server.common.data.kv.ReadTsKvQueryResult;
&nbsp;import org.thingsboard.server.common.data.kv.TsKvEntry;
&nbsp;import org.thingsboard.server.common.data.kv.TsKvEntryAggWrapper;
&nbsp;import org.thingsboard.server.common.data.kv.TsKvQuery;
&nbsp;import org.thingsboard.server.dao.model.ModelConstants;
&nbsp;import org.thingsboard.server.dao.nosql.TbResultSet;
&nbsp;import org.thingsboard.server.dao.nosql.TbResultSetFuture;
&nbsp;import org.thingsboard.server.dao.sqlts.AggregationTimeseriesDao;
&nbsp;import org.thingsboard.server.dao.util.NoSqlTsDao;
&nbsp;import org.thingsboard.server.dao.util.TimeUtils;
&nbsp;
&nbsp;import java.time.Instant;
&nbsp;import java.time.LocalDateTime;
&nbsp;import java.time.ZoneOffset;
&nbsp;import java.time.temporal.ChronoUnit;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collections;
&nbsp;import java.util.List;
&nbsp;import java.util.Optional;
&nbsp;import java.util.UUID;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.concurrent.locks.Lock;
&nbsp;import java.util.concurrent.locks.ReentrantLock;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;import static com.datastax.oss.driver.api.querybuilder.QueryBuilder.literal;
&nbsp;
&nbsp;/**
&nbsp; * @author Andrew Shvayka
&nbsp; */
&nbsp;@SuppressWarnings(&quot;UnstableApiUsage&quot;)
&nbsp;@Component
<b class="nc">&nbsp;@Slf4j</b>
&nbsp;@NoSqlTsDao
<b class="nc">&nbsp;public class CassandraBaseTimeseriesDao extends AbstractCassandraBaseTimeseriesDao implements TimeseriesDao, AggregationTimeseriesDao {</b>
&nbsp;
&nbsp;    protected static final int MIN_AGGREGATION_STEP_MS = 1000;
&nbsp;    public static final String ASC_ORDER = &quot;ASC&quot;;
<b class="nc">&nbsp;    public static final long SECONDS_IN_DAY = TimeUnit.DAYS.toSeconds(1);</b>
<b class="nc">&nbsp;    protected static final List&lt;Long&gt; FIXED_PARTITION = List.of(0L);</b>
&nbsp;    protected static final String INSERT_WITH_NULL = INSERT_INTO + ModelConstants.TS_KV_CF +
&nbsp;            &quot;(&quot; + ModelConstants.ENTITY_TYPE_COLUMN +
&nbsp;            &quot;,&quot; + ModelConstants.ENTITY_ID_COLUMN +
&nbsp;            &quot;,&quot; + ModelConstants.KEY_COLUMN +
&nbsp;            &quot;,&quot; + ModelConstants.PARTITION_COLUMN +
&nbsp;            &quot;,&quot; + ModelConstants.TS_COLUMN +
&nbsp;            &quot;,&quot; + ModelConstants.BOOLEAN_VALUE_COLUMN +
&nbsp;            &quot;,&quot; + ModelConstants.STRING_VALUE_COLUMN +
&nbsp;            &quot;,&quot; + ModelConstants.LONG_VALUE_COLUMN +
&nbsp;            &quot;,&quot; + ModelConstants.DOUBLE_VALUE_COLUMN +
&nbsp;            &quot;,&quot; + ModelConstants.JSON_VALUE_COLUMN + &quot;)&quot; +
&nbsp;            &quot; VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)&quot;;
&nbsp;
&nbsp;    private CassandraTsPartitionsCache cassandraTsPartitionsCache;
&nbsp;
&nbsp;    @Autowired
&nbsp;    private Environment environment;
&nbsp;
&nbsp;    @Getter
&nbsp;    @Value(&quot;${cassandra.query.ts_key_value_partitioning}&quot;)
&nbsp;    private String partitioning;
&nbsp;
&nbsp;    @Getter
&nbsp;    @Value(&quot;${cassandra.query.use_ts_key_value_partitioning_on_read:true}&quot;)
&nbsp;    private boolean useTsKeyValuePartitioningOnRead;
&nbsp;
&nbsp;    @Getter
&nbsp;    @Value(&quot;${cassandra.query.use_ts_key_value_partitioning_on_read_max_estimated_partition_count:40}&quot;) // 3+ years for MONTHS
&nbsp;    private int useTsKeyValuePartitioningOnReadMaxEstimatedPartitionCount;
&nbsp;
&nbsp;    @Value(&quot;${cassandra.query.ts_key_value_partitions_max_cache_size:100000}&quot;)
&nbsp;    private long partitionsCacheSize;
&nbsp;
&nbsp;    @Value(&quot;${cassandra.query.ts_key_value_ttl}&quot;)
&nbsp;    private long systemTtl;
&nbsp;
&nbsp;    @Value(&quot;${cassandra.query.set_null_values_enabled}&quot;)
&nbsp;    private boolean setNullValuesEnabled;
&nbsp;
&nbsp;    private NoSqlTsPartitionDate tsFormat;
&nbsp;
&nbsp;    private PreparedStatement partitionInsertStmt;
&nbsp;    private PreparedStatement partitionInsertTtlStmt;
&nbsp;    private PreparedStatement[] saveStmts;
&nbsp;    private PreparedStatement[] saveTtlStmts;
&nbsp;    private PreparedStatement[] fetchStmtsAsc;
&nbsp;    private PreparedStatement[] fetchStmtsDesc;
&nbsp;    private PreparedStatement deleteStmt;
&nbsp;    private PreparedStatement saveWithNullStmt;
&nbsp;    private PreparedStatement saveWithNullWithTtlStmt;
<b class="nc">&nbsp;    private final Lock stmtCreationLock = new ReentrantLock();</b>
&nbsp;
&nbsp;    private boolean isInstall() {
<b class="nc">&nbsp;        return environment.acceptsProfiles(Profiles.of(&quot;install&quot;));</b>
&nbsp;    }
&nbsp;
&nbsp;    @PostConstruct
&nbsp;    public void init() {
<b class="nc">&nbsp;        super.startExecutor();</b>
<b class="nc">&nbsp;        if (!isInstall()) {</b>
<b class="nc">&nbsp;            getFetchStmt(Aggregation.NONE, DESC_ORDER);</b>
&nbsp;        }
<b class="nc">&nbsp;        Optional&lt;NoSqlTsPartitionDate&gt; partition = NoSqlTsPartitionDate.parse(partitioning);</b>
<b class="nc">&nbsp;        if (partition.isPresent()) {</b>
<b class="nc">&nbsp;            tsFormat = partition.get();</b>
<b class="nc">&nbsp;            if (!isFixedPartitioning() &amp;&amp; partitionsCacheSize &gt; 0) {</b>
<b class="nc">&nbsp;                cassandraTsPartitionsCache = new CassandraTsPartitionsCache(partitionsCacheSize);</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            log.warn(&quot;Incorrect configuration of partitioning {}&quot;, partitioning);</b>
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Failed to parse partitioning property: &quot; + partitioning + &quot;!&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @PreDestroy
&nbsp;    public void stop() {
<b class="nc">&nbsp;        super.stopExecutor();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ListenableFuture&lt;List&lt;ReadTsKvQueryResult&gt;&gt; findAllAsync(TenantId tenantId, EntityId entityId, List&lt;ReadTsKvQuery&gt; queries) {
<b class="nc">&nbsp;        List&lt;ListenableFuture&lt;ReadTsKvQueryResult&gt;&gt; futures = queries.stream()</b>
<b class="nc">&nbsp;                .map(query -&gt; findAllAsync(tenantId, entityId, query)).collect(Collectors.toList());</b>
<b class="nc">&nbsp;        return Futures.allAsList(futures);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ListenableFuture&lt;Integer&gt; save(TenantId tenantId, EntityId entityId, TsKvEntry tsKvEntry, long ttl) {
<b class="nc">&nbsp;        List&lt;ListenableFuture&lt;Void&gt;&gt; futures = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        ttl = computeTtl(ttl);</b>
<b class="nc">&nbsp;        int dataPointDays = tsKvEntry.getDataPoints() * Math.max(1, (int) (ttl / SECONDS_IN_DAY));</b>
<b class="nc">&nbsp;        long partition = toPartitionTs(tsKvEntry.getTs());</b>
<b class="nc">&nbsp;        String entityType = entityId.getEntityType().name();</b>
<b class="nc">&nbsp;        UUID entityIdId = entityId.getId();</b>
<b class="nc">&nbsp;        String entryKey = tsKvEntry.getKey();</b>
<b class="nc">&nbsp;        long ts = tsKvEntry.getTs();</b>
<b class="nc">&nbsp;        DataType type = tsKvEntry.getDataType();</b>
&nbsp;        BoundStatementBuilder stmtBuilder;
<b class="nc">&nbsp;        if (setNullValuesEnabled) {</b>
<b class="nc">&nbsp;            Boolean booleanValue = tsKvEntry.getBooleanValue().orElse(null);</b>
<b class="nc">&nbsp;            String strValue = tsKvEntry.getStrValue().orElse(null);</b>
<b class="nc">&nbsp;            Long longValue = tsKvEntry.getLongValue().orElse(null);</b>
<b class="nc">&nbsp;            Double doubleValue = tsKvEntry.getDoubleValue().orElse(null);</b>
<b class="nc">&nbsp;            String jsonValue = tsKvEntry.getJsonValue().orElse(null);</b>
<b class="nc">&nbsp;            if (ttl == 0) {</b>
<b class="nc">&nbsp;                stmtBuilder = new BoundStatementBuilder(getSaveWithNullStmt()</b>
<b class="nc">&nbsp;                        .bind(entityType, entityIdId, entryKey, partition, ts, booleanValue, strValue, longValue, doubleValue, jsonValue));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                stmtBuilder = new BoundStatementBuilder(getSaveWithNullWithTtlStmt()</b>
<b class="nc">&nbsp;                        .bind(entityType, entityIdId, entryKey, partition, ts, booleanValue, strValue, longValue, doubleValue, jsonValue, (int) ttl));</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            stmtBuilder = new BoundStatementBuilder((ttl == 0 ? getSaveStmt(type) : getSaveTtlStmt(type)).bind());</b>
<b class="nc">&nbsp;            stmtBuilder.setString(0, entityType)</b>
<b class="nc">&nbsp;                    .setUuid(1, entityIdId)</b>
<b class="nc">&nbsp;                    .setString(2, entryKey)</b>
<b class="nc">&nbsp;                    .setLong(3, partition)</b>
<b class="nc">&nbsp;                    .setLong(4, ts);</b>
<b class="nc">&nbsp;            addValue(tsKvEntry, stmtBuilder, 5);</b>
<b class="nc">&nbsp;            if (ttl &gt; 0) {</b>
<b class="nc">&nbsp;                stmtBuilder.setInt(6, (int) ttl);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        BoundStatement stmt = stmtBuilder.build();</b>
<b class="nc">&nbsp;        futures.add(getFuture(executeAsyncWrite(tenantId, stmt), rs -&gt; null));</b>
<b class="nc">&nbsp;        return Futures.transform(Futures.allAsList(futures), result -&gt; dataPointDays, MoreExecutors.directExecutor());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ListenableFuture&lt;Integer&gt; savePartition(TenantId tenantId, EntityId entityId, long tsKvEntryTs, String key) {
<b class="nc">&nbsp;        if (isFixedPartitioning()) {</b>
<b class="nc">&nbsp;            return Futures.immediateFuture(null);</b>
&nbsp;        }
&nbsp;        // DO NOT apply custom TTL to partition, otherwise, short TTL will remove partition too early
&nbsp;        // partitions must remain in the DB forever or be removed only by systemTtl
&nbsp;        // removal of empty partition is too expensive (we need to scan all data keys for these partitions with ALLOW FILTERING)
<b class="nc">&nbsp;        long ttl = computeTtl(0);</b>
<b class="nc">&nbsp;        long partition = toPartitionTs(tsKvEntryTs);</b>
<b class="nc">&nbsp;        if (cassandraTsPartitionsCache == null) {</b>
<b class="nc">&nbsp;            return doSavePartition(tenantId, entityId, key, ttl, partition);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            CassandraPartitionCacheKey partitionSearchKey = new CassandraPartitionCacheKey(entityId, key, partition);</b>
<b class="nc">&nbsp;            if (!cassandraTsPartitionsCache.has(partitionSearchKey)) {</b>
<b class="nc">&nbsp;                ListenableFuture&lt;Integer&gt; result = doSavePartition(tenantId, entityId, key, ttl, partition);</b>
<b class="nc">&nbsp;                Futures.addCallback(result, new CacheCallback&lt;&gt;(partitionSearchKey), MoreExecutors.directExecutor());</b>
<b class="nc">&nbsp;                return result;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return Futures.immediateFuture(0);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ListenableFuture&lt;Void&gt; remove(TenantId tenantId, EntityId entityId, DeleteTsKvQuery query) {
<b class="nc">&nbsp;        long minPartition = toPartitionTs(query.getStartTs());</b>
<b class="nc">&nbsp;        long maxPartition = toPartitionTs(query.getEndTs());</b>
&nbsp;
<b class="nc">&nbsp;        final SimpleListenableFuture&lt;Void&gt; resultFuture = new SimpleListenableFuture&lt;&gt;();</b>
<b class="nc">&nbsp;        final ListenableFuture&lt;List&lt;Long&gt;&gt; partitionsListFuture = getPartitionsFuture(tenantId, query, entityId, minPartition, maxPartition);</b>
&nbsp;
<b class="nc">&nbsp;        Futures.addCallback(partitionsListFuture, new FutureCallback&lt;List&lt;Long&gt;&gt;() {</b>
&nbsp;            @Override
&nbsp;            public void onSuccess(@Nullable List&lt;Long&gt; partitions) {
<b class="nc">&nbsp;                QueryCursor cursor = new QueryCursor(entityId.getEntityType().name(), entityId.getId(), query, partitions);</b>
<b class="nc">&nbsp;                deleteAsync(tenantId, cursor, resultFuture);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void onFailure(Throwable t) {
<b class="nc">&nbsp;                log.error(&quot;[{}][{}] Failed to fetch partitions for interval {}-{}&quot;, entityId.getEntityType().name(), entityId.getId(), minPartition, maxPartition, t);</b>
&nbsp;            }
&nbsp;        }, readResultsProcessingExecutor);
<b class="nc">&nbsp;        return resultFuture;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ListenableFuture&lt;ReadTsKvQueryResult&gt; findAllAsync(TenantId tenantId, EntityId entityId, ReadTsKvQuery query) {
<b class="nc">&nbsp;        var aggParams = query.getAggParameters();</b>
<b class="nc">&nbsp;        if (Aggregation.NONE.equals(aggParams.getAggregation())) {</b>
<b class="nc">&nbsp;            return findAllAsyncWithLimit(tenantId, entityId, query);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            long startPeriod = query.getStartTs();</b>
<b class="nc">&nbsp;            long endPeriod = Math.max(query.getStartTs() + 1, query.getEndTs());</b>
<b class="nc">&nbsp;            List&lt;ListenableFuture&lt;Optional&lt;TsKvEntryAggWrapper&gt;&gt;&gt; futures = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;            var intervalType = aggParams.getIntervalType();</b>
<b class="nc">&nbsp;            while (startPeriod &lt; endPeriod) {</b>
<b class="nc">&nbsp;                long startTs = startPeriod;</b>
&nbsp;                long endTs;
<b class="nc">&nbsp;                if (IntervalType.MILLISECONDS.equals(intervalType)) {</b>
<b class="nc">&nbsp;                    endTs = startPeriod + Math.max(query.getInterval(), MIN_AGGREGATION_STEP_MS);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    endTs = TimeUtils.calculateIntervalEnd(startTs, aggParams.getIntervalType(), aggParams.getTzId());</b>
&nbsp;                }
<b class="nc">&nbsp;                endTs = Math.min(endTs, endPeriod);</b>
<b class="nc">&nbsp;                ReadTsKvQuery subQuery = new BaseReadTsKvQuery(query.getKey(), startTs, endTs, endTs - startTs, 1, query.getAggregation(), query.getOrder());</b>
<b class="nc">&nbsp;                futures.add(findAndAggregateAsync(tenantId, entityId, subQuery, toPartitionTs(startTs), toPartitionTs(endTs)));</b>
<b class="nc">&nbsp;                startPeriod = endTs;</b>
&nbsp;            }
<b class="nc">&nbsp;            ListenableFuture&lt;List&lt;Optional&lt;TsKvEntryAggWrapper&gt;&gt;&gt; future = Futures.allAsList(futures);</b>
<b class="nc">&nbsp;            return Futures.transform(future, new Function&lt;&gt;() {</b>
&nbsp;                @Nullable
&nbsp;                @Override
&nbsp;                public ReadTsKvQueryResult apply(@Nullable List&lt;Optional&lt;TsKvEntryAggWrapper&gt;&gt; input) {
<b class="nc">&nbsp;                    if (input == null) {</b>
<b class="nc">&nbsp;                        return new ReadTsKvQueryResult(query.getId(), Collections.emptyList(), query.getStartTs());</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        long maxTs = query.getStartTs();</b>
<b class="nc">&nbsp;                        List&lt;TsKvEntry&gt; data = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;                        for (var opt : input) {</b>
<b class="nc">&nbsp;                            if (opt.isPresent()) {</b>
<b class="nc">&nbsp;                                TsKvEntryAggWrapper tsKvEntryAggWrapper = opt.get();</b>
<b class="nc">&nbsp;                                maxTs = Math.max(maxTs, tsKvEntryAggWrapper.getLastEntryTs());</b>
<b class="nc">&nbsp;                                data.add(tsKvEntryAggWrapper.getEntry());</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                        return new ReadTsKvQueryResult(query.getId(), data, maxTs);</b>
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;            }, readResultsProcessingExecutor);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void cleanup(long systemTtl) {
&nbsp;        //Cleanup by TTL is native for Cassandra
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private ListenableFuture&lt;ReadTsKvQueryResult&gt; findAllAsyncWithLimit(TenantId tenantId, EntityId entityId, ReadTsKvQuery query) {
<b class="nc">&nbsp;        long minPartition = toPartitionTs(query.getStartTs());</b>
<b class="nc">&nbsp;        long maxPartition = toPartitionTs(query.getEndTs());</b>
<b class="nc">&nbsp;        final ListenableFuture&lt;List&lt;Long&gt;&gt; partitionsListFuture = getPartitionsFuture(tenantId, query, entityId, minPartition, maxPartition);</b>
<b class="nc">&nbsp;        final SimpleListenableFuture&lt;List&lt;TsKvEntry&gt;&gt; resultFuture = new SimpleListenableFuture&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        Futures.addCallback(partitionsListFuture, new FutureCallback&lt;&gt;() {</b>
&nbsp;            @Override
&nbsp;            public void onSuccess(@Nullable List&lt;Long&gt; partitions) {
<b class="nc">&nbsp;                TsKvQueryCursor cursor = new TsKvQueryCursor(entityId.getEntityType().name(), entityId.getId(), query, partitions);</b>
<b class="nc">&nbsp;                findAllAsyncSequentiallyWithLimit(tenantId, cursor, resultFuture);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void onFailure(Throwable t) {
<b class="nc">&nbsp;                log.error(&quot;[{}][{}] Failed to fetch partitions for interval {}-{}&quot;, entityId.getEntityType().name(), entityId.getId(), toPartitionTs(query.getStartTs()), toPartitionTs(query.getEndTs()), t);</b>
&nbsp;            }
&nbsp;        }, readResultsProcessingExecutor);
&nbsp;
<b class="nc">&nbsp;        return Futures.transform(resultFuture, tsKvEntries -&gt; {</b>
<b class="nc">&nbsp;            long lastTs = query.getStartTs();</b>
<b class="nc">&nbsp;            if (tsKvEntries != null) {</b>
<b class="nc">&nbsp;                lastTs = tsKvEntries.stream().map(TsKvEntry::getTs).max(Long::compare).orElse(query.getStartTs());</b>
&nbsp;            }
<b class="nc">&nbsp;            return new ReadTsKvQueryResult(query.getId(), tsKvEntries, lastTs);</b>
<b class="nc">&nbsp;        }, MoreExecutors.directExecutor());</b>
&nbsp;    }
&nbsp;
&nbsp;    long toPartitionTs(long ts) {
<b class="nc">&nbsp;        LocalDateTime time = LocalDateTime.ofInstant(Instant.ofEpochMilli(ts), ZoneOffset.UTC);</b>
<b class="nc">&nbsp;        return tsFormat.truncatedTo(time).toInstant(ZoneOffset.UTC).toEpochMilli();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void findAllAsyncSequentiallyWithLimit(TenantId tenantId, final TsKvQueryCursor cursor, final SimpleListenableFuture&lt;List&lt;TsKvEntry&gt;&gt; resultFuture) {
<b class="nc">&nbsp;        if (cursor.isFull() || !cursor.hasNextPartition()) {</b>
<b class="nc">&nbsp;            resultFuture.set(cursor.getData());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            PreparedStatement proto = getFetchStmt(Aggregation.NONE, cursor.getOrderBy());</b>
<b class="nc">&nbsp;            BoundStatementBuilder stmtBuilder = new BoundStatementBuilder(proto.bind());</b>
&nbsp;
<b class="nc">&nbsp;            stmtBuilder.setString(0, cursor.getEntityType());</b>
<b class="nc">&nbsp;            stmtBuilder.setUuid(1, cursor.getEntityId());</b>
<b class="nc">&nbsp;            stmtBuilder.setString(2, cursor.getKey());</b>
<b class="nc">&nbsp;            stmtBuilder.setLong(3, cursor.getNextPartition());</b>
<b class="nc">&nbsp;            stmtBuilder.setLong(4, cursor.getStartTs());</b>
<b class="nc">&nbsp;            stmtBuilder.setLong(5, cursor.getEndTs());</b>
<b class="nc">&nbsp;            stmtBuilder.setInt(6, cursor.getCurrentLimit());</b>
&nbsp;
<b class="nc">&nbsp;            BoundStatement stmt = stmtBuilder.build();</b>
&nbsp;
<b class="nc">&nbsp;            Futures.addCallback(executeAsyncRead(tenantId, stmt), new FutureCallback&lt;TbResultSet&gt;() {</b>
&nbsp;                @Override
&nbsp;                public void onSuccess(@Nullable TbResultSet result) {
<b class="nc">&nbsp;                    if (result == null) {</b>
<b class="nc">&nbsp;                        cursor.addData(convertResultToTsKvEntryList(Collections.emptyList()));</b>
<b class="nc">&nbsp;                        findAllAsyncSequentiallyWithLimit(tenantId, cursor, resultFuture);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        Futures.addCallback(result.allRows(readResultsProcessingExecutor), new FutureCallback&lt;List&lt;Row&gt;&gt;() {</b>
&nbsp;
&nbsp;                            @Override
&nbsp;                            public void onSuccess(@Nullable List&lt;Row&gt; result) {
<b class="nc">&nbsp;                                cursor.addData(convertResultToTsKvEntryList(result == null ? Collections.emptyList() : result));</b>
<b class="nc">&nbsp;                                findAllAsyncSequentiallyWithLimit(tenantId, cursor, resultFuture);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public void onFailure(Throwable t) {
<b class="nc">&nbsp;                                log.error(&quot;[{}][{}] Failed to fetch data for query {}-{}&quot;, stmt, t);</b>
&nbsp;                            }
<b class="nc">&nbsp;                        }, readResultsProcessingExecutor);</b>
&nbsp;
&nbsp;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onFailure(Throwable t) {
<b class="nc">&nbsp;                    log.error(&quot;[{}][{}] Failed to fetch data for query {}-{}&quot;, stmt, t);</b>
&nbsp;                }
&nbsp;            }, readResultsProcessingExecutor);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private ListenableFuture&lt;Optional&lt;TsKvEntryAggWrapper&gt;&gt; findAndAggregateAsync(TenantId tenantId, EntityId entityId, ReadTsKvQuery query, long minPartition, long maxPartition) {
<b class="nc">&nbsp;        final Aggregation aggregation = query.getAggregation();</b>
<b class="nc">&nbsp;        final String key = query.getKey();</b>
<b class="nc">&nbsp;        final long startTs = query.getStartTs();</b>
<b class="nc">&nbsp;        final long endTs = query.getEndTs();</b>
<b class="nc">&nbsp;        final long ts = startTs + (endTs - startTs) / 2;</b>
<b class="nc">&nbsp;        ListenableFuture&lt;List&lt;Long&gt;&gt; partitionsListFuture = getPartitionsFuture(tenantId, query, entityId, minPartition, maxPartition);</b>
<b class="nc">&nbsp;        ListenableFuture&lt;List&lt;TbResultSet&gt;&gt; aggregationChunks = Futures.transformAsync(partitionsListFuture,</b>
<b class="nc">&nbsp;                getFetchChunksAsyncFunction(tenantId, entityId, key, aggregation, startTs, endTs), readResultsProcessingExecutor);</b>
&nbsp;
<b class="nc">&nbsp;        return Futures.transformAsync(aggregationChunks, new AggregatePartitionsFunction(aggregation, key, ts, readResultsProcessingExecutor), readResultsProcessingExecutor);</b>
&nbsp;    }
&nbsp;
&nbsp;    private AsyncFunction&lt;TbResultSet, List&lt;Long&gt;&gt; getPartitionsArrayFunction() {
<b class="nc">&nbsp;        return rs -&gt;</b>
<b class="nc">&nbsp;                Futures.transform(rs.allRows(readResultsProcessingExecutor), rows -&gt;</b>
<b class="nc">&nbsp;                                rows.stream()</b>
<b class="nc">&nbsp;                                        .map(row -&gt; row.getLong(ModelConstants.PARTITION_COLUMN)).collect(Collectors.toList()),</b>
&nbsp;                        readResultsProcessingExecutor);
&nbsp;    }
&nbsp;
&nbsp;    ListenableFuture&lt;List&lt;Long&gt;&gt; getPartitionsFuture(TenantId tenantId, TsKvQuery query, EntityId entityId, long minPartition, long maxPartition) {
<b class="nc">&nbsp;        if (isFixedPartitioning()) { //no need to fetch partitions from DB</b>
<b class="nc">&nbsp;            return Futures.immediateFuture(FIXED_PARTITION);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (!isUseTsKeyValuePartitioningOnRead()) {</b>
<b class="nc">&nbsp;            final long estimatedPartitionCount = estimatePartitionCount(minPartition, maxPartition);</b>
<b class="nc">&nbsp;            if  (estimatedPartitionCount &lt;= useTsKeyValuePartitioningOnReadMaxEstimatedPartitionCount) {</b>
<b class="nc">&nbsp;                return Futures.immediateFuture(calculatePartitions(minPartition, maxPartition, (int) estimatedPartitionCount));</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return getPartitionsFromDB(tenantId, query, entityId, minPartition, maxPartition);</b>
&nbsp;    }
&nbsp;
&nbsp;    ListenableFuture&lt;List&lt;Long&gt;&gt; getPartitionsFromDB(TenantId tenantId, TsKvQuery query, EntityId entityId, long minPartition, long maxPartition) {
<b class="nc">&nbsp;        TbResultSetFuture partitionsFuture = fetchPartitions(tenantId, entityId, query.getKey(), minPartition, maxPartition);</b>
<b class="nc">&nbsp;        return Futures.transformAsync(partitionsFuture, getPartitionsArrayFunction(), readResultsProcessingExecutor);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Optimistic estimation of partition count, expected to be never called for infinite partitioning
&nbsp;    long estimatePartitionCount(long minPartition, long maxPartition) {
<b class="nc">&nbsp;        if (maxPartition &gt; minPartition) {</b>
<b class="nc">&nbsp;            return (maxPartition - minPartition) / tsFormat.getDurationMs() + 2; //at least 2 partitions, at max 2 partitions overestimated</b>
&nbsp;        }
<b class="nc">&nbsp;        return 1; // 1 or 0, but 1 is more optimistic</b>
&nbsp;    }
&nbsp;
&nbsp;    List&lt;Long&gt; calculatePartitions(long minPartition, long maxPartition) {
<b class="nc">&nbsp;       return calculatePartitions(minPartition, maxPartition, 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    List&lt;Long&gt; calculatePartitions(long minPartition, long maxPartition, int estimatedPartitionCount) {
<b class="nc">&nbsp;        if (minPartition == maxPartition) {</b>
<b class="nc">&nbsp;            return Collections.singletonList(minPartition);</b>
&nbsp;        }
<b class="nc">&nbsp;        List&lt;Long&gt; partitions = estimatedPartitionCount &gt; 0 ? new ArrayList&lt;&gt;(estimatedPartitionCount) : new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        long currentPartition = minPartition;</b>
<b class="nc">&nbsp;        LocalDateTime currentPartitionTime = LocalDateTime.ofInstant(Instant.ofEpochMilli(currentPartition), ZoneOffset.UTC);</b>
&nbsp;
<b class="nc">&nbsp;        while (maxPartition &gt; currentPartition) {</b>
<b class="nc">&nbsp;            partitions.add(currentPartition);</b>
<b class="nc">&nbsp;            currentPartitionTime = calculateNextPartition(currentPartitionTime);</b>
<b class="nc">&nbsp;            currentPartition = currentPartitionTime.toInstant(ZoneOffset.UTC).toEpochMilli();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        partitions.add(maxPartition);</b>
&nbsp;
<b class="nc">&nbsp;        return partitions;</b>
&nbsp;    }
&nbsp;
&nbsp;    private LocalDateTime calculateNextPartition(LocalDateTime time) {
<b class="nc">&nbsp;        return time.plus(1, tsFormat.getTruncateUnit());</b>
&nbsp;    }
&nbsp;
&nbsp;    private AsyncFunction&lt;List&lt;Long&gt;, List&lt;TbResultSet&gt;&gt; getFetchChunksAsyncFunction(TenantId tenantId, EntityId entityId, String key, Aggregation aggregation, long startTs, long endTs) {
<b class="nc">&nbsp;        return partitions -&gt; {</b>
&nbsp;            try {
<b class="nc">&nbsp;                PreparedStatement proto = getFetchStmt(aggregation, DESC_ORDER);</b>
<b class="nc">&nbsp;                List&lt;TbResultSetFuture&gt; futures = new ArrayList&lt;&gt;(partitions.size());</b>
<b class="nc">&nbsp;                for (Long partition : partitions) {</b>
<b class="nc">&nbsp;                    log.trace(&quot;Fetching data for partition [{}] for entityType {} and entityId {}&quot;, partition, entityId.getEntityType(), entityId.getId());</b>
<b class="nc">&nbsp;                    BoundStatementBuilder stmtBuilder = new BoundStatementBuilder(proto.bind());</b>
<b class="nc">&nbsp;                    stmtBuilder.setString(0, entityId.getEntityType().name());</b>
<b class="nc">&nbsp;                    stmtBuilder.setUuid(1, entityId.getId());</b>
<b class="nc">&nbsp;                    stmtBuilder.setString(2, key);</b>
<b class="nc">&nbsp;                    stmtBuilder.setLong(3, partition);</b>
<b class="nc">&nbsp;                    stmtBuilder.setLong(4, startTs);</b>
<b class="nc">&nbsp;                    stmtBuilder.setLong(5, endTs);</b>
<b class="nc">&nbsp;                    BoundStatement stmt = stmtBuilder.build();</b>
<b class="nc">&nbsp;                    log.debug(GENERATED_QUERY_FOR_ENTITY_TYPE_AND_ENTITY_ID, stmt, entityId.getEntityType(), entityId.getId());</b>
<b class="nc">&nbsp;                    futures.add(executeAsyncRead(tenantId, stmt));</b>
&nbsp;                }
<b class="nc">&nbsp;                return Futures.allAsList(futures);</b>
&nbsp;            } catch (Throwable e) {
<b class="nc">&nbsp;                log.error(&quot;Failed to fetch data&quot;, e);</b>
&nbsp;                throw e;
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    private boolean isFixedPartitioning() {
<b class="nc">&nbsp;        return tsFormat.getTruncateUnit().equals(ChronoUnit.FOREVER);</b>
&nbsp;    }
&nbsp;
&nbsp;    private ListenableFuture&lt;Integer&gt; doSavePartition(TenantId tenantId, EntityId entityId, String key, long ttl, long partition) {
<b class="nc">&nbsp;        log.debug(&quot;Saving partition {} for the entity [{}-{}] and key {}&quot;, partition, entityId.getEntityType(), entityId.getId(), key);</b>
<b class="nc">&nbsp;        PreparedStatement preparedStatement = ttl == 0 ? getPartitionInsertStmt() : getPartitionInsertTtlStmt();</b>
<b class="nc">&nbsp;        BoundStatement stmt = preparedStatement.bind();</b>
<b class="nc">&nbsp;        stmt = stmt.setString(0, entityId.getEntityType().name())</b>
<b class="nc">&nbsp;                .setUuid(1, entityId.getId())</b>
<b class="nc">&nbsp;                .setLong(2, partition)</b>
<b class="nc">&nbsp;                .setString(3, key);</b>
<b class="nc">&nbsp;        if (ttl &gt; 0) {</b>
<b class="nc">&nbsp;            stmt = stmt.setInt(4, (int) ttl);</b>
&nbsp;        }
<b class="nc">&nbsp;        return getFuture(executeAsyncWrite(tenantId, stmt), rs -&gt; 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    private class CacheCallback&lt;Void&gt; implements FutureCallback&lt;Void&gt; {
&nbsp;        private final CassandraPartitionCacheKey key;
&nbsp;
<b class="nc">&nbsp;        private CacheCallback(CassandraPartitionCacheKey key) {</b>
<b class="nc">&nbsp;            this.key = key;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onSuccess(Void result) {
<b class="nc">&nbsp;            cassandraTsPartitionsCache.put(key);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onFailure(Throwable t) {
&nbsp;
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private long computeTtl(long ttl) {
<b class="nc">&nbsp;        if (systemTtl &gt; 0) {</b>
<b class="nc">&nbsp;            if (ttl == 0) {</b>
<b class="nc">&nbsp;                ttl = systemTtl;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                ttl = Math.min(systemTtl, ttl);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return ttl;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void deleteAsync(TenantId tenantId, final QueryCursor cursor, final SimpleListenableFuture&lt;Void&gt; resultFuture) {
<b class="nc">&nbsp;        if (!cursor.hasNextPartition()) {</b>
<b class="nc">&nbsp;            resultFuture.set(null);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            PreparedStatement proto = getDeleteStmt();</b>
<b class="nc">&nbsp;            BoundStatementBuilder stmtBuilder = new BoundStatementBuilder(proto.bind());</b>
<b class="nc">&nbsp;            stmtBuilder.setString(0, cursor.getEntityType());</b>
<b class="nc">&nbsp;            stmtBuilder.setUuid(1, cursor.getEntityId());</b>
<b class="nc">&nbsp;            stmtBuilder.setString(2, cursor.getKey());</b>
<b class="nc">&nbsp;            stmtBuilder.setLong(3, cursor.getNextPartition());</b>
<b class="nc">&nbsp;            stmtBuilder.setLong(4, cursor.getStartTs());</b>
<b class="nc">&nbsp;            stmtBuilder.setLong(5, cursor.getEndTs());</b>
&nbsp;
<b class="nc">&nbsp;            BoundStatement stmt = stmtBuilder.build();</b>
&nbsp;
<b class="nc">&nbsp;            Futures.addCallback(executeAsyncWrite(tenantId, stmt), new FutureCallback&lt;AsyncResultSet&gt;() {</b>
&nbsp;                @Override
&nbsp;                public void onSuccess(@Nullable AsyncResultSet result) {
<b class="nc">&nbsp;                    deleteAsync(tenantId, cursor, resultFuture);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onFailure(Throwable t) {
<b class="nc">&nbsp;                    log.error(&quot;[{}][{}] Failed to delete data for query {}-{}&quot;, stmt, t);</b>
&nbsp;                }
&nbsp;            }, readResultsProcessingExecutor);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private PreparedStatement getDeleteStmt() {
<b class="nc">&nbsp;        if (deleteStmt == null) {</b>
<b class="nc">&nbsp;            stmtCreationLock.lock();</b>
&nbsp;            try {
<b class="nc">&nbsp;                if (deleteStmt == null) {</b>
<b class="nc">&nbsp;                    deleteStmt = prepare(&quot;DELETE FROM &quot; + ModelConstants.TS_KV_CF +</b>
&nbsp;                            &quot; WHERE &quot; + ModelConstants.ENTITY_TYPE_COLUMN + EQUALS_PARAM
&nbsp;                            + &quot;AND &quot; + ModelConstants.ENTITY_ID_COLUMN + EQUALS_PARAM
&nbsp;                            + &quot;AND &quot; + ModelConstants.KEY_COLUMN + EQUALS_PARAM
&nbsp;                            + &quot;AND &quot; + ModelConstants.PARTITION_COLUMN + EQUALS_PARAM
&nbsp;                            + &quot;AND &quot; + ModelConstants.TS_COLUMN + &quot; &gt;= ? &quot;
&nbsp;                            + &quot;AND &quot; + ModelConstants.TS_COLUMN + &quot; &lt; ?&quot;);
&nbsp;                }
&nbsp;            } finally {
<b class="nc">&nbsp;                stmtCreationLock.unlock();</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return deleteStmt;</b>
&nbsp;    }
&nbsp;
&nbsp;    private PreparedStatement getSaveWithNullStmt() {
<b class="nc">&nbsp;        if (saveWithNullStmt == null) {</b>
<b class="nc">&nbsp;            stmtCreationLock.lock();</b>
&nbsp;            try {
<b class="nc">&nbsp;                if (saveWithNullStmt == null) {</b>
<b class="nc">&nbsp;                    saveWithNullStmt = prepare(INSERT_WITH_NULL);</b>
&nbsp;                }
&nbsp;            } finally {
<b class="nc">&nbsp;                stmtCreationLock.unlock();</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return saveWithNullStmt;</b>
&nbsp;    }
&nbsp;
&nbsp;    private PreparedStatement getSaveWithNullWithTtlStmt() {
<b class="nc">&nbsp;        if (saveWithNullWithTtlStmt == null) {</b>
<b class="nc">&nbsp;            stmtCreationLock.lock();</b>
&nbsp;            try {
<b class="nc">&nbsp;                if (saveWithNullWithTtlStmt == null) {</b>
<b class="nc">&nbsp;                    saveWithNullWithTtlStmt = prepare(INSERT_WITH_NULL + &quot; USING TTL ?&quot;);</b>
&nbsp;                }
&nbsp;            } finally {
<b class="nc">&nbsp;                stmtCreationLock.unlock();</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return saveWithNullWithTtlStmt;</b>
&nbsp;    }
&nbsp;
&nbsp;    private PreparedStatement getSaveStmt(DataType dataType) {
<b class="nc">&nbsp;        if (saveStmts == null) {</b>
<b class="nc">&nbsp;            stmtCreationLock.lock();</b>
&nbsp;            try {
<b class="nc">&nbsp;                if (saveStmts == null) {</b>
<b class="nc">&nbsp;                    var stmts = new PreparedStatement[DataType.values().length];</b>
<b class="nc">&nbsp;                    for (DataType type : DataType.values()) {</b>
<b class="nc">&nbsp;                        stmts[type.ordinal()] = prepare(getPreparedStatementQuery(type));</b>
&nbsp;                    }
<b class="nc">&nbsp;                    saveStmts = stmts;</b>
&nbsp;                }
&nbsp;            } finally {
<b class="nc">&nbsp;                stmtCreationLock.unlock();</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return saveStmts[dataType.ordinal()];</b>
&nbsp;    }
&nbsp;
&nbsp;    private PreparedStatement getSaveTtlStmt(DataType dataType) {
<b class="nc">&nbsp;        if (saveTtlStmts == null) {</b>
<b class="nc">&nbsp;            stmtCreationLock.lock();</b>
&nbsp;            try {
<b class="nc">&nbsp;                if (saveTtlStmts == null) {</b>
<b class="nc">&nbsp;                    var stmts = new PreparedStatement[DataType.values().length];</b>
<b class="nc">&nbsp;                    for (DataType type : DataType.values()) {</b>
<b class="nc">&nbsp;                        stmts[type.ordinal()] = prepare(getPreparedStatementQueryWithTtl(type));</b>
&nbsp;                    }
<b class="nc">&nbsp;                    saveTtlStmts = stmts;</b>
&nbsp;                }
&nbsp;            } finally {
<b class="nc">&nbsp;                stmtCreationLock.unlock();</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return saveTtlStmts[dataType.ordinal()];</b>
&nbsp;    }
&nbsp;
&nbsp;    private String getPreparedStatementQuery(DataType type) {
<b class="nc">&nbsp;        return INSERT_INTO + ModelConstants.TS_KV_CF +</b>
&nbsp;                &quot;(&quot; + ModelConstants.ENTITY_TYPE_COLUMN +
&nbsp;                &quot;,&quot; + ModelConstants.ENTITY_ID_COLUMN +
&nbsp;                &quot;,&quot; + ModelConstants.KEY_COLUMN +
&nbsp;                &quot;,&quot; + ModelConstants.PARTITION_COLUMN +
&nbsp;                &quot;,&quot; + ModelConstants.TS_COLUMN +
<b class="nc">&nbsp;                &quot;,&quot; + getColumnName(type) + &quot;)&quot; +</b>
&nbsp;                &quot; VALUES(?, ?, ?, ?, ?, ?)&quot;;
&nbsp;    }
&nbsp;
&nbsp;    private String getPreparedStatementQueryWithTtl(DataType type) {
<b class="nc">&nbsp;        return getPreparedStatementQuery(type) + &quot; USING TTL ?&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    private PreparedStatement getPartitionInsertStmt() {
<b class="nc">&nbsp;        if (partitionInsertStmt == null) {</b>
<b class="nc">&nbsp;            stmtCreationLock.lock();</b>
&nbsp;            try {
<b class="nc">&nbsp;                if (partitionInsertStmt == null) {</b>
<b class="nc">&nbsp;                    partitionInsertStmt = prepare(INSERT_INTO + ModelConstants.TS_KV_PARTITIONS_CF +</b>
&nbsp;                            &quot;(&quot; + ModelConstants.ENTITY_TYPE_COLUMN +
&nbsp;                            &quot;,&quot; + ModelConstants.ENTITY_ID_COLUMN +
&nbsp;                            &quot;,&quot; + ModelConstants.PARTITION_COLUMN +
&nbsp;                            &quot;,&quot; + ModelConstants.KEY_COLUMN + &quot;)&quot; +
&nbsp;                            &quot; VALUES(?, ?, ?, ?)&quot;);
&nbsp;                }
&nbsp;            } finally {
<b class="nc">&nbsp;                stmtCreationLock.unlock();</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return partitionInsertStmt;</b>
&nbsp;    }
&nbsp;
&nbsp;    private PreparedStatement getPartitionInsertTtlStmt() {
<b class="nc">&nbsp;        if (partitionInsertTtlStmt == null) {</b>
<b class="nc">&nbsp;            stmtCreationLock.lock();</b>
&nbsp;            try {
<b class="nc">&nbsp;                if (partitionInsertTtlStmt == null) {</b>
<b class="nc">&nbsp;                    partitionInsertTtlStmt = prepare(INSERT_INTO + ModelConstants.TS_KV_PARTITIONS_CF +</b>
&nbsp;                            &quot;(&quot; + ModelConstants.ENTITY_TYPE_COLUMN +
&nbsp;                            &quot;,&quot; + ModelConstants.ENTITY_ID_COLUMN +
&nbsp;                            &quot;,&quot; + ModelConstants.PARTITION_COLUMN +
&nbsp;                            &quot;,&quot; + ModelConstants.KEY_COLUMN + &quot;)&quot; +
&nbsp;                            &quot; VALUES(?, ?, ?, ?) USING TTL ?&quot;);
&nbsp;                }
&nbsp;            } finally {
<b class="nc">&nbsp;                stmtCreationLock.unlock();</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return partitionInsertTtlStmt;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static String getColumnName(DataType type) {
<b class="nc">&nbsp;        switch (type) {</b>
&nbsp;            case BOOLEAN:
<b class="nc">&nbsp;                return ModelConstants.BOOLEAN_VALUE_COLUMN;</b>
&nbsp;            case STRING:
<b class="nc">&nbsp;                return ModelConstants.STRING_VALUE_COLUMN;</b>
&nbsp;            case LONG:
<b class="nc">&nbsp;                return ModelConstants.LONG_VALUE_COLUMN;</b>
&nbsp;            case DOUBLE:
<b class="nc">&nbsp;                return ModelConstants.DOUBLE_VALUE_COLUMN;</b>
&nbsp;            case JSON:
<b class="nc">&nbsp;                return ModelConstants.JSON_VALUE_COLUMN;</b>
&nbsp;            default:
<b class="nc">&nbsp;                throw new RuntimeException(&quot;Not implemented!&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static void addValue(KvEntry kvEntry, BoundStatementBuilder stmt, int column) {
<b class="nc">&nbsp;        switch (kvEntry.getDataType()) {</b>
&nbsp;            case BOOLEAN:
<b class="nc">&nbsp;                Optional&lt;Boolean&gt; booleanValue = kvEntry.getBooleanValue();</b>
<b class="nc">&nbsp;                booleanValue.ifPresent(b -&gt; stmt.setBoolean(column, b));</b>
&nbsp;                break;
&nbsp;            case STRING:
<b class="nc">&nbsp;                Optional&lt;String&gt; stringValue = kvEntry.getStrValue();</b>
<b class="nc">&nbsp;                stringValue.ifPresent(s -&gt; stmt.setString(column, s));</b>
&nbsp;                break;
&nbsp;            case LONG:
<b class="nc">&nbsp;                Optional&lt;Long&gt; longValue = kvEntry.getLongValue();</b>
<b class="nc">&nbsp;                longValue.ifPresent(l -&gt; stmt.setLong(column, l));</b>
&nbsp;                break;
&nbsp;            case DOUBLE:
<b class="nc">&nbsp;                Optional&lt;Double&gt; doubleValue = kvEntry.getDoubleValue();</b>
<b class="nc">&nbsp;                doubleValue.ifPresent(d -&gt; stmt.setDouble(column, d));</b>
&nbsp;                break;
&nbsp;            case JSON:
<b class="nc">&nbsp;                Optional&lt;String&gt; jsonValue = kvEntry.getJsonValue();</b>
<b class="nc">&nbsp;                jsonValue.ifPresent(jsonObject -&gt; stmt.setString(column, jsonObject));</b>
&nbsp;                break;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * //     * Select existing partitions from the table
&nbsp;     * //     * &lt;code&gt;{@link ModelConstants#TS_KV_PARTITIONS_CF}&lt;/code&gt; for the given entity
&nbsp;     * //
&nbsp;     */
&nbsp;    private TbResultSetFuture fetchPartitions(TenantId tenantId, EntityId entityId, String key, long minPartition, long maxPartition) {
<b class="nc">&nbsp;        Select select = QueryBuilder.selectFrom(ModelConstants.TS_KV_PARTITIONS_CF).column(ModelConstants.PARTITION_COLUMN)</b>
<b class="nc">&nbsp;                .whereColumn(ModelConstants.ENTITY_TYPE_COLUMN).isEqualTo(literal(entityId.getEntityType().name()))</b>
<b class="nc">&nbsp;                .whereColumn(ModelConstants.ENTITY_ID_COLUMN).isEqualTo(literal(entityId.getId()))</b>
<b class="nc">&nbsp;                .whereColumn(ModelConstants.KEY_COLUMN).isEqualTo(literal(key))</b>
<b class="nc">&nbsp;                .whereColumn(ModelConstants.PARTITION_COLUMN).isGreaterThanOrEqualTo(literal(minPartition))</b>
<b class="nc">&nbsp;                .whereColumn(ModelConstants.PARTITION_COLUMN).isLessThanOrEqualTo(literal(maxPartition));</b>
<b class="nc">&nbsp;        return executeAsyncRead(tenantId, select.build());</b>
&nbsp;    }
&nbsp;
&nbsp;    private PreparedStatement getFetchStmt(Aggregation aggType, String orderBy) {
<b class="nc">&nbsp;        switch (orderBy) {</b>
&nbsp;            case ASC_ORDER:
<b class="nc">&nbsp;                if (fetchStmtsAsc == null) {</b>
<b class="nc">&nbsp;                    stmtCreationLock.lock();</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        if (fetchStmtsAsc == null) {</b>
<b class="nc">&nbsp;                            fetchStmtsAsc = initFetchStmt(orderBy);</b>
&nbsp;                        }
&nbsp;                    } finally {
<b class="nc">&nbsp;                        stmtCreationLock.unlock();</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                return fetchStmtsAsc[aggType.ordinal()];</b>
&nbsp;            case DESC_ORDER:
<b class="nc">&nbsp;                if (fetchStmtsDesc == null) {</b>
<b class="nc">&nbsp;                    stmtCreationLock.lock();</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        if (fetchStmtsDesc == null) {</b>
<b class="nc">&nbsp;                            fetchStmtsDesc = initFetchStmt(orderBy);</b>
&nbsp;                        }
&nbsp;                    } finally {
<b class="nc">&nbsp;                        stmtCreationLock.unlock();</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                return fetchStmtsDesc[aggType.ordinal()];</b>
&nbsp;            default:
<b class="nc">&nbsp;                throw new RuntimeException(&quot;Not supported&quot; + orderBy + &quot;order!&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private PreparedStatement[] initFetchStmt(String orderBy) {
<b class="nc">&nbsp;        PreparedStatement[] fetchStmts = new PreparedStatement[Aggregation.values().length];</b>
<b class="nc">&nbsp;        for (Aggregation type : Aggregation.values()) {</b>
<b class="nc">&nbsp;            if (type == Aggregation.SUM &amp;&amp; fetchStmts[Aggregation.AVG.ordinal()] != null) {</b>
<b class="nc">&nbsp;                fetchStmts[type.ordinal()] = fetchStmts[Aggregation.AVG.ordinal()];</b>
<b class="nc">&nbsp;            } else if (type == Aggregation.AVG &amp;&amp; fetchStmts[Aggregation.SUM.ordinal()] != null) {</b>
<b class="nc">&nbsp;                fetchStmts[type.ordinal()] = fetchStmts[Aggregation.SUM.ordinal()];</b>
&nbsp;            } else {
<b class="nc">&nbsp;                fetchStmts[type.ordinal()] = prepare(SELECT_PREFIX +</b>
<b class="nc">&nbsp;                        String.join(&quot;, &quot;, ModelConstants.getFetchColumnNames(type)) + &quot; FROM &quot; + ModelConstants.TS_KV_CF</b>
&nbsp;                        + &quot; WHERE &quot; + ModelConstants.ENTITY_TYPE_COLUMN + EQUALS_PARAM
&nbsp;                        + &quot;AND &quot; + ModelConstants.ENTITY_ID_COLUMN + EQUALS_PARAM
&nbsp;                        + &quot;AND &quot; + ModelConstants.KEY_COLUMN + EQUALS_PARAM
&nbsp;                        + &quot;AND &quot; + ModelConstants.PARTITION_COLUMN + EQUALS_PARAM
&nbsp;                        + &quot;AND &quot; + ModelConstants.TS_COLUMN + &quot; &gt;= ? &quot;
&nbsp;                        + &quot;AND &quot; + ModelConstants.TS_COLUMN + &quot; &lt; ?&quot;
<b class="nc">&nbsp;                        + (type == Aggregation.NONE ? &quot; ORDER BY &quot; + ModelConstants.TS_COLUMN + &quot; &quot; + orderBy + &quot; LIMIT ?&quot; : &quot;&quot;));</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return fetchStmts;</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
