<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > TbInMemoryRegistrationStore</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.server.transport.lwm2m.server.store</a>
</div>

<h1>Coverage Summary for Class: TbInMemoryRegistrationStore (org.thingsboard.server.transport.lwm2m.server.store)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TbInMemoryRegistrationStore</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/29)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/78)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/176)
  </span>
</td>
</tr>
  <tr>
    <td class="name">TbInMemoryRegistrationStore$Cleaner</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/31)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/82)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/187)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.server.transport.lwm2m.server.store;
&nbsp;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.eclipse.californium.core.network.TokenGenerator;
&nbsp;import org.eclipse.leshan.core.Destroyable;
&nbsp;import org.eclipse.leshan.core.Startable;
&nbsp;import org.eclipse.leshan.core.Stoppable;
&nbsp;import org.eclipse.leshan.core.observation.CompositeObservation;
&nbsp;import org.eclipse.leshan.core.observation.Observation;
&nbsp;import org.eclipse.leshan.core.observation.ObservationIdentifier;
&nbsp;import org.eclipse.leshan.core.observation.SingleObservation;
&nbsp;import org.eclipse.leshan.core.peer.LwM2mIdentity;
&nbsp;import org.eclipse.leshan.server.registration.Deregistration;
&nbsp;import org.eclipse.leshan.server.registration.ExpirationListener;
&nbsp;import org.eclipse.leshan.server.registration.Registration;
&nbsp;import org.eclipse.leshan.server.registration.RegistrationStore;
&nbsp;import org.eclipse.leshan.server.registration.RegistrationUpdate;
&nbsp;import org.eclipse.leshan.server.registration.UpdatedRegistration;
&nbsp;import org.thingsboard.common.util.ThingsBoardExecutors;
&nbsp;import org.thingsboard.server.transport.lwm2m.config.LwM2MTransportServerConfig;
&nbsp;import org.thingsboard.server.transport.lwm2m.server.LwM2mVersionedModelProvider;
&nbsp;
&nbsp;import java.net.InetSocketAddress;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collection;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Objects;
&nbsp;import java.util.Set;
&nbsp;import java.util.concurrent.ScheduledExecutorService;
&nbsp;import java.util.concurrent.ScheduledFuture;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.concurrent.locks.ReadWriteLock;
&nbsp;import java.util.concurrent.locks.ReentrantReadWriteLock;
&nbsp;
<b class="nc">&nbsp;@Slf4j</b>
&nbsp;public class TbInMemoryRegistrationStore implements RegistrationStore, Startable, Stoppable, Destroyable {
&nbsp;
&nbsp;    // Data structure
<b class="nc">&nbsp;    private final Map&lt;String /* end-point */, Registration&gt; regsByEp = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;    private final Map&lt;InetSocketAddress, Registration&gt; regsByAddr = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;    private final Map&lt;String /* reg-id */, Registration&gt; regsByRegId = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;    private final Map&lt;LwM2mIdentity, Registration&gt; regsByIdentity = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;    private final Map&lt;ObservationIdentifier, Observation&gt; obsByToken = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;    private final Map&lt;String, Set&lt;ObservationIdentifier&gt;&gt; tokensByRegId = new HashMap&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;    private final ReadWriteLock lock = new ReentrantReadWriteLock();</b>
&nbsp;
&nbsp;    // Listener use to notify when a registration expires
&nbsp;    private ExpirationListener expirationListener;
&nbsp;
&nbsp;    private final ScheduledExecutorService schedExecutor;
&nbsp;    private ScheduledFuture&lt;?&gt; cleanerTask;
<b class="nc">&nbsp;    private boolean started = false;</b>
&nbsp;    private final long cleanPeriod; // in seconds
&nbsp;
&nbsp;    private final LwM2MTransportServerConfig config;
&nbsp;
&nbsp;    private final LwM2mVersionedModelProvider modelProvider;
&nbsp;
&nbsp;    private TokenGenerator tokenGenerator;
&nbsp;
&nbsp;    public TbInMemoryRegistrationStore() {
<b class="nc">&nbsp;        this(null, 2, null); // default clean period : 2s</b>
&nbsp;    }
&nbsp;
&nbsp;    public TbInMemoryRegistrationStore(LwM2MTransportServerConfig config, long cleanPeriodInSec, LwM2mVersionedModelProvider modelProvider) {
<b class="nc">&nbsp;        this(config, ThingsBoardExecutors.newSingleThreadScheduledExecutor(String.format(&quot;TbInMemoryRegistrationStore Cleaner (%ds)&quot;, cleanPeriodInSec)), cleanPeriodInSec, modelProvider);</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public TbInMemoryRegistrationStore(LwM2MTransportServerConfig config, ScheduledExecutorService schedExecutor, long cleanPeriodInSec, LwM2mVersionedModelProvider modelProvider) {</b>
<b class="nc">&nbsp;        this.schedExecutor = schedExecutor;</b>
<b class="nc">&nbsp;        this.cleanPeriod = cleanPeriodInSec;</b>
<b class="nc">&nbsp;        this.modelProvider = modelProvider;</b>
<b class="nc">&nbsp;        this.config = config;</b>
&nbsp;    }
&nbsp;
&nbsp;    /* *************** Leshan Registration API **************** */
&nbsp;
&nbsp;    @Override
&nbsp;    public Deregistration addRegistration(Registration registration) {
&nbsp;        try {
<b class="nc">&nbsp;            lock.writeLock().lock();</b>
&nbsp;
<b class="nc">&nbsp;            Registration registrationRemoved = regsByEp.put(registration.getEndpoint(), registration);</b>
<b class="nc">&nbsp;            regsByRegId.put(registration.getId(), registration);</b>
<b class="nc">&nbsp;            regsByIdentity.put(registration.getClientTransportData().getIdentity(), registration);</b>
&nbsp;            // If a registration is already associated to this address we don&#39;t care as we only want to keep the most
&nbsp;            // recent binding.
<b class="nc">&nbsp;            regsByAddr.put(registration.getSocketAddress(), registration);</b>
<b class="nc">&nbsp;            if (registrationRemoved != null) {</b>
<b class="nc">&nbsp;                Collection&lt;Observation&gt; observationsRemoved = unsafeRemoveAllObservations(registrationRemoved.getId());</b>
<b class="nc">&nbsp;                if (!registrationRemoved.getSocketAddress().equals(registration.getSocketAddress())) {</b>
<b class="nc">&nbsp;                    removeFromMap(regsByAddr, registrationRemoved.getSocketAddress(), registrationRemoved);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (!registrationRemoved.getId().equals(registration.getId())) {</b>
<b class="nc">&nbsp;                    removeFromMap(regsByRegId, registrationRemoved.getId(), registrationRemoved);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (!registrationRemoved.getClientTransportData().getIdentity()</b>
<b class="nc">&nbsp;                        .equals(registration.getClientTransportData().getIdentity())) {</b>
<b class="nc">&nbsp;                    removeFromMap(regsByIdentity, registrationRemoved.getClientTransportData().getIdentity(),</b>
&nbsp;                            registrationRemoved);
&nbsp;                }
<b class="nc">&nbsp;                return new Deregistration(registrationRemoved, observationsRemoved);</b>
&nbsp;            }
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.writeLock().unlock();</b>
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public UpdatedRegistration updateRegistration(RegistrationUpdate update) {
<b class="nc">&nbsp;        log.trace(&quot;updateRegistration [{}]&quot;, update);</b>
&nbsp;        try {
<b class="nc">&nbsp;            lock.writeLock().lock();</b>
&nbsp;
<b class="nc">&nbsp;            Registration registration = getRegistration(update.getRegistrationId());</b>
<b class="nc">&nbsp;            if (registration == null) {</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                Registration updatedRegistration = update.update(registration);</b>
<b class="nc">&nbsp;                regsByEp.put(updatedRegistration.getEndpoint(), updatedRegistration);</b>
&nbsp;                // If registration is already associated to this address we don&#39;t care as we only want to keep the most
&nbsp;                // recent binding.
<b class="nc">&nbsp;                regsByAddr.put(updatedRegistration.getSocketAddress(), updatedRegistration);</b>
<b class="nc">&nbsp;                if (!registration.getSocketAddress().equals(updatedRegistration.getSocketAddress())) {</b>
<b class="nc">&nbsp;                    removeFromMap(regsByAddr, registration.getSocketAddress(), registration);</b>
&nbsp;                }
<b class="nc">&nbsp;                regsByIdentity.put(updatedRegistration.getClientTransportData().getIdentity(), updatedRegistration);</b>
<b class="nc">&nbsp;                if (!registration.getClientTransportData().getIdentity()</b>
<b class="nc">&nbsp;                        .equals(updatedRegistration.getClientTransportData().getIdentity())) {</b>
<b class="nc">&nbsp;                    removeFromMap(regsByIdentity, registration.getClientTransportData().getIdentity(), registration);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                regsByRegId.put(updatedRegistration.getId(), updatedRegistration);</b>
&nbsp;
<b class="nc">&nbsp;                return new UpdatedRegistration(registration, updatedRegistration);</b>
&nbsp;            }
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.writeLock().unlock();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Registration getRegistration(String registrationId) {
&nbsp;        try {
<b class="nc">&nbsp;            lock.readLock().lock();</b>
<b class="nc">&nbsp;            return regsByRegId.get(registrationId);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.readLock().unlock();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Registration getRegistrationByEndpoint(String endpoint) {
&nbsp;        try {
<b class="nc">&nbsp;            lock.readLock().lock();</b>
<b class="nc">&nbsp;            return regsByEp.get(endpoint);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.readLock().unlock();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Registration getRegistrationByAdress(InetSocketAddress address) {
&nbsp;        try {
<b class="nc">&nbsp;            lock.readLock().lock();</b>
<b class="nc">&nbsp;            return regsByAddr.get(address);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.readLock().unlock();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Registration getRegistrationByIdentity(LwM2mIdentity identity) {
&nbsp;        try {
<b class="nc">&nbsp;            lock.readLock().lock();</b>
<b class="nc">&nbsp;            return regsByIdentity.get(identity);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.readLock().unlock();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Iterator&lt;Registration&gt; getAllRegistrations() {
&nbsp;        try {
<b class="nc">&nbsp;            lock.readLock().lock();</b>
<b class="nc">&nbsp;            return new ArrayList&lt;&gt;(regsByEp.values()).iterator();</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.readLock().unlock();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Deregistration removeRegistration(String registrationId) {
&nbsp;        try {
<b class="nc">&nbsp;            lock.writeLock().lock();</b>
&nbsp;
<b class="nc">&nbsp;            Registration registration = getRegistration(registrationId);</b>
<b class="nc">&nbsp;            if (registration != null) {</b>
<b class="nc">&nbsp;                Collection&lt;Observation&gt; observationsRemoved = unsafeRemoveAllObservations(registration.getId());</b>
<b class="nc">&nbsp;                regsByEp.remove(registration.getEndpoint());</b>
<b class="nc">&nbsp;                removeFromMap(regsByAddr, registration.getSocketAddress(), registration);</b>
<b class="nc">&nbsp;                removeFromMap(regsByRegId, registration.getId(), registration);</b>
<b class="nc">&nbsp;                removeFromMap(regsByIdentity, registration.getClientTransportData().getIdentity(), registration);</b>
<b class="nc">&nbsp;                return new Deregistration(registration, observationsRemoved);</b>
&nbsp;            }
<b class="nc">&nbsp;            return null;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.writeLock().unlock();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /* *************** Leshan Observation API **************** */
&nbsp;
&nbsp;    @Override
&nbsp;    public Collection&lt;Observation&gt; addObservation(String registrationId, Observation observation, boolean addIfAbsent) {
<b class="nc">&nbsp;        List&lt;Observation&gt; removed = new ArrayList&lt;&gt;();</b>
&nbsp;        try {
<b class="nc">&nbsp;            lock.writeLock().lock();</b>
<b class="nc">&nbsp;            if (!regsByRegId.containsKey(registrationId)) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(String.format(</b>
&nbsp;                        &quot;can not add observation %s there is no registration with id %s&quot;, observation, registrationId));
&nbsp;            }
<b class="nc">&nbsp;            updateObservation(registrationId, observation, addIfAbsent, removed);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.writeLock().unlock();</b>
&nbsp;        }
<b class="nc">&nbsp;        return removed;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void updateObservation(String registrationId, Observation observation, boolean addIfAbsent, List&lt;Observation&gt; removed) {
&nbsp;
&nbsp;        // Absorption by existing Observations
<b class="nc">&nbsp;        Observation previousObservation = null;</b>
<b class="nc">&nbsp;        ObservationIdentifier id = observation.getId();</b>
<b class="nc">&nbsp;        if (addIfAbsent) {</b>
<b class="nc">&nbsp;            if (!obsByToken.containsKey(id)) {</b>
<b class="nc">&nbsp;                previousObservation = obsByToken.put(id, observation);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                obsByToken.put(id, observation);</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            previousObservation = obsByToken.put(id, observation);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!tokensByRegId.containsKey(registrationId)) {</b>
<b class="nc">&nbsp;            tokensByRegId.put(registrationId, new HashSet&lt;ObservationIdentifier&gt;());</b>
&nbsp;        }
<b class="nc">&nbsp;        tokensByRegId.get(registrationId).add(id);</b>
&nbsp;
&nbsp;        // log any collisions
<b class="nc">&nbsp;        if (previousObservation != null) {</b>
<b class="nc">&nbsp;            removed.add(previousObservation);</b>
<b class="nc">&nbsp;            log.warn(&quot;Token collision ? observation [{}] will be replaced by observation [{}] &quot;,</b>
&nbsp;                    previousObservation, observation);
&nbsp;        }
&nbsp;        // cancel existing observations for the same path and registration id.
<b class="nc">&nbsp;        for (Observation obs : unsafeGetObservations(registrationId)) {</b>
<b class="nc">&nbsp;            if (areTheSamePaths(observation, obs) &amp;&amp; !observation.getId().equals(obs.getId())) {</b>
<b class="nc">&nbsp;                unsafeRemoveObservation(obs.getId());</b>
<b class="nc">&nbsp;                removed.add(obs);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private boolean areTheSamePaths(Observation observation, Observation obs) {
<b class="nc">&nbsp;        if (observation instanceof SingleObservation &amp;&amp; obs instanceof SingleObservation) {</b>
<b class="nc">&nbsp;            return ((SingleObservation) observation).getPath().equals(((SingleObservation) obs).getPath());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (observation instanceof CompositeObservation &amp;&amp; obs instanceof CompositeObservation) {</b>
<b class="nc">&nbsp;            return ((CompositeObservation) observation).getPaths().equals(((CompositeObservation) obs).getPaths());</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Observation removeObservation(String registrationId, ObservationIdentifier observationId) {
&nbsp;        try {
<b class="nc">&nbsp;            lock.writeLock().lock();</b>
<b class="nc">&nbsp;            Observation observation = unsafeGetObservation(observationId);</b>
<b class="nc">&nbsp;            if (observation instanceof SingleObservation){</b>
<b class="nc">&nbsp;                log.trace(&quot;(SingleObservation) removeObservation: [{}]&quot;, ((SingleObservation)observation).getPath());</b>
&nbsp;            } else {
<b class="nc">&nbsp;                log.trace(&quot;(CompositeObservation) removeObservation: [{}]&quot;, ((CompositeObservation)observation).getPaths());</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (observation != null &amp;&amp; registrationId.equals(observation.getRegistrationId())) {</b>
<b class="nc">&nbsp;                unsafeRemoveObservation(observationId);</b>
<b class="nc">&nbsp;                return observation;</b>
&nbsp;            }
<b class="nc">&nbsp;            return null;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.writeLock().unlock();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Observation getObservation(String registrationId, ObservationIdentifier observationId) {
&nbsp;        try {
<b class="nc">&nbsp;            lock.readLock().lock();</b>
<b class="nc">&nbsp;            Observation observation = unsafeGetObservation(observationId);</b>
<b class="nc">&nbsp;            if (observation != null &amp;&amp; registrationId.equals(observation.getRegistrationId())) {</b>
<b class="nc">&nbsp;                return observation;</b>
&nbsp;            }
<b class="nc">&nbsp;            return null;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.readLock().unlock();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Observation getObservation(ObservationIdentifier observationId) {
&nbsp;        try {
<b class="nc">&nbsp;            lock.readLock().lock();</b>
<b class="nc">&nbsp;            Observation observation = unsafeGetObservation(observationId);</b>
<b class="nc">&nbsp;            if (observation != null) {</b>
<b class="nc">&nbsp;                return observation;</b>
&nbsp;            }
<b class="nc">&nbsp;            return null;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.readLock().unlock();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prepare for Cancel one Observation
&nbsp;     * @param registrationId
&nbsp;     * @return
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Collection&lt;Observation&gt; getObservations(String registrationId) {
&nbsp;        try {
<b class="nc">&nbsp;            lock.readLock().lock();</b>
<b class="nc">&nbsp;            return unsafeGetObservations(registrationId);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.readLock().unlock();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * CancelAllObservation
&nbsp;     * @param registrationId
&nbsp;     * @return
&nbsp;     */
&nbsp;
&nbsp;    @Override
&nbsp;    public Collection&lt;Observation&gt; removeObservations(String registrationId) {
&nbsp;        try {
<b class="nc">&nbsp;            lock.writeLock().lock();</b>
<b class="nc">&nbsp;            return unsafeRemoveAllObservations(registrationId);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.writeLock().unlock();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /* *************** Observation utility functions **************** */
&nbsp;
&nbsp;    private Observation unsafeGetObservation(ObservationIdentifier token) {
<b class="nc">&nbsp;        Observation obs = obsByToken.get(token);</b>
<b class="nc">&nbsp;        return obs;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void unsafeRemoveObservation(ObservationIdentifier observationId) {
<b class="nc">&nbsp;        Observation removed = obsByToken.remove(observationId);</b>
<b class="nc">&nbsp;        if (removed != null) {</b>
<b class="nc">&nbsp;            String registrationId = removed.getRegistrationId();</b>
<b class="nc">&nbsp;            Set&lt;ObservationIdentifier&gt; tokens = tokensByRegId.get(registrationId);</b>
<b class="nc">&nbsp;            tokens.remove(observationId);</b>
<b class="nc">&nbsp;            if (tokens.isEmpty()) {</b>
<b class="nc">&nbsp;                tokensByRegId.remove(registrationId);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * CancelAllObservation
&nbsp;     * @param registrationId
&nbsp;     * @return
&nbsp;     */
&nbsp;    private Collection&lt;Observation&gt; unsafeRemoveAllObservations(String registrationId) {
<b class="nc">&nbsp;        Collection&lt;Observation&gt; removed = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        Set&lt;ObservationIdentifier&gt; ids = tokensByRegId.get(registrationId);</b>
<b class="nc">&nbsp;        if (ids != null) {</b>
<b class="nc">&nbsp;            for (ObservationIdentifier id : ids) {</b>
<b class="nc">&nbsp;                Observation observationRemoved = obsByToken.remove(id);</b>
<b class="nc">&nbsp;                if (observationRemoved != null) {</b>
<b class="nc">&nbsp;                    removed.add(observationRemoved);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        tokensByRegId.remove(registrationId);</b>
<b class="nc">&nbsp;        return removed;</b>
&nbsp;    }
&nbsp;
&nbsp;    private Collection&lt;Observation&gt; unsafeGetObservations(String registrationId) {
<b class="nc">&nbsp;        Collection&lt;Observation&gt; result = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        Set&lt;ObservationIdentifier&gt; ids = tokensByRegId.get(registrationId);</b>
<b class="nc">&nbsp;        if (ids != null) {</b>
<b class="nc">&nbsp;            for (ObservationIdentifier id : ids) {</b>
<b class="nc">&nbsp;                Observation obs = unsafeGetObservation(id);</b>
<b class="nc">&nbsp;                if (obs != null) {</b>
<b class="nc">&nbsp;                    result.add(obs);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;    /* *************** Expiration handling **************** */
&nbsp;
&nbsp;    @Override
&nbsp;    public void setExpirationListener(ExpirationListener listener) {
<b class="nc">&nbsp;        this.expirationListener = listener;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * start the registration store, will start regular cleanup of dead registrations.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public synchronized void start() {
<b class="nc">&nbsp;        if (!started) {</b>
<b class="nc">&nbsp;            started = true;</b>
<b class="nc">&nbsp;            cleanerTask = schedExecutor.scheduleAtFixedRate(new TbInMemoryRegistrationStore.Cleaner(), cleanPeriod, cleanPeriod, TimeUnit.SECONDS);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Stop the underlying cleanup of the registrations.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public synchronized void stop() {
<b class="nc">&nbsp;        if (started) {</b>
<b class="nc">&nbsp;            started = false;</b>
<b class="nc">&nbsp;            if (cleanerTask != null) {</b>
<b class="nc">&nbsp;                cleanerTask.cancel(false);</b>
<b class="nc">&nbsp;                cleanerTask = null;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Destroy &quot;cleanup&quot; scheduler.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public synchronized void destroy() {
<b class="nc">&nbsp;        started = false;</b>
<b class="nc">&nbsp;        schedExecutor.shutdownNow();</b>
&nbsp;        try {
<b class="nc">&nbsp;            schedExecutor.awaitTermination(5, TimeUnit.SECONDS);</b>
&nbsp;        } catch (InterruptedException e) {
<b class="nc">&nbsp;            log.warn(&quot;Destroying InMemoryRegistrationStore was interrupted.&quot;, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private class Cleaner implements Runnable {</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void run() {
&nbsp;            try {
<b class="nc">&nbsp;                Collection&lt;Registration&gt; allRegs = new ArrayList&lt;&gt;();</b>
&nbsp;                try {
<b class="nc">&nbsp;                    lock.readLock().lock();</b>
<b class="nc">&nbsp;                    allRegs.addAll(regsByEp.values());</b>
&nbsp;                } finally {
<b class="nc">&nbsp;                    lock.readLock().unlock();</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                for (Registration reg : allRegs) {</b>
<b class="nc">&nbsp;                    if (!reg.isAlive()) {</b>
&nbsp;                        // force de-registration
<b class="nc">&nbsp;                        Deregistration removedRegistration = removeRegistration(reg.getId());</b>
<b class="nc">&nbsp;                        expirationListener.registrationExpired(removedRegistration.getRegistration(),</b>
<b class="nc">&nbsp;                                removedRegistration.getObservations());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            } catch (Exception e) {
<b class="nc">&nbsp;                log.warn(&quot;Unexpected Exception while registration cleaning&quot;, e);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    // boolean remove(Object key, Object value) exist only since java8
&nbsp;    // So this method is here only while we want to support java 7
&nbsp;    protected &lt;K, V&gt; boolean removeFromMap(Map&lt;K, V&gt; map, K key, V value) {
<b class="nc">&nbsp;        if (map.containsKey(key) &amp;&amp; Objects.equals(map.get(key), value)) {</b>
<b class="nc">&nbsp;            map.remove(key);</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        } else
<b class="nc">&nbsp;            return false;</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
