<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > TbGetTelemetryNode</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.rule.engine.metadata</a>
</div>

<h1>Coverage Summary for Class: TbGetTelemetryNode (org.thingsboard.rule.engine.metadata)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TbGetTelemetryNode</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/64)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/119)
  </span>
</td>
</tr>
  <tr>
    <td class="name">TbGetTelemetryNode$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TbGetTelemetryNode$Interval</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/64)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/120)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.rule.engine.metadata;
&nbsp;
&nbsp;import com.fasterxml.jackson.databind.JsonNode;
&nbsp;import com.fasterxml.jackson.databind.node.ArrayNode;
&nbsp;import com.fasterxml.jackson.databind.node.ObjectNode;
&nbsp;import com.google.common.util.concurrent.ListenableFuture;
&nbsp;import lombok.Data;
&nbsp;import lombok.NoArgsConstructor;
&nbsp;import org.apache.commons.lang3.math.NumberUtils;
&nbsp;import org.thingsboard.common.util.DonAsynchron;
&nbsp;import org.thingsboard.common.util.JacksonUtil;
&nbsp;import org.thingsboard.rule.engine.api.RuleNode;
&nbsp;import org.thingsboard.rule.engine.api.TbContext;
&nbsp;import org.thingsboard.rule.engine.api.TbNode;
&nbsp;import org.thingsboard.rule.engine.api.TbNodeConfiguration;
&nbsp;import org.thingsboard.rule.engine.api.TbNodeException;
&nbsp;import org.thingsboard.rule.engine.api.util.TbNodeUtils;
&nbsp;import org.thingsboard.server.common.data.kv.Aggregation;
&nbsp;import org.thingsboard.server.common.data.kv.BaseReadTsKvQuery;
&nbsp;import org.thingsboard.server.common.data.kv.ReadTsKvQuery;
&nbsp;import org.thingsboard.server.common.data.kv.TsKvEntry;
&nbsp;import org.thingsboard.server.common.data.page.SortOrder.Direction;
&nbsp;import org.thingsboard.server.common.data.plugin.ComponentType;
&nbsp;import org.thingsboard.server.common.data.util.TbPair;
&nbsp;import org.thingsboard.server.common.msg.TbMsg;
&nbsp;import org.thingsboard.server.common.msg.TbMsgMetaData;
&nbsp;
&nbsp;import java.util.List;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;@RuleNode(
&nbsp;        type = ComponentType.ENRICHMENT,
&nbsp;        name = &quot;originator telemetry&quot;,
&nbsp;        configClazz = TbGetTelemetryNodeConfiguration.class,
&nbsp;        version = 2,
&nbsp;        nodeDescription = &quot;Adds message originator telemetry for selected time range into message metadata&quot;,
&nbsp;        nodeDetails = &quot;Useful when you need to get telemetry data set from the message originator for a specific time range &quot; +
&nbsp;                &quot;instead of fetching just the latest telemetry or if you need to get the closest telemetry to the fetch interval start or end. &quot; +
&nbsp;                &quot;Also, this node can be used for telemetry aggregation within configured fetch interval.&lt;br&gt;&lt;br&gt;&quot; +
&nbsp;                &quot;Output connections: &lt;code&gt;Success&lt;/code&gt;, &lt;code&gt;Failure&lt;/code&gt;.&quot;,
&nbsp;        configDirective = &quot;tbEnrichmentNodeGetTelemetryFromDatabase&quot;,
&nbsp;        docUrl = &quot;https://thingsboard.io/docs/user-guide/rule-engine-2-0/nodes/enrichment/originator-telemetry/&quot;
&nbsp;)
<b class="nc">&nbsp;public class TbGetTelemetryNode implements TbNode {</b>
&nbsp;
&nbsp;    private TbGetTelemetryNodeConfiguration config;
&nbsp;    private List&lt;String&gt; tsKeyNames;
&nbsp;    private int limit;
&nbsp;    private FetchMode fetchMode;
&nbsp;    private Direction orderBy;
&nbsp;    private Aggregation aggregation;
&nbsp;
&nbsp;    @Override
&nbsp;    public void init(TbContext ctx, TbNodeConfiguration configuration) throws TbNodeException {
<b class="nc">&nbsp;        this.config = TbNodeUtils.convert(configuration, TbGetTelemetryNodeConfiguration.class);</b>
<b class="nc">&nbsp;        tsKeyNames = config.getLatestTsKeyNames();</b>
<b class="nc">&nbsp;        if (tsKeyNames.isEmpty()) {</b>
<b class="nc">&nbsp;            throw new TbNodeException(&quot;Telemetry should be specified!&quot;, true);</b>
&nbsp;        }
<b class="nc">&nbsp;        fetchMode = config.getFetchMode();</b>
<b class="nc">&nbsp;        if (fetchMode == null) {</b>
<b class="nc">&nbsp;            throw new TbNodeException(&quot;FetchMode should be specified!&quot;, true);</b>
&nbsp;        }
<b class="nc">&nbsp;        switch (fetchMode) {</b>
&nbsp;            case ALL:
<b class="nc">&nbsp;                limit = validateLimit(config.getLimit());</b>
<b class="nc">&nbsp;                if (config.getOrderBy() == null) {</b>
<b class="nc">&nbsp;                    throw new TbNodeException(&quot;OrderBy should be specified!&quot;, true);</b>
&nbsp;                }
<b class="nc">&nbsp;                orderBy = config.getOrderBy();</b>
<b class="nc">&nbsp;                if (config.getAggregation() == null) {</b>
<b class="nc">&nbsp;                    throw new TbNodeException(&quot;Aggregation should be specified!&quot;, true);</b>
&nbsp;                }
<b class="nc">&nbsp;                aggregation = config.getAggregation();</b>
&nbsp;                break;
&nbsp;            case FIRST:
<b class="nc">&nbsp;                limit = 1;</b>
<b class="nc">&nbsp;                orderBy = Direction.ASC;</b>
<b class="nc">&nbsp;                aggregation = Aggregation.NONE;</b>
&nbsp;                break;
&nbsp;            case LAST:
<b class="nc">&nbsp;                limit = 1;</b>
<b class="nc">&nbsp;                orderBy = Direction.DESC;</b>
<b class="nc">&nbsp;                aggregation = Aggregation.NONE;</b>
&nbsp;                break;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void onMsg(TbContext ctx, TbMsg msg) {
<b class="nc">&nbsp;        Interval interval = getInterval(msg);</b>
<b class="nc">&nbsp;        if (interval.getStartTs() &gt; interval.getEndTs()) {</b>
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Interval start should be less than Interval end&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        List&lt;String&gt; keys = TbNodeUtils.processPatterns(tsKeyNames, msg);</b>
<b class="nc">&nbsp;        ListenableFuture&lt;List&lt;TsKvEntry&gt;&gt; list = ctx.getTimeseriesService().findAll(ctx.getTenantId(), msg.getOriginator(), buildQueries(interval, keys));</b>
<b class="nc">&nbsp;        DonAsynchron.withCallback(list, data -&gt; {</b>
<b class="nc">&nbsp;            var metaData = updateMetadata(data, msg, keys);</b>
<b class="nc">&nbsp;            ctx.tellSuccess(msg.transform()</b>
<b class="nc">&nbsp;                    .metaData(metaData)</b>
<b class="nc">&nbsp;                    .build());</b>
<b class="nc">&nbsp;        }, error -&gt; ctx.tellFailure(msg, error), ctx.getDbCallbackExecutor());</b>
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;ReadTsKvQuery&gt; buildQueries(Interval interval, List&lt;String&gt; keys) {
<b class="nc">&nbsp;        final long aggIntervalStep = Aggregation.NONE.equals(aggregation) ? 1 :</b>
&nbsp;                // exact how it validates on BaseTimeseriesService.validate()
&nbsp;                // see CassandraBaseTimeseriesDao.findAllAsync()
<b class="nc">&nbsp;                interval.getEndTs() - interval.getStartTs();</b>
&nbsp;
<b class="nc">&nbsp;        return keys.stream()</b>
<b class="nc">&nbsp;                .map(key -&gt; new BaseReadTsKvQuery(key, interval.getStartTs(), interval.getEndTs(), aggIntervalStep, limit, aggregation, orderBy.name()))</b>
<b class="nc">&nbsp;                .collect(Collectors.toList());</b>
&nbsp;    }
&nbsp;
&nbsp;    private TbMsgMetaData updateMetadata(List&lt;TsKvEntry&gt; entries, TbMsg msg, List&lt;String&gt; keys) {
<b class="nc">&nbsp;        ObjectNode resultNode = JacksonUtil.newObjectNode(JacksonUtil.ALLOW_UNQUOTED_FIELD_NAMES_MAPPER);</b>
<b class="nc">&nbsp;        if (FetchMode.ALL.equals(fetchMode)) {</b>
<b class="nc">&nbsp;            entries.forEach(entry -&gt; processArray(resultNode, entry));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            entries.forEach(entry -&gt; processSingle(resultNode, entry));</b>
&nbsp;        }
<b class="nc">&nbsp;        var copy = msg.getMetaData().copy();</b>
<b class="nc">&nbsp;        for (String key : keys) {</b>
<b class="nc">&nbsp;            if (resultNode.has(key)) {</b>
<b class="nc">&nbsp;                copy.putValue(key, resultNode.get(key).toString());</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return copy;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void processSingle(ObjectNode node, TsKvEntry entry) {
<b class="nc">&nbsp;        node.put(entry.getKey(), entry.getValueAsString());</b>
&nbsp;    }
&nbsp;
&nbsp;    private void processArray(ObjectNode node, TsKvEntry entry) {
<b class="nc">&nbsp;        if (node.has(entry.getKey())) {</b>
<b class="nc">&nbsp;            ArrayNode arrayNode = (ArrayNode) node.get(entry.getKey());</b>
<b class="nc">&nbsp;            arrayNode.add(buildNode(entry));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            ArrayNode arrayNode = JacksonUtil.ALLOW_UNQUOTED_FIELD_NAMES_MAPPER.createArrayNode();</b>
<b class="nc">&nbsp;            arrayNode.add(buildNode(entry));</b>
<b class="nc">&nbsp;            node.set(entry.getKey(), arrayNode);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private ObjectNode buildNode(TsKvEntry entry) {
<b class="nc">&nbsp;        ObjectNode obj = JacksonUtil.newObjectNode(JacksonUtil.ALLOW_UNQUOTED_FIELD_NAMES_MAPPER);</b>
<b class="nc">&nbsp;        obj.put(&quot;ts&quot;, entry.getTs());</b>
<b class="nc">&nbsp;        JacksonUtil.addKvEntry(obj, entry, &quot;value&quot;, JacksonUtil.ALLOW_UNQUOTED_FIELD_NAMES_MAPPER);</b>
<b class="nc">&nbsp;        return obj;</b>
&nbsp;    }
&nbsp;
&nbsp;    private Interval getInterval(TbMsg msg) {
<b class="nc">&nbsp;        if (config.isUseMetadataIntervalPatterns()) {</b>
<b class="nc">&nbsp;            return getIntervalFromPatterns(msg);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            Interval interval = new Interval();</b>
<b class="nc">&nbsp;            long ts = getCurrentTimeMillis();</b>
<b class="nc">&nbsp;            interval.setStartTs(ts - TimeUnit.valueOf(config.getStartIntervalTimeUnit()).toMillis(config.getStartInterval()));</b>
<b class="nc">&nbsp;            interval.setEndTs(ts - TimeUnit.valueOf(config.getEndIntervalTimeUnit()).toMillis(config.getEndInterval()));</b>
<b class="nc">&nbsp;            return interval;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private Interval getIntervalFromPatterns(TbMsg msg) {
<b class="nc">&nbsp;        Interval interval = new Interval();</b>
<b class="nc">&nbsp;        interval.setStartTs(checkPattern(msg, config.getStartIntervalPattern()));</b>
<b class="nc">&nbsp;        interval.setEndTs(checkPattern(msg, config.getEndIntervalPattern()));</b>
<b class="nc">&nbsp;        return interval;</b>
&nbsp;    }
&nbsp;
&nbsp;    private long checkPattern(TbMsg msg, String pattern) {
<b class="nc">&nbsp;        String value = getValuePattern(msg, pattern);</b>
<b class="nc">&nbsp;        if (value == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Message value: &#39;&quot; +</b>
<b class="nc">&nbsp;                    replaceRegex(pattern) + &quot;&#39; is undefined&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        boolean parsable = NumberUtils.isParsable(value);</b>
<b class="nc">&nbsp;        if (!parsable) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Message value: &#39;&quot; +</b>
<b class="nc">&nbsp;                    replaceRegex(pattern) + &quot;&#39; has invalid format&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return Long.parseLong(value);</b>
&nbsp;    }
&nbsp;
&nbsp;    private String getValuePattern(TbMsg msg, String pattern) {
<b class="nc">&nbsp;        String value = TbNodeUtils.processPattern(pattern, msg);</b>
<b class="nc">&nbsp;        return value.equals(pattern) ? null : value;</b>
&nbsp;    }
&nbsp;
&nbsp;    private String replaceRegex(String pattern) {
<b class="nc">&nbsp;        return pattern.replaceAll(&quot;[$\\[{}\\]]&quot;, &quot;&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    private int validateLimit(int limit) throws TbNodeException {
<b class="nc">&nbsp;        if (limit &lt; 2 || limit &gt; TbGetTelemetryNodeConfiguration.MAX_FETCH_SIZE) {</b>
<b class="nc">&nbsp;            throw new TbNodeException(&quot;Limit should be in a range from 2 to 1000.&quot;, true);</b>
&nbsp;        }
<b class="nc">&nbsp;        return limit;</b>
&nbsp;    }
&nbsp;
&nbsp;    long getCurrentTimeMillis() {
<b class="nc">&nbsp;        return System.currentTimeMillis();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Data
&nbsp;    @NoArgsConstructor
&nbsp;    private static class Interval {
&nbsp;        private Long startTs;
&nbsp;        private Long endTs;
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public TbPair&lt;Boolean, JsonNode&gt; upgrade(int fromVersion, JsonNode oldConfiguration) throws TbNodeException {
<b class="nc">&nbsp;        boolean hasChanges = false;</b>
<b class="nc">&nbsp;        switch (fromVersion) {</b>
&nbsp;            case 0: {
<b class="nc">&nbsp;                if (oldConfiguration.hasNonNull(&quot;fetchMode&quot;)) {</b>
<b class="nc">&nbsp;                    String fetchMode = oldConfiguration.get(&quot;fetchMode&quot;).asText();</b>
<b class="nc">&nbsp;                    switch (fetchMode) {</b>
&nbsp;                        case &quot;FIRST&quot; -&gt; {
<b class="nc">&nbsp;                            ((ObjectNode) oldConfiguration).put(&quot;orderBy&quot;, Direction.ASC.name());</b>
<b class="nc">&nbsp;                            ((ObjectNode) oldConfiguration).put(&quot;aggregation&quot;, Aggregation.NONE.name());</b>
<b class="nc">&nbsp;                            hasChanges = true;</b>
&nbsp;                        }
&nbsp;                        case &quot;LAST&quot; -&gt; {
<b class="nc">&nbsp;                            ((ObjectNode) oldConfiguration).put(&quot;orderBy&quot;, Direction.DESC.name());</b>
<b class="nc">&nbsp;                            ((ObjectNode) oldConfiguration).put(&quot;aggregation&quot;, Aggregation.NONE.name());</b>
<b class="nc">&nbsp;                            hasChanges = true;</b>
&nbsp;                        }
&nbsp;                        case &quot;ALL&quot; -&gt; {
<b class="nc">&nbsp;                            if (oldConfiguration.has(&quot;orderBy&quot;) &amp;&amp;</b>
<b class="nc">&nbsp;                                    (oldConfiguration.get(&quot;orderBy&quot;).isNull() || oldConfiguration.get(&quot;orderBy&quot;).asText().isEmpty())) {</b>
<b class="nc">&nbsp;                                ((ObjectNode) oldConfiguration).put(&quot;orderBy&quot;, Direction.ASC.name());</b>
<b class="nc">&nbsp;                                hasChanges = true;</b>
&nbsp;                            }
<b class="nc">&nbsp;                            if (oldConfiguration.has(&quot;aggregation&quot;) &amp;&amp;</b>
<b class="nc">&nbsp;                                    (oldConfiguration.get(&quot;aggregation&quot;).isNull() || oldConfiguration.get(&quot;aggregation&quot;).asText().isEmpty())) {</b>
<b class="nc">&nbsp;                                ((ObjectNode) oldConfiguration).put(&quot;aggregation&quot;, Aggregation.NONE.name());</b>
<b class="nc">&nbsp;                                hasChanges = true;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                        default -&gt; {
<b class="nc">&nbsp;                            ((ObjectNode) oldConfiguration).put(&quot;fetchMode&quot;, FetchMode.LAST.name());</b>
<b class="nc">&nbsp;                            ((ObjectNode) oldConfiguration).put(&quot;orderBy&quot;, Direction.DESC.name());</b>
<b class="nc">&nbsp;                            ((ObjectNode) oldConfiguration).put(&quot;aggregation&quot;, Aggregation.NONE.name());</b>
<b class="nc">&nbsp;                            hasChanges = true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;            case 1: {
<b class="nc">&nbsp;                if (!oldConfiguration.hasNonNull(&quot;limit&quot;)) {</b>
<b class="nc">&nbsp;                    ((ObjectNode) oldConfiguration).put(&quot;limit&quot;, 1000);</b>
<b class="nc">&nbsp;                    hasChanges = true;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (oldConfiguration.has(&quot;fetchMode&quot;) &amp;&amp; oldConfiguration.get(&quot;fetchMode&quot;).asText().equals(&quot;ALL&quot;)) {</b>
<b class="nc">&nbsp;                    if (!oldConfiguration.hasNonNull(&quot;aggregation&quot;)) {</b>
<b class="nc">&nbsp;                        ((ObjectNode) oldConfiguration).put(&quot;aggregation&quot;, Aggregation.NONE.name());</b>
<b class="nc">&nbsp;                        hasChanges = true;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (!oldConfiguration.hasNonNull(&quot;orderBy&quot;)) {</b>
<b class="nc">&nbsp;                        ((ObjectNode) oldConfiguration).put(&quot;orderBy&quot;, Direction.ASC.name());</b>
<b class="nc">&nbsp;                        hasChanges = true;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                break;
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return new TbPair&lt;&gt;(hasChanges, oldConfiguration);</b>
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
