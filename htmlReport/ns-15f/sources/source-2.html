<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > GeofencingCalculatedFieldState</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.server.service.cf.ctx.state.geofencing</a>
</div>

<h1>Coverage Summary for Class: GeofencingCalculatedFieldState (org.thingsboard.server.service.cf.ctx.state.geofencing)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">GeofencingCalculatedFieldState</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/45)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/79)
  </span>
</td>
</tr>
  <tr>
    <td class="name">GeofencingCalculatedFieldState$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/45)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/82)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.server.service.cf.ctx.state.geofencing;
&nbsp;
&nbsp;import com.fasterxml.jackson.databind.node.ObjectNode;
&nbsp;import com.google.common.util.concurrent.Futures;
&nbsp;import com.google.common.util.concurrent.ListenableFuture;
&nbsp;import com.google.common.util.concurrent.MoreExecutors;
&nbsp;import lombok.EqualsAndHashCode;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.thingsboard.common.util.JacksonUtil;
&nbsp;import org.thingsboard.common.util.geo.Coordinates;
&nbsp;import org.thingsboard.server.common.data.cf.CalculatedFieldType;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.OutputType;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.geofencing.GeofencingCalculatedFieldConfiguration;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.geofencing.GeofencingReportStrategy;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.geofencing.GeofencingTransitionEvent;
&nbsp;import org.thingsboard.server.common.data.cf.configuration.geofencing.ZoneGroupConfiguration;
&nbsp;import org.thingsboard.server.common.data.id.EntityId;
&nbsp;import org.thingsboard.server.common.data.relation.EntityRelation;
&nbsp;import org.thingsboard.server.service.cf.CalculatedFieldResult;
&nbsp;import org.thingsboard.server.service.cf.TelemetryCalculatedFieldResult;
&nbsp;import org.thingsboard.server.service.cf.ctx.state.ArgumentEntry;
&nbsp;import org.thingsboard.server.service.cf.ctx.state.ArgumentEntryType;
&nbsp;import org.thingsboard.server.service.cf.ctx.state.BaseCalculatedFieldState;
&nbsp;import org.thingsboard.server.service.cf.ctx.state.CalculatedFieldCtx;
&nbsp;import org.thingsboard.server.service.cf.ctx.state.SingleValueArgumentEntry;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;import static org.thingsboard.server.common.data.cf.configuration.geofencing.EntityCoordinates.ENTITY_ID_LATITUDE_ARGUMENT_KEY;
&nbsp;import static org.thingsboard.server.common.data.cf.configuration.geofencing.EntityCoordinates.ENTITY_ID_LONGITUDE_ARGUMENT_KEY;
&nbsp;import static org.thingsboard.server.common.data.cf.configuration.geofencing.GeofencingPresenceStatus.INSIDE;
&nbsp;import static org.thingsboard.server.common.data.cf.configuration.geofencing.GeofencingPresenceStatus.OUTSIDE;
&nbsp;
<b class="nc">&nbsp;@Slf4j</b>
&nbsp;@EqualsAndHashCode(callSuper = true)
&nbsp;public class GeofencingCalculatedFieldState extends BaseCalculatedFieldState implements ScheduledRefreshSupported {
&nbsp;
<b class="nc">&nbsp;    private long lastDynamicArgumentsRefreshTs = DEFAULT_LAST_UPDATE_TS;</b>
&nbsp;
&nbsp;    public GeofencingCalculatedFieldState(EntityId entityId) {
<b class="nc">&nbsp;        super(entityId);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public CalculatedFieldType getType() {
<b class="nc">&nbsp;        return CalculatedFieldType.GEOFENCING;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected void validateNewEntry(String key, ArgumentEntry newEntry) {
<b class="nc">&nbsp;        switch (key) {</b>
&nbsp;            case ENTITY_ID_LATITUDE_ARGUMENT_KEY, ENTITY_ID_LONGITUDE_ARGUMENT_KEY -&gt; {
<b class="nc">&nbsp;                if (!(newEntry instanceof SingleValueArgumentEntry)) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;Unsupported argument entry type for &quot; + key + &quot; argument: &quot; + newEntry.getType() + &quot;. &quot; +</b>
&nbsp;                                                       &quot;Only SINGLE_VALUE type is allowed.&quot;);
&nbsp;                }
&nbsp;            }
&nbsp;            default -&gt; {
<b class="nc">&nbsp;                if (!(newEntry instanceof GeofencingArgumentEntry)) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;Unsupported argument entry type for &quot; + key + &quot; argument: &quot; + newEntry.getType() + &quot;. &quot; +</b>
&nbsp;                                                       &quot;Only GEOFENCING type is allowed.&quot;);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ListenableFuture&lt;CalculatedFieldResult&gt; performCalculation(Map&lt;String, ArgumentEntry&gt; updatedArgs, CalculatedFieldCtx ctx) {
<b class="nc">&nbsp;        double latitude = (double) arguments.get(ENTITY_ID_LATITUDE_ARGUMENT_KEY).getValue();</b>
<b class="nc">&nbsp;        double longitude = (double) arguments.get(ENTITY_ID_LONGITUDE_ARGUMENT_KEY).getValue();</b>
<b class="nc">&nbsp;        Coordinates entityCoordinates = new Coordinates(latitude, longitude);</b>
&nbsp;
<b class="nc">&nbsp;        var geofencingCfg = (GeofencingCalculatedFieldConfiguration) ctx.getCalculatedField().getConfiguration();</b>
<b class="nc">&nbsp;        Map&lt;String, ZoneGroupConfiguration&gt; zoneGroups = geofencingCfg.getZoneGroups();</b>
&nbsp;
<b class="nc">&nbsp;        ObjectNode valuesNode = JacksonUtil.newObjectNode();</b>
<b class="nc">&nbsp;        List&lt;ListenableFuture&lt;Boolean&gt;&gt; relationFutures = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        getGeofencingArguments().forEach((argumentKey, argumentEntry) -&gt; {</b>
<b class="nc">&nbsp;            ZoneGroupConfiguration zoneGroupCfg = zoneGroups.get(argumentKey);</b>
<b class="nc">&nbsp;            if (zoneGroupCfg == null) {</b>
<b class="nc">&nbsp;                throw new RuntimeException(&quot;Zone group configuration is missing for the: &quot; + entityId);</b>
&nbsp;            }
<b class="nc">&nbsp;            boolean createRelationsWithMatchedZones = zoneGroupCfg.isCreateRelationsWithMatchedZones();</b>
<b class="nc">&nbsp;            List&lt;GeofencingEvalResult&gt; zoneResults = new ArrayList&lt;&gt;(argumentEntry.getZoneStates().size());</b>
<b class="nc">&nbsp;            argumentEntry.getZoneStates().forEach((zoneId, zoneState) -&gt; {</b>
<b class="nc">&nbsp;                boolean firstEval = zoneState.getLastPresence() == null;</b>
<b class="nc">&nbsp;                GeofencingEvalResult eval = zoneState.evaluate(entityCoordinates);</b>
<b class="nc">&nbsp;                zoneResults.add(eval);</b>
<b class="nc">&nbsp;                if (!createRelationsWithMatchedZones) {</b>
&nbsp;                    return;
&nbsp;                }
<b class="nc">&nbsp;                GeofencingTransitionEvent transitionEvent = eval.transition();</b>
<b class="nc">&nbsp;                if (transitionEvent == null) {</b>
<b class="nc">&nbsp;                    if (!firstEval) {</b>
&nbsp;                        return;
&nbsp;                    }
<b class="nc">&nbsp;                    transitionEvent = eval.status() == INSIDE ?</b>
<b class="nc">&nbsp;                            GeofencingTransitionEvent.ENTERED :</b>
<b class="nc">&nbsp;                            GeofencingTransitionEvent.LEFT;</b>
&nbsp;                }
<b class="nc">&nbsp;                EntityRelation relation = switch (zoneGroupCfg.getDirection()) {</b>
<b class="nc">&nbsp;                    case TO -&gt; new EntityRelation(zoneId, entityId, zoneGroupCfg.getRelationType());</b>
<b class="nc">&nbsp;                    case FROM -&gt; new EntityRelation(entityId, zoneId, zoneGroupCfg.getRelationType());</b>
&nbsp;                };
<b class="nc">&nbsp;                ListenableFuture&lt;Boolean&gt; f = switch (transitionEvent) {</b>
<b class="nc">&nbsp;                    case ENTERED -&gt; ctx.getRelationService().saveRelationAsync(ctx.getTenantId(), relation);</b>
<b class="nc">&nbsp;                    case LEFT -&gt; ctx.getRelationService().deleteRelationAsync(ctx.getTenantId(), relation);</b>
&nbsp;                };
<b class="nc">&nbsp;                relationFutures.add(f);</b>
&nbsp;            });
<b class="nc">&nbsp;            updateValuesNode(argumentKey, zoneResults, zoneGroupCfg.getReportStrategy(), valuesNode);</b>
&nbsp;        });
&nbsp;
<b class="nc">&nbsp;        OutputType outputType = ctx.getOutput().getType();</b>
<b class="nc">&nbsp;        var result = TelemetryCalculatedFieldResult.builder()</b>
<b class="nc">&nbsp;                .outputStrategy(ctx.getOutput().getStrategy())</b>
<b class="nc">&nbsp;                .type(outputType)</b>
<b class="nc">&nbsp;                .scope(ctx.getOutput().getScope())</b>
<b class="nc">&nbsp;                .result(toResultNode(valuesNode))</b>
<b class="nc">&nbsp;                .build();</b>
<b class="nc">&nbsp;        if (relationFutures.isEmpty()) {</b>
<b class="nc">&nbsp;            return Futures.immediateFuture(result);</b>
&nbsp;        }
<b class="nc">&nbsp;        return Futures.whenAllComplete(relationFutures).call(() -&gt; result, MoreExecutors.directExecutor());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void reset() {
<b class="nc">&nbsp;        super.reset();</b>
<b class="nc">&nbsp;        resetScheduledRefreshTs();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void resetScheduledRefreshTs() {
<b class="nc">&nbsp;        lastDynamicArgumentsRefreshTs = DEFAULT_LAST_UPDATE_TS;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public long getLastScheduledRefreshTs() {
<b class="nc">&nbsp;        return lastDynamicArgumentsRefreshTs;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void updateScheduledRefreshTs() {
<b class="nc">&nbsp;        lastDynamicArgumentsRefreshTs = System.currentTimeMillis();</b>
&nbsp;    }
&nbsp;
&nbsp;    private Map&lt;String, GeofencingArgumentEntry&gt; getGeofencingArguments() {
<b class="nc">&nbsp;        return arguments.entrySet()</b>
<b class="nc">&nbsp;                .stream()</b>
<b class="nc">&nbsp;                .filter(entry -&gt; entry.getValue().getType().equals(ArgumentEntryType.GEOFENCING))</b>
<b class="nc">&nbsp;                .collect(Collectors.toMap(Map.Entry::getKey, entry -&gt; (GeofencingArgumentEntry) entry.getValue()));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void updateValuesNode(String argumentKey, List&lt;GeofencingEvalResult&gt; zoneResults, GeofencingReportStrategy geofencingReportStrategy, ObjectNode resultNode) {
<b class="nc">&nbsp;        GeofencingEvalResult aggregationResult = aggregateZoneGroup(zoneResults);</b>
<b class="nc">&nbsp;        final String eventKey = argumentKey + &quot;Event&quot;;</b>
<b class="nc">&nbsp;        final String statusKey = argumentKey + &quot;Status&quot;;</b>
<b class="nc">&nbsp;        switch (geofencingReportStrategy) {</b>
<b class="nc">&nbsp;            case REPORT_TRANSITION_EVENTS_ONLY -&gt; addTransitionEventIfExists(resultNode, aggregationResult, eventKey);</b>
<b class="nc">&nbsp;            case REPORT_PRESENCE_STATUS_ONLY -&gt; resultNode.put(statusKey, aggregationResult.status().name());</b>
&nbsp;            case REPORT_TRANSITION_EVENTS_AND_PRESENCE_STATUS -&gt; {
<b class="nc">&nbsp;                addTransitionEventIfExists(resultNode, aggregationResult, eventKey);</b>
<b class="nc">&nbsp;                resultNode.put(statusKey, aggregationResult.status().name());</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private GeofencingEvalResult aggregateZoneGroup(List&lt;GeofencingEvalResult&gt; zoneResults) {
<b class="nc">&nbsp;        boolean nowInside = zoneResults.stream().anyMatch(r -&gt; INSIDE.equals(r.status()));</b>
<b class="nc">&nbsp;        boolean prevInside = zoneResults.stream()</b>
<b class="nc">&nbsp;                .anyMatch(r -&gt; GeofencingTransitionEvent.LEFT.equals(r.transition()) || r.transition() == null &amp;&amp; r.status() == INSIDE);</b>
<b class="nc">&nbsp;        GeofencingTransitionEvent transition = null;</b>
<b class="nc">&nbsp;        if (!prevInside &amp;&amp; nowInside) {</b>
<b class="nc">&nbsp;            transition = GeofencingTransitionEvent.ENTERED;</b>
<b class="nc">&nbsp;        } else if (prevInside &amp;&amp; !nowInside) {</b>
<b class="nc">&nbsp;            transition = GeofencingTransitionEvent.LEFT;</b>
&nbsp;        }
<b class="nc">&nbsp;        return new GeofencingEvalResult(transition, nowInside ? INSIDE : OUTSIDE);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void addTransitionEventIfExists(ObjectNode resultNode, GeofencingEvalResult aggregationResult, String eventKey) {
<b class="nc">&nbsp;        if (aggregationResult.transition() != null) {</b>
<b class="nc">&nbsp;            resultNode.put(eventKey, aggregationResult.transition().name());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
