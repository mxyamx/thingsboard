<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > PgCaMigrator</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.client.tools.migrator</a>
</div>

<h1>Coverage Summary for Class: PgCaMigrator (org.thingsboard.client.tools.migrator)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">PgCaMigrator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/48)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/120)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.client.tools.migrator;
&nbsp;
&nbsp;import com.google.common.collect.Lists;
&nbsp;import org.apache.cassandra.io.sstable.CQLSSTableWriter;
&nbsp;import org.apache.commons.io.FileUtils;
&nbsp;import org.apache.commons.io.LineIterator;
&nbsp;import org.apache.commons.lang3.math.NumberUtils;
&nbsp;import org.thingsboard.server.common.data.StringUtils;
&nbsp;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.time.Instant;
&nbsp;import java.time.LocalDateTime;
&nbsp;import java.time.ZoneOffset;
&nbsp;import java.time.temporal.ChronoUnit;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Date;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Set;
&nbsp;import java.util.UUID;
&nbsp;import java.util.function.Function;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;public class PgCaMigrator {
&nbsp;
<b class="nc">&nbsp;    private final long LOG_BATCH = 1000000;</b>
<b class="nc">&nbsp;    private final long rowPerFile = 1000000;</b>
&nbsp;
<b class="nc">&nbsp;    private long linesTsMigrated = 0;</b>
<b class="nc">&nbsp;    private long linesLatestMigrated = 0;</b>
<b class="nc">&nbsp;    private long castErrors = 0;</b>
<b class="nc">&nbsp;    private long castedOk = 0;</b>
&nbsp;
<b class="nc">&nbsp;    private long currentWriterCount = 1;</b>
&nbsp;
&nbsp;    private final File sourceFile;
&nbsp;    private final boolean castStringIfPossible;
&nbsp;
&nbsp;    private final RelatedEntitiesParser entityIdsAndTypes;
&nbsp;    private final DictionaryParser keyParser;
&nbsp;    private CQLSSTableWriter currentTsWriter;
&nbsp;    private CQLSSTableWriter currentPartitionsWriter;
&nbsp;    private CQLSSTableWriter currentTsLatestWriter;
<b class="nc">&nbsp;    private final Set&lt;String&gt; partitions = new HashSet&lt;&gt;();</b>
&nbsp;
&nbsp;    private File outTsDir;
&nbsp;    private File outTsLatestDir;
&nbsp;
&nbsp;    public PgCaMigrator(File sourceFile,
&nbsp;                                File ourTsDir,
&nbsp;                                File outTsPartitionDir,
&nbsp;                                File outTsLatestDir,
&nbsp;                                RelatedEntitiesParser allEntityIdsAndTypes,
&nbsp;                                DictionaryParser dictionaryParser,
<b class="nc">&nbsp;                                boolean castStringsIfPossible) {</b>
<b class="nc">&nbsp;        this.sourceFile = sourceFile;</b>
<b class="nc">&nbsp;        this.entityIdsAndTypes = allEntityIdsAndTypes;</b>
<b class="nc">&nbsp;        this.keyParser = dictionaryParser;</b>
<b class="nc">&nbsp;        this.castStringIfPossible = castStringsIfPossible;</b>
<b class="nc">&nbsp;        if(outTsLatestDir != null) {</b>
<b class="nc">&nbsp;            this.currentTsLatestWriter = WriterBuilder.getLatestWriter(outTsLatestDir);</b>
<b class="nc">&nbsp;            this.outTsLatestDir = outTsLatestDir;</b>
&nbsp;        }
<b class="nc">&nbsp;        if(ourTsDir != null) {</b>
<b class="nc">&nbsp;            this.currentTsWriter = WriterBuilder.getTsWriter(ourTsDir);</b>
<b class="nc">&nbsp;            this.currentPartitionsWriter = WriterBuilder.getPartitionWriter(outTsPartitionDir);</b>
<b class="nc">&nbsp;            this.outTsDir = ourTsDir;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void migrate() throws IOException {
<b class="nc">&nbsp;        boolean isTsDone = false;</b>
<b class="nc">&nbsp;        boolean isLatestDone = false;</b>
&nbsp;        String line;
<b class="nc">&nbsp;        LineIterator iterator = FileUtils.lineIterator(this.sourceFile);</b>
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            while(iterator.hasNext()) {</b>
<b class="nc">&nbsp;                line = iterator.nextLine();</b>
<b class="nc">&nbsp;                if(!isLatestDone &amp;&amp; isBlockLatestStarted(line)) {</b>
<b class="nc">&nbsp;                    System.out.println(&quot;START TO MIGRATE LATEST&quot;);</b>
<b class="nc">&nbsp;                    long start = System.currentTimeMillis();</b>
<b class="nc">&nbsp;                    processBlock(iterator, currentTsLatestWriter, outTsLatestDir, this::toValuesLatest);</b>
<b class="nc">&nbsp;                    System.out.println(&quot;TOTAL LINES MIGRATED: &quot; + linesLatestMigrated + &quot;, FORMING OF SSL FOR LATEST TS FINISHED WITH TIME: &quot; + (System.currentTimeMillis() - start) + &quot; ms.&quot;);</b>
<b class="nc">&nbsp;                    isLatestDone = true;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if(!isTsDone &amp;&amp; isBlockTsStarted(line)) {</b>
<b class="nc">&nbsp;                    System.out.println(&quot;START TO MIGRATE TS&quot;);</b>
<b class="nc">&nbsp;                    long start = System.currentTimeMillis();</b>
<b class="nc">&nbsp;                    processBlock(iterator, currentTsWriter, outTsDir, this::toValuesTs);</b>
<b class="nc">&nbsp;                    System.out.println(&quot;TOTAL LINES MIGRATED: &quot; + linesTsMigrated + &quot;, FORMING OF SSL FOR TS FINISHED WITH TIME: &quot; + (System.currentTimeMillis() - start) + &quot; ms.&quot;);</b>
<b class="nc">&nbsp;                    isTsDone = true;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            System.out.println(&quot;Partitions collected &quot; + partitions.size());</b>
<b class="nc">&nbsp;            long startTs = System.currentTimeMillis();</b>
<b class="nc">&nbsp;            for (String partition : partitions) {</b>
<b class="nc">&nbsp;                String[] split = partition.split(&quot;\\|&quot;);</b>
<b class="nc">&nbsp;                List&lt;Object&gt; values = Lists.newArrayList();</b>
<b class="nc">&nbsp;                values.add(split[0]);</b>
<b class="nc">&nbsp;                values.add(UUID.fromString(split[1]));</b>
<b class="nc">&nbsp;                values.add(split[2]);</b>
<b class="nc">&nbsp;                values.add(Long.parseLong(split[3]));</b>
<b class="nc">&nbsp;                currentPartitionsWriter.addRow(values);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            System.out.println(new Date() + &quot; Migrated partitions &quot; + partitions.size() + &quot; in &quot; + (System.currentTimeMillis() - startTs));</b>
&nbsp;
<b class="nc">&nbsp;            System.out.println();</b>
<b class="nc">&nbsp;            System.out.println(&quot;Finished migrate Telemetry&quot;);</b>
&nbsp;
&nbsp;        } finally {
&nbsp;            iterator.close();
<b class="nc">&nbsp;            currentTsLatestWriter.close();</b>
<b class="nc">&nbsp;            currentTsWriter.close();</b>
<b class="nc">&nbsp;            currentPartitionsWriter.close();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void logLinesProcessed(long lines) {
<b class="nc">&nbsp;        if (lines % LOG_BATCH == 0) {</b>
<b class="nc">&nbsp;            System.out.println(new Date() + &quot; lines processed = &quot; + lines + &quot; in, castOk &quot; + castedOk + &quot;  castErr &quot; + castErrors);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void logLinesMigrated(long lines) {
<b class="nc">&nbsp;        if(lines % LOG_BATCH == 0) {</b>
<b class="nc">&nbsp;            System.out.println(new Date() + &quot; lines migrated = &quot; + lines + &quot; in, castOk &quot; + castedOk + &quot;  castErr &quot; + castErrors);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void addTypeIdKey(List&lt;Object&gt; result, List&lt;String&gt; raw) {
<b class="nc">&nbsp;        result.add(entityIdsAndTypes.getEntityType(raw.get(0)));</b>
<b class="nc">&nbsp;        result.add(UUID.fromString(raw.get(0)));</b>
<b class="nc">&nbsp;        result.add(keyParser.getKeyByKeyId(raw.get(1)));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void addPartitions(List&lt;Object&gt; result, List&lt;String&gt; raw) {
<b class="nc">&nbsp;        long ts = Long.parseLong(raw.get(2));</b>
<b class="nc">&nbsp;        long partition = toPartitionTs(ts);</b>
<b class="nc">&nbsp;        result.add(partition);</b>
<b class="nc">&nbsp;        result.add(ts);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void addTimeseries(List&lt;Object&gt; result, List&lt;String&gt; raw) {
<b class="nc">&nbsp;        result.add(Long.parseLong(raw.get(2)));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void addValues(List&lt;Object&gt; result, List&lt;String&gt; raw) {
<b class="nc">&nbsp;        result.add(raw.get(3).equals(&quot;\\N&quot;) ? null : raw.get(3).equals(&quot;t&quot;) ? Boolean.TRUE : Boolean.FALSE);</b>
<b class="nc">&nbsp;        result.add(raw.get(4).equals(&quot;\\N&quot;) ? null : raw.get(4));</b>
<b class="nc">&nbsp;        result.add(raw.get(5).equals(&quot;\\N&quot;) ? null : Long.parseLong(raw.get(5)));</b>
<b class="nc">&nbsp;        result.add(raw.get(6).equals(&quot;\\N&quot;) ? null : Double.parseDouble(raw.get(6)));</b>
<b class="nc">&nbsp;        result.add(raw.get(7).equals(&quot;\\N&quot;) ? null : raw.get(7));</b>
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;Object&gt; toValuesTs(List&lt;String&gt; raw) {
&nbsp;
<b class="nc">&nbsp;        logLinesMigrated(linesTsMigrated++);</b>
&nbsp;
<b class="nc">&nbsp;        List&lt;Object&gt; result = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        addTypeIdKey(result, raw);</b>
<b class="nc">&nbsp;        addPartitions(result, raw);</b>
<b class="nc">&nbsp;        addValues(result, raw);</b>
&nbsp;
<b class="nc">&nbsp;        processPartitions(result);</b>
&nbsp;
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;Object&gt; toValuesLatest(List&lt;String&gt; raw) {
<b class="nc">&nbsp;        logLinesMigrated(linesLatestMigrated++);</b>
<b class="nc">&nbsp;        List&lt;Object&gt; result = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        addTypeIdKey(result, raw);</b>
<b class="nc">&nbsp;        addTimeseries(result, raw);</b>
<b class="nc">&nbsp;        addValues(result, raw);</b>
&nbsp;
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    private long toPartitionTs(long ts) {
<b class="nc">&nbsp;        LocalDateTime time = LocalDateTime.ofInstant(Instant.ofEpochMilli(ts), ZoneOffset.UTC);</b>
<b class="nc">&nbsp;        return time.truncatedTo(ChronoUnit.DAYS).withDayOfMonth(1).toInstant(ZoneOffset.UTC).toEpochMilli();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void processPartitions(List&lt;Object&gt; values) {
<b class="nc">&nbsp;        String key = values.get(0) + &quot;|&quot; + values.get(1) + &quot;|&quot; + values.get(2) + &quot;|&quot; + values.get(3);</b>
<b class="nc">&nbsp;        partitions.add(key);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void processBlock(LineIterator iterator, CQLSSTableWriter writer, File outDir, Function&lt;List&lt;String&gt;, List&lt;Object&gt;&gt; function) {
&nbsp;        String currentLine;
<b class="nc">&nbsp;        long linesProcessed = 0;</b>
<b class="nc">&nbsp;        while(iterator.hasNext()) {</b>
<b class="nc">&nbsp;            logLinesProcessed(linesProcessed++);</b>
<b class="nc">&nbsp;            currentLine = iterator.nextLine();</b>
<b class="nc">&nbsp;            if(isBlockFinished(currentLine)) {</b>
&nbsp;                return;
&nbsp;            }
&nbsp;
&nbsp;            try {
<b class="nc">&nbsp;                List&lt;String&gt; raw = Arrays.stream(currentLine.trim().split(&quot;\t&quot;))</b>
<b class="nc">&nbsp;                        .map(String::trim)</b>
<b class="nc">&nbsp;                        .collect(Collectors.toList());</b>
<b class="nc">&nbsp;                List&lt;Object&gt; values = function.apply(raw);</b>
&nbsp;
<b class="nc">&nbsp;                if (this.currentWriterCount == 0) {</b>
<b class="nc">&nbsp;                    System.out.println(new Date() + &quot; close writer &quot; + new Date());</b>
&nbsp;                    writer.close();
<b class="nc">&nbsp;                    writer = WriterBuilder.getLatestWriter(outDir);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (this.castStringIfPossible) {</b>
<b class="nc">&nbsp;                    writer.addRow(castToNumericIfPossible(values));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    writer.addRow(values);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                currentWriterCount++;</b>
<b class="nc">&nbsp;                if (currentWriterCount &gt;= rowPerFile) {</b>
<b class="nc">&nbsp;                    currentWriterCount = 0;</b>
&nbsp;                }
&nbsp;            } catch (Exception ex) {
<b class="nc">&nbsp;                System.out.println(ex.getMessage() + &quot; -&gt; &quot; + currentLine);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;Object&gt; castToNumericIfPossible(List&lt;Object&gt; values) {
&nbsp;        try {
<b class="nc">&nbsp;            if (values.get(6) != null &amp;&amp; NumberUtils.isNumber(values.get(6).toString())) {</b>
<b class="nc">&nbsp;                Double casted = NumberUtils.createDouble(values.get(6).toString());</b>
<b class="nc">&nbsp;                List&lt;Object&gt; numeric = Lists.newArrayList();</b>
<b class="nc">&nbsp;                numeric.addAll(values);</b>
<b class="nc">&nbsp;                numeric.set(6, null);</b>
<b class="nc">&nbsp;                numeric.set(8, casted);</b>
<b class="nc">&nbsp;                castedOk++;</b>
<b class="nc">&nbsp;                return numeric;</b>
&nbsp;            }
&nbsp;        } catch (Throwable th) {
<b class="nc">&nbsp;            castErrors++;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        processPartitions(values);</b>
&nbsp;
<b class="nc">&nbsp;        return values;</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean isBlockFinished(String line) {
<b class="nc">&nbsp;        return StringUtils.isBlank(line) || line.equals(&quot;\\.&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean isBlockTsStarted(String line) {
<b class="nc">&nbsp;        return line.startsWith(&quot;COPY public.ts_kv (&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean isBlockLatestStarted(String line) {
<b class="nc">&nbsp;        return line.startsWith(&quot;COPY public.ts_kv_latest (&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
