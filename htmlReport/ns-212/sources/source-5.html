<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > MqttTransportHandler</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.server.transport.mqtt</a>
</div>

<h1>Coverage Summary for Class: MqttTransportHandler (org.thingsboard.server.transport.mqtt)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MqttTransportHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/73)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/372)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/690)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MqttTransportHandler$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MqttTransportHandler$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MqttTransportHandler$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MqttTransportHandler$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MqttTransportHandler$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MqttTransportHandler$DeviceProvisionCallback</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MqttTransportHandler$OtaPackageCallback</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/92)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/380)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/752)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.server.transport.mqtt;
&nbsp;
&nbsp;import com.fasterxml.jackson.databind.JsonNode;
&nbsp;import com.google.gson.JsonParseException;
&nbsp;import com.google.protobuf.InvalidProtocolBufferException;
&nbsp;import io.netty.channel.ChannelFuture;
&nbsp;import io.netty.channel.ChannelHandlerContext;
&nbsp;import io.netty.channel.ChannelInboundHandlerAdapter;
&nbsp;import io.netty.handler.codec.mqtt.MqttConnAckMessage;
&nbsp;import io.netty.handler.codec.mqtt.MqttConnectMessage;
&nbsp;import io.netty.handler.codec.mqtt.MqttConnectReturnCode;
&nbsp;import io.netty.handler.codec.mqtt.MqttFixedHeader;
&nbsp;import io.netty.handler.codec.mqtt.MqttMessage;
&nbsp;import io.netty.handler.codec.mqtt.MqttMessageBuilders;
&nbsp;import io.netty.handler.codec.mqtt.MqttMessageIdVariableHeader;
&nbsp;import io.netty.handler.codec.mqtt.MqttProperties.IntegerProperty;
&nbsp;import io.netty.handler.codec.mqtt.MqttProperties.MqttPropertyType;
&nbsp;import io.netty.handler.codec.mqtt.MqttPubAckMessage;
&nbsp;import io.netty.handler.codec.mqtt.MqttPublishMessage;
&nbsp;import io.netty.handler.codec.mqtt.MqttQoS;
&nbsp;import io.netty.handler.codec.mqtt.MqttReasonCodes;
&nbsp;import io.netty.handler.codec.mqtt.MqttSubAckMessage;
&nbsp;import io.netty.handler.codec.mqtt.MqttSubAckPayload;
&nbsp;import io.netty.handler.codec.mqtt.MqttSubscribeMessage;
&nbsp;import io.netty.handler.codec.mqtt.MqttTopicSubscription;
&nbsp;import io.netty.handler.codec.mqtt.MqttUnsubscribeMessage;
&nbsp;import io.netty.handler.codec.mqtt.MqttVersion;
&nbsp;import io.netty.handler.ssl.SslHandler;
&nbsp;import io.netty.util.CharsetUtil;
&nbsp;import io.netty.util.ReferenceCountUtil;
&nbsp;import io.netty.util.concurrent.Future;
&nbsp;import io.netty.util.concurrent.GenericFutureListener;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.eclipse.leshan.core.ResponseCode;
&nbsp;import org.thingsboard.common.util.JacksonUtil;
&nbsp;import org.thingsboard.server.common.adaptor.AdaptorException;
&nbsp;import org.thingsboard.server.common.data.DataConstants;
&nbsp;import org.thingsboard.server.common.data.Device;
&nbsp;import org.thingsboard.server.common.data.DeviceProfile;
&nbsp;import org.thingsboard.server.common.data.DeviceTransportType;
&nbsp;import org.thingsboard.server.common.data.StringUtils;
&nbsp;import org.thingsboard.server.common.data.TransportPayloadType;
&nbsp;import org.thingsboard.server.common.data.device.profile.MqttTopics;
&nbsp;import org.thingsboard.server.common.data.exception.ThingsboardErrorCode;
&nbsp;import org.thingsboard.server.common.data.exception.ThingsboardException;
&nbsp;import org.thingsboard.server.common.data.id.DeviceId;
&nbsp;import org.thingsboard.server.common.data.id.OtaPackageId;
&nbsp;import org.thingsboard.server.common.data.ota.OtaPackageType;
&nbsp;import org.thingsboard.server.common.data.rpc.RpcStatus;
&nbsp;import org.thingsboard.server.common.data.tenant.profile.DefaultTenantProfileConfiguration;
&nbsp;import org.thingsboard.server.common.msg.EncryptionUtil;
&nbsp;import org.thingsboard.server.common.msg.TbMsgMetaData;
&nbsp;import org.thingsboard.server.common.msg.tools.TbRateLimitsException;
&nbsp;import org.thingsboard.server.common.transport.SessionMsgListener;
&nbsp;import org.thingsboard.server.common.transport.TransportService;
&nbsp;import org.thingsboard.server.common.transport.TransportServiceCallback;
&nbsp;import org.thingsboard.server.common.transport.auth.SessionInfoCreator;
&nbsp;import org.thingsboard.server.common.transport.auth.TransportDeviceInfo;
&nbsp;import org.thingsboard.server.common.transport.auth.ValidateDeviceCredentialsResponse;
&nbsp;import org.thingsboard.server.common.transport.service.SessionMetaData;
&nbsp;import org.thingsboard.server.common.transport.util.SslUtil;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.ProvisionDeviceResponseMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.ValidateDeviceX509CertRequestMsg;
&nbsp;import org.thingsboard.server.gen.transport.mqtt.SparkplugBProto;
&nbsp;import org.thingsboard.server.queue.scheduler.SchedulerComponent;
&nbsp;import org.thingsboard.server.transport.mqtt.adaptors.MqttTransportAdaptor;
&nbsp;import org.thingsboard.server.transport.mqtt.adaptors.ProtoMqttAdaptor;
&nbsp;import org.thingsboard.server.transport.mqtt.limits.GatewaySessionLimits;
&nbsp;import org.thingsboard.server.transport.mqtt.limits.SessionLimits;
&nbsp;import org.thingsboard.server.transport.mqtt.session.DeviceSessionCtx;
&nbsp;import org.thingsboard.server.transport.mqtt.session.GatewaySessionHandler;
&nbsp;import org.thingsboard.server.transport.mqtt.session.MqttTopicMatcher;
&nbsp;import org.thingsboard.server.transport.mqtt.session.SparkplugDeviceSessionContext;
&nbsp;import org.thingsboard.server.transport.mqtt.session.SparkplugNodeSessionHandler;
&nbsp;import org.thingsboard.server.transport.mqtt.util.ReturnCodeResolver;
&nbsp;import org.thingsboard.server.transport.mqtt.util.sparkplug.SparkplugMessageType;
&nbsp;import org.thingsboard.server.transport.mqtt.util.sparkplug.SparkplugRpcRequestHeader;
&nbsp;import org.thingsboard.server.transport.mqtt.util.sparkplug.SparkplugRpcResponseBody;
&nbsp;import org.thingsboard.server.transport.mqtt.util.sparkplug.SparkplugTopic;
&nbsp;
&nbsp;import javax.net.ssl.SSLPeerUnverifiedException;
&nbsp;import java.io.IOException;
&nbsp;import java.net.InetSocketAddress;
&nbsp;import java.nio.charset.StandardCharsets;
&nbsp;import java.security.cert.Certificate;
&nbsp;import java.security.cert.X509Certificate;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Date;
&nbsp;import java.util.List;
&nbsp;import java.util.Map.Entry;
&nbsp;import java.util.Optional;
&nbsp;import java.util.UUID;
&nbsp;import java.util.concurrent.Callable;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.concurrent.ConcurrentMap;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.regex.Matcher;
&nbsp;import java.util.regex.Pattern;
&nbsp;
&nbsp;import static io.netty.handler.codec.mqtt.MqttMessageType.CONNECT;
&nbsp;import static io.netty.handler.codec.mqtt.MqttMessageType.PINGRESP;
&nbsp;import static io.netty.handler.codec.mqtt.MqttMessageType.SUBACK;
&nbsp;import static io.netty.handler.codec.mqtt.MqttQoS.AT_LEAST_ONCE;
&nbsp;import static io.netty.handler.codec.mqtt.MqttQoS.AT_MOST_ONCE;
&nbsp;import static org.thingsboard.server.common.transport.service.DefaultTransportService.SESSION_EVENT_MSG_CLOSED;
&nbsp;import static org.thingsboard.server.common.transport.service.DefaultTransportService.SESSION_EVENT_MSG_OPEN;
&nbsp;import static org.thingsboard.server.common.transport.service.DefaultTransportService.SUBSCRIBE_TO_ATTRIBUTE_UPDATES_ASYNC_MSG;
&nbsp;import static org.thingsboard.server.common.transport.service.DefaultTransportService.SUBSCRIBE_TO_RPC_ASYNC_MSG;
&nbsp;import static org.thingsboard.server.transport.mqtt.util.sparkplug.SparkplugConnectionState.OFFLINE;
&nbsp;import static org.thingsboard.server.transport.mqtt.util.sparkplug.SparkplugMessageType.NBIRTH;
&nbsp;import static org.thingsboard.server.transport.mqtt.util.sparkplug.SparkplugMessageType.NCMD;
&nbsp;import static org.thingsboard.server.transport.mqtt.util.sparkplug.SparkplugMessageType.NDEATH;
&nbsp;import static org.thingsboard.server.transport.mqtt.util.sparkplug.SparkplugMetricUtil.SPARKPLUG_BD_SEQUENCE_NUMBER_KEY;
&nbsp;import static org.thingsboard.server.transport.mqtt.util.sparkplug.SparkplugMetricUtil.getTsKvProto;
&nbsp;import static org.thingsboard.server.transport.mqtt.util.sparkplug.SparkplugMetricUtil.getTsKvProtoFromJsonNode;
&nbsp;import static org.thingsboard.server.transport.mqtt.util.sparkplug.SparkplugTopic.parseTopic;
&nbsp;import static org.thingsboard.server.transport.mqtt.util.sparkplug.SparkplugTopicService.parseTopicPublish;
&nbsp;
<b class="nc">&nbsp;@Slf4j</b>
&nbsp;public class MqttTransportHandler extends ChannelInboundHandlerAdapter implements GenericFutureListener&lt;Future&lt;? super Void&gt;&gt;, SessionMsgListener {
&nbsp;
<b class="nc">&nbsp;    private static final Pattern FW_REQUEST_PATTERN = Pattern.compile(MqttTopics.DEVICE_FIRMWARE_REQUEST_TOPIC_PATTERN);</b>
<b class="nc">&nbsp;    private static final Pattern SW_REQUEST_PATTERN = Pattern.compile(MqttTopics.DEVICE_SOFTWARE_REQUEST_TOPIC_PATTERN);</b>
&nbsp;
&nbsp;    private static final String SESSION_LIMITS = &quot;getSessionLimits&quot;;
&nbsp;
&nbsp;    private static final String PAYLOAD_TOO_LARGE = &quot;PAYLOAD_TOO_LARGE&quot;;
&nbsp;
<b class="nc">&nbsp;    private static final MqttQoS MAX_SUPPORTED_QOS_LVL = AT_LEAST_ONCE;</b>
&nbsp;
&nbsp;    private final UUID sessionId;
&nbsp;
&nbsp;    protected final MqttTransportContext context;
&nbsp;    private final TransportService transportService;
&nbsp;    private final SchedulerComponent scheduler;
&nbsp;    private final SslHandler sslHandler;
&nbsp;    private final ConcurrentMap&lt;MqttTopicMatcher, Integer&gt; mqttQoSMap;
&nbsp;
&nbsp;    final DeviceSessionCtx deviceSessionCtx;
&nbsp;    volatile InetSocketAddress address;
&nbsp;    volatile GatewaySessionHandler gatewaySessionHandler;
&nbsp;    volatile SparkplugNodeSessionHandler sparkplugSessionHandler;
&nbsp;
&nbsp;    private final ConcurrentHashMap&lt;String, String&gt; otaPackSessions;
&nbsp;    private final ConcurrentHashMap&lt;String, Integer&gt; chunkSizes;
&nbsp;    private final ConcurrentMap&lt;Integer, TransportProtos.ToDeviceRpcRequestMsg&gt; rpcAwaitingAck;
&nbsp;
&nbsp;    private TopicType attrSubTopicType;
&nbsp;    private TopicType rpcSubTopicType;
&nbsp;    private TopicType attrReqTopicType;
&nbsp;    private TopicType toServerRpcSubTopicType;
&nbsp;
<b class="nc">&nbsp;    MqttTransportHandler(MqttTransportContext context, SslHandler sslHandler) {</b>
<b class="nc">&nbsp;        this.sessionId = UUID.randomUUID();</b>
<b class="nc">&nbsp;        this.context = context;</b>
<b class="nc">&nbsp;        this.transportService = context.getTransportService();</b>
<b class="nc">&nbsp;        this.scheduler = context.getScheduler();</b>
<b class="nc">&nbsp;        this.sslHandler = sslHandler;</b>
<b class="nc">&nbsp;        this.mqttQoSMap = new ConcurrentHashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        this.deviceSessionCtx = new DeviceSessionCtx(sessionId, mqttQoSMap, context);</b>
<b class="nc">&nbsp;        this.otaPackSessions = new ConcurrentHashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        this.chunkSizes = new ConcurrentHashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        this.rpcAwaitingAck = new ConcurrentHashMap&lt;&gt;();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {
<b class="nc">&nbsp;        super.channelRegistered(ctx);</b>
<b class="nc">&nbsp;        context.channelRegistered();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {
<b class="nc">&nbsp;        super.channelUnregistered(ctx);</b>
<b class="nc">&nbsp;        context.channelUnregistered();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void channelRead(ChannelHandlerContext ctx, Object msg) {
<b class="nc">&nbsp;        log.trace(&quot;[{}] Processing msg: {}&quot;, sessionId, msg);</b>
<b class="nc">&nbsp;        if (address == null) {</b>
<b class="nc">&nbsp;            address = getAddress(ctx);</b>
&nbsp;        }
&nbsp;        try {
<b class="nc">&nbsp;            if (msg instanceof MqttMessage) {</b>
<b class="nc">&nbsp;                MqttMessage message = (MqttMessage) msg;</b>
<b class="nc">&nbsp;                if (message.decoderResult().isSuccess()) {</b>
<b class="nc">&nbsp;                    processMqttMsg(ctx, message);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    log.error(&quot;[{}] Message decoding failed: {}&quot;, sessionId, message.decoderResult().cause().getMessage());</b>
<b class="nc">&nbsp;                    closeCtx(ctx, MqttReasonCodes.Disconnect.MALFORMED_PACKET);</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                log.debug(&quot;[{}] Received non mqtt message: {}&quot;, sessionId, msg.getClass().getSimpleName());</b>
<b class="nc">&nbsp;                closeCtx(ctx, (MqttMessage) null);</b>
&nbsp;            }
&nbsp;        } finally {
<b class="nc">&nbsp;            ReferenceCountUtil.safeRelease(msg);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void closeCtx(ChannelHandlerContext ctx, MqttReasonCodes.Disconnect returnCode) {
<b class="nc">&nbsp;        closeCtx(ctx, returnCode.byteValue());</b>
&nbsp;    }
&nbsp;
&nbsp;    private void closeCtx(ChannelHandlerContext ctx, MqttConnectReturnCode returnCode) {
<b class="nc">&nbsp;        closeCtx(ctx, ReturnCodeResolver.getConnectionReturnCode(deviceSessionCtx.getMqttVersion(), returnCode).byteValue());</b>
&nbsp;    }
&nbsp;
&nbsp;    private void closeCtx(ChannelHandlerContext ctx, byte returnCode) {
<b class="nc">&nbsp;        closeCtx(ctx, createMqttDisconnectMsg(deviceSessionCtx, returnCode));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void closeCtx(ChannelHandlerContext ctx, MqttMessage msg) {
<b class="nc">&nbsp;        if (!rpcAwaitingAck.isEmpty()) {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}] Cleanup RPC awaiting ack map due to session close!&quot;, sessionId);</b>
<b class="nc">&nbsp;            rpcAwaitingAck.clear();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (ctx.channel() == null) {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}] Channel is null, closing ctx...&quot;, sessionId);</b>
<b class="nc">&nbsp;            ctx.close();</b>
<b class="nc">&nbsp;        } else if (ctx.channel().isOpen()) {</b>
<b class="nc">&nbsp;            if (msg != null &amp;&amp; MqttVersion.MQTT_5 == deviceSessionCtx.getMqttVersion()) {</b>
<b class="nc">&nbsp;                ChannelFuture channelFuture = ctx.writeAndFlush(msg).addListener(future -&gt; ctx.close());</b>
<b class="nc">&nbsp;                scheduler.schedule(() -&gt; {</b>
<b class="nc">&nbsp;                    if (!channelFuture.isDone()) {</b>
<b class="nc">&nbsp;                        log.debug(&quot;[{}] Closing channel due to timeout!&quot;, sessionId);</b>
<b class="nc">&nbsp;                        ctx.close();</b>
&nbsp;                    }
<b class="nc">&nbsp;                }, context.getDisconnectTimeout(), TimeUnit.MILLISECONDS);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                ctx.close();</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            log.debug(&quot;[{}] Channel is already closed!&quot;, sessionId);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    InetSocketAddress getAddress(ChannelHandlerContext ctx) {
<b class="nc">&nbsp;        var address = ctx.channel().attr(MqttTransportService.ADDRESS).get();</b>
<b class="nc">&nbsp;        if (address == null) {</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}] Received empty address.&quot;, ctx.channel().id());</b>
<b class="nc">&nbsp;            InetSocketAddress remoteAddress = (InetSocketAddress) ctx.channel().remoteAddress();</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}] Going to use address: {}&quot;, ctx.channel().id(), remoteAddress);</b>
<b class="nc">&nbsp;            return remoteAddress;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            log.trace(&quot;[{}] Received address: {}&quot;, ctx.channel().id(), address);</b>
&nbsp;        }
<b class="nc">&nbsp;        return address;</b>
&nbsp;    }
&nbsp;
&nbsp;    void processMqttMsg(ChannelHandlerContext ctx, MqttMessage msg) {
<b class="nc">&nbsp;        if (msg.fixedHeader() == null) {</b>
<b class="nc">&nbsp;            log.info(&quot;[{}:{}] Invalid message received&quot;, address.getHostName(), address.getPort());</b>
<b class="nc">&nbsp;            closeCtx(ctx, MqttReasonCodes.Disconnect.PROTOCOL_ERROR);</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        deviceSessionCtx.setChannel(ctx);</b>
<b class="nc">&nbsp;        if (CONNECT.equals(msg.fixedHeader().messageType())) {</b>
<b class="nc">&nbsp;            processConnect(ctx, (MqttConnectMessage) msg);</b>
<b class="nc">&nbsp;        } else if (deviceSessionCtx.isProvisionOnly()) {</b>
<b class="nc">&nbsp;            processProvisionSessionMsg(ctx, msg);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            enqueueRegularSessionMsg(ctx, msg);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void processProvisionSessionMsg(ChannelHandlerContext ctx, MqttMessage msg) {
<b class="nc">&nbsp;        switch (msg.fixedHeader().messageType()) {</b>
&nbsp;            case PUBLISH:
<b class="nc">&nbsp;                MqttPublishMessage mqttMsg = (MqttPublishMessage) msg;</b>
<b class="nc">&nbsp;                String topicName = mqttMsg.variableHeader().topicName();</b>
<b class="nc">&nbsp;                int msgId = mqttMsg.variableHeader().packetId();</b>
&nbsp;                try {
<b class="nc">&nbsp;                    if (topicName.equals(MqttTopics.DEVICE_PROVISION_REQUEST_TOPIC)) {</b>
&nbsp;                        try {
<b class="nc">&nbsp;                            TransportProtos.ProvisionDeviceRequestMsg provisionRequestMsg = deviceSessionCtx.getContext().getJsonMqttAdaptor().convertToProvisionRequestMsg(deviceSessionCtx, mqttMsg);</b>
<b class="nc">&nbsp;                            transportService.process(provisionRequestMsg, new DeviceProvisionCallback(ctx, msgId, provisionRequestMsg));</b>
<b class="nc">&nbsp;                            log.trace(&quot;[{}][{}] Processing provision publish msg [{}][{}]!&quot;, sessionId, deviceSessionCtx.getDeviceId(), topicName, msgId);</b>
&nbsp;                        } catch (Exception e) {
<b class="nc">&nbsp;                            if (e instanceof JsonParseException || (e.getCause() != null &amp;&amp; e.getCause() instanceof JsonParseException)) {</b>
<b class="nc">&nbsp;                                TransportProtos.ProvisionDeviceRequestMsg provisionRequestMsg = deviceSessionCtx.getContext().getProtoMqttAdaptor().convertToProvisionRequestMsg(deviceSessionCtx, mqttMsg);</b>
<b class="nc">&nbsp;                                transportService.process(provisionRequestMsg, new DeviceProvisionCallback(ctx, msgId, provisionRequestMsg));</b>
<b class="nc">&nbsp;                                deviceSessionCtx.setProvisionPayloadType(TransportPayloadType.PROTOBUF);</b>
<b class="nc">&nbsp;                                log.trace(&quot;[{}][{}] Processing provision publish msg [{}][{}]!&quot;, sessionId, deviceSessionCtx.getDeviceId(), topicName, msgId);</b>
&nbsp;                            } else {
&nbsp;                                throw e;
&nbsp;                            }
&nbsp;                        }
&nbsp;                    } else {
<b class="nc">&nbsp;                        log.debug(&quot;[{}] Unsupported topic for provisioning requests: {}!&quot;, sessionId, topicName);</b>
<b class="nc">&nbsp;                        ack(ctx, msgId, MqttReasonCodes.PubAck.TOPIC_NAME_INVALID);</b>
<b class="nc">&nbsp;                        closeCtx(ctx, MqttReasonCodes.Disconnect.TOPIC_NAME_INVALID);</b>
&nbsp;                    }
&nbsp;                } catch (RuntimeException e) {
<b class="nc">&nbsp;                    log.warn(&quot;[{}] Failed to process publish msg [{}][{}]&quot;, sessionId, topicName, msgId, e);</b>
<b class="nc">&nbsp;                    ack(ctx, msgId, MqttReasonCodes.PubAck.IMPLEMENTATION_SPECIFIC_ERROR);</b>
<b class="nc">&nbsp;                    closeCtx(ctx, MqttReasonCodes.Disconnect.IMPLEMENTATION_SPECIFIC_ERROR);</b>
&nbsp;                } catch (AdaptorException e) {
<b class="nc">&nbsp;                    log.debug(&quot;[{}] Failed to process publish msg [{}][{}]&quot;, sessionId, topicName, msgId, e);</b>
<b class="nc">&nbsp;                    sendResponseForAdaptorErrorOrCloseContext(ctx, topicName, msgId);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case SUBSCRIBE:
<b class="nc">&nbsp;                MqttSubscribeMessage subscribeMessage = (MqttSubscribeMessage) msg;</b>
<b class="nc">&nbsp;                processSubscribe(ctx, subscribeMessage);</b>
&nbsp;                break;
&nbsp;            case UNSUBSCRIBE:
<b class="nc">&nbsp;                MqttUnsubscribeMessage unsubscribeMessage = (MqttUnsubscribeMessage) msg;</b>
<b class="nc">&nbsp;                processUnsubscribe(ctx, unsubscribeMessage);</b>
&nbsp;                break;
&nbsp;            case PINGREQ:
<b class="nc">&nbsp;                ctx.writeAndFlush(new MqttMessage(new MqttFixedHeader(PINGRESP, false, AT_MOST_ONCE, false, 0)));</b>
&nbsp;                break;
&nbsp;            case DISCONNECT:
<b class="nc">&nbsp;                closeCtx(ctx, MqttReasonCodes.Disconnect.NORMAL_DISCONNECT);</b>
&nbsp;                break;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    void enqueueRegularSessionMsg(ChannelHandlerContext ctx, MqttMessage msg) {
<b class="nc">&nbsp;        final int queueSize = deviceSessionCtx.getMsgQueueSize();</b>
<b class="nc">&nbsp;        if (queueSize &gt;= context.getMessageQueueSizePerDeviceLimit()) {</b>
<b class="nc">&nbsp;            log.info(&quot;Closing current session because msq queue size for device {} exceed limit {} with msgQueueSize counter {} and actual queue size {}&quot;,</b>
<b class="nc">&nbsp;                    deviceSessionCtx.getDeviceId(), context.getMessageQueueSizePerDeviceLimit(), queueSize, deviceSessionCtx.getMsgQueueSize());</b>
<b class="nc">&nbsp;            closeCtx(ctx, MqttReasonCodes.Disconnect.QUOTA_EXCEEDED);</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        deviceSessionCtx.addToQueue(msg);</b>
<b class="nc">&nbsp;        processMsgQueue(ctx); //Under the normal conditions the msg queue will contain 0 messages. Many messages will be processed on device connect event in separate thread pool</b>
&nbsp;    }
&nbsp;
&nbsp;    void processMsgQueue(ChannelHandlerContext ctx) {
<b class="nc">&nbsp;        if (!deviceSessionCtx.isConnected()) {</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}] Postpone processing msg due to device is not connected. Msg queue size is {}&quot;, sessionId, deviceSessionCtx.getDeviceId(), deviceSessionCtx.getMsgQueueSize());</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        deviceSessionCtx.tryProcessQueuedMsgs(msg -&gt; processRegularSessionMsg(ctx, msg));</b>
&nbsp;    }
&nbsp;
&nbsp;    void processRegularSessionMsg(ChannelHandlerContext ctx, MqttMessage msg) {
<b class="nc">&nbsp;        switch (msg.fixedHeader().messageType()) {</b>
&nbsp;            case PUBLISH:
<b class="nc">&nbsp;                processPublish(ctx, (MqttPublishMessage) msg);</b>
&nbsp;                break;
&nbsp;            case SUBSCRIBE:
<b class="nc">&nbsp;                processSubscribe(ctx, (MqttSubscribeMessage) msg);</b>
&nbsp;                break;
&nbsp;            case UNSUBSCRIBE:
<b class="nc">&nbsp;                processUnsubscribe(ctx, (MqttUnsubscribeMessage) msg);</b>
&nbsp;                break;
&nbsp;            case PINGREQ:
<b class="nc">&nbsp;                if (checkConnected(ctx, msg)) {</b>
<b class="nc">&nbsp;                    ctx.writeAndFlush(new MqttMessage(new MqttFixedHeader(PINGRESP, false, AT_MOST_ONCE, false, 0)));</b>
<b class="nc">&nbsp;                    transportService.recordActivity(deviceSessionCtx.getSessionInfo());</b>
<b class="nc">&nbsp;                    if (gatewaySessionHandler != null) {</b>
<b class="nc">&nbsp;                        gatewaySessionHandler.onGatewayPing();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;                break;
&nbsp;            case DISCONNECT:
<b class="nc">&nbsp;                closeCtx(ctx, MqttReasonCodes.Disconnect.NORMAL_DISCONNECT);</b>
&nbsp;                break;
&nbsp;            case PUBACK:
<b class="nc">&nbsp;                int msgId = ((MqttPubAckMessage) msg).variableHeader().messageId();</b>
<b class="nc">&nbsp;                TransportProtos.ToDeviceRpcRequestMsg rpcRequest = rpcAwaitingAck.remove(msgId);</b>
<b class="nc">&nbsp;                if (rpcRequest != null) {</b>
<b class="nc">&nbsp;                    transportService.process(deviceSessionCtx.getSessionInfo(), rpcRequest, RpcStatus.DELIVERED, true, TransportServiceCallback.EMPTY);</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            default:
&nbsp;                break;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void processPublish(ChannelHandlerContext ctx, MqttPublishMessage mqttMsg) {
<b class="nc">&nbsp;        if (!checkConnected(ctx, mqttMsg)) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        String topicName = mqttMsg.variableHeader().topicName();</b>
<b class="nc">&nbsp;        int msgId = mqttMsg.variableHeader().packetId();</b>
<b class="nc">&nbsp;        log.trace(&quot;[{}][{}] Processing publish msg [{}][{}]!&quot;, sessionId, deviceSessionCtx.getDeviceId(), topicName, msgId);</b>
<b class="nc">&nbsp;        if (topicName.startsWith(MqttTopics.BASE_GATEWAY_API_TOPIC)) {</b>
<b class="nc">&nbsp;            if (gatewaySessionHandler != null) {</b>
<b class="nc">&nbsp;                handleGatewayPublishMsg(ctx, topicName, msgId, mqttMsg);</b>
<b class="nc">&nbsp;                transportService.recordActivity(deviceSessionCtx.getSessionInfo());</b>
&nbsp;            } else {
<b class="nc">&nbsp;                log.error(&quot;[gatewaySessionHandler] is null, [{}] Failed to process publish msg [{}][{}]&quot;, sessionId, topicName, msgId);</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (sparkplugSessionHandler != null) {</b>
<b class="nc">&nbsp;            handleSparkplugPublishMsg(ctx, topicName, mqttMsg);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            processDevicePublish(ctx, mqttMsg, topicName, msgId);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void handleGatewayPublishMsg(ChannelHandlerContext ctx, String topicName, int msgId, MqttPublishMessage mqttMsg) {
&nbsp;        try {
<b class="nc">&nbsp;            switch (topicName) {</b>
&nbsp;                case MqttTopics.GATEWAY_TELEMETRY_TOPIC:
<b class="nc">&nbsp;                    gatewaySessionHandler.onDeviceTelemetry(mqttMsg);</b>
&nbsp;                    break;
&nbsp;                case MqttTopics.GATEWAY_CLAIM_TOPIC:
<b class="nc">&nbsp;                    gatewaySessionHandler.onDeviceClaim(mqttMsg);</b>
&nbsp;                    break;
&nbsp;                case MqttTopics.GATEWAY_ATTRIBUTES_TOPIC:
<b class="nc">&nbsp;                    gatewaySessionHandler.onDeviceAttributes(mqttMsg);</b>
&nbsp;                    break;
&nbsp;                case MqttTopics.GATEWAY_ATTRIBUTES_REQUEST_TOPIC:
<b class="nc">&nbsp;                    gatewaySessionHandler.onDeviceAttributesRequest(mqttMsg);</b>
&nbsp;                    break;
&nbsp;                case MqttTopics.GATEWAY_RPC_TOPIC:
<b class="nc">&nbsp;                    gatewaySessionHandler.onDeviceRpcResponse(mqttMsg);</b>
&nbsp;                    break;
&nbsp;                case MqttTopics.GATEWAY_CONNECT_TOPIC:
<b class="nc">&nbsp;                    gatewaySessionHandler.onDeviceConnect(mqttMsg);</b>
&nbsp;                    break;
&nbsp;                case MqttTopics.GATEWAY_DISCONNECT_TOPIC:
<b class="nc">&nbsp;                    gatewaySessionHandler.onDeviceDisconnect(mqttMsg);</b>
&nbsp;                    break;
&nbsp;                default:
<b class="nc">&nbsp;                    ack(ctx, msgId, MqttReasonCodes.PubAck.TOPIC_NAME_INVALID);</b>
&nbsp;            }
&nbsp;        } catch (RuntimeException e) {
<b class="nc">&nbsp;            log.warn(&quot;[{}] Failed to process publish msg [{}][{}]&quot;, sessionId, topicName, msgId, e);</b>
<b class="nc">&nbsp;            ack(ctx, msgId, MqttReasonCodes.PubAck.IMPLEMENTATION_SPECIFIC_ERROR);</b>
<b class="nc">&nbsp;            closeCtx(ctx, MqttReasonCodes.Disconnect.IMPLEMENTATION_SPECIFIC_ERROR);</b>
&nbsp;        } catch (AdaptorException e) {
<b class="nc">&nbsp;            log.debug(&quot;[{}] Failed to process publish msg [{}][{}]&quot;, sessionId, topicName, msgId, e);</b>
<b class="nc">&nbsp;            sendResponseForAdaptorErrorOrCloseContext(ctx, topicName, msgId);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * It may be the case that an Edge Node has many dynamic associated devices.
&nbsp;     * Publish: spBv1.0/G1/DBIRTH/E1/+
&nbsp;     * Publish: spBv1.0/G1/DDATA/E1/+
&nbsp;     * Publish: spBv1.0/G1/DCMD/E1/+
&nbsp;     * Publish: spBv1.0/G1/DDEATH/E1/+
&nbsp;     * @param ctx
&nbsp;     * @param topicName
&nbsp;     * @param mqttMsg
&nbsp;     */
&nbsp;
&nbsp;    private void handleSparkplugPublishMsg(ChannelHandlerContext ctx, String topicName, MqttPublishMessage mqttMsg) {
<b class="nc">&nbsp;        int msgId = mqttMsg.variableHeader().packetId();</b>
&nbsp;        try {
<b class="nc">&nbsp;            SparkplugTopic sparkplugTopic = parseTopicPublish(topicName);</b>
<b class="nc">&nbsp;            boolean isWildcardInPublish = topicName.contains(&quot;+&quot;);</b>
<b class="nc">&nbsp;            if (!isWildcardInPublish &amp;&amp; sparkplugTopic.isNode()) {</b>
&nbsp;                // A node topic
<b class="nc">&nbsp;                SparkplugBProto.Payload sparkplugBProtoNode = SparkplugBProto.Payload.parseFrom(ProtoMqttAdaptor.toBytes(mqttMsg.payload()));</b>
<b class="nc">&nbsp;                switch (sparkplugTopic.getType()) {</b>
&nbsp;                    case NBIRTH:
&nbsp;                    case NCMD:
&nbsp;                    case NDATA:
<b class="nc">&nbsp;                        sparkplugSessionHandler.onAttributesTelemetryProto(msgId, sparkplugBProtoNode, sparkplugTopic);</b>
&nbsp;                        break;
&nbsp;                    case NDEATH:
<b class="nc">&nbsp;                        if (sparkplugSessionHandler.onValidateNDEATH(sparkplugBProtoNode)) {</b>
<b class="nc">&nbsp;                            doDisconnect();</b>
&nbsp;                            break;
&nbsp;                        } else {
<b class="nc">&nbsp;                            throw new ThingsboardException(SPARKPLUG_BD_SEQUENCE_NUMBER_KEY + &quot; of &quot; + NDEATH.name() + &quot; is not equals &quot; +</b>
<b class="nc">&nbsp;                                    SPARKPLUG_BD_SEQUENCE_NUMBER_KEY + &quot; of &quot; + NBIRTH.name(), ThingsboardErrorCode.BAD_REQUEST_PARAMS);</b>
&nbsp;                        }
&nbsp;                    default:
&nbsp;                }
&nbsp;            } else {
&nbsp;                // A device topic
<b class="nc">&nbsp;                SparkplugBProto.Payload sparkplugBProtoDevice = SparkplugBProto.Payload.parseFrom(ProtoMqttAdaptor.toBytes(mqttMsg.payload()));</b>
<b class="nc">&nbsp;                if (isWildcardInPublish) {</b>
<b class="nc">&nbsp;                    for (Entry&lt;String, SparkplugDeviceSessionContext&gt; entry : sparkplugSessionHandler.getDevices().entrySet()) {</b>
<b class="nc">&nbsp;                        String deviceName = entry.getKey();</b>
<b class="nc">&nbsp;                        SparkplugTopic sparkplugTopicDevice = sparkplugTopic;</b>
<b class="nc">&nbsp;                        sparkplugTopicDevice.updateDeviceIdPlus(deviceName);</b>
<b class="nc">&nbsp;                        handleSparkplugPublishDeviceMsg(sparkplugTopicDevice, msgId, mqttMsg, sparkplugBProtoDevice);</b>
&nbsp;                    }
&nbsp;                } else {
<b class="nc">&nbsp;                    handleSparkplugPublishDeviceMsg(sparkplugTopic, msgId, mqttMsg, sparkplugBProtoDevice);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        } catch (RuntimeException e) {
<b class="nc">&nbsp;            log.error(&quot;[{}] Failed to process publish msg [{}][{}]&quot;, sessionId, topicName, msgId, e);</b>
<b class="nc">&nbsp;            ack(ctx, msgId, MqttReasonCodes.PubAck.IMPLEMENTATION_SPECIFIC_ERROR);</b>
<b class="nc">&nbsp;            closeCtx(ctx, MqttReasonCodes.Disconnect.IMPLEMENTATION_SPECIFIC_ERROR);</b>
&nbsp;        } catch (AdaptorException | ThingsboardException | InvalidProtocolBufferException e) {
<b class="nc">&nbsp;            log.error(&quot;[{}] Failed to process publish msg [{}][{}]&quot;, sessionId, topicName, msgId, e);</b>
<b class="nc">&nbsp;            sendResponseForAdaptorErrorOrCloseContext(ctx, topicName, msgId);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * It may be the case that an Edge Node has many dynamic associated devices.
&nbsp;     * Publish: spBv1.0/G1/DBIRTH/E1/+
&nbsp;     * Publish: spBv1.0/G1/DDATA/E1/+
&nbsp;     * Publish: spBv1.0/G1/DCMD/E1/+
&nbsp;     * Publish: spBv1.0/G1/DDEATH/E1/+
&nbsp;     * @param sparkplugTopic
&nbsp;     * @param msgId
&nbsp;     * @param mqttMsg
&nbsp;     * @throws AdaptorException
&nbsp;     * @throws ThingsboardException
&nbsp;     * @throws InvalidProtocolBufferException
&nbsp;     */
&nbsp;    private void handleSparkplugPublishDeviceMsg(SparkplugTopic sparkplugTopic, int msgId,
&nbsp;                                                 MqttPublishMessage mqttMsg, SparkplugBProto.Payload sparkplugBProtoDevice)
&nbsp;            throws AdaptorException, ThingsboardException, InvalidProtocolBufferException {
&nbsp;        // A device topic
<b class="nc">&nbsp;        switch (sparkplugTopic.getType()) {</b>
&nbsp;            case DBIRTH:
&nbsp;            case DCMD:
&nbsp;            case DDATA:
<b class="nc">&nbsp;                sparkplugSessionHandler.onAttributesTelemetryProto(msgId, sparkplugBProtoDevice, sparkplugTopic);</b>
&nbsp;                break;
&nbsp;            case DDEATH:
<b class="nc">&nbsp;                sparkplugSessionHandler.onDeviceDisconnect(mqttMsg, sparkplugTopic.getDeviceId());</b>
&nbsp;                break;
&nbsp;            default:
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void processDevicePublish(ChannelHandlerContext ctx, MqttPublishMessage mqttMsg, String topicName, int msgId) {
&nbsp;        try {
&nbsp;            Matcher fwMatcher;
<b class="nc">&nbsp;            MqttTransportAdaptor payloadAdaptor = deviceSessionCtx.getPayloadAdaptor();</b>
<b class="nc">&nbsp;            if (deviceSessionCtx.isDeviceAttributesTopic(topicName)) {</b>
<b class="nc">&nbsp;                TransportProtos.PostAttributeMsg postAttributeMsg = payloadAdaptor.convertToPostAttributes(deviceSessionCtx, mqttMsg);</b>
<b class="nc">&nbsp;                transportService.process(deviceSessionCtx.getSessionInfo(), postAttributeMsg, getMetadata(deviceSessionCtx, topicName),</b>
<b class="nc">&nbsp;                        getPubAckCallback(ctx, msgId, postAttributeMsg));</b>
<b class="nc">&nbsp;            } else if (deviceSessionCtx.isDeviceTelemetryTopic(topicName)) {</b>
<b class="nc">&nbsp;                TransportProtos.PostTelemetryMsg postTelemetryMsg = payloadAdaptor.convertToPostTelemetry(deviceSessionCtx, mqttMsg);</b>
<b class="nc">&nbsp;                transportService.process(deviceSessionCtx.getSessionInfo(), postTelemetryMsg, getMetadata(deviceSessionCtx, topicName),</b>
<b class="nc">&nbsp;                        getPubAckCallback(ctx, msgId, postTelemetryMsg));</b>
<b class="nc">&nbsp;            } else if (topicName.startsWith(MqttTopics.DEVICE_ATTRIBUTES_REQUEST_TOPIC_PREFIX)) {</b>
<b class="nc">&nbsp;                TransportProtos.GetAttributeRequestMsg getAttributeMsg = payloadAdaptor.convertToGetAttributes(deviceSessionCtx, mqttMsg, MqttTopics.DEVICE_ATTRIBUTES_REQUEST_TOPIC_PREFIX);</b>
<b class="nc">&nbsp;                transportService.process(deviceSessionCtx.getSessionInfo(), getAttributeMsg, getPubAckCallback(ctx, msgId, getAttributeMsg));</b>
<b class="nc">&nbsp;                attrReqTopicType = TopicType.V1;</b>
<b class="nc">&nbsp;            } else if (topicName.startsWith(MqttTopics.DEVICE_RPC_RESPONSE_TOPIC)) {</b>
<b class="nc">&nbsp;                TransportProtos.ToDeviceRpcResponseMsg rpcResponseMsg = payloadAdaptor.convertToDeviceRpcResponse(deviceSessionCtx, mqttMsg, MqttTopics.DEVICE_RPC_RESPONSE_TOPIC);</b>
<b class="nc">&nbsp;                transportService.process(deviceSessionCtx.getSessionInfo(), rpcResponseMsg, getPubAckCallback(ctx, msgId, rpcResponseMsg));</b>
<b class="nc">&nbsp;            } else if (topicName.startsWith(MqttTopics.DEVICE_RPC_REQUESTS_TOPIC)) {</b>
<b class="nc">&nbsp;                TransportProtos.ToServerRpcRequestMsg rpcRequestMsg = payloadAdaptor.convertToServerRpcRequest(deviceSessionCtx, mqttMsg, MqttTopics.DEVICE_RPC_REQUESTS_TOPIC);</b>
<b class="nc">&nbsp;                toServerRpcSubTopicType = TopicType.V1;</b>
<b class="nc">&nbsp;                if (SESSION_LIMITS.equals(rpcRequestMsg.getMethodName())) {</b>
<b class="nc">&nbsp;                    onGetSessionLimitsRpc(deviceSessionCtx.getSessionInfo(), ctx, msgId, rpcRequestMsg);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    transportService.process(deviceSessionCtx.getSessionInfo(), rpcRequestMsg, getPubAckCallback(ctx, msgId, rpcRequestMsg));</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (topicName.equals(MqttTopics.DEVICE_CLAIM_TOPIC)) {</b>
<b class="nc">&nbsp;                TransportProtos.ClaimDeviceMsg claimDeviceMsg = payloadAdaptor.convertToClaimDevice(deviceSessionCtx, mqttMsg);</b>
<b class="nc">&nbsp;                transportService.process(deviceSessionCtx.getSessionInfo(), claimDeviceMsg, getPubAckCallback(ctx, msgId, claimDeviceMsg));</b>
<b class="nc">&nbsp;            } else if ((fwMatcher = FW_REQUEST_PATTERN.matcher(topicName)).find()) {</b>
<b class="nc">&nbsp;                getOtaPackageCallback(ctx, mqttMsg, msgId, fwMatcher, OtaPackageType.FIRMWARE);</b>
<b class="nc">&nbsp;            } else if ((fwMatcher = SW_REQUEST_PATTERN.matcher(topicName)).find()) {</b>
<b class="nc">&nbsp;                getOtaPackageCallback(ctx, mqttMsg, msgId, fwMatcher, OtaPackageType.SOFTWARE);</b>
<b class="nc">&nbsp;            } else if (topicName.equals(MqttTopics.DEVICE_TELEMETRY_SHORT_TOPIC)) {</b>
<b class="nc">&nbsp;                TransportProtos.PostTelemetryMsg postTelemetryMsg = payloadAdaptor.convertToPostTelemetry(deviceSessionCtx, mqttMsg);</b>
<b class="nc">&nbsp;                transportService.process(deviceSessionCtx.getSessionInfo(), postTelemetryMsg, getMetadata(deviceSessionCtx, topicName),</b>
<b class="nc">&nbsp;                        getPubAckCallback(ctx, msgId, postTelemetryMsg));</b>
<b class="nc">&nbsp;            } else if (topicName.equals(MqttTopics.DEVICE_TELEMETRY_SHORT_JSON_TOPIC)) {</b>
<b class="nc">&nbsp;                TransportProtos.PostTelemetryMsg postTelemetryMsg = context.getJsonMqttAdaptor().convertToPostTelemetry(deviceSessionCtx, mqttMsg);</b>
<b class="nc">&nbsp;                transportService.process(deviceSessionCtx.getSessionInfo(), postTelemetryMsg, getMetadata(deviceSessionCtx, topicName),</b>
<b class="nc">&nbsp;                        getPubAckCallback(ctx, msgId, postTelemetryMsg));</b>
<b class="nc">&nbsp;            } else if (topicName.equals(MqttTopics.DEVICE_TELEMETRY_SHORT_PROTO_TOPIC)) {</b>
<b class="nc">&nbsp;                TransportProtos.PostTelemetryMsg postTelemetryMsg = context.getProtoMqttAdaptor().convertToPostTelemetry(deviceSessionCtx, mqttMsg);</b>
<b class="nc">&nbsp;                transportService.process(deviceSessionCtx.getSessionInfo(), postTelemetryMsg, getMetadata(deviceSessionCtx, topicName),</b>
<b class="nc">&nbsp;                        getPubAckCallback(ctx, msgId, postTelemetryMsg));</b>
<b class="nc">&nbsp;            } else if (topicName.equals(MqttTopics.DEVICE_ATTRIBUTES_SHORT_TOPIC)) {</b>
<b class="nc">&nbsp;                TransportProtos.PostAttributeMsg postAttributeMsg = payloadAdaptor.convertToPostAttributes(deviceSessionCtx, mqttMsg);</b>
<b class="nc">&nbsp;                transportService.process(deviceSessionCtx.getSessionInfo(), postAttributeMsg, getMetadata(deviceSessionCtx, topicName),</b>
<b class="nc">&nbsp;                        getPubAckCallback(ctx, msgId, postAttributeMsg));</b>
<b class="nc">&nbsp;            } else if (topicName.equals(MqttTopics.DEVICE_ATTRIBUTES_SHORT_JSON_TOPIC)) {</b>
<b class="nc">&nbsp;                TransportProtos.PostAttributeMsg postAttributeMsg = context.getJsonMqttAdaptor().convertToPostAttributes(deviceSessionCtx, mqttMsg);</b>
<b class="nc">&nbsp;                transportService.process(deviceSessionCtx.getSessionInfo(), postAttributeMsg, getMetadata(deviceSessionCtx, topicName),</b>
<b class="nc">&nbsp;                        getPubAckCallback(ctx, msgId, postAttributeMsg));</b>
<b class="nc">&nbsp;            } else if (topicName.equals(MqttTopics.DEVICE_ATTRIBUTES_SHORT_PROTO_TOPIC)) {</b>
<b class="nc">&nbsp;                TransportProtos.PostAttributeMsg postAttributeMsg = context.getProtoMqttAdaptor().convertToPostAttributes(deviceSessionCtx, mqttMsg);</b>
<b class="nc">&nbsp;                transportService.process(deviceSessionCtx.getSessionInfo(), postAttributeMsg, getMetadata(deviceSessionCtx, topicName),</b>
<b class="nc">&nbsp;                        getPubAckCallback(ctx, msgId, postAttributeMsg));</b>
<b class="nc">&nbsp;            } else if (topicName.startsWith(MqttTopics.DEVICE_RPC_RESPONSE_SHORT_JSON_TOPIC)) {</b>
<b class="nc">&nbsp;                TransportProtos.ToDeviceRpcResponseMsg rpcResponseMsg = context.getJsonMqttAdaptor().convertToDeviceRpcResponse(deviceSessionCtx, mqttMsg, MqttTopics.DEVICE_RPC_RESPONSE_SHORT_JSON_TOPIC);</b>
<b class="nc">&nbsp;                transportService.process(deviceSessionCtx.getSessionInfo(), rpcResponseMsg, getPubAckCallback(ctx, msgId, rpcResponseMsg));</b>
<b class="nc">&nbsp;            } else if (topicName.startsWith(MqttTopics.DEVICE_RPC_RESPONSE_SHORT_PROTO_TOPIC)) {</b>
<b class="nc">&nbsp;                TransportProtos.ToDeviceRpcResponseMsg rpcResponseMsg = context.getProtoMqttAdaptor().convertToDeviceRpcResponse(deviceSessionCtx, mqttMsg, MqttTopics.DEVICE_RPC_RESPONSE_SHORT_PROTO_TOPIC);</b>
<b class="nc">&nbsp;                transportService.process(deviceSessionCtx.getSessionInfo(), rpcResponseMsg, getPubAckCallback(ctx, msgId, rpcResponseMsg));</b>
<b class="nc">&nbsp;            } else if (topicName.startsWith(MqttTopics.DEVICE_RPC_RESPONSE_SHORT_TOPIC)) {</b>
<b class="nc">&nbsp;                TransportProtos.ToDeviceRpcResponseMsg rpcResponseMsg = payloadAdaptor.convertToDeviceRpcResponse(deviceSessionCtx, mqttMsg, MqttTopics.DEVICE_RPC_RESPONSE_SHORT_TOPIC);</b>
<b class="nc">&nbsp;                transportService.process(deviceSessionCtx.getSessionInfo(), rpcResponseMsg, getPubAckCallback(ctx, msgId, rpcResponseMsg));</b>
<b class="nc">&nbsp;            } else if (topicName.startsWith(MqttTopics.DEVICE_RPC_REQUESTS_SHORT_JSON_TOPIC)) {</b>
<b class="nc">&nbsp;                TransportProtos.ToServerRpcRequestMsg rpcRequestMsg = context.getJsonMqttAdaptor().convertToServerRpcRequest(deviceSessionCtx, mqttMsg, MqttTopics.DEVICE_RPC_REQUESTS_SHORT_JSON_TOPIC);</b>
<b class="nc">&nbsp;                transportService.process(deviceSessionCtx.getSessionInfo(), rpcRequestMsg, getPubAckCallback(ctx, msgId, rpcRequestMsg));</b>
<b class="nc">&nbsp;                toServerRpcSubTopicType = TopicType.V2_JSON;</b>
<b class="nc">&nbsp;            } else if (topicName.startsWith(MqttTopics.DEVICE_RPC_REQUESTS_SHORT_PROTO_TOPIC)) {</b>
<b class="nc">&nbsp;                TransportProtos.ToServerRpcRequestMsg rpcRequestMsg = context.getProtoMqttAdaptor().convertToServerRpcRequest(deviceSessionCtx, mqttMsg, MqttTopics.DEVICE_RPC_REQUESTS_SHORT_PROTO_TOPIC);</b>
<b class="nc">&nbsp;                transportService.process(deviceSessionCtx.getSessionInfo(), rpcRequestMsg, getPubAckCallback(ctx, msgId, rpcRequestMsg));</b>
<b class="nc">&nbsp;                toServerRpcSubTopicType = TopicType.V2_PROTO;</b>
<b class="nc">&nbsp;            } else if (topicName.startsWith(MqttTopics.DEVICE_RPC_REQUESTS_SHORT_TOPIC)) {</b>
<b class="nc">&nbsp;                TransportProtos.ToServerRpcRequestMsg rpcRequestMsg = payloadAdaptor.convertToServerRpcRequest(deviceSessionCtx, mqttMsg, MqttTopics.DEVICE_RPC_REQUESTS_SHORT_TOPIC);</b>
<b class="nc">&nbsp;                transportService.process(deviceSessionCtx.getSessionInfo(), rpcRequestMsg, getPubAckCallback(ctx, msgId, rpcRequestMsg));</b>
<b class="nc">&nbsp;                toServerRpcSubTopicType = TopicType.V2;</b>
<b class="nc">&nbsp;            } else if (topicName.startsWith(MqttTopics.DEVICE_ATTRIBUTES_REQUEST_SHORT_JSON_TOPIC_PREFIX)) {</b>
<b class="nc">&nbsp;                TransportProtos.GetAttributeRequestMsg getAttributeMsg = context.getJsonMqttAdaptor().convertToGetAttributes(deviceSessionCtx, mqttMsg, MqttTopics.DEVICE_ATTRIBUTES_REQUEST_SHORT_JSON_TOPIC_PREFIX);</b>
<b class="nc">&nbsp;                transportService.process(deviceSessionCtx.getSessionInfo(), getAttributeMsg, getPubAckCallback(ctx, msgId, getAttributeMsg));</b>
<b class="nc">&nbsp;                attrReqTopicType = TopicType.V2_JSON;</b>
<b class="nc">&nbsp;            } else if (topicName.startsWith(MqttTopics.DEVICE_ATTRIBUTES_REQUEST_SHORT_PROTO_TOPIC_PREFIX)) {</b>
<b class="nc">&nbsp;                TransportProtos.GetAttributeRequestMsg getAttributeMsg = context.getProtoMqttAdaptor().convertToGetAttributes(deviceSessionCtx, mqttMsg, MqttTopics.DEVICE_ATTRIBUTES_REQUEST_SHORT_PROTO_TOPIC_PREFIX);</b>
<b class="nc">&nbsp;                transportService.process(deviceSessionCtx.getSessionInfo(), getAttributeMsg, getPubAckCallback(ctx, msgId, getAttributeMsg));</b>
<b class="nc">&nbsp;                attrReqTopicType = TopicType.V2_PROTO;</b>
<b class="nc">&nbsp;            } else if (topicName.startsWith(MqttTopics.DEVICE_ATTRIBUTES_REQUEST_SHORT_TOPIC_PREFIX)) {</b>
<b class="nc">&nbsp;                TransportProtos.GetAttributeRequestMsg getAttributeMsg = payloadAdaptor.convertToGetAttributes(deviceSessionCtx, mqttMsg, MqttTopics.DEVICE_ATTRIBUTES_REQUEST_SHORT_TOPIC_PREFIX);</b>
<b class="nc">&nbsp;                transportService.process(deviceSessionCtx.getSessionInfo(), getAttributeMsg, getPubAckCallback(ctx, msgId, getAttributeMsg));</b>
<b class="nc">&nbsp;                attrReqTopicType = TopicType.V2;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                transportService.recordActivity(deviceSessionCtx.getSessionInfo());</b>
<b class="nc">&nbsp;                ack(ctx, msgId, MqttReasonCodes.PubAck.TOPIC_NAME_INVALID);</b>
&nbsp;            }
&nbsp;        } catch (AdaptorException e) {
<b class="nc">&nbsp;            log.debug(&quot;[{}] Failed to process publish msg [{}][{}]&quot;, sessionId, topicName, msgId, e);</b>
<b class="nc">&nbsp;            sendResponseForAdaptorErrorOrCloseContext(ctx, topicName, msgId);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private TbMsgMetaData getMetadata(DeviceSessionCtx ctx, String topicName) {
<b class="nc">&nbsp;        if (ctx.isDeviceProfileMqttTransportType()) {</b>
<b class="nc">&nbsp;            TbMsgMetaData md = new TbMsgMetaData();</b>
<b class="nc">&nbsp;            md.putValue(DataConstants.MQTT_TOPIC, topicName);</b>
<b class="nc">&nbsp;            return md;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void sendResponseForAdaptorErrorOrCloseContext(ChannelHandlerContext ctx, String topicName, int msgId) {
<b class="nc">&nbsp;        if ((deviceSessionCtx.isSendAckOnValidationException() || MqttVersion.MQTT_5.equals(deviceSessionCtx.getMqttVersion())) &amp;&amp; msgId &gt; 0) {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}] Send pub ack on invalid publish msg [{}][{}]&quot;, sessionId, topicName, msgId);</b>
<b class="nc">&nbsp;            ctx.writeAndFlush(createMqttPubAckMsg(deviceSessionCtx, msgId, MqttReasonCodes.PubAck.PAYLOAD_FORMAT_INVALID.byteValue()));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            log.info(&quot;[{}] Closing current session due to invalid publish msg [{}][{}]&quot;, sessionId, topicName, msgId);</b>
<b class="nc">&nbsp;            closeCtx(ctx, MqttReasonCodes.Disconnect.PAYLOAD_FORMAT_INVALID);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void getOtaPackageCallback(ChannelHandlerContext ctx, MqttPublishMessage mqttMsg, int msgId, Matcher fwMatcher, OtaPackageType type) {
<b class="nc">&nbsp;        String payload = mqttMsg.content().toString(StandardCharsets.UTF_8);</b>
<b class="nc">&nbsp;        int chunkSize = StringUtils.isNotEmpty(payload) ? Integer.parseInt(payload) : 0;</b>
<b class="nc">&nbsp;        String requestId = fwMatcher.group(&quot;requestId&quot;);</b>
<b class="nc">&nbsp;        int chunk = Integer.parseInt(fwMatcher.group(&quot;chunk&quot;));</b>
&nbsp;
<b class="nc">&nbsp;        if (chunkSize &gt; 0) {</b>
<b class="nc">&nbsp;            this.chunkSizes.put(requestId, chunkSize);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            chunkSize = chunkSizes.getOrDefault(requestId, 0);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (chunkSize &gt; context.getMaxPayloadSize()) {</b>
<b class="nc">&nbsp;            sendOtaPackageError(ctx, PAYLOAD_TOO_LARGE);</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        String otaPackageId = otaPackSessions.get(requestId);</b>
&nbsp;
<b class="nc">&nbsp;        if (otaPackageId != null) {</b>
<b class="nc">&nbsp;            sendOtaPackage(ctx, mqttMsg.variableHeader().packetId(), otaPackageId, requestId, chunkSize, chunk, type);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            TransportProtos.SessionInfoProto sessionInfo = deviceSessionCtx.getSessionInfo();</b>
<b class="nc">&nbsp;            TransportProtos.GetOtaPackageRequestMsg getOtaPackageRequestMsg = TransportProtos.GetOtaPackageRequestMsg.newBuilder()</b>
<b class="nc">&nbsp;                    .setDeviceIdMSB(sessionInfo.getDeviceIdMSB())</b>
<b class="nc">&nbsp;                    .setDeviceIdLSB(sessionInfo.getDeviceIdLSB())</b>
<b class="nc">&nbsp;                    .setTenantIdMSB(sessionInfo.getTenantIdMSB())</b>
<b class="nc">&nbsp;                    .setTenantIdLSB(sessionInfo.getTenantIdLSB())</b>
<b class="nc">&nbsp;                    .setType(type.name())</b>
<b class="nc">&nbsp;                    .build();</b>
<b class="nc">&nbsp;            transportService.process(deviceSessionCtx.getSessionInfo(), getOtaPackageRequestMsg,</b>
&nbsp;                    new OtaPackageCallback(ctx, msgId, getOtaPackageRequestMsg, requestId, chunkSize, chunk));
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void ack(ChannelHandlerContext ctx, int msgId, MqttReasonCodes.PubAck returnCode) {
<b class="nc">&nbsp;        ack(ctx, msgId, returnCode.byteValue());</b>
&nbsp;    }
&nbsp;
&nbsp;    private void ack(ChannelHandlerContext ctx, int msgId, byte returnCode) {
<b class="nc">&nbsp;        if (msgId &gt; 0) {</b>
<b class="nc">&nbsp;            ctx.writeAndFlush(createMqttPubAckMsg(deviceSessionCtx, msgId, returnCode));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private &lt;T&gt; TransportServiceCallback&lt;Void&gt; getPubAckCallback(final ChannelHandlerContext ctx, final int msgId, final T msg) {
<b class="nc">&nbsp;        return new TransportServiceCallback&lt;&gt;() {</b>
&nbsp;            @Override
&nbsp;            public void onSuccess(Void dummy) {
<b class="nc">&nbsp;                log.trace(&quot;[{}] Published msg: {}&quot;, sessionId, msg);</b>
<b class="nc">&nbsp;                ack(ctx, msgId, MqttReasonCodes.PubAck.SUCCESS);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void onError(Throwable e) {
<b class="nc">&nbsp;                log.trace(&quot;[{}] Failed to publish msg: {}&quot;, sessionId, msg, e);</b>
<b class="nc">&nbsp;                closeCtx(ctx, MqttReasonCodes.Disconnect.IMPLEMENTATION_SPECIFIC_ERROR);</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    private class DeviceProvisionCallback implements TransportServiceCallback&lt;ProvisionDeviceResponseMsg&gt; {
&nbsp;        private final ChannelHandlerContext ctx;
&nbsp;        private final int msgId;
&nbsp;        private final TransportProtos.ProvisionDeviceRequestMsg msg;
&nbsp;
<b class="nc">&nbsp;        DeviceProvisionCallback(ChannelHandlerContext ctx, int msgId, TransportProtos.ProvisionDeviceRequestMsg msg) {</b>
<b class="nc">&nbsp;            this.ctx = ctx;</b>
<b class="nc">&nbsp;            this.msgId = msgId;</b>
<b class="nc">&nbsp;            this.msg = msg;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onSuccess(TransportProtos.ProvisionDeviceResponseMsg provisionResponseMsg) {
<b class="nc">&nbsp;            log.trace(&quot;[{}] Published msg: {}&quot;, sessionId, msg);</b>
<b class="nc">&nbsp;            ack(ctx, msgId, MqttReasonCodes.PubAck.SUCCESS);</b>
&nbsp;            try {
<b class="nc">&nbsp;                if (deviceSessionCtx.getProvisionPayloadType().equals(TransportPayloadType.JSON)) {</b>
<b class="nc">&nbsp;                    deviceSessionCtx.getContext().getJsonMqttAdaptor().convertToPublish(deviceSessionCtx, provisionResponseMsg).ifPresent(deviceSessionCtx.getChannel()::writeAndFlush);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    deviceSessionCtx.getContext().getProtoMqttAdaptor().convertToPublish(deviceSessionCtx, provisionResponseMsg).ifPresent(deviceSessionCtx.getChannel()::writeAndFlush);</b>
&nbsp;                }
<b class="nc">&nbsp;                scheduler.schedule((Callable&lt;ChannelFuture&gt;) ctx::close, 60, TimeUnit.SECONDS);</b>
&nbsp;            } catch (Exception e) {
<b class="nc">&nbsp;                log.trace(&quot;[{}] Failed to convert device provision response to MQTT msg&quot;, sessionId, e);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onError(Throwable e) {
<b class="nc">&nbsp;            log.trace(&quot;[{}] Failed to publish msg: {}&quot;, sessionId, msg, e);</b>
<b class="nc">&nbsp;            ack(ctx, msgId, MqttReasonCodes.PubAck.IMPLEMENTATION_SPECIFIC_ERROR);</b>
<b class="nc">&nbsp;            closeCtx(ctx, MqttReasonCodes.Disconnect.IMPLEMENTATION_SPECIFIC_ERROR);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private class OtaPackageCallback implements TransportServiceCallback&lt;TransportProtos.GetOtaPackageResponseMsg&gt; {
&nbsp;        private final ChannelHandlerContext ctx;
&nbsp;        private final int msgId;
&nbsp;        private final TransportProtos.GetOtaPackageRequestMsg msg;
&nbsp;        private final String requestId;
&nbsp;        private final int chunkSize;
&nbsp;        private final int chunk;
&nbsp;
<b class="nc">&nbsp;        OtaPackageCallback(ChannelHandlerContext ctx, int msgId, TransportProtos.GetOtaPackageRequestMsg msg, String requestId, int chunkSize, int chunk) {</b>
<b class="nc">&nbsp;            this.ctx = ctx;</b>
<b class="nc">&nbsp;            this.msgId = msgId;</b>
<b class="nc">&nbsp;            this.msg = msg;</b>
<b class="nc">&nbsp;            this.requestId = requestId;</b>
<b class="nc">&nbsp;            this.chunkSize = chunkSize;</b>
<b class="nc">&nbsp;            this.chunk = chunk;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onSuccess(TransportProtos.GetOtaPackageResponseMsg response) {
<b class="nc">&nbsp;            if (TransportProtos.ResponseStatus.SUCCESS.equals(response.getResponseStatus())) {</b>
<b class="nc">&nbsp;                OtaPackageId firmwareId = new OtaPackageId(new UUID(response.getOtaPackageIdMSB(), response.getOtaPackageIdLSB()));</b>
<b class="nc">&nbsp;                otaPackSessions.put(requestId, firmwareId.toString());</b>
<b class="nc">&nbsp;                sendOtaPackage(ctx, msgId, firmwareId.toString(), requestId, chunkSize, chunk, OtaPackageType.valueOf(response.getType()));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                sendOtaPackageError(ctx, response.getResponseStatus().toString());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onError(Throwable e) {
<b class="nc">&nbsp;            log.trace(&quot;[{}] Failed to get firmware: {}&quot;, sessionId, msg, e);</b>
<b class="nc">&nbsp;            closeCtx(ctx, MqttReasonCodes.Disconnect.IMPLEMENTATION_SPECIFIC_ERROR);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void sendOtaPackage(ChannelHandlerContext ctx, int msgId, String firmwareId, String requestId, int chunkSize, int chunk, OtaPackageType type) {
<b class="nc">&nbsp;        log.trace(&quot;[{}] Send firmware [{}] to device!&quot;, sessionId, firmwareId);</b>
<b class="nc">&nbsp;        ack(ctx, msgId, MqttReasonCodes.PubAck.SUCCESS);</b>
&nbsp;        try {
<b class="nc">&nbsp;            byte[] firmwareChunk = context.getOtaPackageDataCache().get(firmwareId, chunkSize, chunk);</b>
<b class="nc">&nbsp;            deviceSessionCtx.getPayloadAdaptor()</b>
<b class="nc">&nbsp;                    .convertToPublish(deviceSessionCtx, firmwareChunk, requestId, chunk, type)</b>
<b class="nc">&nbsp;                    .ifPresent(deviceSessionCtx.getChannel()::writeAndFlush);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.trace(&quot;[{}] Failed to send firmware response!&quot;, sessionId, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void sendOtaPackageError(ChannelHandlerContext ctx, String error) {
<b class="nc">&nbsp;        log.warn(&quot;[{}] {}&quot;, sessionId, error);</b>
<b class="nc">&nbsp;        deviceSessionCtx.getChannel().writeAndFlush(deviceSessionCtx</b>
<b class="nc">&nbsp;                .getPayloadAdaptor()</b>
<b class="nc">&nbsp;                .createMqttPublishMsg(deviceSessionCtx, MqttTopics.DEVICE_FIRMWARE_ERROR_TOPIC, error.getBytes()));</b>
<b class="nc">&nbsp;        closeCtx(ctx, MqttReasonCodes.Disconnect.IMPLEMENTATION_SPECIFIC_ERROR);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void processSubscribe(ChannelHandlerContext ctx, MqttSubscribeMessage mqttMsg) {
<b class="nc">&nbsp;        if (!checkConnected(ctx, mqttMsg) &amp;&amp; !deviceSessionCtx.isProvisionOnly()) {</b>
<b class="nc">&nbsp;            ctx.writeAndFlush(createSubAckMessage(mqttMsg.variableHeader().messageId(), Collections.singletonList(MqttReasonCodes.SubAck.NOT_AUTHORIZED.byteValue() &amp; 0xFF)));</b>
&nbsp;            return;
&nbsp;        }
&nbsp;        //TODO consume the rate limit
<b class="nc">&nbsp;        log.trace(&quot;[{}][{}] Processing subscription [{}]!&quot;, deviceSessionCtx.getTenantId(), sessionId, mqttMsg.variableHeader().messageId());</b>
<b class="nc">&nbsp;        List&lt;Integer&gt; grantedQoSList = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        boolean activityReported = false;</b>
<b class="nc">&nbsp;        for (MqttTopicSubscription subscription : mqttMsg.payload().topicSubscriptions()) {</b>
<b class="nc">&nbsp;            String topic = subscription.topicName();</b>
<b class="nc">&nbsp;            MqttQoS reqQoS = subscription.qualityOfService();</b>
<b class="nc">&nbsp;            if (deviceSessionCtx.isProvisionOnly()) {</b>
<b class="nc">&nbsp;                if (MqttTopics.DEVICE_PROVISION_RESPONSE_TOPIC.equals(topic)) {</b>
<b class="nc">&nbsp;                    registerSubQoS(topic, grantedQoSList, reqQoS);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    log.debug(&quot;[{}][{}] Failed to subscribe because this session is provision only [{}][{}]&quot;, deviceSessionCtx.getTenantId(), sessionId, topic, reqQoS);</b>
<b class="nc">&nbsp;                    grantedQoSList.add(ReturnCodeResolver.getSubscriptionReturnCode(deviceSessionCtx.getMqttVersion(), MqttReasonCodes.SubAck.TOPIC_FILTER_INVALID));</b>
&nbsp;                }
<b class="nc">&nbsp;                activityReported = true;</b>
&nbsp;                continue;
&nbsp;            }
<b class="nc">&nbsp;            if (deviceSessionCtx.isDeviceSubscriptionAttributesTopic(topic)) {</b>
<b class="nc">&nbsp;                processAttributesSubscribe(grantedQoSList, topic, reqQoS, TopicType.V1);</b>
<b class="nc">&nbsp;                activityReported = true;</b>
&nbsp;                continue;
&nbsp;            }
&nbsp;            try {
<b class="nc">&nbsp;                if (sparkplugSessionHandler != null) {</b>
<b class="nc">&nbsp;                    sparkplugSessionHandler.handleSparkplugSubscribeMsg(subscription);</b>
<b class="nc">&nbsp;                    activityReported = true;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    switch (topic) {</b>
&nbsp;                        case MqttTopics.DEVICE_ATTRIBUTES_TOPIC: {
<b class="nc">&nbsp;                            processAttributesSubscribe(grantedQoSList, topic, reqQoS, TopicType.V1);</b>
<b class="nc">&nbsp;                            activityReported = true;</b>
&nbsp;                            break;
&nbsp;                        }
&nbsp;                        case MqttTopics.DEVICE_ATTRIBUTES_SHORT_TOPIC: {
<b class="nc">&nbsp;                            processAttributesSubscribe(grantedQoSList, topic, reqQoS, TopicType.V2);</b>
<b class="nc">&nbsp;                            activityReported = true;</b>
&nbsp;                            break;
&nbsp;                        }
&nbsp;                        case MqttTopics.DEVICE_ATTRIBUTES_SHORT_JSON_TOPIC: {
<b class="nc">&nbsp;                            processAttributesSubscribe(grantedQoSList, topic, reqQoS, TopicType.V2_JSON);</b>
<b class="nc">&nbsp;                            activityReported = true;</b>
&nbsp;                            break;
&nbsp;                        }
&nbsp;                        case MqttTopics.DEVICE_ATTRIBUTES_SHORT_PROTO_TOPIC: {
<b class="nc">&nbsp;                            processAttributesSubscribe(grantedQoSList, topic, reqQoS, TopicType.V2_PROTO);</b>
<b class="nc">&nbsp;                            activityReported = true;</b>
&nbsp;                            break;
&nbsp;                        }
&nbsp;                        case MqttTopics.DEVICE_RPC_REQUESTS_SUB_TOPIC: {
<b class="nc">&nbsp;                            processRpcSubscribe(grantedQoSList, topic, reqQoS, TopicType.V1);</b>
<b class="nc">&nbsp;                            activityReported = true;</b>
&nbsp;                            break;
&nbsp;                        }
&nbsp;                        case MqttTopics.DEVICE_RPC_REQUESTS_SUB_SHORT_TOPIC: {
<b class="nc">&nbsp;                            processRpcSubscribe(grantedQoSList, topic, reqQoS, TopicType.V2);</b>
<b class="nc">&nbsp;                            activityReported = true;</b>
&nbsp;                            break;
&nbsp;                        }
&nbsp;                        case MqttTopics.DEVICE_RPC_REQUESTS_SUB_SHORT_JSON_TOPIC: {
<b class="nc">&nbsp;                            processRpcSubscribe(grantedQoSList, topic, reqQoS, TopicType.V2_JSON);</b>
<b class="nc">&nbsp;                            activityReported = true;</b>
&nbsp;                            break;
&nbsp;                        }
&nbsp;                        case MqttTopics.DEVICE_RPC_REQUESTS_SUB_SHORT_PROTO_TOPIC: {
<b class="nc">&nbsp;                            processRpcSubscribe(grantedQoSList, topic, reqQoS, TopicType.V2_PROTO);</b>
<b class="nc">&nbsp;                            activityReported = true;</b>
&nbsp;                            break;
&nbsp;                        }
&nbsp;                        case MqttTopics.DEVICE_RPC_RESPONSE_SUB_TOPIC:
&nbsp;                        case MqttTopics.DEVICE_RPC_RESPONSE_SUB_SHORT_TOPIC:
&nbsp;                        case MqttTopics.DEVICE_RPC_RESPONSE_SUB_SHORT_JSON_TOPIC:
&nbsp;                        case MqttTopics.DEVICE_RPC_RESPONSE_SUB_SHORT_PROTO_TOPIC:
&nbsp;                        case MqttTopics.DEVICE_ATTRIBUTES_RESPONSES_TOPIC:
&nbsp;                        case MqttTopics.DEVICE_ATTRIBUTES_RESPONSES_SHORT_TOPIC:
&nbsp;                        case MqttTopics.DEVICE_ATTRIBUTES_RESPONSES_SHORT_JSON_TOPIC:
&nbsp;                        case MqttTopics.DEVICE_ATTRIBUTES_RESPONSES_SHORT_PROTO_TOPIC:
&nbsp;                        case MqttTopics.GATEWAY_ATTRIBUTES_TOPIC:
&nbsp;                        case MqttTopics.GATEWAY_RPC_TOPIC:
&nbsp;                        case MqttTopics.GATEWAY_ATTRIBUTES_RESPONSE_TOPIC:
&nbsp;                        case MqttTopics.DEVICE_FIRMWARE_RESPONSES_TOPIC:
&nbsp;                        case MqttTopics.DEVICE_FIRMWARE_ERROR_TOPIC:
&nbsp;                        case MqttTopics.DEVICE_SOFTWARE_RESPONSES_TOPIC:
&nbsp;                        case MqttTopics.DEVICE_SOFTWARE_ERROR_TOPIC:
<b class="nc">&nbsp;                            registerSubQoS(topic, grantedQoSList, reqQoS);</b>
&nbsp;                            break;
&nbsp;                        default:
&nbsp;                            //TODO increment an error counter if any exists
<b class="nc">&nbsp;                            log.warn(&quot;[{}][{}] Failed to subscribe because topic is not supported [{}][{}]&quot;, deviceSessionCtx.getTenantId(), sessionId, topic, reqQoS);</b>
<b class="nc">&nbsp;                            grantedQoSList.add(ReturnCodeResolver.getSubscriptionReturnCode(deviceSessionCtx.getMqttVersion(), MqttReasonCodes.SubAck.TOPIC_FILTER_INVALID));</b>
&nbsp;                            break;
&nbsp;                    }
&nbsp;                }
&nbsp;            } catch (Exception e) {
<b class="nc">&nbsp;                log.warn(&quot;[{}][{}] Failed to subscribe to [{}][{}]&quot;, deviceSessionCtx.getTenantId(), sessionId, topic, reqQoS, e);</b>
<b class="nc">&nbsp;                grantedQoSList.add(ReturnCodeResolver.getSubscriptionReturnCode(deviceSessionCtx.getMqttVersion(), MqttReasonCodes.SubAck.IMPLEMENTATION_SPECIFIC_ERROR));</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (!activityReported) {</b>
<b class="nc">&nbsp;            transportService.recordActivity(deviceSessionCtx.getSessionInfo());</b>
&nbsp;        }
<b class="nc">&nbsp;        ctx.writeAndFlush(createSubAckMessage(mqttMsg.variableHeader().messageId(), grantedQoSList));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void processRpcSubscribe(List&lt;Integer&gt; grantedQoSList, String topic, MqttQoS reqQoS, TopicType topicType) {
<b class="nc">&nbsp;        transportService.process(deviceSessionCtx.getSessionInfo(), TransportProtos.SubscribeToRPCMsg.newBuilder().build(), null);</b>
<b class="nc">&nbsp;        rpcSubTopicType = topicType;</b>
<b class="nc">&nbsp;        registerSubQoS(topic, grantedQoSList, reqQoS);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void processAttributesSubscribe(List&lt;Integer&gt; grantedQoSList, String topic, MqttQoS reqQoS, TopicType topicType) {
<b class="nc">&nbsp;        transportService.process(deviceSessionCtx.getSessionInfo(), TransportProtos.SubscribeToAttributeUpdatesMsg.newBuilder().build(), null);</b>
<b class="nc">&nbsp;        attrSubTopicType = topicType;</b>
<b class="nc">&nbsp;        registerSubQoS(topic, grantedQoSList, reqQoS);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * 3.0.0 Edge Node Session Establishment:
&nbsp;     * ncmd-subscribe
&nbsp;     * [tck-id-message-flow-edge-node-ncmd-subscribe] The MQTT client associated with the Edge
&nbsp;     * Node MUST subscribe to a topic of the form spBv1.0/group_id/NCMD/edge_node_id where
&nbsp;     * group_id is the Sparkplug Group ID and the edge_node_id is the Sparkplug Edge Node ID for
&nbsp;     * this Edge Node. It MUST subscribe on this topic with a QoS of 1.
&nbsp;     */
&nbsp;    public void processAttributesRpcSubscribeSparkplugNode() {
<b class="nc">&nbsp;        List&lt;Integer&gt; grantedQoSList = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        transportService.process(TransportProtos.TransportToDeviceActorMsg.newBuilder()</b>
<b class="nc">&nbsp;                .setSessionInfo(deviceSessionCtx.getSessionInfo())</b>
<b class="nc">&nbsp;                .setSubscribeToAttributes(SUBSCRIBE_TO_ATTRIBUTE_UPDATES_ASYNC_MSG)</b>
<b class="nc">&nbsp;                .setSubscribeToRPC(SUBSCRIBE_TO_RPC_ASYNC_MSG)</b>
<b class="nc">&nbsp;                .build(), null);</b>
<b class="nc">&nbsp;        registerSubQoS(MqttTopics.DEVICE_ATTRIBUTES_TOPIC, grantedQoSList, AT_LEAST_ONCE);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void registerSubQoS(String topic, List&lt;Integer&gt; grantedQoSList, MqttQoS reqQoS) {
<b class="nc">&nbsp;        grantedQoSList.add(getMinSupportedQos(reqQoS));</b>
<b class="nc">&nbsp;        mqttQoSMap.put(new MqttTopicMatcher(topic), getMinSupportedQos(reqQoS));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void processUnsubscribe(ChannelHandlerContext ctx, MqttUnsubscribeMessage mqttMsg) {
<b class="nc">&nbsp;        if (!checkConnected(ctx, mqttMsg) &amp;&amp; !deviceSessionCtx.isProvisionOnly()) {</b>
<b class="nc">&nbsp;            ctx.writeAndFlush(createUnSubAckMessage(mqttMsg.variableHeader().messageId(),</b>
<b class="nc">&nbsp;                    Collections.singletonList((short) MqttReasonCodes.UnsubAck.NOT_AUTHORIZED.byteValue())));</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        boolean activityReported = false;</b>
<b class="nc">&nbsp;        List&lt;Short&gt; unSubResults = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        log.trace(&quot;[{}] Processing subscription [{}]!&quot;, sessionId, mqttMsg.variableHeader().messageId());</b>
<b class="nc">&nbsp;        for (String topicName : mqttMsg.payload().topics()) {</b>
<b class="nc">&nbsp;            MqttTopicMatcher matcher = new MqttTopicMatcher(topicName);</b>
<b class="nc">&nbsp;            if (mqttQoSMap.containsKey(matcher)) {</b>
<b class="nc">&nbsp;                mqttQoSMap.remove(matcher);</b>
&nbsp;                try {
<b class="nc">&nbsp;                    short resultValue = MqttReasonCodes.UnsubAck.SUCCESS.byteValue();</b>
<b class="nc">&nbsp;                    if (deviceSessionCtx.isProvisionOnly()) {</b>
<b class="nc">&nbsp;                        if (!matcher.matches(MqttTopics.DEVICE_PROVISION_RESPONSE_TOPIC)) {</b>
<b class="nc">&nbsp;                            resultValue = MqttReasonCodes.UnsubAck.TOPIC_FILTER_INVALID.byteValue();</b>
&nbsp;                        }
<b class="nc">&nbsp;                        unSubResults.add(resultValue);</b>
<b class="nc">&nbsp;                        activityReported = true;</b>
&nbsp;                        continue;
&nbsp;                    }
<b class="nc">&nbsp;                    switch (topicName) {</b>
&nbsp;                        case MqttTopics.DEVICE_ATTRIBUTES_TOPIC:
&nbsp;                        case MqttTopics.DEVICE_ATTRIBUTES_SHORT_TOPIC:
&nbsp;                        case MqttTopics.DEVICE_ATTRIBUTES_SHORT_PROTO_TOPIC:
&nbsp;                        case MqttTopics.DEVICE_ATTRIBUTES_SHORT_JSON_TOPIC: {
<b class="nc">&nbsp;                            transportService.process(deviceSessionCtx.getSessionInfo(),</b>
<b class="nc">&nbsp;                                    TransportProtos.SubscribeToAttributeUpdatesMsg.newBuilder().setUnsubscribe(true).build(), null);</b>
<b class="nc">&nbsp;                            activityReported = true;</b>
&nbsp;                            break;
&nbsp;                        }
&nbsp;                        case MqttTopics.DEVICE_RPC_REQUESTS_SUB_TOPIC:
&nbsp;                        case MqttTopics.DEVICE_RPC_REQUESTS_SUB_SHORT_TOPIC:
&nbsp;                        case MqttTopics.DEVICE_RPC_REQUESTS_SUB_SHORT_JSON_TOPIC:
&nbsp;                        case MqttTopics.DEVICE_RPC_REQUESTS_SUB_SHORT_PROTO_TOPIC: {
<b class="nc">&nbsp;                            transportService.process(deviceSessionCtx.getSessionInfo(),</b>
<b class="nc">&nbsp;                                    TransportProtos.SubscribeToRPCMsg.newBuilder().setUnsubscribe(true).build(), null);</b>
<b class="nc">&nbsp;                            activityReported = true;</b>
&nbsp;                            break;
&nbsp;                        }
&nbsp;                        case MqttTopics.DEVICE_RPC_RESPONSE_SUB_TOPIC:
&nbsp;                        case MqttTopics.DEVICE_RPC_RESPONSE_SUB_SHORT_TOPIC:
&nbsp;                        case MqttTopics.DEVICE_RPC_RESPONSE_SUB_SHORT_JSON_TOPIC:
&nbsp;                        case MqttTopics.DEVICE_RPC_RESPONSE_SUB_SHORT_PROTO_TOPIC:
&nbsp;                        case MqttTopics.DEVICE_ATTRIBUTES_RESPONSES_TOPIC:
&nbsp;                        case MqttTopics.DEVICE_ATTRIBUTES_RESPONSES_SHORT_TOPIC:
&nbsp;                        case MqttTopics.DEVICE_ATTRIBUTES_RESPONSES_SHORT_JSON_TOPIC:
&nbsp;                        case MqttTopics.DEVICE_ATTRIBUTES_RESPONSES_SHORT_PROTO_TOPIC:
&nbsp;                        case MqttTopics.GATEWAY_ATTRIBUTES_TOPIC:
&nbsp;                        case MqttTopics.GATEWAY_RPC_TOPIC:
&nbsp;                        case MqttTopics.GATEWAY_ATTRIBUTES_RESPONSE_TOPIC:
&nbsp;                        case MqttTopics.DEVICE_FIRMWARE_RESPONSES_TOPIC:
&nbsp;                        case MqttTopics.DEVICE_FIRMWARE_ERROR_TOPIC:
&nbsp;                        case MqttTopics.DEVICE_SOFTWARE_RESPONSES_TOPIC:
&nbsp;                        case MqttTopics.DEVICE_SOFTWARE_ERROR_TOPIC: {
<b class="nc">&nbsp;                            activityReported = true;</b>
&nbsp;                            break;
&nbsp;                        }
&nbsp;                        default:
<b class="nc">&nbsp;                            log.trace(&quot;[{}] Failed to process unsubscription [{}] to [{}]&quot;, sessionId, mqttMsg.variableHeader().messageId(), topicName);</b>
<b class="nc">&nbsp;                            resultValue = MqttReasonCodes.UnsubAck.TOPIC_FILTER_INVALID.byteValue();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    unSubResults.add(resultValue);</b>
&nbsp;                } catch (Exception e) {
<b class="nc">&nbsp;                    log.debug(&quot;[{}] Failed to process unsubscription [{}] to [{}]&quot;, sessionId, mqttMsg.variableHeader().messageId(), topicName);</b>
<b class="nc">&nbsp;                    unSubResults.add((short) MqttReasonCodes.UnsubAck.IMPLEMENTATION_SPECIFIC_ERROR.byteValue());</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                log.debug(&quot;[{}] Failed to process unsubscription [{}] to [{}] - Subscription not found&quot;, sessionId, mqttMsg.variableHeader().messageId(), topicName);</b>
<b class="nc">&nbsp;                unSubResults.add((short) MqttReasonCodes.UnsubAck.NO_SUBSCRIPTION_EXISTED.byteValue());</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (!activityReported &amp;&amp; !deviceSessionCtx.isProvisionOnly()) {</b>
<b class="nc">&nbsp;            transportService.recordActivity(deviceSessionCtx.getSessionInfo());</b>
&nbsp;        }
<b class="nc">&nbsp;        ctx.writeAndFlush(createUnSubAckMessage(mqttMsg.variableHeader().messageId(), unSubResults));</b>
&nbsp;    }
&nbsp;
&nbsp;    private MqttMessage createUnSubAckMessage(int msgId, List&lt;Short&gt; resultCodes) {
<b class="nc">&nbsp;        MqttMessageBuilders.UnsubAckBuilder unsubAckBuilder = MqttMessageBuilders.unsubAck();</b>
<b class="nc">&nbsp;        unsubAckBuilder.packetId(msgId);</b>
<b class="nc">&nbsp;        if (MqttVersion.MQTT_5.equals(deviceSessionCtx.getMqttVersion())) {</b>
<b class="nc">&nbsp;            unsubAckBuilder.addReasonCodes(resultCodes.toArray(Short[]::new));</b>
&nbsp;        }
<b class="nc">&nbsp;        return unsubAckBuilder.build();</b>
&nbsp;    }
&nbsp;
&nbsp;    void processConnect(ChannelHandlerContext ctx, MqttConnectMessage msg) {
<b class="nc">&nbsp;        log.debug(&quot;[{}][{}] Processing connect msg for client: {}!&quot;, address, sessionId, msg.payload().clientIdentifier());</b>
<b class="nc">&nbsp;        String userName = msg.payload().userName();</b>
<b class="nc">&nbsp;        String clientId = msg.payload().clientIdentifier();</b>
<b class="nc">&nbsp;        deviceSessionCtx.setMqttVersion(getMqttVersion(msg.variableHeader().version()));</b>
<b class="nc">&nbsp;        if (DataConstants.PROVISION.equals(userName) || DataConstants.PROVISION.equals(clientId)) {</b>
<b class="nc">&nbsp;            deviceSessionCtx.setProvisionOnly(true);</b>
<b class="nc">&nbsp;            ctx.writeAndFlush(createMqttConnAckMsg(MqttConnectReturnCode.CONNECTION_ACCEPTED, msg));</b>
&nbsp;        } else {
&nbsp;            X509Certificate cert;
<b class="nc">&nbsp;            if (sslHandler != null &amp;&amp; (cert = getX509Certificate()) != null) {</b>
<b class="nc">&nbsp;                processX509CertConnect(ctx, cert, msg);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                processAuthTokenConnect(ctx, msg);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void processAuthTokenConnect(ChannelHandlerContext ctx, MqttConnectMessage connectMessage) {
<b class="nc">&nbsp;        String userName = connectMessage.payload().userName();</b>
<b class="nc">&nbsp;        log.debug(&quot;[{}][{}] Processing connect msg for client with user name: {}!&quot;, address, sessionId, userName);</b>
<b class="nc">&nbsp;        TransportProtos.ValidateBasicMqttCredRequestMsg.Builder request = TransportProtos.ValidateBasicMqttCredRequestMsg.newBuilder()</b>
<b class="nc">&nbsp;                .setClientId(connectMessage.payload().clientIdentifier());</b>
<b class="nc">&nbsp;        if (userName != null) {</b>
<b class="nc">&nbsp;            request.setUserName(userName);</b>
&nbsp;        }
<b class="nc">&nbsp;        byte[] passwordBytes = connectMessage.payload().passwordInBytes();</b>
<b class="nc">&nbsp;        if (passwordBytes != null) {</b>
<b class="nc">&nbsp;            String password = new String(passwordBytes, CharsetUtil.UTF_8);</b>
<b class="nc">&nbsp;            request.setPassword(password);</b>
&nbsp;        }
<b class="nc">&nbsp;        transportService.process(DeviceTransportType.MQTT, request.build(),</b>
<b class="nc">&nbsp;                new TransportServiceCallback&lt;&gt;() {</b>
&nbsp;                    @Override
&nbsp;                    public void onSuccess(ValidateDeviceCredentialsResponse msg) {
<b class="nc">&nbsp;                        onValidateDeviceResponse(msg, ctx, connectMessage);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void onError(Throwable e) {
<b class="nc">&nbsp;                        log.trace(&quot;[{}] Failed to process credentials: {}&quot;, address, userName, e);</b>
<b class="nc">&nbsp;                        ctx.writeAndFlush(createMqttConnAckMsg(MqttConnectReturnCode.CONNECTION_REFUSED_SERVER_UNAVAILABLE_5, connectMessage));</b>
<b class="nc">&nbsp;                        closeCtx(ctx, MqttReasonCodes.Disconnect.SERVER_BUSY);</b>
&nbsp;                    }
&nbsp;                });
&nbsp;    }
&nbsp;
&nbsp;    private void processX509CertConnect(ChannelHandlerContext ctx, X509Certificate cert, MqttConnectMessage connectMessage) {
&nbsp;        try {
<b class="nc">&nbsp;            if (!context.isSkipValidityCheckForClientCert()) {</b>
<b class="nc">&nbsp;                cert.checkValidity();</b>
&nbsp;            }
<b class="nc">&nbsp;            String strCert = SslUtil.getCertificateString(cert);</b>
<b class="nc">&nbsp;            String sha3Hash = EncryptionUtil.getSha3Hash(strCert);</b>
<b class="nc">&nbsp;            transportService.process(DeviceTransportType.MQTT, ValidateDeviceX509CertRequestMsg.newBuilder().setHash(sha3Hash).build(),</b>
<b class="nc">&nbsp;                    new TransportServiceCallback&lt;&gt;() {</b>
&nbsp;                        @Override
&nbsp;                        public void onSuccess(ValidateDeviceCredentialsResponse msg) {
<b class="nc">&nbsp;                            onValidateDeviceResponse(msg, ctx, connectMessage);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public void onError(Throwable e) {
<b class="nc">&nbsp;                            log.trace(&quot;[{}] Failed to process credentials: {}&quot;, address, sha3Hash, e);</b>
<b class="nc">&nbsp;                            ctx.writeAndFlush(createMqttConnAckMsg(MqttConnectReturnCode.CONNECTION_REFUSED_SERVER_UNAVAILABLE_5, connectMessage));</b>
<b class="nc">&nbsp;                            closeCtx(ctx, MqttReasonCodes.Disconnect.IMPLEMENTATION_SPECIFIC_ERROR);</b>
&nbsp;                        }
&nbsp;                    });
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            context.onAuthFailure(address);</b>
<b class="nc">&nbsp;            ctx.writeAndFlush(createMqttConnAckMsg(MqttConnectReturnCode.CONNECTION_REFUSED_NOT_AUTHORIZED_5, connectMessage));</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}] X509 auth failure: {}&quot;, sessionId, address, e);</b>
<b class="nc">&nbsp;            closeCtx(ctx, MqttReasonCodes.Disconnect.NOT_AUTHORIZED);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private X509Certificate getX509Certificate() {
&nbsp;        try {
<b class="nc">&nbsp;            Certificate[] certChain = sslHandler.engine().getSession().getPeerCertificates();</b>
<b class="nc">&nbsp;            if (certChain.length &gt; 0) {</b>
<b class="nc">&nbsp;                return (X509Certificate) certChain[0];</b>
&nbsp;            }
&nbsp;        } catch (SSLPeerUnverifiedException e) {
<b class="nc">&nbsp;            log.warn(e.getMessage());</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    private MqttConnAckMessage createMqttConnAckMsg(MqttConnectReturnCode returnCode, MqttConnectMessage msg) {
<b class="nc">&nbsp;        MqttMessageBuilders.ConnAckBuilder connAckBuilder = MqttMessageBuilders.connAck();</b>
<b class="nc">&nbsp;        connAckBuilder.sessionPresent(!msg.variableHeader().isCleanSession());</b>
<b class="nc">&nbsp;        MqttConnectReturnCode finalReturnCode = ReturnCodeResolver.getConnectionReturnCode(deviceSessionCtx.getMqttVersion(), returnCode);</b>
<b class="nc">&nbsp;        connAckBuilder.returnCode(finalReturnCode);</b>
<b class="nc">&nbsp;        return connAckBuilder.build();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void channelReadComplete(ChannelHandlerContext ctx) {
<b class="nc">&nbsp;        ctx.flush();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
<b class="nc">&nbsp;        if (cause instanceof IOException) {</b>
<b class="nc">&nbsp;            if (log.isDebugEnabled()) {</b>
<b class="nc">&nbsp;                log.debug(&quot;[{}][{}][{}] IOException: {}&quot;, sessionId,</b>
<b class="nc">&nbsp;                        Optional.ofNullable(this.deviceSessionCtx.getDeviceInfo()).map(TransportDeviceInfo::getDeviceId).orElse(null),</b>
<b class="nc">&nbsp;                        Optional.ofNullable(this.deviceSessionCtx.getDeviceInfo()).map(TransportDeviceInfo::getDeviceName).orElse(&quot;&quot;),</b>
<b class="nc">&nbsp;                        cause.getMessage(),</b>
&nbsp;                        cause);
<b class="nc">&nbsp;            } else if (log.isInfoEnabled()) {</b>
<b class="nc">&nbsp;                log.info(&quot;[{}][{}][{}] IOException: {}&quot;, sessionId,</b>
<b class="nc">&nbsp;                        Optional.ofNullable(this.deviceSessionCtx.getDeviceInfo()).map(TransportDeviceInfo::getDeviceId).orElse(null),</b>
<b class="nc">&nbsp;                        Optional.ofNullable(this.deviceSessionCtx.getDeviceInfo()).map(TransportDeviceInfo::getDeviceName).orElse(&quot;&quot;),</b>
<b class="nc">&nbsp;                        cause.getMessage());</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            log.error(&quot;[{}] Unexpected Exception&quot;, sessionId, cause);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        closeCtx(ctx, MqttReasonCodes.Disconnect.SERVER_SHUTTING_DOWN);</b>
<b class="nc">&nbsp;        if (cause instanceof OutOfMemoryError) {</b>
<b class="nc">&nbsp;            log.error(&quot;Received critical error. Going to shutdown the service.&quot;);</b>
<b class="nc">&nbsp;            System.exit(1);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static MqttSubAckMessage createSubAckMessage(Integer msgId, List&lt;Integer&gt; reasonCodes) {
<b class="nc">&nbsp;        MqttFixedHeader mqttFixedHeader =</b>
&nbsp;                new MqttFixedHeader(SUBACK, false, AT_MOST_ONCE, false, 0);
<b class="nc">&nbsp;        MqttMessageIdVariableHeader mqttMessageIdVariableHeader = MqttMessageIdVariableHeader.from(msgId);</b>
<b class="nc">&nbsp;        MqttSubAckPayload mqttSubAckPayload = new MqttSubAckPayload(reasonCodes);</b>
<b class="nc">&nbsp;        return new MqttSubAckMessage(mqttFixedHeader, mqttMessageIdVariableHeader, mqttSubAckPayload);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static int getMinSupportedQos(MqttQoS reqQoS) {
<b class="nc">&nbsp;        return Math.min(reqQoS.value(), MAX_SUPPORTED_QOS_LVL.value());</b>
&nbsp;    }
&nbsp;
&nbsp;    private static MqttVersion getMqttVersion(int versionCode) {
<b class="nc">&nbsp;        switch (versionCode) {</b>
&nbsp;            case 3:
<b class="nc">&nbsp;                return MqttVersion.MQTT_3_1;</b>
&nbsp;            case 5:
<b class="nc">&nbsp;                return MqttVersion.MQTT_5;</b>
&nbsp;            default:
<b class="nc">&nbsp;                return MqttVersion.MQTT_3_1_1;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static MqttMessage createMqttPubAckMsg(DeviceSessionCtx deviceSessionCtx, int requestId, byte returnCode) {
<b class="nc">&nbsp;        MqttMessageBuilders.PubAckBuilder pubAckMsgBuilder = MqttMessageBuilders.pubAck().packetId(requestId);</b>
<b class="nc">&nbsp;        if (MqttVersion.MQTT_5.equals(deviceSessionCtx.getMqttVersion())) {</b>
<b class="nc">&nbsp;            pubAckMsgBuilder.reasonCode(returnCode);</b>
&nbsp;        }
<b class="nc">&nbsp;        return pubAckMsgBuilder.build();</b>
&nbsp;    }
&nbsp;
&nbsp;    public static MqttMessage createMqttDisconnectMsg(DeviceSessionCtx deviceSessionCtx, byte returnCode) {
<b class="nc">&nbsp;        MqttMessageBuilders.DisconnectBuilder disconnectBuilder = MqttMessageBuilders.disconnect();</b>
<b class="nc">&nbsp;        if (MqttVersion.MQTT_5.equals(deviceSessionCtx.getMqttVersion())) {</b>
<b class="nc">&nbsp;            disconnectBuilder.reasonCode(returnCode);</b>
&nbsp;        }
<b class="nc">&nbsp;        return disconnectBuilder.build();</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean checkConnected(ChannelHandlerContext ctx, MqttMessage msg) {
<b class="nc">&nbsp;        if (deviceSessionCtx.isConnected()) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            log.info(&quot;[{}] Closing current session due to invalid msg order: {}&quot;, sessionId, msg);</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void checkGatewaySession(SessionMetaData sessionMetaData) {
<b class="nc">&nbsp;        TransportDeviceInfo device = deviceSessionCtx.getDeviceInfo();</b>
&nbsp;        try {
<b class="nc">&nbsp;            JsonNode infoNode = context.getMapper().readTree(device.getAdditionalInfo());</b>
<b class="nc">&nbsp;            if (infoNode != null) {</b>
<b class="nc">&nbsp;                JsonNode gatewayNode = infoNode.get(DataConstants.GATEWAY_PARAMETER);</b>
<b class="nc">&nbsp;                if (gatewayNode != null &amp;&amp; gatewayNode.asBoolean()) {</b>
<b class="nc">&nbsp;                    boolean overwriteDevicesActivity = false;</b>
<b class="nc">&nbsp;                    if (infoNode.has(DataConstants.OVERWRITE_ACTIVITY_TIME_PARAMETER)</b>
<b class="nc">&nbsp;                            &amp;&amp; infoNode.get(DataConstants.OVERWRITE_ACTIVITY_TIME_PARAMETER).isBoolean()) {</b>
<b class="nc">&nbsp;                        overwriteDevicesActivity = infoNode.get(DataConstants.OVERWRITE_ACTIVITY_TIME_PARAMETER).asBoolean();</b>
<b class="nc">&nbsp;                        sessionMetaData.setOverwriteActivityTime(overwriteDevicesActivity);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    gatewaySessionHandler = new GatewaySessionHandler(deviceSessionCtx, sessionId, overwriteDevicesActivity);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        } catch (IOException e) {
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}] Failed to fetch device additional info&quot;, sessionId, device.getDeviceName(), e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void checkSparkplugNodeSession(MqttConnectMessage connectMessage, ChannelHandlerContext ctx, SessionMetaData sessionMetaData) {
&nbsp;        try {
<b class="nc">&nbsp;            if (sparkplugSessionHandler == null) {</b>
<b class="nc">&nbsp;                SparkplugTopic sparkplugTopic = validatedSparkplugConnectedWillTopic(connectMessage);</b>
<b class="nc">&nbsp;                if (sparkplugTopic != null) {</b>
<b class="nc">&nbsp;                    SparkplugBProto.Payload sparkplugBProtoNode = SparkplugBProto.Payload.parseFrom(connectMessage.payload().willMessageInBytes());</b>
<b class="nc">&nbsp;                    sparkplugSessionHandler = new SparkplugNodeSessionHandler(this, deviceSessionCtx, sessionId, true, sparkplugTopic);</b>
<b class="nc">&nbsp;                    sparkplugSessionHandler.onAttributesTelemetryProto(0, sparkplugBProtoNode, sparkplugTopic);</b>
<b class="nc">&nbsp;                    sessionMetaData.setOverwriteActivityTime(true);</b>
&nbsp;                    // ncmd-subscribe
<b class="nc">&nbsp;                    processAttributesRpcSubscribeSparkplugNode();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    log.trace(&quot;[{}][{}] Failed to fetch sparkplugDevice connect:  sparkplugTopicName without SparkplugMessageType.NDEATH.&quot;, sessionId, deviceSessionCtx.getDeviceInfo().getDeviceName());</b>
<b class="nc">&nbsp;                    throw new ThingsboardException(&quot;Invalid request body&quot;, ThingsboardErrorCode.BAD_REQUEST_PARAMS);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}] Failed to fetch sparkplugDevice connect, sparkplugTopicName&quot;, sessionId, deviceSessionCtx.getDeviceInfo().getDeviceName(), e);</b>
<b class="nc">&nbsp;            ctx.writeAndFlush(createMqttConnAckMsg(MqttConnectReturnCode.CONNECTION_REFUSED_SERVER_UNAVAILABLE_5, connectMessage));</b>
<b class="nc">&nbsp;            closeCtx(ctx, MqttReasonCodes.Disconnect.IMPLEMENTATION_SPECIFIC_ERROR);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *  The Death Certificate topic and payload described here are not “published” as an MQTT message by a client,
&nbsp;     *  but provided as parameters within the MQTT CONNECT control packet when this Sparkplug Edge Node first establishes the MQTT Client session.
&nbsp;     * - NDEATH message MUST be registered as a Will Message in the MQTT CONNECT packet.
&nbsp;     * -- in the MQTT CONNECT packet The NDEATH message MUST set the MQTT Will QoS to 1.
&nbsp;     * -- in the MQTT CONNECT packet The NDEATH message MUST set the MQTT Will Retained flag to false.
&nbsp;     * -- If the MQTT client is using MQTT v3.1.1, the Edge Node’s MQTT CONNECT packet MUST set the Clean Session flag to true.
&nbsp;     * -- If the MQTT client is using MQTT v5.0, the Edge Node’s MQTT CONNECT packet MUST set the Clean Start flag to true and the Session Expiry Interval to 0
&nbsp;     * @param connectMessage
&nbsp;     * @return
&nbsp;     * @throws ThingsboardException
&nbsp;     */
&nbsp;    private SparkplugTopic validatedSparkplugConnectedWillTopic(MqttConnectMessage connectMessage) throws ThingsboardException {
<b class="nc">&nbsp;        if (StringUtils.isNotBlank(connectMessage.payload().willTopic())</b>
<b class="nc">&nbsp;                &amp;&amp; connectMessage.payload().willMessageInBytes() != null</b>
<b class="nc">&nbsp;                &amp;&amp; connectMessage.payload().willMessageInBytes().length &gt; 0) {</b>
<b class="nc">&nbsp;            SparkplugTopic sparkplugTopicNode = parseTopic(connectMessage.payload().willTopic());</b>
<b class="nc">&nbsp;            if (NDEATH.equals(sparkplugTopicNode.getType())) {</b>
<b class="nc">&nbsp;                if (connectMessage.variableHeader().willQos() != 1 || connectMessage.variableHeader().isWillRetain())</b>
<b class="nc">&nbsp;                    return null;</b>
<b class="nc">&nbsp;                if (!connectMessage.variableHeader().isCleanSession()) return null;</b>
<b class="nc">&nbsp;                int mqttVer = connectMessage.variableHeader().version();</b>
<b class="nc">&nbsp;                if (mqttVer == 5) {</b>
<b class="nc">&nbsp;                    Object sessionExpiryIntervalObj = connectMessage.variableHeader().properties().isEmpty() ? null : connectMessage.variableHeader().properties().getProperty(MqttPropertyType.SESSION_EXPIRY_INTERVAL.value());</b>
<b class="nc">&nbsp;                    Integer sessionExpiryInterval = sessionExpiryIntervalObj == null ? null : ((IntegerProperty) sessionExpiryIntervalObj).value();</b>
<b class="nc">&nbsp;                    if (sessionExpiryInterval == null || sessionExpiryInterval != 0) return null;</b>
&nbsp;                }
<b class="nc">&nbsp;                return sparkplugTopicNode;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void operationComplete(Future&lt;? super Void&gt; future) throws Exception {
<b class="nc">&nbsp;        log.trace(&quot;[{}] Channel closed!&quot;, sessionId);</b>
<b class="nc">&nbsp;        doDisconnect();</b>
&nbsp;    }
&nbsp;
&nbsp;    public void doDisconnect() {
<b class="nc">&nbsp;        if (deviceSessionCtx.isConnected()) {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}] Client disconnected!&quot;, sessionId);</b>
<b class="nc">&nbsp;            transportService.process(deviceSessionCtx.getSessionInfo(), SESSION_EVENT_MSG_CLOSED, null);</b>
<b class="nc">&nbsp;            transportService.deregisterSession(deviceSessionCtx.getSessionInfo());</b>
<b class="nc">&nbsp;            if (gatewaySessionHandler != null) {</b>
<b class="nc">&nbsp;                gatewaySessionHandler.onDevicesDisconnect();</b>
&nbsp;            }
<b class="nc">&nbsp;            if (sparkplugSessionHandler != null) {</b>
&nbsp;                // add Msg Telemetry node: key STATE type: String value: OFFLINE ts: sparkplugBProto.getTimestamp()
<b class="nc">&nbsp;                sparkplugSessionHandler.sendSparkplugStateOnTelemetry(deviceSessionCtx.getSessionInfo(),</b>
<b class="nc">&nbsp;                        deviceSessionCtx.getDeviceInfo().getDeviceName(), OFFLINE, new Date().getTime());</b>
<b class="nc">&nbsp;                sparkplugSessionHandler.onDevicesDisconnect();</b>
&nbsp;            }
<b class="nc">&nbsp;            deviceSessionCtx.setDisconnected();</b>
&nbsp;        }
<b class="nc">&nbsp;        deviceSessionCtx.release();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void onValidateDeviceResponse(ValidateDeviceCredentialsResponse msg, ChannelHandlerContext ctx, MqttConnectMessage connectMessage) {
<b class="nc">&nbsp;        if (!msg.hasDeviceInfo()) {</b>
<b class="nc">&nbsp;            context.onAuthFailure(address);</b>
<b class="nc">&nbsp;            MqttConnectReturnCode returnCode = MqttConnectReturnCode.CONNECTION_REFUSED_NOT_AUTHORIZED_5;</b>
<b class="nc">&nbsp;            if (sslHandler == null || getX509Certificate() == null) {</b>
<b class="nc">&nbsp;                String username = connectMessage.payload().userName();</b>
<b class="nc">&nbsp;                byte[] passwordBytes = connectMessage.payload().passwordInBytes();</b>
<b class="nc">&nbsp;                String clientId = connectMessage.payload().clientIdentifier();</b>
<b class="nc">&nbsp;                if ((username != null &amp;&amp; passwordBytes != null &amp;&amp; clientId != null)</b>
&nbsp;                        || (username == null ^ passwordBytes == null)) {
<b class="nc">&nbsp;                    returnCode = MqttConnectReturnCode.CONNECTION_REFUSED_BAD_USERNAME_OR_PASSWORD;</b>
<b class="nc">&nbsp;                } else if (!StringUtils.isBlank(clientId)) {</b>
<b class="nc">&nbsp;                    returnCode = MqttConnectReturnCode.CONNECTION_REFUSED_CLIENT_IDENTIFIER_NOT_VALID;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            ctx.writeAndFlush(createMqttConnAckMsg(returnCode, connectMessage));</b>
<b class="nc">&nbsp;            closeCtx(ctx, returnCode);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            context.onAuthSuccess(address);</b>
<b class="nc">&nbsp;            deviceSessionCtx.setDeviceInfo(msg.getDeviceInfo());</b>
<b class="nc">&nbsp;            deviceSessionCtx.setDeviceProfile(msg.getDeviceProfile());</b>
<b class="nc">&nbsp;            deviceSessionCtx.setSessionInfo(SessionInfoCreator.create(msg, context, sessionId));</b>
<b class="nc">&nbsp;            transportService.process(deviceSessionCtx.getSessionInfo(), SESSION_EVENT_MSG_OPEN, new TransportServiceCallback&lt;Void&gt;() {</b>
&nbsp;                @Override
&nbsp;                public void onSuccess(Void msg) {
<b class="nc">&nbsp;                    SessionMetaData sessionMetaData = transportService.registerAsyncSession(deviceSessionCtx.getSessionInfo(), MqttTransportHandler.this);</b>
<b class="nc">&nbsp;                    if (deviceSessionCtx.isSparkplug()) {</b>
<b class="nc">&nbsp;                        checkSparkplugNodeSession(connectMessage, ctx, sessionMetaData);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        checkGatewaySession(sessionMetaData);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    ctx.writeAndFlush(createMqttConnAckMsg(MqttConnectReturnCode.CONNECTION_ACCEPTED, connectMessage));</b>
<b class="nc">&nbsp;                    deviceSessionCtx.setConnected(true);</b>
<b class="nc">&nbsp;                    log.debug(&quot;[{}] Client connected!&quot;, sessionId);</b>
<b class="nc">&nbsp;                    transportService.getCallbackExecutor().execute(() -&gt; processMsgQueue(ctx)); //this callback will execute in Producer worker thread and hard or blocking work have to be submitted to the separate thread.</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onError(Throwable e) {
<b class="nc">&nbsp;                    if (e instanceof TbRateLimitsException) {</b>
<b class="nc">&nbsp;                        log.trace(&quot;[{}] Failed to submit session event: {}&quot;, sessionId, e.getMessage());</b>
<b class="nc">&nbsp;                        ctx.writeAndFlush(createMqttConnAckMsg(MqttConnectReturnCode.CONNECTION_REFUSED_CONNECTION_RATE_EXCEEDED, connectMessage));</b>
<b class="nc">&nbsp;                        closeCtx(ctx, MqttReasonCodes.Disconnect.MESSAGE_RATE_TOO_HIGH);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        log.warn(&quot;[{}] Failed to submit session event&quot;, sessionId, e);</b>
<b class="nc">&nbsp;                        ctx.writeAndFlush(createMqttConnAckMsg(MqttConnectReturnCode.CONNECTION_REFUSED_SERVER_UNAVAILABLE_5, connectMessage));</b>
<b class="nc">&nbsp;                        closeCtx(ctx, MqttReasonCodes.Disconnect.IMPLEMENTATION_SPECIFIC_ERROR);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            });
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void onGetAttributesResponse(TransportProtos.GetAttributeResponseMsg response) {
<b class="nc">&nbsp;        log.trace(&quot;[{}] Received get attributes response&quot;, sessionId);</b>
<b class="nc">&nbsp;        String topicBase = attrReqTopicType.getAttributesResponseTopicBase();</b>
<b class="nc">&nbsp;        MqttTransportAdaptor adaptor = deviceSessionCtx.getAdaptor(attrReqTopicType);</b>
&nbsp;        try {
<b class="nc">&nbsp;            adaptor.convertToPublish(deviceSessionCtx, response, topicBase).ifPresent(deviceSessionCtx.getChannel()::writeAndFlush);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.trace(&quot;[{}] Failed to convert device attributes response to MQTT msg&quot;, sessionId, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void onAttributeUpdate(UUID sessionId, TransportProtos.AttributeUpdateNotificationMsg notification) {
&nbsp;        try {
<b class="nc">&nbsp;            if (sparkplugSessionHandler != null) {</b>
<b class="nc">&nbsp;                log.trace(&quot;[{}] Received attributes update notification to sparkplug Edge Node&quot;, sessionId);</b>
<b class="nc">&nbsp;                notification.getSharedUpdatedList().forEach(tsKvProtoShared -&gt; {</b>
<b class="nc">&nbsp;                    SparkplugMessageType messageType = NCMD;</b>
<b class="nc">&nbsp;                    TransportProtos.TsKvProto tsKvProto = tsKvProtoShared;</b>
<b class="nc">&nbsp;                    if (&quot;JSON_V&quot;.equals(tsKvProtoShared.getKv().getType().name())) {</b>
&nbsp;                        try {
<b class="nc">&nbsp;                            messageType = SparkplugMessageType.parseMessageType(tsKvProtoShared.getKv().getKey());</b>
<b class="nc">&nbsp;                            tsKvProto = getTsKvProtoFromJsonNode(JacksonUtil.toJsonNode(tsKvProtoShared.getKv().getJsonV()), tsKvProtoShared.getTs());</b>
&nbsp;                        } catch (ThingsboardException e) {
<b class="nc">&nbsp;                            messageType = null;</b>
<b class="nc">&nbsp;                            log.error(&quot;Failed attributes update notification to sparkplug Edge Node [{}]. &quot;, sparkplugSessionHandler.getSparkplugTopicNode().getEdgeNodeId(), e);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    if (messageType != null &amp;&amp; messageType.isSubscribe() &amp;&amp; messageType.isNode()</b>
<b class="nc">&nbsp;                            &amp;&amp; sparkplugSessionHandler.getNodeBirthMetrics().containsKey(tsKvProto.getKv().getKey())) {</b>
<b class="nc">&nbsp;                        SparkplugTopic sparkplugTopic = new SparkplugTopic(sparkplugSessionHandler.getSparkplugTopicNode(), messageType);</b>
<b class="nc">&nbsp;                        sparkplugSessionHandler.createSparkplugMqttPublishMsg(tsKvProto,</b>
<b class="nc">&nbsp;                                        sparkplugTopic.toString(),</b>
<b class="nc">&nbsp;                                        sparkplugSessionHandler.getNodeBirthMetrics().get(tsKvProto.getKv().getKey()))</b>
<b class="nc">&nbsp;                                .ifPresent(sparkplugSessionHandler::writeAndFlush);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        log.trace(&quot;Failed attributes update notification to sparkplug Edge Node [{}]. &quot;, sparkplugSessionHandler.getSparkplugTopicNode().getEdgeNodeId());</b>
&nbsp;                    }
&nbsp;                });
&nbsp;            } else {
<b class="nc">&nbsp;                String topic = attrSubTopicType.getAttributesSubTopic();</b>
<b class="nc">&nbsp;                MqttTransportAdaptor adaptor = deviceSessionCtx.getAdaptor(attrSubTopicType);</b>
<b class="nc">&nbsp;                adaptor.convertToPublish(deviceSessionCtx, notification, topic).ifPresent(deviceSessionCtx.getChannel()::writeAndFlush);</b>
&nbsp;            }
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.trace(&quot;[{}] Failed to convert device/Edge Node attributes update to MQTT msg&quot;, sessionId, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void onRemoteSessionCloseCommand(UUID sessionId, TransportProtos.SessionCloseNotificationProto sessionCloseNotification) {
<b class="nc">&nbsp;        log.trace(&quot;[{}] Received the remote command to close the session: {}&quot;, sessionId, sessionCloseNotification.getMessage());</b>
<b class="nc">&nbsp;        transportService.deregisterSession(deviceSessionCtx.getSessionInfo());</b>
<b class="nc">&nbsp;        MqttReasonCodes.Disconnect returnCode = switch (sessionCloseNotification.getReason()) {</b>
<b class="nc">&nbsp;            case CREDENTIALS_UPDATED, RPC_DELIVERY_TIMEOUT -&gt; MqttReasonCodes.Disconnect.ADMINISTRATIVE_ACTION;</b>
<b class="nc">&nbsp;            case MAX_CONCURRENT_SESSIONS_LIMIT_REACHED -&gt; MqttReasonCodes.Disconnect.SESSION_TAKEN_OVER;</b>
<b class="nc">&nbsp;            case SESSION_TIMEOUT -&gt; MqttReasonCodes.Disconnect.MAXIMUM_CONNECT_TIME;</b>
<b class="nc">&nbsp;            default -&gt; MqttReasonCodes.Disconnect.IMPLEMENTATION_SPECIFIC_ERROR;</b>
&nbsp;        };
<b class="nc">&nbsp;        closeCtx(deviceSessionCtx.getChannel(), returnCode);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void onToDeviceRpcRequest(UUID sessionId, TransportProtos.ToDeviceRpcRequestMsg rpcRequest) {
<b class="nc">&nbsp;        log.trace(&quot;[{}][{}] Received RPC command to device: {}&quot;, deviceSessionCtx.getDeviceId(), sessionId, rpcRequest);</b>
&nbsp;        try {
<b class="nc">&nbsp;            if (sparkplugSessionHandler != null) {</b>
<b class="nc">&nbsp;                handleToSparkplugDeviceRpcRequest(rpcRequest);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                String baseTopic = rpcSubTopicType.getRpcRequestTopicBase();</b>
<b class="nc">&nbsp;                MqttTransportAdaptor adaptor = deviceSessionCtx.getAdaptor(rpcSubTopicType);</b>
<b class="nc">&nbsp;                adaptor.convertToPublish(deviceSessionCtx, rpcRequest, baseTopic)</b>
<b class="nc">&nbsp;                        .ifPresent(payload -&gt; sendToDeviceRpcRequest(payload, rpcRequest, deviceSessionCtx.getSessionInfo()));</b>
&nbsp;            }
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}] Failed to convert device RPC command to MQTT msg&quot;, deviceSessionCtx.getDeviceId(), sessionId, e);</b>
<b class="nc">&nbsp;            this.sendErrorRpcResponse(deviceSessionCtx.getSessionInfo(), rpcRequest.getRequestId(),</b>
&nbsp;                    ThingsboardErrorCode.INVALID_ARGUMENTS,
<b class="nc">&nbsp;                    &quot;Failed to convert device RPC command to MQTT msg: &quot; + rpcRequest.getMethodName() + rpcRequest.getParams());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void onGetSessionLimitsRpc(TransportProtos.SessionInfoProto sessionInfo, ChannelHandlerContext ctx, int msgId, TransportProtos.
&nbsp;            ToServerRpcRequestMsg rpcRequestMsg) {
<b class="nc">&nbsp;        var tenantProfile = context.getTenantProfileCache().get(deviceSessionCtx.getTenantId());</b>
<b class="nc">&nbsp;        DefaultTenantProfileConfiguration profile = tenantProfile.getDefaultProfileConfiguration();</b>
&nbsp;
&nbsp;        SessionLimits sessionLimits;
&nbsp;
<b class="nc">&nbsp;        if (sessionInfo.getIsGateway()) {</b>
<b class="nc">&nbsp;            var gatewaySessionLimits = new GatewaySessionLimits();</b>
<b class="nc">&nbsp;            var gatewayLimits = new SessionLimits.SessionRateLimits(profile.getTransportGatewayMsgRateLimit(),</b>
<b class="nc">&nbsp;                    profile.getTransportGatewayTelemetryMsgRateLimit(),</b>
<b class="nc">&nbsp;                    profile.getTransportGatewayTelemetryDataPointsRateLimit());</b>
<b class="nc">&nbsp;            var gatewayDeviceLimits = new SessionLimits.SessionRateLimits(profile.getTransportGatewayDeviceMsgRateLimit(),</b>
<b class="nc">&nbsp;                    profile.getTransportGatewayDeviceTelemetryMsgRateLimit(),</b>
<b class="nc">&nbsp;                    profile.getTransportGatewayDeviceTelemetryDataPointsRateLimit());</b>
<b class="nc">&nbsp;            gatewaySessionLimits.setGatewayRateLimits(gatewayLimits);</b>
<b class="nc">&nbsp;            gatewaySessionLimits.setRateLimits(gatewayDeviceLimits);</b>
<b class="nc">&nbsp;            sessionLimits = gatewaySessionLimits;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            var rateLimits = new SessionLimits.SessionRateLimits(profile.getTransportDeviceMsgRateLimit(),</b>
<b class="nc">&nbsp;                    profile.getTransportDeviceTelemetryMsgRateLimit(),</b>
<b class="nc">&nbsp;                    profile.getTransportDeviceTelemetryDataPointsRateLimit());</b>
<b class="nc">&nbsp;            sessionLimits = new SessionLimits();</b>
<b class="nc">&nbsp;            sessionLimits.setRateLimits(rateLimits);</b>
&nbsp;        }
<b class="nc">&nbsp;        sessionLimits.setMaxPayloadSize(context.getMaxPayloadSize());</b>
<b class="nc">&nbsp;        sessionLimits.setMaxInflightMessages(context.getMessageQueueSizePerDeviceLimit());</b>
&nbsp;
<b class="nc">&nbsp;        ack(ctx, msgId, MqttReasonCodes.PubAck.SUCCESS);</b>
&nbsp;
<b class="nc">&nbsp;        TransportProtos.ToServerRpcResponseMsg responseMsg = TransportProtos.ToServerRpcResponseMsg.newBuilder()</b>
<b class="nc">&nbsp;                .setRequestId(rpcRequestMsg.getRequestId())</b>
<b class="nc">&nbsp;                .setPayload(JacksonUtil.toString(sessionLimits))</b>
<b class="nc">&nbsp;                .build();</b>
&nbsp;
<b class="nc">&nbsp;        onToServerRpcResponse(responseMsg);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void handleToSparkplugDeviceRpcRequest(TransportProtos.ToDeviceRpcRequestMsg rpcRequest) throws ThingsboardException {
<b class="nc">&nbsp;        SparkplugMessageType messageType = SparkplugMessageType.parseMessageType(rpcRequest.getMethodName());</b>
&nbsp;        SparkplugRpcRequestHeader header;
<b class="nc">&nbsp;        if (StringUtils.isNotEmpty(rpcRequest.getParams())) {</b>
<b class="nc">&nbsp;            header = JacksonUtil.fromString(rpcRequest.getParams(), SparkplugRpcRequestHeader.class);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            header = new SparkplugRpcRequestHeader();</b>
&nbsp;        }
<b class="nc">&nbsp;        header.setMessageType(messageType.name());</b>
<b class="nc">&nbsp;        TransportProtos.TsKvProto tsKvProto = getTsKvProto(header.getMetricName(), header.getValue(), new Date().getTime());</b>
<b class="nc">&nbsp;        if (sparkplugSessionHandler.getNodeBirthMetrics().containsKey(tsKvProto.getKv().getKey())) {</b>
<b class="nc">&nbsp;            SparkplugTopic sparkplugTopic = new SparkplugTopic(sparkplugSessionHandler.getSparkplugTopicNode(),</b>
&nbsp;                    messageType);
<b class="nc">&nbsp;            sparkplugSessionHandler.createSparkplugMqttPublishMsg(tsKvProto,</b>
<b class="nc">&nbsp;                            sparkplugTopic.toString(),</b>
<b class="nc">&nbsp;                            sparkplugSessionHandler.getNodeBirthMetrics().get(tsKvProto.getKv().getKey()))</b>
<b class="nc">&nbsp;                    .ifPresent(payload -&gt; sendToDeviceRpcRequest(payload, rpcRequest, deviceSessionCtx.getSessionInfo()));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            sendErrorRpcResponse(deviceSessionCtx.getSessionInfo(), rpcRequest.getRequestId(),</b>
&nbsp;                    ThingsboardErrorCode.BAD_REQUEST_PARAMS, &quot;Failed send To Node Rpc Request: &quot; +
<b class="nc">&nbsp;                            rpcRequest.getMethodName() + &quot;. This node does not have a metricName: [&quot; + tsKvProto.getKv().getKey() + &quot;]&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void sendToDeviceRpcRequest(MqttMessage payload, TransportProtos.ToDeviceRpcRequestMsg rpcRequest, TransportProtos.SessionInfoProto sessionInfo) {
<b class="nc">&nbsp;        int msgId = ((MqttPublishMessage) payload).variableHeader().packetId();</b>
<b class="nc">&nbsp;        int requestId = rpcRequest.getRequestId();</b>
<b class="nc">&nbsp;        if (isAckExpected(payload)) {</b>
<b class="nc">&nbsp;            rpcAwaitingAck.put(msgId, rpcRequest);</b>
<b class="nc">&nbsp;            context.getScheduler().schedule(() -&gt; {</b>
<b class="nc">&nbsp;                TransportProtos.ToDeviceRpcRequestMsg msg = rpcAwaitingAck.remove(msgId);</b>
<b class="nc">&nbsp;                if (msg != null) {</b>
<b class="nc">&nbsp;                    log.trace(&quot;[{}][{}][{}] Going to send to device actor RPC request TIMEOUT status update ...&quot;, deviceSessionCtx.getDeviceId(), sessionId, requestId);</b>
<b class="nc">&nbsp;                    transportService.process(sessionInfo, rpcRequest, RpcStatus.TIMEOUT, TransportServiceCallback.EMPTY);</b>
&nbsp;                }
<b class="nc">&nbsp;            }, Math.max(0, Math.min(deviceSessionCtx.getContext().getTimeout(), rpcRequest.getExpirationTime() - System.currentTimeMillis())), TimeUnit.MILLISECONDS);</b>
&nbsp;        }
<b class="nc">&nbsp;        var cf = publish(payload, deviceSessionCtx);</b>
<b class="nc">&nbsp;        cf.addListener(result -&gt; {</b>
<b class="nc">&nbsp;            Throwable throwable = result.cause();</b>
<b class="nc">&nbsp;            if (throwable != null) {</b>
<b class="nc">&nbsp;                log.trace(&quot;[{}][{}][{}] Failed send RPC request to device due to: &quot;, deviceSessionCtx.getDeviceId(), sessionId, requestId, throwable);</b>
<b class="nc">&nbsp;                this.sendErrorRpcResponse(sessionInfo, requestId,</b>
<b class="nc">&nbsp;                        ThingsboardErrorCode.INVALID_ARGUMENTS, &quot; Failed send To Device Rpc Request: &quot; + rpcRequest.getMethodName());</b>
&nbsp;                return;
&nbsp;            }
<b class="nc">&nbsp;            if (!isAckExpected(payload)) {</b>
<b class="nc">&nbsp;                log.trace(&quot;[{}][{}][{}] Going to send to device actor RPC request DELIVERED status update ...&quot;, deviceSessionCtx.getDeviceId(), sessionId, requestId);</b>
<b class="nc">&nbsp;                transportService.process(sessionInfo, rpcRequest, RpcStatus.DELIVERED, TransportServiceCallback.EMPTY);</b>
<b class="nc">&nbsp;            } else if (rpcRequest.getPersisted()) {</b>
<b class="nc">&nbsp;                log.trace(&quot;[{}][{}][{}] Going to send to device actor RPC request SENT status update ...&quot;, deviceSessionCtx.getDeviceId(), sessionId, requestId);</b>
<b class="nc">&nbsp;                transportService.process(sessionInfo, rpcRequest, RpcStatus.SENT, TransportServiceCallback.EMPTY);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (sparkplugSessionHandler != null) {</b>
<b class="nc">&nbsp;                this.sendSuccessRpcResponse(sessionInfo, requestId, ResponseCode.CONTENT, &quot;Success: &quot; + rpcRequest.getMethodName());</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void onToServerRpcResponse(TransportProtos.ToServerRpcResponseMsg rpcResponse) {
<b class="nc">&nbsp;        log.trace(&quot;[{}] Received RPC response from server&quot;, sessionId);</b>
<b class="nc">&nbsp;        String baseTopic = toServerRpcSubTopicType.getRpcResponseTopicBase();</b>
<b class="nc">&nbsp;        MqttTransportAdaptor adaptor = deviceSessionCtx.getAdaptor(toServerRpcSubTopicType);</b>
&nbsp;        try {
<b class="nc">&nbsp;            adaptor.convertToPublish(deviceSessionCtx, rpcResponse, baseTopic).ifPresent(deviceSessionCtx.getChannel()::writeAndFlush);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.trace(&quot;[{}] Failed to convert device RPC command to MQTT msg&quot;, sessionId, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private ChannelFuture publish(MqttMessage message, DeviceSessionCtx deviceSessionCtx) {
<b class="nc">&nbsp;        return deviceSessionCtx.getChannel().writeAndFlush(message);</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean isAckExpected(MqttMessage message) {
<b class="nc">&nbsp;        return message.fixedHeader().qosLevel().value() &gt; 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void onDeviceProfileUpdate(TransportProtos.SessionInfoProto sessionInfo, DeviceProfile deviceProfile) {
<b class="nc">&nbsp;        deviceSessionCtx.onDeviceProfileUpdate(sessionInfo, deviceProfile);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void onDeviceUpdate(TransportProtos.SessionInfoProto sessionInfo, Device device, Optional&lt;DeviceProfile&gt; deviceProfileOpt) {
<b class="nc">&nbsp;        deviceSessionCtx.onDeviceUpdate(sessionInfo, device, deviceProfileOpt);</b>
<b class="nc">&nbsp;        if (gatewaySessionHandler != null) {</b>
<b class="nc">&nbsp;            gatewaySessionHandler.onGatewayUpdate(sessionInfo, device, deviceProfileOpt);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void onDeviceDeleted(DeviceId deviceId) {
<b class="nc">&nbsp;        context.onAuthFailure(address);</b>
<b class="nc">&nbsp;        ChannelHandlerContext ctx = deviceSessionCtx.getChannel();</b>
<b class="nc">&nbsp;        closeCtx(ctx, MqttReasonCodes.Disconnect.ADMINISTRATIVE_ACTION);</b>
<b class="nc">&nbsp;        if (gatewaySessionHandler != null) {</b>
<b class="nc">&nbsp;            gatewaySessionHandler.onGatewayDelete(deviceId);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void sendErrorRpcResponse(TransportProtos.SessionInfoProto sessionInfo, int requestId, ThingsboardErrorCode result, String errorMsg) {
<b class="nc">&nbsp;        String payload = JacksonUtil.toString(SparkplugRpcResponseBody.builder().result(result.name()).error(errorMsg).build());</b>
<b class="nc">&nbsp;        TransportProtos.ToDeviceRpcResponseMsg msg = TransportProtos.ToDeviceRpcResponseMsg.newBuilder().setRequestId(requestId).setError(payload).build();</b>
<b class="nc">&nbsp;        transportService.process(sessionInfo, msg, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void sendSuccessRpcResponse(TransportProtos.SessionInfoProto sessionInfo, int requestId, ResponseCode result, String successMsg) {
<b class="nc">&nbsp;        String payload = JacksonUtil.toString(SparkplugRpcResponseBody.builder().result(result.getName()).result(successMsg).build());</b>
<b class="nc">&nbsp;        TransportProtos.ToDeviceRpcResponseMsg msg = TransportProtos.ToDeviceRpcResponseMsg.newBuilder().setRequestId(requestId).setError(payload).build();</b>
<b class="nc">&nbsp;        transportService.process(sessionInfo, msg, null);</b>
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
