<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > EdqsSyncService</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.server.service.edqs</a>
</div>

<h1>Coverage Summary for Class: EdqsSyncService (org.thingsboard.server.service.edqs)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">EdqsSyncService</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/45)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/133)
  </span>
</td>
</tr>
  <tr>
    <td class="name">EdqsSyncService$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EdqsSyncService$EntityIdInfo</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/45)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/135)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.server.service.edqs;
&nbsp;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.springframework.beans.factory.annotation.Autowired;
&nbsp;import org.springframework.beans.factory.annotation.Value;
&nbsp;import org.springframework.context.annotation.Lazy;
&nbsp;import org.thingsboard.server.common.data.AttributeScope;
&nbsp;import org.thingsboard.server.common.data.EntityType;
&nbsp;import org.thingsboard.server.common.data.ObjectType;
&nbsp;import org.thingsboard.server.common.data.edqs.AttributeKv;
&nbsp;import org.thingsboard.server.common.data.edqs.EdqsEventType;
&nbsp;import org.thingsboard.server.common.data.edqs.EdqsObject;
&nbsp;import org.thingsboard.server.common.data.edqs.EdqsSyncRequest;
&nbsp;import org.thingsboard.server.common.data.edqs.Entity;
&nbsp;import org.thingsboard.server.common.data.edqs.LatestTsKv;
&nbsp;import org.thingsboard.server.common.data.edqs.fields.EntityFields;
&nbsp;import org.thingsboard.server.common.data.id.EntityId;
&nbsp;import org.thingsboard.server.common.data.id.EntityIdFactory;
&nbsp;import org.thingsboard.server.common.data.id.TenantId;
&nbsp;import org.thingsboard.server.common.data.page.PageDataIterable;
&nbsp;import org.thingsboard.server.common.data.relation.RelationTypeGroup;
&nbsp;import org.thingsboard.server.dao.Dao;
&nbsp;import org.thingsboard.server.dao.attributes.AttributesDao;
&nbsp;import org.thingsboard.server.dao.dictionary.KeyDictionaryDao;
&nbsp;import org.thingsboard.server.dao.entity.EntityDaoRegistry;
&nbsp;import org.thingsboard.server.dao.model.sql.AttributeKvEntity;
&nbsp;import org.thingsboard.server.dao.model.sql.RelationEntity;
&nbsp;import org.thingsboard.server.dao.model.sqlts.dictionary.KeyDictionaryEntry;
&nbsp;import org.thingsboard.server.dao.model.sqlts.latest.TsKvLatestEntity;
&nbsp;import org.thingsboard.server.dao.sql.relation.RelationRepository;
&nbsp;import org.thingsboard.server.dao.sqlts.latest.TsKvLatestRepository;
&nbsp;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.UUID;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.concurrent.atomic.AtomicInteger;
&nbsp;
&nbsp;import static org.thingsboard.server.common.data.ObjectType.ATTRIBUTE_KV;
&nbsp;import static org.thingsboard.server.common.data.ObjectType.LATEST_TS_KV;
&nbsp;import static org.thingsboard.server.common.data.ObjectType.RELATION;
&nbsp;import static org.thingsboard.server.common.data.ObjectType.edqsTenantTypes;
&nbsp;
<b class="nc">&nbsp;@Slf4j</b>
<b class="nc">&nbsp;public abstract class EdqsSyncService {</b>
&nbsp;
&nbsp;    @Value(&quot;${queue.edqs.sync.entity_batch_size:10000}&quot;)
&nbsp;    private int entityBatchSize;
&nbsp;    @Value(&quot;${queue.edqs.sync.ts_batch_size:10000}&quot;)
&nbsp;    private int tsBatchSize;
&nbsp;    @Autowired
&nbsp;    private EntityDaoRegistry entityDaoRegistry;
&nbsp;    @Autowired
&nbsp;    private AttributesDao attributesDao;
&nbsp;    @Autowired
&nbsp;    private KeyDictionaryDao keyDictionaryDao;
&nbsp;    @Autowired
&nbsp;    private RelationRepository relationRepository;
&nbsp;    @Autowired
&nbsp;    private TsKvLatestRepository tsKvLatestRepository;
&nbsp;    @Autowired
&nbsp;    @Lazy
&nbsp;    private DefaultEdqsService edqsService;
&nbsp;
<b class="nc">&nbsp;    private final ConcurrentHashMap&lt;UUID, EntityIdInfo&gt; entityInfoMap = new ConcurrentHashMap&lt;&gt;();</b>
<b class="nc">&nbsp;    private final ConcurrentHashMap&lt;Integer, String&gt; keys = new ConcurrentHashMap&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;    private final Map&lt;ObjectType, AtomicInteger&gt; counters = new ConcurrentHashMap&lt;&gt;();</b>
&nbsp;
&nbsp;    public abstract boolean isSyncNeeded();
&nbsp;
&nbsp;    public void sync(EdqsSyncRequest syncRequest) {
<b class="nc">&nbsp;        log.info(&quot;Synchronizing data to EDQS&quot;);</b>
<b class="nc">&nbsp;        long startTs = System.currentTimeMillis();</b>
<b class="nc">&nbsp;        counters.clear();</b>
&nbsp;
<b class="nc">&nbsp;        if (syncRequest.getObjectTypes() != null &amp;&amp; !syncRequest.getObjectTypes().isEmpty()) {</b>
<b class="nc">&nbsp;            log.info(&quot;Sync request for entity types: {}&quot;, syncRequest.getObjectTypes());</b>
<b class="nc">&nbsp;            for (ObjectType objectType : syncRequest.getObjectTypes()) {</b>
<b class="nc">&nbsp;                syncObjectType(objectType);</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            log.info(&quot;Sync request for all entity types&quot;);</b>
<b class="nc">&nbsp;            syncTenantEntities();</b>
<b class="nc">&nbsp;            syncRelations();</b>
<b class="nc">&nbsp;            loadKeyDictionary();</b>
<b class="nc">&nbsp;            syncAttributes();</b>
<b class="nc">&nbsp;            syncLatestTimeseries();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        counters.clear();</b>
<b class="nc">&nbsp;        log.info(&quot;Finished synchronizing data to EDQS in {} ms&quot;, (System.currentTimeMillis() - startTs));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void syncObjectType(ObjectType objectType) {
<b class="nc">&nbsp;        switch (objectType) {</b>
<b class="nc">&nbsp;            case RELATION -&gt; syncRelations();</b>
<b class="nc">&nbsp;            case ATTRIBUTE_KV -&gt; syncAttributes();</b>
<b class="nc">&nbsp;            case LATEST_TS_KV -&gt; syncLatestTimeseries();</b>
<b class="nc">&nbsp;            default -&gt; syncTenantEntity(objectType);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void process(TenantId tenantId, ObjectType type, EdqsObject object) {
<b class="nc">&nbsp;        AtomicInteger counter = counters.computeIfAbsent(type, t -&gt; new AtomicInteger());</b>
<b class="nc">&nbsp;        if (counter.incrementAndGet() % 10000 == 0) {</b>
<b class="nc">&nbsp;            log.info(&quot;Processed {} {} objects&quot;, counter.get(), type);</b>
&nbsp;        }
<b class="nc">&nbsp;        edqsService.processEvent(tenantId, type, EdqsEventType.UPDATED, object);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void syncTenantEntities() {
<b class="nc">&nbsp;        for (ObjectType type : edqsTenantTypes) {</b>
<b class="nc">&nbsp;            syncTenantEntity(type);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void syncTenantEntity(ObjectType type) {
<b class="nc">&nbsp;        log.info(&quot;Synchronizing {} entities to EDQS&quot;, type);</b>
<b class="nc">&nbsp;        long ts = System.currentTimeMillis();</b>
<b class="nc">&nbsp;        EntityType entityType = type.toEntityType();</b>
<b class="nc">&nbsp;        Dao&lt;?&gt; dao = entityDaoRegistry.getDao(entityType);</b>
<b class="nc">&nbsp;        UUID lastId = UUID.fromString(&quot;00000000-0000-0000-0000-000000000000&quot;);</b>
&nbsp;        while (true) {
<b class="nc">&nbsp;            var batch = dao.findNextBatch(lastId, entityBatchSize);</b>
<b class="nc">&nbsp;            if (batch.isEmpty()) {</b>
&nbsp;                break;
&nbsp;            }
<b class="nc">&nbsp;            for (EntityFields entityFields : batch) {</b>
<b class="nc">&nbsp;                TenantId tenantId = TenantId.fromUUID(entityFields.getTenantId());</b>
<b class="nc">&nbsp;                entityInfoMap.put(entityFields.getId(), new EntityIdInfo(entityType, tenantId));</b>
<b class="nc">&nbsp;                process(tenantId, type, new Entity(entityType, entityFields));</b>
&nbsp;            }
<b class="nc">&nbsp;            EntityFields lastRecord = batch.get(batch.size() - 1);</b>
<b class="nc">&nbsp;            lastId = lastRecord.getId();</b>
&nbsp;        }
<b class="nc">&nbsp;        log.info(&quot;Finished synchronizing {} entities to EDQS in {} ms&quot;, type, (System.currentTimeMillis() - ts));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void syncRelations() {
<b class="nc">&nbsp;        log.info(&quot;Synchronizing relations to EDQS&quot;);</b>
<b class="nc">&nbsp;        long ts = System.currentTimeMillis();</b>
<b class="nc">&nbsp;        UUID lastFromEntityId = UUID.fromString(&quot;00000000-0000-0000-0000-000000000000&quot;);</b>
<b class="nc">&nbsp;        String lastFromEntityType = &quot;&quot;;</b>
<b class="nc">&nbsp;        String lastRelationTypeGroup = &quot;&quot;;</b>
<b class="nc">&nbsp;        String lastRelationType = &quot;&quot;;</b>
<b class="nc">&nbsp;        UUID lastToEntityId = UUID.fromString(&quot;00000000-0000-0000-0000-000000000000&quot;);</b>
<b class="nc">&nbsp;        String lastToEntityType = &quot;&quot;;</b>
&nbsp;
&nbsp;        while (true) {
<b class="nc">&nbsp;            List&lt;RelationEntity&gt; batch = relationRepository.findNextBatch(lastFromEntityId, lastFromEntityType, lastRelationTypeGroup,</b>
&nbsp;                    lastRelationType, lastToEntityId, lastToEntityType, entityBatchSize);
<b class="nc">&nbsp;            if (batch.isEmpty()) {</b>
&nbsp;                break;
&nbsp;            }
<b class="nc">&nbsp;            processRelationBatch(batch);</b>
&nbsp;
<b class="nc">&nbsp;            RelationEntity lastRecord = batch.get(batch.size() - 1);</b>
<b class="nc">&nbsp;            lastFromEntityId = lastRecord.getFromId();</b>
<b class="nc">&nbsp;            lastFromEntityType = lastRecord.getFromType();</b>
<b class="nc">&nbsp;            lastRelationTypeGroup = lastRecord.getRelationTypeGroup();</b>
<b class="nc">&nbsp;            lastRelationType = lastRecord.getRelationType();</b>
<b class="nc">&nbsp;            lastToEntityId = lastRecord.getToId();</b>
<b class="nc">&nbsp;            lastToEntityType = lastRecord.getToType();</b>
&nbsp;        }
<b class="nc">&nbsp;        log.info(&quot;Finished synchronizing relations to EDQS in {} ms&quot;, (System.currentTimeMillis() - ts));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void processRelationBatch(List&lt;RelationEntity&gt; relations) {
<b class="nc">&nbsp;        for (RelationEntity relation : relations) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                if (RelationTypeGroup.COMMON.name().equals(relation.getRelationTypeGroup())) {</b>
<b class="nc">&nbsp;                    EntityIdInfo entityIdInfo = entityInfoMap.get(relation.getFromId());</b>
<b class="nc">&nbsp;                    if (entityIdInfo != null) {</b>
<b class="nc">&nbsp;                        process(entityIdInfo.tenantId(), RELATION, relation.toData());</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        log.info(&quot;Relation from id not found: {} &quot;, relation);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            } catch (Exception e) {
<b class="nc">&nbsp;                log.error(&quot;Failed to sync relation: {}&quot;, relation, e);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void loadKeyDictionary() {
<b class="nc">&nbsp;        log.info(&quot;Loading key dictionary&quot;);</b>
<b class="nc">&nbsp;        long ts = System.currentTimeMillis();</b>
<b class="nc">&nbsp;        var keyDictionaryEntries = new PageDataIterable&lt;&gt;(keyDictionaryDao::findAll, 10000);</b>
<b class="nc">&nbsp;        for (KeyDictionaryEntry keyDictionaryEntry : keyDictionaryEntries) {</b>
<b class="nc">&nbsp;            keys.put(keyDictionaryEntry.getKeyId(), keyDictionaryEntry.getKey());</b>
&nbsp;        }
<b class="nc">&nbsp;        log.info(&quot;Finished loading key dictionary in {} ms&quot;, (System.currentTimeMillis() - ts));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void syncAttributes() {
<b class="nc">&nbsp;        log.info(&quot;Synchronizing attributes to EDQS&quot;);</b>
<b class="nc">&nbsp;        long ts = System.currentTimeMillis();</b>
&nbsp;
<b class="nc">&nbsp;        UUID lastEntityId = UUID.fromString(&quot;00000000-0000-0000-0000-000000000000&quot;);</b>
<b class="nc">&nbsp;        int lastAttributeType = Integer.MIN_VALUE;</b>
<b class="nc">&nbsp;        int lastAttributeKey = Integer.MIN_VALUE;</b>
&nbsp;
&nbsp;        while (true) {
<b class="nc">&nbsp;            List&lt;AttributeKvEntity&gt; batch = attributesDao.findNextBatch(lastEntityId, lastAttributeType, lastAttributeKey, tsBatchSize);</b>
<b class="nc">&nbsp;            if (batch.isEmpty()) {</b>
&nbsp;                break;
&nbsp;            }
<b class="nc">&nbsp;            processAttributeBatch(batch);</b>
&nbsp;
<b class="nc">&nbsp;            AttributeKvEntity lastRecord = batch.get(batch.size() - 1);</b>
<b class="nc">&nbsp;            lastEntityId = lastRecord.getId().getEntityId();</b>
<b class="nc">&nbsp;            lastAttributeType = lastRecord.getId().getAttributeType();</b>
<b class="nc">&nbsp;            lastAttributeKey = lastRecord.getId().getAttributeKey();</b>
&nbsp;        }
<b class="nc">&nbsp;        log.info(&quot;Finished synchronizing attributes to EDQS in {} ms&quot;, (System.currentTimeMillis() - ts));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void processAttributeBatch(List&lt;AttributeKvEntity&gt; batch) {
<b class="nc">&nbsp;        for (AttributeKvEntity attribute : batch) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                attribute.setStrKey(getStrKeyOrFetchFromDb(attribute.getId().getAttributeKey()));</b>
<b class="nc">&nbsp;                UUID entityId = attribute.getId().getEntityId();</b>
<b class="nc">&nbsp;                EntityIdInfo entityIdInfo = entityInfoMap.get(entityId);</b>
<b class="nc">&nbsp;                if (entityIdInfo == null) {</b>
<b class="nc">&nbsp;                    log.debug(&quot;Skipping attribute with entity UUID {} as it is not found in entityInfoMap&quot;, entityId);</b>
&nbsp;                    continue;
&nbsp;                }
<b class="nc">&nbsp;                AttributeKv attributeKv = new AttributeKv(</b>
<b class="nc">&nbsp;                        EntityIdFactory.getByTypeAndUuid(entityIdInfo.entityType(), entityId),</b>
<b class="nc">&nbsp;                        AttributeScope.valueOf(attribute.getId().getAttributeType()),</b>
<b class="nc">&nbsp;                        attribute.toData(),</b>
<b class="nc">&nbsp;                        attribute.getVersion());</b>
<b class="nc">&nbsp;                process(entityIdInfo.tenantId(), ATTRIBUTE_KV, attributeKv);</b>
&nbsp;            } catch (Exception e) {
<b class="nc">&nbsp;                log.error(&quot;Failed to sync attribute: {}&quot;, attribute, e);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void syncLatestTimeseries() {
<b class="nc">&nbsp;        log.info(&quot;Synchronizing latest timeseries to EDQS&quot;);</b>
<b class="nc">&nbsp;        long ts = System.currentTimeMillis();</b>
<b class="nc">&nbsp;        UUID lastEntityId = UUID.fromString(&quot;00000000-0000-0000-0000-000000000000&quot;);</b>
<b class="nc">&nbsp;        int lastKey = Integer.MIN_VALUE;</b>
&nbsp;
&nbsp;        while (true) {
<b class="nc">&nbsp;            List&lt;TsKvLatestEntity&gt; batch = tsKvLatestRepository.findNextBatch(lastEntityId, lastKey, tsBatchSize);</b>
<b class="nc">&nbsp;            if (batch.isEmpty()) {</b>
&nbsp;                break;
&nbsp;            }
<b class="nc">&nbsp;            processTsKvLatestBatch(batch);</b>
&nbsp;
<b class="nc">&nbsp;            TsKvLatestEntity lastRecord = batch.get(batch.size() - 1);</b>
<b class="nc">&nbsp;            lastEntityId = lastRecord.getEntityId();</b>
<b class="nc">&nbsp;            lastKey = lastRecord.getKey();</b>
&nbsp;        }
<b class="nc">&nbsp;        log.info(&quot;Finished synchronizing latest timeseries to EDQS in {} ms&quot;, (System.currentTimeMillis() - ts));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void processTsKvLatestBatch(List&lt;TsKvLatestEntity&gt; tsKvLatestEntities) {
<b class="nc">&nbsp;        for (TsKvLatestEntity tsKvLatestEntity : tsKvLatestEntities) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                String strKey = getStrKeyOrFetchFromDb(tsKvLatestEntity.getKey());</b>
<b class="nc">&nbsp;                if (strKey == null) {</b>
<b class="nc">&nbsp;                    log.debug(&quot;Skipping latest timeseries with key {} as it is not found in key dictionary&quot;, tsKvLatestEntity.getKey());</b>
&nbsp;                    continue;
&nbsp;                }
<b class="nc">&nbsp;                tsKvLatestEntity.setStrKey(strKey);</b>
<b class="nc">&nbsp;                UUID entityUuid = tsKvLatestEntity.getEntityId();</b>
<b class="nc">&nbsp;                EntityIdInfo entityIdInfo = entityInfoMap.get(entityUuid);</b>
<b class="nc">&nbsp;                if (entityIdInfo != null) {</b>
<b class="nc">&nbsp;                    EntityId entityId = EntityIdFactory.getByTypeAndUuid(entityIdInfo.entityType(), entityUuid);</b>
<b class="nc">&nbsp;                    LatestTsKv latestTsKv = new LatestTsKv(entityId, tsKvLatestEntity.toData(), tsKvLatestEntity.getVersion());</b>
<b class="nc">&nbsp;                    process(entityIdInfo.tenantId(), LATEST_TS_KV, latestTsKv);</b>
&nbsp;                }
&nbsp;            } catch (Exception e) {
<b class="nc">&nbsp;                log.error(&quot;Failed to sync latest timeseries: {}&quot;, tsKvLatestEntity, e);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private String getStrKeyOrFetchFromDb(int key) {
<b class="nc">&nbsp;        String strKey = keys.get(key);</b>
<b class="nc">&nbsp;        if (strKey != null) {</b>
<b class="nc">&nbsp;            return strKey;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            strKey = keyDictionaryDao.getKey(key);</b>
<b class="nc">&nbsp;            if (strKey != null) {</b>
<b class="nc">&nbsp;                keys.put(key, strKey);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return strKey;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public record EntityIdInfo(EntityType entityType, TenantId tenantId) {</b>
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
