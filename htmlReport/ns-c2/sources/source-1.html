<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > AbstractActivityManager</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.server.common.transport.activity</a>
</div>

<h1>Coverage Summary for Class: AbstractActivityManager (org.thingsboard.server.common.transport.activity)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AbstractActivityManager</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/61)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AbstractActivityManager$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractActivityManager$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractActivityManager$ActivityStateWrapper</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/67)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.server.common.transport.activity;
&nbsp;
&nbsp;import lombok.Data;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.springframework.beans.factory.annotation.Autowired;
&nbsp;import org.thingsboard.server.common.transport.activity.strategy.ActivityStrategy;
&nbsp;import org.thingsboard.server.queue.scheduler.SchedulerComponent;
&nbsp;
&nbsp;import java.util.Map;
&nbsp;import java.util.Random;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.concurrent.ConcurrentMap;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.concurrent.atomic.AtomicBoolean;
&nbsp;import java.util.concurrent.atomic.AtomicLong;
&nbsp;
<b class="nc">&nbsp;@Slf4j</b>
<b class="nc">&nbsp;public abstract class AbstractActivityManager&lt;Key, Metadata&gt; implements ActivityManager&lt;Key, Metadata&gt; {</b>
&nbsp;
<b class="nc">&nbsp;    private final ConcurrentMap&lt;Key, ActivityStateWrapper&gt; states = new ConcurrentHashMap&lt;&gt;();</b>
&nbsp;
&nbsp;    @Autowired
&nbsp;    protected SchedulerComponent scheduler;
&nbsp;
&nbsp;    @Data
&nbsp;    private class ActivityStateWrapper {
&nbsp;
&nbsp;        private volatile ActivityState&lt;Metadata&gt; state;
&nbsp;        private volatile long lastReportedTime;
&nbsp;        private volatile ActivityStrategy strategy;
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    protected void init() {
<b class="nc">&nbsp;        var reportingPeriodMillis = getReportingPeriodMillis();</b>
<b class="nc">&nbsp;        scheduler.scheduleAtFixedRate(this::onReportingPeriodEnd, new Random().nextInt((int) reportingPeriodMillis), reportingPeriodMillis, TimeUnit.MILLISECONDS);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected abstract long getReportingPeriodMillis();
&nbsp;
&nbsp;    protected abstract ActivityStrategy getStrategy();
&nbsp;
&nbsp;    protected abstract ActivityState&lt;Metadata&gt; updateState(Key key, ActivityState&lt;Metadata&gt; state);
&nbsp;
&nbsp;    protected abstract boolean hasExpired(long lastRecordedTime);
&nbsp;
&nbsp;    protected abstract void onStateExpiry(Key key, Metadata metadata);
&nbsp;
&nbsp;    protected abstract void reportActivity(Key key, Metadata metadata, long timeToReport, ActivityReportCallback&lt;Key&gt; callback);
&nbsp;
&nbsp;    @Override
&nbsp;    public void onActivity(Key key, Metadata metadata, long newLastRecordedTime) {
<b class="nc">&nbsp;        if (key == null) {</b>
<b class="nc">&nbsp;            log.error(&quot;Failed to process activity event: provided activity key is null.&quot;);</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        log.debug(&quot;Received activity event for key: [{}]. Event time: [{}].&quot;, key, newLastRecordedTime);</b>
&nbsp;
<b class="nc">&nbsp;        var shouldReport = new AtomicBoolean(false);</b>
<b class="nc">&nbsp;        var lastRecordedTime = new AtomicLong();</b>
<b class="nc">&nbsp;        var lastReportedTime = new AtomicLong();</b>
&nbsp;
<b class="nc">&nbsp;        states.compute(key, (__, stateWrapper) -&gt; {</b>
<b class="nc">&nbsp;            if (stateWrapper == null) {</b>
<b class="nc">&nbsp;                ActivityState&lt;Metadata&gt; newState = new ActivityState&lt;&gt;();</b>
<b class="nc">&nbsp;                stateWrapper = new ActivityStateWrapper();</b>
<b class="nc">&nbsp;                stateWrapper.setState(newState);</b>
<b class="nc">&nbsp;                stateWrapper.setStrategy(getStrategy());</b>
&nbsp;            }
<b class="nc">&nbsp;            var state = stateWrapper.getState();</b>
<b class="nc">&nbsp;            state.setMetadata(metadata);</b>
<b class="nc">&nbsp;            if (state.getLastRecordedTime() &lt; newLastRecordedTime) {</b>
<b class="nc">&nbsp;                state.setLastRecordedTime(newLastRecordedTime);</b>
&nbsp;            }
<b class="nc">&nbsp;            shouldReport.set(stateWrapper.getStrategy().onActivity());</b>
<b class="nc">&nbsp;            lastRecordedTime.set(state.getLastRecordedTime());</b>
<b class="nc">&nbsp;            lastReportedTime.set(stateWrapper.getLastReportedTime());</b>
<b class="nc">&nbsp;            return stateWrapper;</b>
&nbsp;        });
&nbsp;
<b class="nc">&nbsp;        if (shouldReport.get() &amp;&amp; lastReportedTime.get() &lt; lastRecordedTime.get()) {</b>
<b class="nc">&nbsp;            log.debug(&quot;Going to report first activity event for key: [{}]. Event time: [{}].&quot;, key, lastRecordedTime.get());</b>
<b class="nc">&nbsp;            reportActivity(key, metadata, lastRecordedTime.get(), new ActivityReportCallback&lt;&gt;() {</b>
&nbsp;                @Override
&nbsp;                public void onSuccess(Key key, long reportedTime) {
<b class="nc">&nbsp;                    updateLastReportedTime(key, reportedTime);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onFailure(Key key, Throwable t) {
<b class="nc">&nbsp;                    log.debug(&quot;Failed to report first activity event for key: [{}]. Event time: [{}].&quot;, key, lastRecordedTime.get(), t);</b>
&nbsp;                }
&nbsp;            });
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void onReportingPeriodEnd() {
<b class="nc">&nbsp;        log.debug(&quot;Going to end reporting period.&quot;);</b>
<b class="nc">&nbsp;        for (Map.Entry&lt;Key, ActivityStateWrapper&gt; entry : states.entrySet()) {</b>
<b class="nc">&nbsp;            Key key = entry.getKey();</b>
<b class="nc">&nbsp;            ActivityStateWrapper stateWrapper = entry.getValue();</b>
&nbsp;            try {
<b class="nc">&nbsp;                reportLastEvent(key, stateWrapper);</b>
&nbsp;            } catch (Exception e) {
<b class="nc">&nbsp;                log.error(&quot;Failed to report last activity event on reporting period end for key: [{}]. State: [{}].&quot;, key, stateWrapper, e);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void reportLastEvent(Key key, ActivityStateWrapper stateWrapper) {
<b class="nc">&nbsp;        var currentState = stateWrapper.getState();</b>
&nbsp;
<b class="nc">&nbsp;        long lastRecordedTime = currentState.getLastRecordedTime();</b>
<b class="nc">&nbsp;        long lastReportedTime = stateWrapper.getLastReportedTime();</b>
<b class="nc">&nbsp;        var metadata = currentState.getMetadata();</b>
&nbsp;
&nbsp;        boolean hasExpired;
&nbsp;        boolean shouldReport;
&nbsp;
<b class="nc">&nbsp;        var updatedState = updateState(key, currentState);</b>
<b class="nc">&nbsp;        if (updatedState != null) {</b>
<b class="nc">&nbsp;            stateWrapper.setState(updatedState);</b>
<b class="nc">&nbsp;            lastRecordedTime = updatedState.getLastRecordedTime();</b>
<b class="nc">&nbsp;            metadata = updatedState.getMetadata();</b>
<b class="nc">&nbsp;            hasExpired = hasExpired(lastRecordedTime);</b>
<b class="nc">&nbsp;            shouldReport = stateWrapper.getStrategy().onReportingPeriodEnd();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            states.remove(key);</b>
<b class="nc">&nbsp;            hasExpired = false;</b>
<b class="nc">&nbsp;            shouldReport = true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (hasExpired) {</b>
<b class="nc">&nbsp;            states.remove(key);</b>
<b class="nc">&nbsp;            onStateExpiry(key, metadata);</b>
<b class="nc">&nbsp;            shouldReport = true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (shouldReport &amp;&amp; lastReportedTime &lt; lastRecordedTime) {</b>
<b class="nc">&nbsp;            long timeToReport = lastRecordedTime;</b>
<b class="nc">&nbsp;            log.debug(&quot;Going to report last activity event for key: [{}]. Event time: [{}].&quot;, key, timeToReport);</b>
<b class="nc">&nbsp;            reportActivity(key, metadata, timeToReport, new ActivityReportCallback&lt;&gt;() {</b>
&nbsp;                @Override
&nbsp;                public void onSuccess(Key key, long reportedTime) {
<b class="nc">&nbsp;                    updateLastReportedTime(key, reportedTime);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onFailure(Key key, Throwable t) {
<b class="nc">&nbsp;                    log.debug(&quot;Failed to report last activity event for key: [{}]. Event time: [{}].&quot;, key, timeToReport, t);</b>
&nbsp;                }
&nbsp;            });
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public long getLastRecordedTime(Key key) {
<b class="nc">&nbsp;        ActivityStateWrapper stateWrapper = states.get(key);</b>
<b class="nc">&nbsp;        return stateWrapper == null ? 0L : stateWrapper.getState().getLastRecordedTime();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void updateLastReportedTime(Key key, long newLastReportedTime) {
<b class="nc">&nbsp;        states.computeIfPresent(key, (__, stateWrapper) -&gt; {</b>
<b class="nc">&nbsp;            stateWrapper.setLastReportedTime(Math.max(stateWrapper.getLastReportedTime(), newLastReportedTime));</b>
<b class="nc">&nbsp;            return stateWrapper;</b>
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
