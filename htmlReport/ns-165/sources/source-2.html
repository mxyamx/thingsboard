<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > EdgeGrpcSession</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.server.service.edge.rpc</a>
</div>

<h1>Coverage Summary for Class: EdgeGrpcSession (org.thingsboard.server.service.edge.rpc)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">EdgeGrpcSession</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/43)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/243)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/412)
  </span>
</td>
</tr>
  <tr>
    <td class="name">EdgeGrpcSession$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/33)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EdgeGrpcSession$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EdgeGrpcSession$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EdgeGrpcSession$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EdgeGrpcSession$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EdgeGrpcSession$6</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EdgeGrpcSession$6$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EdgeGrpcSession$7</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/67)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/281)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/491)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.server.service.edge.rpc;
&nbsp;
&nbsp;import com.datastax.oss.driver.api.core.uuid.Uuids;
&nbsp;import com.google.common.util.concurrent.FutureCallback;
&nbsp;import com.google.common.util.concurrent.Futures;
&nbsp;import com.google.common.util.concurrent.ListenableFuture;
&nbsp;import com.google.common.util.concurrent.SettableFuture;
&nbsp;import io.grpc.stub.StreamObserver;
&nbsp;import lombok.Data;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.checkerframework.checker.nullness.qual.Nullable;
&nbsp;import org.springframework.data.util.Pair;
&nbsp;import org.thingsboard.server.common.data.AttributeScope;
&nbsp;import org.thingsboard.server.common.data.DataConstants;
&nbsp;import org.thingsboard.server.common.data.EdgeUtils;
&nbsp;import org.thingsboard.server.common.data.StringUtils;
&nbsp;import org.thingsboard.server.common.data.edge.Edge;
&nbsp;import org.thingsboard.server.common.data.edge.EdgeEvent;
&nbsp;import org.thingsboard.server.common.data.edge.EdgeEventType;
&nbsp;import org.thingsboard.server.common.data.id.EdgeId;
&nbsp;import org.thingsboard.server.common.data.id.TenantId;
&nbsp;import org.thingsboard.server.common.data.kv.AttributeKvEntry;
&nbsp;import org.thingsboard.server.common.data.kv.AttributesSaveResult;
&nbsp;import org.thingsboard.server.common.data.kv.BaseAttributeKvEntry;
&nbsp;import org.thingsboard.server.common.data.kv.LongDataEntry;
&nbsp;import org.thingsboard.server.common.data.kv.StringDataEntry;
&nbsp;import org.thingsboard.server.common.data.limit.LimitedApi;
&nbsp;import org.thingsboard.server.common.data.notification.rule.trigger.EdgeCommunicationFailureTrigger;
&nbsp;import org.thingsboard.server.common.data.page.PageData;
&nbsp;import org.thingsboard.server.common.data.page.PageLink;
&nbsp;import org.thingsboard.server.common.data.page.TimePageLink;
&nbsp;import org.thingsboard.server.common.msg.edge.EdgeEventUpdateMsg;
&nbsp;import org.thingsboard.server.dao.edge.stats.EdgeStatsKey;
&nbsp;import org.thingsboard.server.gen.edge.v1.AiModelUpdateMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.AlarmCommentUpdateMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.AlarmUpdateMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.AssetProfileUpdateMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.AssetUpdateMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.AttributesRequestMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.CalculatedFieldRequestMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.CalculatedFieldUpdateMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.ConnectRequestMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.ConnectResponseCode;
&nbsp;import org.thingsboard.server.gen.edge.v1.ConnectResponseMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.DashboardUpdateMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.DeviceCredentialsRequestMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.DeviceCredentialsUpdateMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.DeviceProfileUpdateMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.DeviceRpcCallMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.DeviceUpdateMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.DownlinkMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.DownlinkResponseMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.EdgeConfiguration;
&nbsp;import org.thingsboard.server.gen.edge.v1.EdgeUpdateMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.EdgeVersion;
&nbsp;import org.thingsboard.server.gen.edge.v1.EntityDataProto;
&nbsp;import org.thingsboard.server.gen.edge.v1.EntityViewUpdateMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.EntityViewsRequestMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.RelationRequestMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.RelationUpdateMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.RequestMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.RequestMsgType;
&nbsp;import org.thingsboard.server.gen.edge.v1.ResourceUpdateMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.ResponseMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.RuleChainMetadataRequestMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.RuleChainMetadataUpdateMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.RuleChainUpdateMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.SyncCompletedMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.UplinkMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.UplinkResponseMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.UserCredentialsRequestMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.UserCredentialsUpdateMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.UserUpdateMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.WidgetBundleTypesRequestMsg;
&nbsp;import org.thingsboard.server.service.edge.EdgeContextComponent;
&nbsp;import org.thingsboard.server.service.edge.EdgeMsgConstructorUtils;
&nbsp;import org.thingsboard.server.service.edge.rpc.fetch.EdgeEventFetcher;
&nbsp;import org.thingsboard.server.service.edge.rpc.fetch.GeneralEdgeEventFetcher;
&nbsp;import org.thingsboard.server.service.edge.rpc.utils.EdgeVersionUtils;
&nbsp;
&nbsp;import java.io.Closeable;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.List;
&nbsp;import java.util.Optional;
&nbsp;import java.util.UUID;
&nbsp;import java.util.concurrent.ConcurrentLinkedQueue;
&nbsp;import java.util.concurrent.ScheduledExecutorService;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.concurrent.locks.Lock;
&nbsp;import java.util.concurrent.locks.ReentrantLock;
&nbsp;import java.util.function.BiConsumer;
&nbsp;
<b class="nc">&nbsp;@Slf4j</b>
&nbsp;@Data
&nbsp;public abstract class EdgeGrpcSession implements Closeable {
&nbsp;
&nbsp;    private static final String QUEUE_START_TS_ATTR_KEY = &quot;queueStartTs&quot;;
&nbsp;    private static final String QUEUE_START_SEQ_ID_ATTR_KEY = &quot;queueStartSeqId&quot;;
&nbsp;
&nbsp;    private static final int MAX_DOWNLINK_ATTEMPTS = 3;
&nbsp;    private static final String RATE_LIMIT_REACHED = &quot;Rate limit reached&quot;;
&nbsp;
<b class="nc">&nbsp;    protected final ConcurrentLinkedQueue&lt;EdgeEvent&gt; highPriorityQueue = new ConcurrentLinkedQueue&lt;&gt;();</b>
&nbsp;
&nbsp;    protected UUID sessionId;
&nbsp;    private BiConsumer&lt;EdgeId, EdgeGrpcSession&gt; sessionOpenListener;
&nbsp;    private BiConsumer&lt;Edge, UUID&gt; sessionCloseListener;
&nbsp;
<b class="nc">&nbsp;    private final EdgeSessionState sessionState = new EdgeSessionState();</b>
<b class="nc">&nbsp;    private final ReentrantLock downlinkMsgLock = new ReentrantLock();</b>
<b class="nc">&nbsp;    private final Lock sequenceDependencyLock = new ReentrantLock();</b>
&nbsp;
&nbsp;    protected EdgeContextComponent ctx;
&nbsp;    protected Edge edge;
&nbsp;    protected TenantId tenantId;
&nbsp;
&nbsp;    private Long newStartTs;
&nbsp;    private Long previousStartTs;
&nbsp;    private Long newStartSeqId;
&nbsp;    private Long previousStartSeqId;
&nbsp;
&nbsp;    private StreamObserver&lt;RequestMsg&gt; inputStream;
&nbsp;    private StreamObserver&lt;ResponseMsg&gt; outputStream;
&nbsp;
&nbsp;    private volatile boolean connected;
&nbsp;    private volatile boolean syncInProgress;
&nbsp;
&nbsp;    private EdgeVersion edgeVersion;
&nbsp;    private int maxInboundMessageSize;
&nbsp;    private int clientMaxInboundMessageSize;
&nbsp;    private int maxHighPriorityQueueSizePerSession;
&nbsp;
&nbsp;    private ScheduledExecutorService sendDownlinkExecutorService;
&nbsp;
&nbsp;    public EdgeGrpcSession(EdgeContextComponent ctx, StreamObserver&lt;ResponseMsg&gt; outputStream,
&nbsp;                           BiConsumer&lt;EdgeId, EdgeGrpcSession&gt; sessionOpenListener,
&nbsp;                           BiConsumer&lt;Edge, UUID&gt; sessionCloseListener,
&nbsp;                           ScheduledExecutorService sendDownlinkExecutorService,
<b class="nc">&nbsp;                           int maxInboundMessageSize, int maxHighPriorityQueueSizePerSession) {</b>
<b class="nc">&nbsp;        this.sessionId = UUID.randomUUID();</b>
<b class="nc">&nbsp;        this.ctx = ctx;</b>
<b class="nc">&nbsp;        this.outputStream = outputStream;</b>
<b class="nc">&nbsp;        this.sessionOpenListener = sessionOpenListener;</b>
<b class="nc">&nbsp;        this.sessionCloseListener = sessionCloseListener;</b>
<b class="nc">&nbsp;        this.sendDownlinkExecutorService = sendDownlinkExecutorService;</b>
<b class="nc">&nbsp;        this.maxInboundMessageSize = maxInboundMessageSize;</b>
<b class="nc">&nbsp;        this.maxHighPriorityQueueSizePerSession = maxHighPriorityQueueSizePerSession;</b>
<b class="nc">&nbsp;        initInputStream();</b>
&nbsp;    }
&nbsp;
&nbsp;    protected abstract ListenableFuture&lt;Boolean&gt; migrateEdgeEvents() throws Exception;
&nbsp;
&nbsp;    public void initInputStream() {
<b class="nc">&nbsp;        inputStream = new StreamObserver&lt;&gt;() {</b>
&nbsp;            @Override
&nbsp;            public void onNext(RequestMsg requestMsg) {
<b class="nc">&nbsp;                if (!connected &amp;&amp; requestMsg.getMsgType().equals(RequestMsgType.CONNECT_RPC_MESSAGE)) {</b>
<b class="nc">&nbsp;                    ConnectResponseMsg responseMsg = processConnect(requestMsg.getConnectRequestMsg());</b>
<b class="nc">&nbsp;                    outputStream.onNext(ResponseMsg.newBuilder()</b>
<b class="nc">&nbsp;                            .setConnectResponseMsg(responseMsg)</b>
<b class="nc">&nbsp;                            .build());</b>
<b class="nc">&nbsp;                    if (ConnectResponseCode.ACCEPTED != responseMsg.getResponseCode()) {</b>
<b class="nc">&nbsp;                        outputStream.onError(new RuntimeException(responseMsg.getErrorMsg()));</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        if (requestMsg.getConnectRequestMsg().hasMaxInboundMessageSize()) {</b>
<b class="nc">&nbsp;                            log.debug(&quot;[{}][{}] Client max inbound message size: {}&quot;, tenantId, sessionId, requestMsg.getConnectRequestMsg().getMaxInboundMessageSize());</b>
<b class="nc">&nbsp;                            clientMaxInboundMessageSize = requestMsg.getConnectRequestMsg().getMaxInboundMessageSize();</b>
&nbsp;                        }
<b class="nc">&nbsp;                        connected = true;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                if (connected) {</b>
<b class="nc">&nbsp;                    if (requestMsg.getMsgType().equals(RequestMsgType.SYNC_REQUEST_RPC_MESSAGE)) {</b>
<b class="nc">&nbsp;                        if (requestMsg.hasSyncRequestMsg()) {</b>
<b class="nc">&nbsp;                            boolean fullSync = false;</b>
<b class="nc">&nbsp;                            if (requestMsg.getSyncRequestMsg().hasFullSync()) {</b>
<b class="nc">&nbsp;                                fullSync = requestMsg.getSyncRequestMsg().getFullSync();</b>
&nbsp;                            }
<b class="nc">&nbsp;                            startSyncProcess(fullSync);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            syncInProgress = false;</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    if (requestMsg.getMsgType().equals(RequestMsgType.UPLINK_RPC_MESSAGE)) {</b>
<b class="nc">&nbsp;                        if (requestMsg.hasUplinkMsg()) {</b>
<b class="nc">&nbsp;                            onUplinkMsg(requestMsg.getUplinkMsg());</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (requestMsg.hasDownlinkResponseMsg()) {</b>
<b class="nc">&nbsp;                            onDownlinkResponse(requestMsg.getDownlinkResponseMsg());</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void onError(Throwable t) {
<b class="nc">&nbsp;                log.trace(&quot;[{}][{}] Stream was terminated due to error:&quot;, tenantId, sessionId, t);</b>
<b class="nc">&nbsp;                closeSession();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void onCompleted() {
<b class="nc">&nbsp;                log.info(&quot;[{}][{}] Stream was closed and completed successfully!&quot;, tenantId, sessionId);</b>
<b class="nc">&nbsp;                closeSession();</b>
&nbsp;            }
&nbsp;
&nbsp;            private void closeSession() {
<b class="nc">&nbsp;                connected = false;</b>
<b class="nc">&nbsp;                if (edge != null) {</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        sessionCloseListener.accept(edge, sessionId);</b>
&nbsp;                    } catch (Exception ignored) {
&nbsp;                    }
&nbsp;                }
&nbsp;                try {
<b class="nc">&nbsp;                    outputStream.onCompleted();</b>
&nbsp;                } catch (Exception ignored) {
&nbsp;                }
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    public void onConfigurationUpdate(Edge edge) {
<b class="nc">&nbsp;        log.debug(&quot;[{}] onConfigurationUpdate [{}]&quot;, sessionId, edge);</b>
<b class="nc">&nbsp;        this.tenantId = edge.getTenantId();</b>
<b class="nc">&nbsp;        this.edge = edge;</b>
<b class="nc">&nbsp;        EdgeUpdateMsg edgeConfig = EdgeUpdateMsg.newBuilder()</b>
<b class="nc">&nbsp;                .setConfiguration(EdgeMsgConstructorUtils.constructEdgeConfiguration(edge)).build();</b>
<b class="nc">&nbsp;        ResponseMsg edgeConfigMsg = ResponseMsg.newBuilder()</b>
<b class="nc">&nbsp;                .setEdgeUpdateMsg(edgeConfig)</b>
<b class="nc">&nbsp;                .build();</b>
<b class="nc">&nbsp;        sendDownlinkMsg(edgeConfigMsg);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void startSyncProcess(boolean fullSync) {
<b class="nc">&nbsp;        if (!syncInProgress) {</b>
<b class="nc">&nbsp;            log.info(&quot;[{}][{}][{}] Staring edge sync process&quot;, tenantId, edge.getId(), sessionId);</b>
<b class="nc">&nbsp;            syncInProgress = true;</b>
<b class="nc">&nbsp;            interruptGeneralProcessingOnSync();</b>
<b class="nc">&nbsp;            doSync(new EdgeSyncCursor(ctx, edge, fullSync));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            log.info(&quot;[{}][{}][{}] Sync is already started, skipping starting it now&quot;, tenantId, edge.getId(), sessionId);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void doSync(EdgeSyncCursor cursor) {
<b class="nc">&nbsp;        if (cursor.hasNext()) {</b>
<b class="nc">&nbsp;            EdgeEventFetcher next = cursor.getNext();</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}][{}] starting sync process, cursor current idx = {}, class = {}&quot;,</b>
<b class="nc">&nbsp;                    tenantId, edge.getId(), cursor.getCurrentIdx(), next.getClass().getSimpleName());</b>
<b class="nc">&nbsp;            ListenableFuture&lt;Pair&lt;Long, Long&gt;&gt; future = startProcessingEdgeEvents(next);</b>
<b class="nc">&nbsp;            Futures.addCallback(future, new FutureCallback&lt;&gt;() {</b>
&nbsp;                @Override
&nbsp;                public void onSuccess(@Nullable Pair&lt;Long, Long&gt; result) {
<b class="nc">&nbsp;                    doSync(cursor);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onFailure(Throwable t) {
<b class="nc">&nbsp;                    log.error(&quot;[{}][{}] Exception during sync process&quot;, tenantId, edge.getId(), t);</b>
&nbsp;                }
<b class="nc">&nbsp;            }, ctx.getGrpcCallbackExecutorService());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            log.info(&quot;[{}][{}] sync process completed&quot;, tenantId, edge.getId());</b>
<b class="nc">&nbsp;            DownlinkMsg syncCompleteDownlinkMsg = DownlinkMsg.newBuilder()</b>
<b class="nc">&nbsp;                    .setDownlinkMsgId(EdgeUtils.nextPositiveInt())</b>
<b class="nc">&nbsp;                    .setSyncCompletedMsg(SyncCompletedMsg.newBuilder().build())</b>
<b class="nc">&nbsp;                    .build();</b>
<b class="nc">&nbsp;            Futures.addCallback(sendDownlinkMsgsPack(Collections.singletonList(syncCompleteDownlinkMsg)), new FutureCallback&lt;&gt;() {</b>
&nbsp;                @Override
&nbsp;                public void onSuccess(Boolean isInterrupted) {
<b class="nc">&nbsp;                    markSyncCompletedSendEdgeEventUpdate();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onFailure(Throwable t) {
<b class="nc">&nbsp;                    log.error(&quot;[{}][{}] Exception during sending sync complete&quot;, tenantId, edge.getId(), t);</b>
<b class="nc">&nbsp;                    markSyncCompletedSendEdgeEventUpdate();</b>
&nbsp;                }
<b class="nc">&nbsp;            }, ctx.getGrpcCallbackExecutorService());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected void processEdgeEvents(EdgeEventFetcher fetcher, PageLink pageLink, SettableFuture&lt;Pair&lt;Long, Long&gt;&gt; result) {
&nbsp;        try {
<b class="nc">&nbsp;            log.trace(&quot;[{}] Start processing edge events, fetcher = {}, pageLink = {}&quot;, edge.getId(), fetcher.getClass().getSimpleName(), pageLink);</b>
<b class="nc">&nbsp;            processHighPriorityEvents();</b>
<b class="nc">&nbsp;            PageData&lt;EdgeEvent&gt; pageData = fetcher.fetchEdgeEvents(edge.getTenantId(), edge, pageLink);</b>
<b class="nc">&nbsp;            if (isConnected() &amp;&amp; !pageData.getData().isEmpty()) {</b>
<b class="nc">&nbsp;                if (fetcher instanceof GeneralEdgeEventFetcher) {</b>
<b class="nc">&nbsp;                    long queueSize = pageData.getTotalElements() - ((long) pageLink.getPageSize() * pageLink.getPage());</b>
<b class="nc">&nbsp;                    ctx.getStatsCounterService().ifPresent(statsCounterService -&gt;</b>
<b class="nc">&nbsp;                            statsCounterService.recordEvent(EdgeStatsKey.DOWNLINK_MSGS_LAG, tenantId, edge.getId(), queueSize));</b>
&nbsp;                }
<b class="nc">&nbsp;                log.trace(&quot;[{}][{}][{}] event(s) are going to be processed.&quot;, tenantId, edge.getId(), pageData.getData().size());</b>
<b class="nc">&nbsp;                List&lt;DownlinkMsg&gt; downlinkMsgsPack = convertToDownlinkMsgsPack(pageData.getData());</b>
<b class="nc">&nbsp;                Futures.addCallback(sendDownlinkMsgsPack(downlinkMsgsPack), new FutureCallback&lt;&gt;() {</b>
&nbsp;                    @Override
&nbsp;                    public void onSuccess(@Nullable Boolean isInterrupted) {
<b class="nc">&nbsp;                        if (Boolean.TRUE.equals(isInterrupted)) {</b>
<b class="nc">&nbsp;                            log.debug(&quot;[{}][{}][{}] Send downlink messages task was interrupted&quot;, tenantId, edge.getId(), sessionId);</b>
<b class="nc">&nbsp;                            result.set(null);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            if (isConnected() &amp;&amp; pageData.hasNext()) {</b>
<b class="nc">&nbsp;                                processEdgeEvents(fetcher, pageLink.nextPageLink(), result);</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                EdgeEvent latestEdgeEvent = pageData.getData().get(pageData.getData().size() - 1);</b>
<b class="nc">&nbsp;                                UUID idOffset = latestEdgeEvent.getUuidId();</b>
<b class="nc">&nbsp;                                if (idOffset != null) {</b>
<b class="nc">&nbsp;                                    Long newStartTs = Uuids.unixTimestamp(idOffset);</b>
<b class="nc">&nbsp;                                    long newStartSeqId = latestEdgeEvent.getSeqId();</b>
<b class="nc">&nbsp;                                    result.set(Pair.of(newStartTs, newStartSeqId));</b>
&nbsp;                                } else {
<b class="nc">&nbsp;                                    result.set(null);</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void onFailure(Throwable t) {
<b class="nc">&nbsp;                        log.error(&quot;[{}] Failed to send downlink msgs pack&quot;, edge.getId(), t);</b>
<b class="nc">&nbsp;                        result.setException(t);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }, ctx.getGrpcCallbackExecutorService());</b>
&nbsp;            } else {
<b class="nc">&nbsp;                log.trace(&quot;[{}] no event(s) found. Stop processing edge events, fetcher = {}, pageLink = {}&quot;, edge.getId(), fetcher.getClass().getSimpleName(), pageLink);</b>
<b class="nc">&nbsp;                result.set(null);</b>
&nbsp;            }
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.error(&quot;[{}] Failed to fetch edge events&quot;, edge.getId(), e);</b>
<b class="nc">&nbsp;            result.setException(e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private ConnectResponseMsg processConnect(ConnectRequestMsg request) {
<b class="nc">&nbsp;        log.trace(&quot;[{}] processConnect [{}]&quot;, sessionId, request);</b>
<b class="nc">&nbsp;        Optional&lt;Edge&gt; optional = ctx.getEdgeService().findEdgeByRoutingKey(TenantId.SYS_TENANT_ID, request.getEdgeRoutingKey());</b>
<b class="nc">&nbsp;        if (optional.isPresent()) {</b>
<b class="nc">&nbsp;            edge = optional.get();</b>
<b class="nc">&nbsp;            tenantId = edge.getTenantId();</b>
&nbsp;            try {
<b class="nc">&nbsp;                if (edge.getSecret().equals(request.getEdgeSecret())) {</b>
<b class="nc">&nbsp;                    sessionOpenListener.accept(edge.getId(), this);</b>
<b class="nc">&nbsp;                    edgeVersion = request.getEdgeVersion();</b>
<b class="nc">&nbsp;                    processSaveEdgeVersionAsAttribute(request.getEdgeVersion().name());</b>
<b class="nc">&nbsp;                    return ConnectResponseMsg.newBuilder()</b>
<b class="nc">&nbsp;                            .setResponseCode(ConnectResponseCode.ACCEPTED)</b>
<b class="nc">&nbsp;                            .setErrorMsg(&quot;&quot;)</b>
<b class="nc">&nbsp;                            .setConfiguration(EdgeMsgConstructorUtils.constructEdgeConfiguration(edge))</b>
<b class="nc">&nbsp;                            .setMaxInboundMessageSize(maxInboundMessageSize)</b>
<b class="nc">&nbsp;                            .build();</b>
&nbsp;                }
<b class="nc">&nbsp;                String error = &quot;Failed to validate the edge!&quot;;</b>
<b class="nc">&nbsp;                String failureMsg = String.format(&quot;%s Provided request secret: %s&quot;, error, request.getEdgeSecret());</b>
<b class="nc">&nbsp;                ctx.getRuleProcessor().process(EdgeCommunicationFailureTrigger.builder().tenantId(tenantId).edgeId(edge.getId())</b>
<b class="nc">&nbsp;                        .customerId(edge.getCustomerId()).edgeName(edge.getName()).failureMsg(failureMsg).error(error).build());</b>
<b class="nc">&nbsp;                return ConnectResponseMsg.newBuilder()</b>
<b class="nc">&nbsp;                        .setResponseCode(ConnectResponseCode.BAD_CREDENTIALS)</b>
<b class="nc">&nbsp;                        .setErrorMsg(failureMsg)</b>
<b class="nc">&nbsp;                        .setConfiguration(EdgeConfiguration.getDefaultInstance()).build();</b>
&nbsp;            } catch (Exception e) {
<b class="nc">&nbsp;                String failureMsg = &quot;Failed to process edge connection!&quot;;</b>
<b class="nc">&nbsp;                ctx.getRuleProcessor().process(EdgeCommunicationFailureTrigger.builder().tenantId(tenantId).edgeId(edge.getId())</b>
<b class="nc">&nbsp;                        .customerId(edge.getCustomerId()).edgeName(edge.getName()).failureMsg(failureMsg).error(e.getMessage()).build());</b>
<b class="nc">&nbsp;                log.error(failureMsg, e);</b>
<b class="nc">&nbsp;                return ConnectResponseMsg.newBuilder()</b>
<b class="nc">&nbsp;                        .setResponseCode(ConnectResponseCode.SERVER_UNAVAILABLE)</b>
<b class="nc">&nbsp;                        .setErrorMsg(failureMsg)</b>
<b class="nc">&nbsp;                        .setConfiguration(EdgeConfiguration.getDefaultInstance()).build();</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return ConnectResponseMsg.newBuilder()</b>
<b class="nc">&nbsp;                .setResponseCode(ConnectResponseCode.BAD_CREDENTIALS)</b>
<b class="nc">&nbsp;                .setErrorMsg(&quot;Failed to find the edge! Routing key: &quot; + request.getEdgeRoutingKey())</b>
<b class="nc">&nbsp;                .setConfiguration(EdgeConfiguration.getDefaultInstance()).build();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void processSaveEdgeVersionAsAttribute(String edgeVersion) {
<b class="nc">&nbsp;        AttributeKvEntry attributeKvEntry = new BaseAttributeKvEntry(new StringDataEntry(DataConstants.EDGE_VERSION_ATTR_KEY, edgeVersion), System.currentTimeMillis());</b>
<b class="nc">&nbsp;        ctx.getAttributesService().save(tenantId, edge.getId(), AttributeScope.SERVER_SCOPE, attributeKvEntry);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void interruptGeneralProcessingOnSync() {
<b class="nc">&nbsp;        log.debug(&quot;[{}][{}][{}] Sync process started. General processing interrupted!&quot;, tenantId, edge.getId(), sessionId);</b>
<b class="nc">&nbsp;        stopCurrentSendDownlinkMsgsTask(true);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected ListenableFuture&lt;Boolean&gt; sendDownlinkMsgsPack(List&lt;DownlinkMsg&gt; downlinkMsgsPack) {
<b class="nc">&nbsp;        interruptPreviousSendDownlinkMsgsTask();</b>
&nbsp;
<b class="nc">&nbsp;        sessionState.setSendDownlinkMsgsFuture(SettableFuture.create());</b>
<b class="nc">&nbsp;        sessionState.getPendingMsgsMap().clear();</b>
&nbsp;
<b class="nc">&nbsp;        downlinkMsgsPack.forEach(msg -&gt; sessionState.getPendingMsgsMap().put(msg.getDownlinkMsgId(), msg));</b>
<b class="nc">&nbsp;        scheduleDownlinkMsgsPackSend(1);</b>
&nbsp;
<b class="nc">&nbsp;        return sessionState.getSendDownlinkMsgsFuture();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void interruptPreviousSendDownlinkMsgsTask() {
<b class="nc">&nbsp;        if (sessionState.getSendDownlinkMsgsFuture() != null &amp;&amp; !sessionState.getSendDownlinkMsgsFuture().isDone()</b>
<b class="nc">&nbsp;                || sessionState.getScheduledSendDownlinkTask() != null &amp;&amp; !sessionState.getScheduledSendDownlinkTask().isCancelled()) {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}][{}][{}] Previous send downlink future was not properly completed, stopping it now!&quot;, tenantId, edge.getId(), sessionId);</b>
<b class="nc">&nbsp;            stopCurrentSendDownlinkMsgsTask(true);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}][{}] Previous send downlink future is not active&quot;, tenantId, edge.getId(), sessionId);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void onUplinkMsg(UplinkMsg uplinkMsg) {
<b class="nc">&nbsp;        if (isRateLimitViolated(uplinkMsg)) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        ListenableFuture&lt;List&lt;Void&gt;&gt; future = processUplinkMsg(uplinkMsg);</b>
<b class="nc">&nbsp;        Futures.addCallback(future, new FutureCallback&lt;&gt;() {</b>
&nbsp;            @Override
&nbsp;            public void onSuccess(@Nullable List&lt;Void&gt; result) {
<b class="nc">&nbsp;                sendResponseMessage(uplinkMsg.getUplinkMsgId(), true, null);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void onFailure(Throwable t) {
<b class="nc">&nbsp;                String errorMsg = EdgeUtils.createErrorMsgFromRootCauseAndStackTrace(t);</b>
<b class="nc">&nbsp;                sendResponseMessage(uplinkMsg.getUplinkMsgId(), false, errorMsg);</b>
&nbsp;            }
<b class="nc">&nbsp;        }, ctx.getGrpcCallbackExecutorService());</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean isRateLimitViolated(UplinkMsg uplinkMsg) {
<b class="nc">&nbsp;        if (!ctx.getRateLimitService().checkRateLimit(LimitedApi.EDGE_UPLINK_MESSAGES, tenantId) ||</b>
<b class="nc">&nbsp;                !ctx.getRateLimitService().checkRateLimit(LimitedApi.EDGE_UPLINK_MESSAGES_PER_EDGE, tenantId, edge.getId())) {</b>
<b class="nc">&nbsp;            String errorMsg = String.format(&quot;Failed to process uplink message. %s&quot;, RATE_LIMIT_REACHED);</b>
<b class="nc">&nbsp;            sendResponseMessage(uplinkMsg.getUplinkMsgId(), false, errorMsg);</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void scheduleDownlinkMsgsPackSend(int attempt) {
<b class="nc">&nbsp;        Runnable sendDownlinkMsgsTask = () -&gt; {</b>
&nbsp;            try {
<b class="nc">&nbsp;                if (!isConnected()) {</b>
<b class="nc">&nbsp;                    stopCurrentSendDownlinkMsgsTask(true);</b>
&nbsp;                    return;
&nbsp;                }
<b class="nc">&nbsp;                if (!sessionState.getPendingMsgsMap().values().isEmpty()) {</b>
<b class="nc">&nbsp;                    List&lt;DownlinkMsg&gt; copy = new ArrayList&lt;&gt;(sessionState.getPendingMsgsMap().values());</b>
<b class="nc">&nbsp;                    if (attempt &gt; 1) {</b>
<b class="nc">&nbsp;                        String error = &quot;Failed to deliver the batch&quot;;</b>
<b class="nc">&nbsp;                        String failureMsg = String.format(&quot;{%s} (size: {%s})&quot;, error, copy.size());</b>
<b class="nc">&nbsp;                        if (attempt == 2) {</b>
&nbsp;                            // Send a failure notification only on the second attempt.
&nbsp;                            // This ensures that failure alerts are sent just once to avoid redundant notifications.
<b class="nc">&nbsp;                            ctx.getRuleProcessor().process(EdgeCommunicationFailureTrigger.builder().tenantId(tenantId)</b>
<b class="nc">&nbsp;                                    .edgeId(edge.getId()).customerId(edge.getCustomerId()).edgeName(edge.getName()).failureMsg(failureMsg).error(error).build());</b>
&nbsp;                        }
<b class="nc">&nbsp;                        ctx.getStatsCounterService().ifPresent(statsCounterService -&gt;</b>
<b class="nc">&nbsp;                                statsCounterService.recordEvent(EdgeStatsKey.DOWNLINK_MSGS_TMP_FAILED, edge.getTenantId(), edge.getId(), 1));</b>
<b class="nc">&nbsp;                        log.warn(&quot;[{}][{}] {} on attempt {}&quot;, tenantId, edge.getId(), failureMsg, attempt);</b>
<b class="nc">&nbsp;                        log.debug(&quot;[{}][{}] entities in failed batch: {}&quot;, tenantId, edge.getId(), copy);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    log.trace(&quot;[{}][{}][{}] downlink msg(s) are going to be send.&quot;, tenantId, edge.getId(), copy.size());</b>
<b class="nc">&nbsp;                    for (DownlinkMsg downlinkMsg : copy) {</b>
<b class="nc">&nbsp;                        if (clientMaxInboundMessageSize != 0 &amp;&amp; downlinkMsg.getSerializedSize() &gt; clientMaxInboundMessageSize) {</b>
<b class="nc">&nbsp;                            String error = String.format(&quot;Client max inbound message size %s is exceeded. Please increase value of CLOUD_RPC_MAX_INBOUND_MESSAGE_SIZE &quot; +</b>
<b class="nc">&nbsp;                                    &quot;env variable on the edge and restart it.&quot;, clientMaxInboundMessageSize);</b>
<b class="nc">&nbsp;                            String message = String.format(&quot;Downlink msg size %s exceeds client max inbound message size %s. &quot; +</b>
<b class="nc">&nbsp;                                    &quot;Please increase value of CLOUD_RPC_MAX_INBOUND_MESSAGE_SIZE env variable on the edge and restart it.&quot;, downlinkMsg.getSerializedSize(), clientMaxInboundMessageSize);</b>
<b class="nc">&nbsp;                            log.error(&quot;[{}][{}][{}] {} Message {}&quot;, tenantId, edge.getId(), sessionId, message, downlinkMsg);</b>
<b class="nc">&nbsp;                            ctx.getRuleProcessor().process(EdgeCommunicationFailureTrigger.builder().tenantId(tenantId)</b>
<b class="nc">&nbsp;                                    .edgeId(edge.getId()).customerId(edge.getCustomerId()).edgeName(edge.getName()).failureMsg(message).error(error).build());</b>
<b class="nc">&nbsp;                            ctx.getStatsCounterService().ifPresent(statsCounterService -&gt;</b>
<b class="nc">&nbsp;                                    statsCounterService.recordEvent(EdgeStatsKey.DOWNLINK_MSGS_PERMANENTLY_FAILED, edge.getTenantId(), edge.getId(), 1));</b>
<b class="nc">&nbsp;                            sessionState.getPendingMsgsMap().remove(downlinkMsg.getDownlinkMsgId());</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            sendDownlinkMsg(ResponseMsg.newBuilder()</b>
<b class="nc">&nbsp;                                    .setDownlinkMsg(downlinkMsg)</b>
<b class="nc">&nbsp;                                    .build());</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    if (attempt &lt; MAX_DOWNLINK_ATTEMPTS) {</b>
<b class="nc">&nbsp;                        scheduleDownlinkMsgsPackSend(attempt + 1);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        String failureMsg = String.format(&quot;Failed to deliver messages: %s&quot;, copy);</b>
<b class="nc">&nbsp;                        log.warn(&quot;[{}][{}] Failed to deliver the batch after {} attempts. Next messages are going to be discarded {}&quot;,</b>
<b class="nc">&nbsp;                                tenantId, edge.getId(), MAX_DOWNLINK_ATTEMPTS, copy);</b>
<b class="nc">&nbsp;                        ctx.getRuleProcessor().process(EdgeCommunicationFailureTrigger.builder().tenantId(tenantId).edgeId(edge.getId())</b>
<b class="nc">&nbsp;                                .customerId(edge.getCustomerId()).edgeName(edge.getName()).failureMsg(failureMsg)</b>
<b class="nc">&nbsp;                                .error(&quot;Failed to deliver messages after &quot; + MAX_DOWNLINK_ATTEMPTS + &quot; attempts&quot;).build());</b>
<b class="nc">&nbsp;                        ctx.getStatsCounterService().ifPresent(statsCounterService -&gt;</b>
<b class="nc">&nbsp;                                statsCounterService.recordEvent(EdgeStatsKey.DOWNLINK_MSGS_PERMANENTLY_FAILED, edge.getTenantId(), edge.getId(), copy.size()));</b>
<b class="nc">&nbsp;                        stopCurrentSendDownlinkMsgsTask(false);</b>
&nbsp;                    }
&nbsp;                } else {
<b class="nc">&nbsp;                    stopCurrentSendDownlinkMsgsTask(false);</b>
&nbsp;                }
&nbsp;            } catch (Exception e) {
<b class="nc">&nbsp;                log.warn(&quot;[{}][{}] Failed to send downlink msgs. Error msg {}&quot;, tenantId, edge.getId(), e.getMessage(), e);</b>
<b class="nc">&nbsp;                stopCurrentSendDownlinkMsgsTask(true);</b>
&nbsp;            }
&nbsp;        };
&nbsp;
<b class="nc">&nbsp;        if (attempt == 1) {</b>
<b class="nc">&nbsp;            sendDownlinkExecutorService.submit(sendDownlinkMsgsTask);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            sessionState.setScheduledSendDownlinkTask(</b>
<b class="nc">&nbsp;                    sendDownlinkExecutorService.schedule(</b>
&nbsp;                            sendDownlinkMsgsTask,
<b class="nc">&nbsp;                            ctx.getEdgeEventStorageSettings().getSleepIntervalBetweenBatches(),</b>
&nbsp;                            TimeUnit.MILLISECONDS)
&nbsp;            );
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void sendResponseMessage(int uplinkMsgId, boolean success, String errorMsg) {
<b class="nc">&nbsp;        UplinkResponseMsg.Builder responseBuilder = UplinkResponseMsg.newBuilder()</b>
<b class="nc">&nbsp;                .setUplinkMsgId(uplinkMsgId)</b>
<b class="nc">&nbsp;                .setSuccess(success);</b>
<b class="nc">&nbsp;        if (errorMsg != null) {</b>
<b class="nc">&nbsp;            responseBuilder.setErrorMsg(errorMsg);</b>
&nbsp;        }
<b class="nc">&nbsp;        sendDownlinkMsg(ResponseMsg.newBuilder()</b>
<b class="nc">&nbsp;                .setUplinkResponseMsg(responseBuilder.build())</b>
<b class="nc">&nbsp;                .build());</b>
&nbsp;    }
&nbsp;
&nbsp;    private void onDownlinkResponse(DownlinkResponseMsg msg) {
&nbsp;        try {
<b class="nc">&nbsp;            if (msg.getSuccess()) {</b>
<b class="nc">&nbsp;                sessionState.getPendingMsgsMap().remove(msg.getDownlinkMsgId());</b>
<b class="nc">&nbsp;                ctx.getStatsCounterService().ifPresent(statsCounterService -&gt;</b>
<b class="nc">&nbsp;                        statsCounterService.recordEvent(EdgeStatsKey.DOWNLINK_MSGS_PUSHED, edge.getTenantId(), edge.getId(), 1));</b>
<b class="nc">&nbsp;                log.debug(&quot;[{}][{}][{}] Msg has been processed successfully! Msg Id: [{}], Msg: {}&quot;, tenantId, edge.getId(), sessionId, msg.getDownlinkMsgId(), msg);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                log.debug(&quot;[{}][{}][{}] Msg processing failed! Msg Id: [{}], Error msg: {}&quot;, tenantId, edge.getId(), sessionId, msg.getDownlinkMsgId(), msg.getErrorMsg());</b>
<b class="nc">&nbsp;                DownlinkMsg downlinkMsg = sessionState.getPendingMsgsMap().get(msg.getDownlinkMsgId());</b>
&nbsp;                // if NOT timeseries or attributes failures - ack failed downlink
<b class="nc">&nbsp;                if (downlinkMsg.getEntityDataCount() == 0) {</b>
<b class="nc">&nbsp;                    sessionState.getPendingMsgsMap().remove(msg.getDownlinkMsgId());</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (sessionState.getPendingMsgsMap().isEmpty()) {</b>
<b class="nc">&nbsp;                log.debug(&quot;[{}][{}][{}] Pending msgs map is empty. Stopping current iteration&quot;, tenantId, edge.getId(), sessionId);</b>
<b class="nc">&nbsp;                stopCurrentSendDownlinkMsgsTask(false);</b>
&nbsp;            }
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.error(&quot;[{}][{}] Can&#39;t process downlink response message [{}]&quot;, tenantId, edge.getId(), msg, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void processHighPriorityEvents() {
&nbsp;        try {
<b class="nc">&nbsp;            if (isConnected() &amp;&amp; !isSyncInProgress()) {</b>
<b class="nc">&nbsp;                if (highPriorityQueue.isEmpty()) {</b>
&nbsp;                    return;
&nbsp;                }
<b class="nc">&nbsp;                List&lt;EdgeEvent&gt; highPriorityEvents = new ArrayList&lt;&gt;();</b>
&nbsp;                EdgeEvent event;
<b class="nc">&nbsp;                while ((event = highPriorityQueue.poll()) != null) {</b>
<b class="nc">&nbsp;                    highPriorityEvents.add(event);</b>
&nbsp;                }
<b class="nc">&nbsp;                log.trace(&quot;[{}][{}] Sending high priority events {}&quot;, tenantId, edge.getId(), highPriorityEvents.size());</b>
<b class="nc">&nbsp;                List&lt;DownlinkMsg&gt; downlinkMsgsPack = convertToDownlinkMsgsPack(highPriorityEvents);</b>
<b class="nc">&nbsp;                sendDownlinkMsgsPack(downlinkMsgsPack).get();</b>
&nbsp;            }
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.error(&quot;[{}] Failed to process high priority events&quot;, edge.getId(), e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public ListenableFuture&lt;Boolean&gt; processEdgeEvents() throws Exception {
<b class="nc">&nbsp;        SettableFuture&lt;Boolean&gt; result = SettableFuture.create();</b>
<b class="nc">&nbsp;        if (isConnected() &amp;&amp; !isSyncInProgress()) {</b>
<b class="nc">&nbsp;            Pair&lt;Long, Long&gt; startTsAndSeqId = getQueueStartTsAndSeqId().get();</b>
<b class="nc">&nbsp;            previousStartTs = startTsAndSeqId.getFirst();</b>
<b class="nc">&nbsp;            previousStartSeqId = startTsAndSeqId.getSecond();</b>
<b class="nc">&nbsp;            GeneralEdgeEventFetcher fetcher = new GeneralEdgeEventFetcher(</b>
&nbsp;                    previousStartTs,
&nbsp;                    previousStartSeqId,
&nbsp;                    false,
<b class="nc">&nbsp;                    Integer.toUnsignedLong(ctx.getEdgeEventStorageSettings().getMaxReadRecordsCount()),</b>
<b class="nc">&nbsp;                    ctx.getEdgeEventService(),</b>
<b class="nc">&nbsp;                    ctx.getEdgeEventStorageSettings().getMisorderingCompensationMillis());</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}] starting processing edge events, previousStartTs = {}, previousStartSeqId = {}&quot;,</b>
<b class="nc">&nbsp;                    tenantId, edge.getId(), previousStartTs, previousStartSeqId);</b>
<b class="nc">&nbsp;            Futures.addCallback(startProcessingEdgeEvents(fetcher), new FutureCallback&lt;&gt;() {</b>
&nbsp;                @Override
&nbsp;                public void onSuccess(@Nullable Pair&lt;Long, Long&gt; newStartTsAndSeqId) {
<b class="nc">&nbsp;                    if (newStartTsAndSeqId != null) {</b>
<b class="nc">&nbsp;                        ListenableFuture&lt;AttributesSaveResult&gt; updateFuture = updateQueueStartTsAndSeqId(newStartTsAndSeqId);</b>
<b class="nc">&nbsp;                        Futures.addCallback(updateFuture, new FutureCallback&lt;&gt;() {</b>
&nbsp;                            @Override
&nbsp;                            public void onSuccess(@Nullable AttributesSaveResult saveResult) {
<b class="nc">&nbsp;                                log.debug(&quot;[{}][{}] queue offset was updated [{}]&quot;, tenantId, edge.getId(), newStartTsAndSeqId);</b>
&nbsp;                                boolean newEventsAvailable;
<b class="nc">&nbsp;                                if (fetcher.isSeqIdNewCycleStarted()) {</b>
<b class="nc">&nbsp;                                    newEventsAvailable = isNewEdgeEventsAvailable();</b>
&nbsp;                                } else {
<b class="nc">&nbsp;                                    newEventsAvailable = isSeqIdStartedNewCycle();</b>
<b class="nc">&nbsp;                                    if (!newEventsAvailable) {</b>
<b class="nc">&nbsp;                                        newEventsAvailable = isNewEdgeEventsAvailable();</b>
&nbsp;                                    }
&nbsp;                                }
<b class="nc">&nbsp;                                result.set(newEventsAvailable);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public void onFailure(Throwable t) {
<b class="nc">&nbsp;                                log.error(&quot;[{}][{}] Failed to update queue offset [{}]&quot;, tenantId, edge.getId(), newStartTsAndSeqId, t);</b>
<b class="nc">&nbsp;                                result.setException(t);</b>
&nbsp;                            }
<b class="nc">&nbsp;                        }, ctx.getGrpcCallbackExecutorService());</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        log.trace(&quot;[{}][{}] newStartTsAndSeqId is null. Skipping iteration without db update&quot;, tenantId, edge.getId());</b>
<b class="nc">&nbsp;                        result.set(Boolean.FALSE);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onFailure(Throwable t) {
<b class="nc">&nbsp;                    log.error(&quot;[{}][{}] Failed to process events&quot;, tenantId, edge.getId(), t);</b>
<b class="nc">&nbsp;                    result.setException(t);</b>
&nbsp;                }
<b class="nc">&nbsp;            }, ctx.getGrpcCallbackExecutorService());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            if (isSyncInProgress()) {</b>
<b class="nc">&nbsp;                log.trace(&quot;[{}][{}] edge sync is not completed yet. Skipping iteration&quot;, tenantId, edge.getId());</b>
<b class="nc">&nbsp;                result.set(Boolean.TRUE);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                log.trace(&quot;[{}][{}] edge is not connected. Skipping iteration&quot;, tenantId, edge.getId());</b>
<b class="nc">&nbsp;                result.set(null);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected List&lt;DownlinkMsg&gt; convertToDownlinkMsgsPack(List&lt;EdgeEvent&gt; edgeEvents) {
<b class="nc">&nbsp;        List&lt;DownlinkMsg&gt; result = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        List&lt;EdgeEvent&gt; filtered = EdgeMsgConstructorUtils.mergeAndFilterDownlinkDuplicates(edgeEvents);</b>
<b class="nc">&nbsp;        for (EdgeEvent edgeEvent : filtered) {</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}] converting edge event to downlink msg [{}]&quot;, tenantId, edge.getId(), edgeEvent);</b>
<b class="nc">&nbsp;            DownlinkMsg downlinkMsg = null;</b>
&nbsp;            try {
<b class="nc">&nbsp;                switch (edgeEvent.getAction()) {</b>
&nbsp;                    case UPDATED, ADDED, DELETED, ASSIGNED_TO_EDGE, UNASSIGNED_FROM_EDGE, ALARM_ACK, ALARM_CLEAR,
&nbsp;                         ALARM_DELETE, CREDENTIALS_UPDATED, RELATION_ADD_OR_UPDATE, RELATION_DELETED, RPC_CALL,
&nbsp;                         ASSIGNED_TO_CUSTOMER, UNASSIGNED_FROM_CUSTOMER, ADDED_COMMENT, UPDATED_COMMENT, DELETED_COMMENT -&gt; {
<b class="nc">&nbsp;                        downlinkMsg = convertEntityEventToDownlink(edgeEvent);</b>
<b class="nc">&nbsp;                        if (downlinkMsg != null &amp;&amp; downlinkMsg.getWidgetTypeUpdateMsgCount() &gt; 0) {</b>
<b class="nc">&nbsp;                            log.trace(&quot;[{}][{}] widgetTypeUpdateMsg message processed, downlinkMsgId = {}&quot;, tenantId, edge.getId(), downlinkMsg.getDownlinkMsgId());</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            log.trace(&quot;[{}][{}] entity message processed [{}]&quot;, tenantId, edge.getId(), downlinkMsg);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                    case ATTRIBUTES_UPDATED, POST_ATTRIBUTES, ATTRIBUTES_DELETED, TIMESERIES_UPDATED -&gt;
<b class="nc">&nbsp;                            downlinkMsg = ctx.getTelemetryProcessor().convertTelemetryEventToDownlink(edge, edgeEvent);</b>
<b class="nc">&nbsp;                    default -&gt; log.warn(&quot;[{}][{}] Unsupported action type [{}]&quot;, tenantId, edge.getId(), edgeEvent.getAction());</b>
&nbsp;                }
&nbsp;            } catch (Exception e) {
<b class="nc">&nbsp;                log.trace(&quot;[{}][{}] Exception during converting edge event to downlink msg&quot;, tenantId, edge.getId(), e);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (downlinkMsg != null) {</b>
<b class="nc">&nbsp;                result.add(downlinkMsg);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    private ListenableFuture&lt;Pair&lt;Long, Long&gt;&gt; getQueueStartTsAndSeqId() {
<b class="nc">&nbsp;        ListenableFuture&lt;List&lt;AttributeKvEntry&gt;&gt; future =</b>
<b class="nc">&nbsp;                ctx.getAttributesService().find(edge.getTenantId(), edge.getId(), AttributeScope.SERVER_SCOPE, Arrays.asList(QUEUE_START_TS_ATTR_KEY, QUEUE_START_SEQ_ID_ATTR_KEY));</b>
<b class="nc">&nbsp;        return Futures.transform(future, attributeKvEntries -&gt; {</b>
<b class="nc">&nbsp;            long startTs = 0L;</b>
<b class="nc">&nbsp;            long startSeqId = 0L;</b>
<b class="nc">&nbsp;            for (AttributeKvEntry attributeKvEntry : attributeKvEntries) {</b>
<b class="nc">&nbsp;                if (QUEUE_START_TS_ATTR_KEY.equals(attributeKvEntry.getKey())) {</b>
<b class="nc">&nbsp;                    startTs = attributeKvEntry.getLongValue().isPresent() ? attributeKvEntry.getLongValue().get() : 0L;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (QUEUE_START_SEQ_ID_ATTR_KEY.equals(attributeKvEntry.getKey())) {</b>
<b class="nc">&nbsp;                    startSeqId = attributeKvEntry.getLongValue().isPresent() ? attributeKvEntry.getLongValue().get() : 0L;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (startSeqId == 0L) {</b>
<b class="nc">&nbsp;                startSeqId = findStartSeqIdFromOldestEventIfAny();</b>
&nbsp;            }
<b class="nc">&nbsp;            return Pair.of(startTs, startSeqId);</b>
<b class="nc">&nbsp;        }, ctx.getGrpcCallbackExecutorService());</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean isSeqIdStartedNewCycle() {
&nbsp;        try {
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}][{}] Checking if seq id started new cycle&quot;, tenantId, edge.getId(), sessionId);</b>
<b class="nc">&nbsp;            TimePageLink pageLink = new TimePageLink(ctx.getEdgeEventStorageSettings().getMaxReadRecordsCount(), 0, null, null, newStartTs, System.currentTimeMillis());</b>
<b class="nc">&nbsp;            PageData&lt;EdgeEvent&gt; edgeEvents = ctx.getEdgeEventService().findEdgeEvents(edge.getTenantId(), edge.getId(), 0L, previousStartSeqId == 0 ? null : previousStartSeqId - 1, pageLink);</b>
<b class="nc">&nbsp;            boolean result = !edgeEvents.getData().isEmpty();</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}][{}] Result of check if seq id started new cycle, result = {}&quot;, tenantId, edge.getId(), sessionId, result);</b>
<b class="nc">&nbsp;            return result;</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.error(&quot;[{}][{}][{}] Failed to execute isSeqIdStartedNewCycle&quot;, tenantId, edge.getId(), sessionId, e);</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean isNewEdgeEventsAvailable() {
&nbsp;        try {
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}][{}] Checking if new edge events available&quot;, tenantId, edge.getId(), sessionId);</b>
<b class="nc">&nbsp;            TimePageLink pageLink = new TimePageLink(ctx.getEdgeEventStorageSettings().getMaxReadRecordsCount(), 0, null, null, newStartTs, System.currentTimeMillis());</b>
<b class="nc">&nbsp;            PageData&lt;EdgeEvent&gt; edgeEvents = ctx.getEdgeEventService().findEdgeEvents(edge.getTenantId(), edge.getId(), newStartSeqId, null, pageLink);</b>
<b class="nc">&nbsp;            boolean result = !edgeEvents.getData().isEmpty() || !highPriorityQueue.isEmpty();</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}][{}] Result of check if new edge events available, result = {}&quot;, tenantId, edge.getId(), sessionId, result);</b>
<b class="nc">&nbsp;            return result;</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.error(&quot;[{}][{}][{}] Failed to execute isNewEdgeEventsAvailable&quot;, tenantId, edge.getId(), sessionId, e);</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    private long findStartSeqIdFromOldestEventIfAny() {
<b class="nc">&nbsp;        long startSeqId = 0L;</b>
&nbsp;        try {
<b class="nc">&nbsp;            TimePageLink pageLink = new TimePageLink(1, 0, null, null, null, null);</b>
<b class="nc">&nbsp;            PageData&lt;EdgeEvent&gt; edgeEvents = ctx.getEdgeEventService().findEdgeEvents(edge.getTenantId(), edge.getId(), null, null, pageLink);</b>
<b class="nc">&nbsp;            if (!edgeEvents.getData().isEmpty()) {</b>
<b class="nc">&nbsp;                startSeqId = edgeEvents.getData().get(0).getSeqId() - 1;</b>
&nbsp;            }
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.error(&quot;[{}][{}][{}] Failed to execute findStartSeqIdFromOldestEventIfAny&quot;, tenantId, edge.getId(), sessionId, e);</b>
&nbsp;        }
<b class="nc">&nbsp;        return startSeqId;</b>
&nbsp;    }
&nbsp;
&nbsp;    private ListenableFuture&lt;AttributesSaveResult&gt; updateQueueStartTsAndSeqId(Pair&lt;Long, Long&gt; pair) {
<b class="nc">&nbsp;        newStartTs = pair.getFirst();</b>
<b class="nc">&nbsp;        newStartSeqId = pair.getSecond();</b>
<b class="nc">&nbsp;        log.trace(&quot;[{}] updateQueueStartTsAndSeqId [{}][{}][{}]&quot;, sessionId, edge.getId(), newStartTs, newStartSeqId);</b>
<b class="nc">&nbsp;        List&lt;AttributeKvEntry&gt; attributes = List.of(</b>
<b class="nc">&nbsp;                new BaseAttributeKvEntry(new LongDataEntry(QUEUE_START_TS_ATTR_KEY, newStartTs), System.currentTimeMillis()),</b>
<b class="nc">&nbsp;                new BaseAttributeKvEntry(new LongDataEntry(QUEUE_START_SEQ_ID_ATTR_KEY, newStartSeqId), System.currentTimeMillis())</b>
&nbsp;        );
<b class="nc">&nbsp;        return ctx.getAttributesService().save(edge.getTenantId(), edge.getId(), AttributeScope.SERVER_SCOPE, attributes);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected ListenableFuture&lt;Pair&lt;Long, Long&gt;&gt; startProcessingEdgeEvents(EdgeEventFetcher fetcher) {
<b class="nc">&nbsp;        SettableFuture&lt;Pair&lt;Long, Long&gt;&gt; result = SettableFuture.create();</b>
<b class="nc">&nbsp;        PageLink pageLink = fetcher.getPageLink(ctx.getEdgeEventStorageSettings().getMaxReadRecordsCount());</b>
<b class="nc">&nbsp;        processEdgeEvents(fetcher, pageLink, result);</b>
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void markSyncCompletedSendEdgeEventUpdate() {
<b class="nc">&nbsp;        syncInProgress = false;</b>
<b class="nc">&nbsp;        ctx.getClusterService().onEdgeEventUpdate(new EdgeEventUpdateMsg(edge.getTenantId(), edge.getId()));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void stopCurrentSendDownlinkMsgsTask(Boolean isInterrupted) {
<b class="nc">&nbsp;        if (sessionState.getSendDownlinkMsgsFuture() != null &amp;&amp; !sessionState.getSendDownlinkMsgsFuture().isDone()) {</b>
<b class="nc">&nbsp;            sessionState.getSendDownlinkMsgsFuture().set(isInterrupted);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (sessionState.getScheduledSendDownlinkTask() != null) {</b>
<b class="nc">&nbsp;            sessionState.getScheduledSendDownlinkTask().cancel(true);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void sendDownlinkMsg(ResponseMsg responseMsg) {
<b class="nc">&nbsp;        if (isConnected()) {</b>
<b class="nc">&nbsp;            String responseMsgStr = StringUtils.truncate(responseMsg.toString(), 10000);</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}] Sending downlink msg [{}]&quot;, tenantId, edge.getId(), responseMsgStr);</b>
<b class="nc">&nbsp;            downlinkMsgLock.lock();</b>
<b class="nc">&nbsp;            String downlinkMsgStr = responseMsg.hasDownlinkMsg() ? String.valueOf(responseMsg.getDownlinkMsg().getDownlinkMsgId()) : responseMsgStr;</b>
&nbsp;            try {
<b class="nc">&nbsp;                outputStream.onNext(responseMsg);</b>
&nbsp;            } catch (Exception e) {
<b class="nc">&nbsp;                log.trace(&quot;[{}][{}] Failed to send downlink message [{}]&quot;, tenantId, edge.getId(), downlinkMsgStr, e);</b>
<b class="nc">&nbsp;                connected = false;</b>
<b class="nc">&nbsp;                sessionCloseListener.accept(edge, sessionId);</b>
&nbsp;            } finally {
<b class="nc">&nbsp;                downlinkMsgLock.unlock();</b>
&nbsp;            }
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}] downlink msg successfully sent [{}]&quot;, tenantId, edge.getId(), downlinkMsgStr);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected DownlinkMsg convertEntityEventToDownlink(EdgeEvent edgeEvent) {
<b class="nc">&nbsp;        log.trace(&quot;[{}] Executing convertEntityEventToDownlink, edgeEvent [{}], action [{}]&quot;, edgeEvent.getTenantId(), edgeEvent, edgeEvent.getAction());</b>
<b class="nc">&nbsp;        if ((EdgeEventType.OAUTH2_CLIENT.equals(edgeEvent.getType()) || EdgeEventType.DOMAIN.equals(edgeEvent.getType())) &amp;&amp;</b>
<b class="nc">&nbsp;                (EdgeVersionUtils.isEdgeVersionOlderThan(edgeVersion, EdgeVersion.V_3_8_0))) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return ctx.getProcessor(edgeEvent.getType()).convertEdgeEventToDownlink(edgeEvent, edgeVersion);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void addEventToHighPriorityQueue(EdgeEvent edgeEvent) {
<b class="nc">&nbsp;        while (highPriorityQueue.size() &gt; maxHighPriorityQueueSizePerSession) {</b>
<b class="nc">&nbsp;            EdgeEvent oldestHighPriority = highPriorityQueue.poll();</b>
<b class="nc">&nbsp;            if (oldestHighPriority != null) {</b>
<b class="nc">&nbsp;                log.warn(&quot;[{}][{}][{}] High priority queue is full. Removing oldest high priority event from queue {}&quot;,</b>
<b class="nc">&nbsp;                        tenantId, edge.getId(), sessionId, oldestHighPriority);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        highPriorityQueue.add(edgeEvent);</b>
<b class="nc">&nbsp;        ctx.getStatsCounterService().ifPresent(statsCounterService -&gt;</b>
<b class="nc">&nbsp;                statsCounterService.recordEvent(EdgeStatsKey.DOWNLINK_MSGS_ADDED, edge.getTenantId(), edgeEvent.getEdgeId(), 1));</b>
&nbsp;    }
&nbsp;
&nbsp;    protected ListenableFuture&lt;List&lt;Void&gt;&gt; processUplinkMsg(UplinkMsg uplinkMsg) {
<b class="nc">&nbsp;        List&lt;ListenableFuture&lt;Void&gt;&gt; result = new ArrayList&lt;&gt;();</b>
&nbsp;        try {
<b class="nc">&nbsp;            if (uplinkMsg.getDeviceProfileUpdateMsgCount() &gt; 0) {</b>
<b class="nc">&nbsp;                for (DeviceProfileUpdateMsg deviceProfileUpdateMsg : uplinkMsg.getDeviceProfileUpdateMsgList()) {</b>
<b class="nc">&nbsp;                    result.add(ctx.getDeviceProfileProcessor().processDeviceProfileMsgFromEdge(edge.getTenantId(), edge, deviceProfileUpdateMsg));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (uplinkMsg.getDeviceUpdateMsgCount() &gt; 0) {</b>
<b class="nc">&nbsp;                for (DeviceUpdateMsg deviceUpdateMsg : uplinkMsg.getDeviceUpdateMsgList()) {</b>
<b class="nc">&nbsp;                    result.add(ctx.getDeviceProcessor().processDeviceMsgFromEdge(edge.getTenantId(), edge, deviceUpdateMsg));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (uplinkMsg.getDeviceCredentialsUpdateMsgCount() &gt; 0) {</b>
<b class="nc">&nbsp;                for (DeviceCredentialsUpdateMsg deviceCredentialsUpdateMsg : uplinkMsg.getDeviceCredentialsUpdateMsgList()) {</b>
<b class="nc">&nbsp;                    result.add(ctx.getDeviceProcessor().processDeviceCredentialsMsgFromEdge(edge.getTenantId(), edge.getId(), deviceCredentialsUpdateMsg));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (uplinkMsg.getAssetProfileUpdateMsgCount() &gt; 0) {</b>
<b class="nc">&nbsp;                for (AssetProfileUpdateMsg assetProfileUpdateMsg : uplinkMsg.getAssetProfileUpdateMsgList()) {</b>
<b class="nc">&nbsp;                    result.add(ctx.getAssetProfileProcessor().processAssetProfileMsgFromEdge(edge.getTenantId(), edge, assetProfileUpdateMsg));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (uplinkMsg.getAssetUpdateMsgCount() &gt; 0) {</b>
<b class="nc">&nbsp;                for (AssetUpdateMsg assetUpdateMsg : uplinkMsg.getAssetUpdateMsgList()) {</b>
<b class="nc">&nbsp;                    result.add(ctx.getAssetProcessor().processAssetMsgFromEdge(edge.getTenantId(), edge, assetUpdateMsg));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (uplinkMsg.getRuleChainUpdateMsgCount() &gt; 0) {</b>
<b class="nc">&nbsp;                for (RuleChainUpdateMsg ruleChainUpdateMsg : uplinkMsg.getRuleChainUpdateMsgList()) {</b>
<b class="nc">&nbsp;                    result.add(ctx.getRuleChainProcessor().processRuleChainMsgFromEdge(edge.getTenantId(), edge, ruleChainUpdateMsg));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (uplinkMsg.getRuleChainMetadataUpdateMsgCount() &gt; 0) {</b>
<b class="nc">&nbsp;                for (RuleChainMetadataUpdateMsg ruleChainMetadataUpdateMsg : uplinkMsg.getRuleChainMetadataUpdateMsgList()) {</b>
<b class="nc">&nbsp;                    result.add(ctx.getRuleChainProcessor().processRuleChainMetadataMsgFromEdge(edge.getTenantId(), edge, ruleChainMetadataUpdateMsg));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (uplinkMsg.getEntityViewUpdateMsgCount() &gt; 0) {</b>
<b class="nc">&nbsp;                for (EntityViewUpdateMsg entityViewUpdateMsg : uplinkMsg.getEntityViewUpdateMsgList()) {</b>
<b class="nc">&nbsp;                    result.add(ctx.getEntityViewProcessor().processEntityViewMsgFromEdge(edge.getTenantId(), edge, entityViewUpdateMsg));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (uplinkMsg.getEntityDataCount() &gt; 0) {</b>
<b class="nc">&nbsp;                for (EntityDataProto entityData : uplinkMsg.getEntityDataList()) {</b>
<b class="nc">&nbsp;                    result.addAll(ctx.getTelemetryProcessor().processTelemetryMsg(edge.getTenantId(), entityData));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (uplinkMsg.getAlarmUpdateMsgCount() &gt; 0) {</b>
<b class="nc">&nbsp;                for (AlarmUpdateMsg alarmUpdateMsg : uplinkMsg.getAlarmUpdateMsgList()) {</b>
<b class="nc">&nbsp;                    result.add(ctx.getAlarmProcessor().processAlarmMsgFromEdge(edge.getTenantId(), edge.getId(), alarmUpdateMsg));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (uplinkMsg.getAlarmCommentUpdateMsgCount() &gt; 0) {</b>
<b class="nc">&nbsp;                for (AlarmCommentUpdateMsg alarmCommentUpdateMsg : uplinkMsg.getAlarmCommentUpdateMsgList()) {</b>
<b class="nc">&nbsp;                    result.add(ctx.getAlarmCommentProcessor().processAlarmCommentMsgFromEdge(edge.getTenantId(), edge.getId(), alarmCommentUpdateMsg));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (uplinkMsg.getRelationUpdateMsgCount() &gt; 0) {</b>
<b class="nc">&nbsp;                for (RelationUpdateMsg relationUpdateMsg : uplinkMsg.getRelationUpdateMsgList()) {</b>
<b class="nc">&nbsp;                    result.add(ctx.getRelationProcessor().processRelationMsgFromEdge(edge.getTenantId(), edge, relationUpdateMsg));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (uplinkMsg.getDashboardUpdateMsgCount() &gt; 0) {</b>
<b class="nc">&nbsp;                for (DashboardUpdateMsg dashboardUpdateMsg : uplinkMsg.getDashboardUpdateMsgList()) {</b>
<b class="nc">&nbsp;                    result.add(ctx.getDashboardProcessor().processDashboardMsgFromEdge(edge.getTenantId(), edge, dashboardUpdateMsg));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (uplinkMsg.getResourceUpdateMsgCount() &gt; 0) {</b>
<b class="nc">&nbsp;                for (ResourceUpdateMsg resourceUpdateMsg : uplinkMsg.getResourceUpdateMsgList()) {</b>
<b class="nc">&nbsp;                    result.add(ctx.getResourceProcessor().processResourceMsgFromEdge(edge.getTenantId(), edge, resourceUpdateMsg));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (uplinkMsg.getRuleChainMetadataRequestMsgCount() &gt; 0) {</b>
<b class="nc">&nbsp;                for (RuleChainMetadataRequestMsg ruleChainMetadataRequestMsg : uplinkMsg.getRuleChainMetadataRequestMsgList()) {</b>
<b class="nc">&nbsp;                    result.add(ctx.getEdgeRequestsService().processRuleChainMetadataRequestMsg(edge.getTenantId(), edge, ruleChainMetadataRequestMsg));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (uplinkMsg.getAttributesRequestMsgCount() &gt; 0) {</b>
<b class="nc">&nbsp;                for (AttributesRequestMsg attributesRequestMsg : uplinkMsg.getAttributesRequestMsgList()) {</b>
<b class="nc">&nbsp;                    result.add(ctx.getEdgeRequestsService().processAttributesRequestMsg(edge.getTenantId(), edge, attributesRequestMsg));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (uplinkMsg.getRelationRequestMsgCount() &gt; 0) {</b>
<b class="nc">&nbsp;                for (RelationRequestMsg relationRequestMsg : uplinkMsg.getRelationRequestMsgList()) {</b>
<b class="nc">&nbsp;                    result.add(ctx.getEdgeRequestsService().processRelationRequestMsg(edge.getTenantId(), edge, relationRequestMsg));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (uplinkMsg.getCalculatedFieldRequestMsgCount() &gt; 0) {</b>
<b class="nc">&nbsp;                for (CalculatedFieldRequestMsg calculatedFieldRequestMsg : uplinkMsg.getCalculatedFieldRequestMsgList()) {</b>
<b class="nc">&nbsp;                    result.add(ctx.getEdgeRequestsService().processCalculatedFieldRequestMsg(edge.getTenantId(), edge, calculatedFieldRequestMsg));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (uplinkMsg.getUserCredentialsRequestMsgCount() &gt; 0) {</b>
<b class="nc">&nbsp;                for (UserCredentialsRequestMsg userCredentialsRequestMsg : uplinkMsg.getUserCredentialsRequestMsgList()) {</b>
<b class="nc">&nbsp;                    result.add(ctx.getEdgeRequestsService().processUserCredentialsRequestMsg(edge.getTenantId(), edge, userCredentialsRequestMsg));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (uplinkMsg.getDeviceCredentialsRequestMsgCount() &gt; 0) {</b>
<b class="nc">&nbsp;                for (DeviceCredentialsRequestMsg deviceCredentialsRequestMsg : uplinkMsg.getDeviceCredentialsRequestMsgList()) {</b>
<b class="nc">&nbsp;                    result.add(ctx.getEdgeRequestsService().processDeviceCredentialsRequestMsg(edge.getTenantId(), edge, deviceCredentialsRequestMsg));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (uplinkMsg.getDeviceRpcCallMsgCount() &gt; 0) {</b>
<b class="nc">&nbsp;                for (DeviceRpcCallMsg deviceRpcCallMsg : uplinkMsg.getDeviceRpcCallMsgList()) {</b>
<b class="nc">&nbsp;                    result.add(ctx.getDeviceProcessor().processDeviceRpcCallFromEdge(edge.getTenantId(), edge, deviceRpcCallMsg));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (uplinkMsg.getWidgetBundleTypesRequestMsgCount() &gt; 0) {</b>
<b class="nc">&nbsp;                for (WidgetBundleTypesRequestMsg widgetBundleTypesRequestMsg : uplinkMsg.getWidgetBundleTypesRequestMsgList()) {</b>
<b class="nc">&nbsp;                    result.add(ctx.getEdgeRequestsService().processWidgetBundleTypesRequestMsg(edge.getTenantId(), edge, widgetBundleTypesRequestMsg));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (uplinkMsg.getEntityViewsRequestMsgCount() &gt; 0) {</b>
<b class="nc">&nbsp;                for (EntityViewsRequestMsg entityViewRequestMsg : uplinkMsg.getEntityViewsRequestMsgList()) {</b>
<b class="nc">&nbsp;                    result.add(ctx.getEdgeRequestsService().processEntityViewsRequestMsg(edge.getTenantId(), edge, entityViewRequestMsg));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (uplinkMsg.getCalculatedFieldUpdateMsgCount() &gt; 0) {</b>
<b class="nc">&nbsp;                for (CalculatedFieldUpdateMsg calculatedFieldUpdateMsg : uplinkMsg.getCalculatedFieldUpdateMsgList()) {</b>
<b class="nc">&nbsp;                    result.add(ctx.getCalculatedFieldProcessor().processCalculatedFieldMsgFromEdge(edge.getTenantId(), edge, calculatedFieldUpdateMsg));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (uplinkMsg.getAiModelUpdateMsgCount() &gt; 0) {</b>
<b class="nc">&nbsp;                for (AiModelUpdateMsg aiModelUpdateMsg : uplinkMsg.getAiModelUpdateMsgList()) {</b>
<b class="nc">&nbsp;                    result.add(ctx.getAiModelProcessor().processAiModelMsgFromEdge(edge.getTenantId(), edge, aiModelUpdateMsg));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (uplinkMsg.getUserUpdateMsgCount() &gt; 0) {</b>
<b class="nc">&nbsp;                for (UserUpdateMsg userUpdateMsg : uplinkMsg.getUserUpdateMsgList()) {</b>
<b class="nc">&nbsp;                    sequenceDependencyLock.lock();</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        result.add(ctx.getUserProcessor().processUserMsgFromEdge(edge.getTenantId(), edge, userUpdateMsg));</b>
&nbsp;                    } finally {
<b class="nc">&nbsp;                        sequenceDependencyLock.unlock();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (uplinkMsg.getUserCredentialsUpdateMsgCount() &gt; 0) {</b>
<b class="nc">&nbsp;                for (UserCredentialsUpdateMsg userCredentialsUpdateMsg : uplinkMsg.getUserCredentialsUpdateMsgList()) {</b>
<b class="nc">&nbsp;                    sequenceDependencyLock.lock();</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        result.add(ctx.getUserProcessor().processUserCredentialsMsgFromEdge(edge.getTenantId(), edge, userCredentialsUpdateMsg));</b>
&nbsp;                    } finally {
<b class="nc">&nbsp;                        sequenceDependencyLock.unlock();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            String failureMsg = String.format(&quot;Can&#39;t process uplink msg [%s] from edge&quot;, uplinkMsg);</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}] Can&#39;t process uplink msg [{}]&quot;, tenantId, edge.getId(), uplinkMsg, e);</b>
<b class="nc">&nbsp;            ctx.getRuleProcessor().process(EdgeCommunicationFailureTrigger.builder().tenantId(tenantId).edgeId(edge.getId())</b>
<b class="nc">&nbsp;                    .customerId(edge.getCustomerId()).edgeName(edge.getName()).failureMsg(failureMsg).error(e.getMessage()).build());</b>
<b class="nc">&nbsp;            return Futures.immediateFailedFuture(e);</b>
&nbsp;        }
<b class="nc">&nbsp;        return Futures.allAsList(result);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected boolean destroy() {
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    protected void cleanUp() {}</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void close() {
<b class="nc">&nbsp;        log.debug(&quot;[{}][{}] Closing session&quot;, tenantId, sessionId);</b>
<b class="nc">&nbsp;        connected = false;</b>
&nbsp;        try {
<b class="nc">&nbsp;            outputStream.onCompleted();</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.debug(&quot;[{}][{}] Failed to close output stream: {}&quot;, tenantId, sessionId, e.getMessage());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
