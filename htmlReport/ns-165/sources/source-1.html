<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > EdgeGrpcService</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.server.service.edge.rpc</a>
</div>

<h1>Coverage Summary for Class: EdgeGrpcService (org.thingsboard.server.service.edge.rpc)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">EdgeGrpcService</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/32)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/120)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/319)
  </span>
</td>
</tr>
  <tr>
    <td class="name">EdgeGrpcService$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EdgeGrpcService$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EdgeGrpcService$AttributeSaveCallback</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/39)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/122)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/334)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.server.service.edge.rpc;
&nbsp;
&nbsp;import com.fasterxml.jackson.databind.node.ObjectNode;
&nbsp;import com.google.common.util.concurrent.FutureCallback;
&nbsp;import com.google.common.util.concurrent.Futures;
&nbsp;import io.grpc.Server;
&nbsp;import io.grpc.netty.shaded.io.grpc.netty.NettyServerBuilder;
&nbsp;import io.grpc.stub.StreamObserver;
&nbsp;import jakarta.annotation.Nullable;
&nbsp;import jakarta.annotation.PreDestroy;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.springframework.beans.factory.annotation.Autowired;
&nbsp;import org.springframework.beans.factory.annotation.Value;
&nbsp;import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
&nbsp;import org.springframework.context.annotation.Lazy;
&nbsp;import org.springframework.stereotype.Service;
&nbsp;import org.thingsboard.common.util.JacksonUtil;
&nbsp;import org.thingsboard.common.util.ThingsBoardExecutors;
&nbsp;import org.thingsboard.rule.engine.api.AttributesSaveRequest;
&nbsp;import org.thingsboard.rule.engine.api.TimeseriesSaveRequest;
&nbsp;import org.thingsboard.server.cache.TbTransactionalCache;
&nbsp;import org.thingsboard.server.cluster.TbClusterService;
&nbsp;import org.thingsboard.server.common.data.AttributeScope;
&nbsp;import org.thingsboard.server.common.data.DataConstants;
&nbsp;import org.thingsboard.server.common.data.ResourceUtils;
&nbsp;import org.thingsboard.server.common.data.edge.Edge;
&nbsp;import org.thingsboard.server.common.data.edge.EdgeEvent;
&nbsp;import org.thingsboard.server.common.data.id.EdgeId;
&nbsp;import org.thingsboard.server.common.data.id.TenantId;
&nbsp;import org.thingsboard.server.common.data.kv.BooleanDataEntry;
&nbsp;import org.thingsboard.server.common.data.kv.LongDataEntry;
&nbsp;import org.thingsboard.server.common.data.msg.TbMsgType;
&nbsp;import org.thingsboard.server.common.data.notification.rule.trigger.EdgeConnectionTrigger;
&nbsp;import org.thingsboard.server.common.msg.TbMsg;
&nbsp;import org.thingsboard.server.common.msg.TbMsgDataType;
&nbsp;import org.thingsboard.server.common.msg.TbMsgMetaData;
&nbsp;import org.thingsboard.server.common.msg.edge.EdgeEventUpdateMsg;
&nbsp;import org.thingsboard.server.common.msg.edge.EdgeHighPriorityMsg;
&nbsp;import org.thingsboard.server.common.msg.edge.EdgeSessionMsg;
&nbsp;import org.thingsboard.server.common.msg.edge.FromEdgeSyncResponse;
&nbsp;import org.thingsboard.server.common.msg.edge.ToEdgeSyncRequest;
&nbsp;import org.thingsboard.server.gen.edge.v1.EdgeRpcServiceGrpc;
&nbsp;import org.thingsboard.server.gen.edge.v1.RequestMsg;
&nbsp;import org.thingsboard.server.gen.edge.v1.ResponseMsg;
&nbsp;import org.thingsboard.server.queue.discovery.TbServiceInfoProvider;
&nbsp;import org.thingsboard.server.queue.discovery.TopicService;
&nbsp;import org.thingsboard.server.queue.kafka.KafkaAdmin;
&nbsp;import org.thingsboard.server.queue.provider.TbCoreQueueFactory;
&nbsp;import org.thingsboard.server.queue.util.AfterStartUp;
&nbsp;import org.thingsboard.server.queue.util.TbCoreComponent;
&nbsp;import org.thingsboard.server.service.edge.EdgeContextComponent;
&nbsp;import org.thingsboard.server.service.telemetry.TelemetrySubscriptionService;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collection;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Optional;
&nbsp;import java.util.UUID;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.concurrent.ConcurrentMap;
&nbsp;import java.util.concurrent.ScheduledExecutorService;
&nbsp;import java.util.concurrent.ScheduledFuture;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.concurrent.locks.Lock;
&nbsp;import java.util.concurrent.locks.ReentrantLock;
&nbsp;import java.util.function.Consumer;
&nbsp;import java.util.function.Function;
&nbsp;
&nbsp;import static org.thingsboard.server.service.state.DefaultDeviceStateService.ACTIVITY_STATE;
&nbsp;import static org.thingsboard.server.service.state.DefaultDeviceStateService.LAST_CONNECT_TIME;
&nbsp;import static org.thingsboard.server.service.state.DefaultDeviceStateService.LAST_DISCONNECT_TIME;
&nbsp;
&nbsp;@Service
<b class="nc">&nbsp;@Slf4j</b>
&nbsp;@ConditionalOnProperty(prefix = &quot;edges&quot;, value = &quot;enabled&quot;, havingValue = &quot;true&quot;)
&nbsp;@TbCoreComponent
<b class="nc">&nbsp;public class EdgeGrpcService extends EdgeRpcServiceGrpc.EdgeRpcServiceImplBase implements EdgeRpcService {</b>
&nbsp;
<b class="nc">&nbsp;    private final ConcurrentMap&lt;EdgeId, EdgeGrpcSession&gt; sessions = new ConcurrentHashMap&lt;&gt;();</b>
<b class="nc">&nbsp;    private final ConcurrentMap&lt;UUID, EdgeGrpcSession&gt; sessionsById = new ConcurrentHashMap&lt;&gt;();</b>
<b class="nc">&nbsp;    private final ConcurrentMap&lt;EdgeId, Lock&gt; sessionNewEventsLocks = new ConcurrentHashMap&lt;&gt;();</b>
<b class="nc">&nbsp;    private final Map&lt;EdgeId, Boolean&gt; sessionNewEvents = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;    private final ConcurrentMap&lt;EdgeId, ScheduledFuture&lt;?&gt;&gt; sessionEdgeEventChecks = new ConcurrentHashMap&lt;&gt;();</b>
<b class="nc">&nbsp;    private final ConcurrentMap&lt;UUID, Consumer&lt;FromEdgeSyncResponse&gt;&gt; localSyncEdgeRequests = new ConcurrentHashMap&lt;&gt;();</b>
<b class="nc">&nbsp;    private final ConcurrentMap&lt;EdgeId, Boolean&gt; edgeEventsMigrationProcessed = new ConcurrentHashMap&lt;&gt;();</b>
<b class="nc">&nbsp;    private final List&lt;EdgeGrpcSession&gt; zombieSessions = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;    @Value(&quot;${edges.rpc.port}&quot;)
&nbsp;    private int rpcPort;
&nbsp;    @Value(&quot;${edges.rpc.ssl.enabled}&quot;)
&nbsp;    private boolean sslEnabled;
&nbsp;    @Value(&quot;${edges.rpc.ssl.cert}&quot;)
&nbsp;    private String certFileResource;
&nbsp;    @Value(&quot;${edges.rpc.ssl.private_key}&quot;)
&nbsp;    private String privateKeyResource;
&nbsp;    @Value(&quot;${edges.state.persistToTelemetry:false}&quot;)
&nbsp;    private boolean persistToTelemetry;
&nbsp;    @Value(&quot;${edges.rpc.client_max_keep_alive_time_sec:1}&quot;)
&nbsp;    private int clientMaxKeepAliveTimeSec;
&nbsp;    @Value(&quot;${edges.rpc.max_inbound_message_size:4194304}&quot;)
&nbsp;    private int maxInboundMessageSize;
&nbsp;    @Value(&quot;${edges.rpc.keep_alive_time_sec:10}&quot;)
&nbsp;    private int keepAliveTimeSec;
&nbsp;    @Value(&quot;${edges.rpc.keep_alive_timeout_sec:5}&quot;)
&nbsp;    private int keepAliveTimeoutSec;
&nbsp;    @Value(&quot;${edges.scheduler_pool_size}&quot;)
&nbsp;    private int schedulerPoolSize;
&nbsp;
&nbsp;    @Value(&quot;${edges.send_scheduler_pool_size}&quot;)
&nbsp;    private int sendSchedulerPoolSize;
&nbsp;
&nbsp;    @Value(&quot;${edges.max_high_priority_queue_size_per_session:10000}&quot;)
&nbsp;    private int maxHighPriorityQueueSizePerSession;
&nbsp;
&nbsp;    @Autowired
&nbsp;    @Lazy
&nbsp;    private EdgeContextComponent ctx;
&nbsp;
&nbsp;    @Autowired
&nbsp;    private TelemetrySubscriptionService tsSubService;
&nbsp;
&nbsp;    @Autowired
&nbsp;    private TbClusterService clusterService;
&nbsp;
&nbsp;    @Autowired
&nbsp;    private TbServiceInfoProvider serviceInfoProvider;
&nbsp;
&nbsp;    @Autowired
&nbsp;    private TbTransactionalCache&lt;EdgeId, String&gt; edgeIdServiceIdCache;
&nbsp;
&nbsp;    @Autowired
&nbsp;    private TopicService topicService;
&nbsp;
&nbsp;    @Autowired
&nbsp;    private TbCoreQueueFactory tbCoreQueueFactory;
&nbsp;
&nbsp;    @Autowired
&nbsp;    private Optional&lt;KafkaAdmin&gt; kafkaAdmin;
&nbsp;
&nbsp;    private Server server;
&nbsp;
&nbsp;    private ScheduledExecutorService edgeEventProcessingExecutorService;
&nbsp;
&nbsp;    private ScheduledExecutorService sendDownlinkExecutorService;
&nbsp;
&nbsp;    private ScheduledExecutorService executorService;
&nbsp;
&nbsp;    @AfterStartUp(order = AfterStartUp.REGULAR_SERVICE)
&nbsp;    public void onStartUp() {
<b class="nc">&nbsp;        log.info(&quot;Initializing Edge RPC service!&quot;);</b>
<b class="nc">&nbsp;        NettyServerBuilder builder = NettyServerBuilder.forPort(rpcPort)</b>
<b class="nc">&nbsp;                .permitKeepAliveTime(clientMaxKeepAliveTimeSec, TimeUnit.SECONDS)</b>
<b class="nc">&nbsp;                .keepAliveTime(keepAliveTimeSec, TimeUnit.SECONDS)</b>
<b class="nc">&nbsp;                .keepAliveTimeout(keepAliveTimeoutSec, TimeUnit.SECONDS)</b>
<b class="nc">&nbsp;                .permitKeepAliveWithoutCalls(true)</b>
<b class="nc">&nbsp;                .maxInboundMessageSize(maxInboundMessageSize)</b>
<b class="nc">&nbsp;                .addService(this);</b>
<b class="nc">&nbsp;        if (sslEnabled) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                InputStream certFileIs = ResourceUtils.getInputStream(this, certFileResource);</b>
<b class="nc">&nbsp;                InputStream privateKeyFileIs = ResourceUtils.getInputStream(this, privateKeyResource);</b>
<b class="nc">&nbsp;                builder.useTransportSecurity(certFileIs, privateKeyFileIs);</b>
&nbsp;            } catch (Exception e) {
<b class="nc">&nbsp;                log.error(&quot;Unable to set up SSL context. Reason: &quot; + e.getMessage(), e);</b>
<b class="nc">&nbsp;                throw new RuntimeException(&quot;Unable to set up SSL context!&quot;, e);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        server = builder.build();</b>
<b class="nc">&nbsp;        log.info(&quot;Going to start Edge RPC server using port: {}&quot;, rpcPort);</b>
&nbsp;        try {
<b class="nc">&nbsp;            server.start();</b>
&nbsp;        } catch (IOException e) {
<b class="nc">&nbsp;            log.error(&quot;Failed to start Edge RPC server!&quot;, e);</b>
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Failed to start Edge RPC server!&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        this.edgeEventProcessingExecutorService = ThingsBoardExecutors.newScheduledThreadPool(schedulerPoolSize, &quot;edge-event-check-scheduler&quot;);</b>
<b class="nc">&nbsp;        this.sendDownlinkExecutorService = ThingsBoardExecutors.newScheduledThreadPool(sendSchedulerPoolSize, &quot;edge-send-scheduler&quot;);</b>
<b class="nc">&nbsp;        this.executorService = ThingsBoardExecutors.newSingleThreadScheduledExecutor(&quot;edge-service&quot;);</b>
<b class="nc">&nbsp;        this.executorService.scheduleAtFixedRate(this::cleanupZombieSessions, 60, 60, TimeUnit.SECONDS);</b>
<b class="nc">&nbsp;        log.info(&quot;Edge RPC service initialized!&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @PreDestroy
&nbsp;    public void destroy() {
<b class="nc">&nbsp;        if (server != null) {</b>
<b class="nc">&nbsp;            server.shutdownNow();</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Map.Entry&lt;EdgeId, ScheduledFuture&lt;?&gt;&gt; entry : sessionEdgeEventChecks.entrySet()) {</b>
<b class="nc">&nbsp;            EdgeId edgeId = entry.getKey();</b>
<b class="nc">&nbsp;            ScheduledFuture&lt;?&gt; sessionEdgeEventCheck = entry.getValue();</b>
<b class="nc">&nbsp;            if (sessionEdgeEventCheck != null &amp;&amp; !sessionEdgeEventCheck.isCancelled() &amp;&amp; !sessionEdgeEventCheck.isDone()) {</b>
<b class="nc">&nbsp;                sessionEdgeEventCheck.cancel(true);</b>
<b class="nc">&nbsp;                sessionEdgeEventChecks.remove(edgeId);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (edgeEventProcessingExecutorService != null) {</b>
<b class="nc">&nbsp;            edgeEventProcessingExecutorService.shutdownNow();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (sendDownlinkExecutorService != null) {</b>
<b class="nc">&nbsp;            sendDownlinkExecutorService.shutdownNow();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (executorService != null) {</b>
<b class="nc">&nbsp;            executorService.shutdownNow();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public StreamObserver&lt;RequestMsg&gt; handleMsgs(StreamObserver&lt;ResponseMsg&gt; outputStream) {
<b class="nc">&nbsp;        EdgeGrpcSession session = createEdgeGrpcSession(outputStream);</b>
<b class="nc">&nbsp;        return session.getInputStream();</b>
&nbsp;    }
&nbsp;
&nbsp;    private EdgeGrpcSession createEdgeGrpcSession(StreamObserver&lt;ResponseMsg&gt; outputStream) {
<b class="nc">&nbsp;        return kafkaAdmin.isPresent()</b>
<b class="nc">&nbsp;                ? new KafkaEdgeGrpcSession(ctx, topicService, tbCoreQueueFactory, kafkaAdmin.get(), outputStream, this::onEdgeConnect, this::onEdgeDisconnect,</b>
&nbsp;                sendDownlinkExecutorService, maxInboundMessageSize, maxHighPriorityQueueSizePerSession)
<b class="nc">&nbsp;                : new PostgresEdgeGrpcSession(ctx, outputStream, this::onEdgeConnect, this::onEdgeDisconnect,</b>
&nbsp;                sendDownlinkExecutorService, maxInboundMessageSize, maxHighPriorityQueueSizePerSession);
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void onToEdgeSessionMsg(TenantId tenantId, EdgeSessionMsg msg) {
<b class="nc">&nbsp;        switch (msg.getMsgType()) {</b>
&nbsp;            case EDGE_HIGH_PRIORITY_TO_EDGE_SESSION_MSG -&gt; {
<b class="nc">&nbsp;                EdgeHighPriorityMsg edgeHighPriorityMsg = (EdgeHighPriorityMsg) msg;</b>
<b class="nc">&nbsp;                log.trace(&quot;[{}] edgeEventMsg [{}]&quot;, tenantId, msg);</b>
<b class="nc">&nbsp;                onEdgeHighPriorityEvent(edgeHighPriorityMsg);</b>
&nbsp;            }
&nbsp;            case EDGE_EVENT_UPDATE_TO_EDGE_SESSION_MSG -&gt; {
<b class="nc">&nbsp;                EdgeEventUpdateMsg edgeEventUpdateMsg = (EdgeEventUpdateMsg) msg;</b>
<b class="nc">&nbsp;                log.trace(&quot;[{}] onToEdgeEventUpdateMsg [{}]&quot;, tenantId, msg);</b>
<b class="nc">&nbsp;                onEdgeEventUpdate(tenantId, edgeEventUpdateMsg.getEdgeId());</b>
&nbsp;            }
&nbsp;            case EDGE_SYNC_REQUEST_TO_EDGE_SESSION_MSG -&gt; {
<b class="nc">&nbsp;                ToEdgeSyncRequest toEdgeSyncRequest = (ToEdgeSyncRequest) msg;</b>
<b class="nc">&nbsp;                log.trace(&quot;[{}] toEdgeSyncRequest [{}]&quot;, tenantId, msg);</b>
<b class="nc">&nbsp;                startSyncProcess(tenantId, toEdgeSyncRequest.getEdgeId(), toEdgeSyncRequest.getId(), toEdgeSyncRequest.getServiceId());</b>
&nbsp;            }
&nbsp;            case EDGE_SYNC_RESPONSE_FROM_EDGE_SESSION_MSG -&gt; {
<b class="nc">&nbsp;                FromEdgeSyncResponse fromEdgeSyncResponse = (FromEdgeSyncResponse) msg;</b>
<b class="nc">&nbsp;                log.trace(&quot;[{}] fromEdgeSyncResponse [{}]&quot;, tenantId, msg);</b>
<b class="nc">&nbsp;                processSyncResponse(fromEdgeSyncResponse);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void updateEdge(TenantId tenantId, Edge edge) {
<b class="nc">&nbsp;        if (edge == null) {</b>
<b class="nc">&nbsp;            log.warn(&quot;[{}] Edge is null - edge is removed and outdated notification is in process!&quot;, tenantId);</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        EdgeGrpcSession session = sessions.get(edge.getId());</b>
<b class="nc">&nbsp;        if (session != null &amp;&amp; session.isConnected()) {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}] Updating configuration for edge [{}] [{}]&quot;, tenantId, edge.getName(), edge.getId());</b>
<b class="nc">&nbsp;            session.onConfigurationUpdate(edge);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            log.debug(&quot;[{}] Session doesn&#39;t exist for edge [{}] [{}]&quot;, tenantId, edge.getName(), edge.getId());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void deleteEdge(TenantId tenantId, EdgeId edgeId) {
<b class="nc">&nbsp;        EdgeGrpcSession session = sessions.get(edgeId);</b>
<b class="nc">&nbsp;        if (session != null &amp;&amp; session.isConnected()) {</b>
<b class="nc">&nbsp;            log.info(&quot;[{}] Closing and removing session for edge [{}]&quot;, tenantId, edgeId);</b>
<b class="nc">&nbsp;            destroySession(session);</b>
<b class="nc">&nbsp;            session.cleanUp();</b>
<b class="nc">&nbsp;            sessions.remove(edgeId);</b>
<b class="nc">&nbsp;            sessionsById.remove(session.getSessionId());</b>
<b class="nc">&nbsp;            final Lock newEventLock = sessionNewEventsLocks.computeIfAbsent(edgeId, id -&gt; new ReentrantLock());</b>
<b class="nc">&nbsp;            newEventLock.lock();</b>
&nbsp;            try {
<b class="nc">&nbsp;                sessionNewEvents.remove(edgeId);</b>
&nbsp;            } finally {
<b class="nc">&nbsp;                newEventLock.unlock();</b>
&nbsp;            }
<b class="nc">&nbsp;            cancelScheduleEdgeEventsCheck(edgeId);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void onEdgeEventUpdate(TenantId tenantId, EdgeId edgeId) {
<b class="nc">&nbsp;        EdgeGrpcSession session = sessions.get(edgeId);</b>
<b class="nc">&nbsp;        if (session != null &amp;&amp; session.isConnected()) {</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}] onEdgeEventUpdate [{}]&quot;, tenantId, edgeId.getId());</b>
<b class="nc">&nbsp;            updateSessionEventsFlag(tenantId, edgeId);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void onEdgeHighPriorityEvent(EdgeHighPriorityMsg msg) {
<b class="nc">&nbsp;        TenantId tenantId = msg.getTenantId();</b>
<b class="nc">&nbsp;        EdgeEvent edgeEvent = msg.getEdgeEvent();</b>
<b class="nc">&nbsp;        EdgeId edgeId = edgeEvent.getEdgeId();</b>
<b class="nc">&nbsp;        EdgeGrpcSession session = sessions.get(edgeId);</b>
<b class="nc">&nbsp;        if (session != null &amp;&amp; session.isConnected()) {</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}] onEdgeEvent [{}]&quot;, tenantId, edgeId);</b>
<b class="nc">&nbsp;            session.addEventToHighPriorityQueue(edgeEvent);</b>
<b class="nc">&nbsp;            updateSessionEventsFlag(tenantId, edgeId);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void updateSessionEventsFlag(TenantId tenantId, EdgeId edgeId) {
<b class="nc">&nbsp;        final Lock newEventLock = sessionNewEventsLocks.computeIfAbsent(edgeId, id -&gt; new ReentrantLock());</b>
<b class="nc">&nbsp;        newEventLock.lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            if (Boolean.FALSE.equals(sessionNewEvents.get(edgeId))) {</b>
<b class="nc">&nbsp;                log.trace(&quot;[{}] set session new events flag to true [{}]&quot;, tenantId, edgeId.getId());</b>
<b class="nc">&nbsp;                sessionNewEvents.put(edgeId, true);</b>
&nbsp;            }
&nbsp;        } finally {
<b class="nc">&nbsp;            newEventLock.unlock();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void onEdgeConnect(EdgeId edgeId, EdgeGrpcSession edgeGrpcSession) {
<b class="nc">&nbsp;        Edge edge = edgeGrpcSession.getEdge();</b>
<b class="nc">&nbsp;        TenantId tenantId = edge.getTenantId();</b>
<b class="nc">&nbsp;        log.info(&quot;[{}][{}] edge [{}] connected successfully.&quot;, tenantId, edgeGrpcSession.getSessionId(), edgeId);</b>
<b class="nc">&nbsp;        if (sessions.containsKey(edgeId)) {</b>
<b class="nc">&nbsp;            EdgeGrpcSession existing = sessions.get(edgeId);</b>
<b class="nc">&nbsp;            if (existing != null) {</b>
<b class="nc">&nbsp;                log.info(&quot;[{}][{}] Replacing existing session [{}] for edge [{}]&quot;, tenantId, edgeGrpcSession.getSessionId(), existing.getSessionId(), edgeId);</b>
<b class="nc">&nbsp;                destroySession(existing);</b>
<b class="nc">&nbsp;                sessionsById.remove(existing.getSessionId());</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        sessions.put(edgeId, edgeGrpcSession);</b>
<b class="nc">&nbsp;        sessionsById.put(edgeGrpcSession.getSessionId(), edgeGrpcSession);</b>
<b class="nc">&nbsp;        final Lock newEventLock = sessionNewEventsLocks.computeIfAbsent(edgeId, id -&gt; new ReentrantLock());</b>
<b class="nc">&nbsp;        newEventLock.lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            sessionNewEvents.put(edgeId, true);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            newEventLock.unlock();</b>
&nbsp;        }
<b class="nc">&nbsp;        save(tenantId, edgeId, ACTIVITY_STATE, true);</b>
<b class="nc">&nbsp;        long lastConnectTs = System.currentTimeMillis();</b>
<b class="nc">&nbsp;        save(tenantId, edgeId, LAST_CONNECT_TIME, lastConnectTs);</b>
<b class="nc">&nbsp;        edgeIdServiceIdCache.put(edgeId, serviceInfoProvider.getServiceId());</b>
<b class="nc">&nbsp;        pushRuleEngineMessage(tenantId, edge, lastConnectTs, TbMsgType.CONNECT_EVENT);</b>
<b class="nc">&nbsp;        cancelScheduleEdgeEventsCheck(edgeId);</b>
<b class="nc">&nbsp;        edgeEventsMigrationProcessed.putIfAbsent(edgeId, Boolean.FALSE);</b>
<b class="nc">&nbsp;        scheduleEdgeEventsCheck(edgeGrpcSession);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void startSyncProcess(TenantId tenantId, EdgeId edgeId, UUID requestId, String requestServiceId) {
<b class="nc">&nbsp;        EdgeGrpcSession session = sessions.get(edgeId);</b>
<b class="nc">&nbsp;        if (session != null) {</b>
<b class="nc">&nbsp;            if (session.isSyncInProgress()) {</b>
<b class="nc">&nbsp;                clusterService.pushEdgeSyncResponseToCore(new FromEdgeSyncResponse(requestId, tenantId, edgeId, false, &quot;Sync process is active at the moment&quot;), requestServiceId);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                boolean success = false;</b>
<b class="nc">&nbsp;                if (session.isConnected()) {</b>
<b class="nc">&nbsp;                    session.startSyncProcess(true);</b>
<b class="nc">&nbsp;                    success = true;</b>
&nbsp;                }
<b class="nc">&nbsp;                clusterService.pushEdgeSyncResponseToCore(new FromEdgeSyncResponse(requestId, tenantId, edgeId, success, &quot;&quot;), requestServiceId);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void processSyncRequest(TenantId tenantId, EdgeId edgeId, Consumer&lt;FromEdgeSyncResponse&gt; responseConsumer) {
<b class="nc">&nbsp;        ToEdgeSyncRequest request = new ToEdgeSyncRequest(UUID.randomUUID(), tenantId, edgeId, serviceInfoProvider.getServiceId());</b>
&nbsp;
<b class="nc">&nbsp;        UUID requestId = request.getId();</b>
<b class="nc">&nbsp;        EdgeGrpcSession session = sessions.get(request.getEdgeId());</b>
<b class="nc">&nbsp;        if (session != null &amp;&amp; session.isSyncInProgress()) {</b>
<b class="nc">&nbsp;            responseConsumer.accept(new FromEdgeSyncResponse(requestId, request.getTenantId(), request.getEdgeId(), false, &quot;Sync process is active at the moment&quot;));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}] Processing sync edge request [{}], serviceId [{}]&quot;, request.getTenantId(), request.getId(), request.getEdgeId(), request.getServiceId());</b>
<b class="nc">&nbsp;            localSyncEdgeRequests.put(requestId, responseConsumer);</b>
<b class="nc">&nbsp;            clusterService.pushEdgeSyncRequestToEdge(request);</b>
<b class="nc">&nbsp;            scheduleSyncRequestTimeout(request, requestId);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void scheduleSyncRequestTimeout(ToEdgeSyncRequest request, UUID requestId) {
<b class="nc">&nbsp;        log.trace(&quot;[{}] scheduling sync edge request&quot;, requestId);</b>
<b class="nc">&nbsp;        executorService.schedule(() -&gt; {</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}] checking if sync edge request is not processed...&quot;, requestId);</b>
<b class="nc">&nbsp;            Consumer&lt;FromEdgeSyncResponse&gt; consumer = localSyncEdgeRequests.remove(requestId);</b>
<b class="nc">&nbsp;            if (consumer != null) {</b>
<b class="nc">&nbsp;                log.trace(&quot;[{}] timeout for processing sync edge request.&quot;, requestId);</b>
<b class="nc">&nbsp;                consumer.accept(new FromEdgeSyncResponse(requestId, request.getTenantId(), request.getEdgeId(), false, &quot;Edge is not connected&quot;));</b>
&nbsp;            }
&nbsp;        }, 20, TimeUnit.SECONDS);
&nbsp;    }
&nbsp;
&nbsp;    private void processSyncResponse(FromEdgeSyncResponse response) {
<b class="nc">&nbsp;        log.trace(&quot;[{}] Received response from sync service: [{}]&quot;, response.getId(), response);</b>
<b class="nc">&nbsp;        UUID requestId = response.getId();</b>
<b class="nc">&nbsp;        Consumer&lt;FromEdgeSyncResponse&gt; consumer = localSyncEdgeRequests.remove(requestId);</b>
<b class="nc">&nbsp;        if (consumer != null) {</b>
<b class="nc">&nbsp;            consumer.accept(response);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            log.trace(&quot;[{}] Unknown or stale sync response received [{}]&quot;, requestId, response);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void scheduleEdgeEventsCheck(EdgeGrpcSession session) {
<b class="nc">&nbsp;        EdgeId edgeId = session.getEdge().getId();</b>
<b class="nc">&nbsp;        TenantId tenantId = session.getEdge().getTenantId();</b>
&nbsp;
<b class="nc">&nbsp;        cancelScheduleEdgeEventsCheck(edgeId);</b>
&nbsp;
<b class="nc">&nbsp;        if (sessions.containsKey(edgeId)) {</b>
<b class="nc">&nbsp;            ScheduledFuture&lt;?&gt; edgeEventCheckTask = edgeEventProcessingExecutorService.schedule(() -&gt; {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    final Lock newEventLock = sessionNewEventsLocks.computeIfAbsent(edgeId, id -&gt; new ReentrantLock());</b>
<b class="nc">&nbsp;                    newEventLock.lock();</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        if (Boolean.TRUE.equals(sessionNewEvents.get(edgeId))) {</b>
<b class="nc">&nbsp;                            log.trace(&quot;[{}][{}] set session new events flag to false&quot;, tenantId, edgeId.getId());</b>
<b class="nc">&nbsp;                            sessionNewEvents.put(edgeId, false);</b>
<b class="nc">&nbsp;                            session.processHighPriorityEvents();</b>
<b class="nc">&nbsp;                            processEdgeEventMigrationIfNeeded(session, edgeId);</b>
<b class="nc">&nbsp;                            if (Boolean.TRUE.equals(edgeEventsMigrationProcessed.get(edgeId))) {</b>
<b class="nc">&nbsp;                                Futures.addCallback(session.processEdgeEvents(), new FutureCallback&lt;&gt;() {</b>
&nbsp;                                    @Override
&nbsp;                                    public void onSuccess(Boolean newEventsAdded) {
<b class="nc">&nbsp;                                        if (Boolean.TRUE.equals(newEventsAdded)) {</b>
<b class="nc">&nbsp;                                            log.trace(&quot;[{}][{}] new events added. set session new events flag to true&quot;, tenantId, edgeId.getId());</b>
<b class="nc">&nbsp;                                            sessionNewEvents.put(edgeId, true);</b>
&nbsp;                                        }
<b class="nc">&nbsp;                                        scheduleEdgeEventsCheck(session);</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    @Override
&nbsp;                                    public void onFailure(Throwable t) {
<b class="nc">&nbsp;                                        log.warn(&quot;[{}] Failed to process edge events for edge [{}]!&quot;, tenantId, session.getEdge().getId().getId(), t);</b>
<b class="nc">&nbsp;                                        scheduleEdgeEventsCheck(session);</b>
&nbsp;                                    }
<b class="nc">&nbsp;                                }, ctx.getGrpcCallbackExecutorService());</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                scheduleEdgeEventsCheck(session);</b>
&nbsp;                            }
&nbsp;                        } else {
<b class="nc">&nbsp;                            scheduleEdgeEventsCheck(session);</b>
&nbsp;                        }
&nbsp;                    } finally {
<b class="nc">&nbsp;                        newEventLock.unlock();</b>
&nbsp;                    }
&nbsp;                } catch (Exception e) {
<b class="nc">&nbsp;                    log.warn(&quot;[{}] Failed to process edge events for edge [{}]!&quot;, tenantId, session.getEdge().getId().getId(), e);</b>
&nbsp;                }
<b class="nc">&nbsp;            }, ctx.getEdgeEventStorageSettings().getNoRecordsSleepInterval(), TimeUnit.MILLISECONDS);</b>
<b class="nc">&nbsp;            sessionEdgeEventChecks.put(edgeId, edgeEventCheckTask);</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}] Check edge event scheduled for edge [{}]&quot;, tenantId, edgeId.getId());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            log.debug(&quot;[{}] Session was removed and edge event check schedule must not be started [{}]&quot;,</b>
<b class="nc">&nbsp;                    tenantId, edgeId.getId());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void processEdgeEventMigrationIfNeeded(EdgeGrpcSession session, EdgeId edgeId) throws Exception {
<b class="nc">&nbsp;        boolean isMigrationProcessed = edgeEventsMigrationProcessed.getOrDefault(edgeId, Boolean.FALSE);</b>
<b class="nc">&nbsp;        if (!isMigrationProcessed) {</b>
<b class="nc">&nbsp;            log.info(&quot;Starting edge event migration for edge [{}]&quot;, edgeId.getId());</b>
<b class="nc">&nbsp;            Boolean eventsExist = session.migrateEdgeEvents().get();</b>
<b class="nc">&nbsp;            if (Boolean.TRUE.equals(eventsExist)) {</b>
<b class="nc">&nbsp;                log.info(&quot;Migration still in progress for edge [{}]&quot;, edgeId.getId());</b>
<b class="nc">&nbsp;                sessionNewEvents.put(edgeId, true);</b>
<b class="nc">&nbsp;                scheduleEdgeEventsCheck(session);</b>
<b class="nc">&nbsp;            } else if (Boolean.FALSE.equals(eventsExist)) {</b>
<b class="nc">&nbsp;                log.info(&quot;Migration completed for edge [{}]&quot;, edgeId.getId());</b>
<b class="nc">&nbsp;                edgeEventsMigrationProcessed.put(edgeId, true);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void cancelScheduleEdgeEventsCheck(EdgeId edgeId) {
<b class="nc">&nbsp;        log.trace(&quot;[{}] cancelling edge event check for edge&quot;, edgeId);</b>
<b class="nc">&nbsp;        if (sessionEdgeEventChecks.containsKey(edgeId)) {</b>
<b class="nc">&nbsp;            ScheduledFuture&lt;?&gt; sessionEdgeEventCheck = sessionEdgeEventChecks.get(edgeId);</b>
<b class="nc">&nbsp;            if (sessionEdgeEventCheck != null &amp;&amp; !sessionEdgeEventCheck.isCancelled() &amp;&amp; !sessionEdgeEventCheck.isDone()) {</b>
<b class="nc">&nbsp;                sessionEdgeEventCheck.cancel(true);</b>
<b class="nc">&nbsp;                sessionEdgeEventChecks.remove(edgeId);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void onEdgeDisconnect(Edge edge, UUID sessionId) {
<b class="nc">&nbsp;        EdgeId edgeId = edge.getId();</b>
<b class="nc">&nbsp;        log.info(&quot;[{}][{}] edge disconnected!&quot;, edgeId, sessionId);</b>
<b class="nc">&nbsp;        EdgeGrpcSession current = sessions.get(edgeId);</b>
<b class="nc">&nbsp;        if (current != null &amp;&amp; current.getSessionId().equals(sessionId)) {</b>
<b class="nc">&nbsp;            EdgeGrpcSession toRemove = sessions.remove(edgeId);</b>
<b class="nc">&nbsp;            final Lock newEventLock = sessionNewEventsLocks.computeIfAbsent(edgeId, id -&gt; new ReentrantLock());</b>
<b class="nc">&nbsp;            newEventLock.lock();</b>
&nbsp;            try {
<b class="nc">&nbsp;                sessionNewEvents.remove(edgeId);</b>
&nbsp;            } finally {
<b class="nc">&nbsp;                newEventLock.unlock();</b>
&nbsp;            }
<b class="nc">&nbsp;            destroySession(toRemove);</b>
<b class="nc">&nbsp;            sessionsById.remove(sessionId);</b>
<b class="nc">&nbsp;            TenantId tenantId = toRemove.getEdge().getTenantId();</b>
<b class="nc">&nbsp;            save(tenantId, edgeId, ACTIVITY_STATE, false);</b>
<b class="nc">&nbsp;            long lastDisconnectTs = System.currentTimeMillis();</b>
<b class="nc">&nbsp;            save(tenantId, edgeId, LAST_DISCONNECT_TIME, lastDisconnectTs);</b>
<b class="nc">&nbsp;            pushRuleEngineMessage(toRemove.getEdge().getTenantId(), edge, lastDisconnectTs, TbMsgType.DISCONNECT_EVENT);</b>
<b class="nc">&nbsp;            cancelScheduleEdgeEventsCheck(edgeId);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            log.info(&quot;[{}] edge session [{}] is not current anymore. Attempting to destroy it by sessionId.&quot;, edgeId, sessionId);</b>
<b class="nc">&nbsp;            EdgeGrpcSession stale = sessionsById.remove(sessionId);</b>
<b class="nc">&nbsp;            if (stale != null) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    destroySession(stale);</b>
<b class="nc">&nbsp;                    log.info(&quot;[{}][{}] Successfully destroyed stale session for edge [{}]&quot;, stale.getTenantId(), sessionId, edgeId);</b>
&nbsp;                } catch (Exception e) {
<b class="nc">&nbsp;                    log.warn(&quot;[{}][{}] Failed to destroy stale session for edge [{}]&quot;, stale.getTenantId(), sessionId, edgeId, e);</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                log.debug(&quot;[{}] No session found by sessionId [{}] to destroy&quot;, edgeId, sessionId);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        edgeIdServiceIdCache.evict(edgeId);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void destroySession(EdgeGrpcSession session) {
<b class="nc">&nbsp;        try (session) {</b>
<b class="nc">&nbsp;            if (!session.destroy()) {</b>
<b class="nc">&nbsp;                log.warn(&quot;[{}][{}] Session destroy failed for edge [{}] with session id [{}]. Adding to zombie queue for later cleanup.&quot;,</b>
<b class="nc">&nbsp;                        session.getTenantId(), session.getEdge().getId(), session.getEdge().getName(), session.getSessionId());</b>
<b class="nc">&nbsp;                zombieSessions.add(session);</b>
&nbsp;            }
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.warn(&quot;[{}][{}] Exception during session destroy for edge [{}] with session id [{}]&quot;,</b>
<b class="nc">&nbsp;                    session.getTenantId(), session.getEdge().getId(), session.getEdge().getName(), session.getSessionId(), e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void save(TenantId tenantId, EdgeId edgeId, String key, long value) {
<b class="nc">&nbsp;        log.debug(&quot;[{}][{}] Updating long edge telemetry [{}] [{}]&quot;, tenantId, edgeId, key, value);</b>
<b class="nc">&nbsp;        if (persistToTelemetry) {</b>
<b class="nc">&nbsp;            tsSubService.saveTimeseries(TimeseriesSaveRequest.builder()</b>
<b class="nc">&nbsp;                    .tenantId(tenantId)</b>
<b class="nc">&nbsp;                    .entityId(edgeId)</b>
<b class="nc">&nbsp;                    .entry(new LongDataEntry(key, value))</b>
<b class="nc">&nbsp;                    .callback(new AttributeSaveCallback(tenantId, edgeId, key, value))</b>
<b class="nc">&nbsp;                    .build());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            tsSubService.saveAttributes(AttributesSaveRequest.builder()</b>
<b class="nc">&nbsp;                    .tenantId(tenantId)</b>
<b class="nc">&nbsp;                    .entityId(edgeId)</b>
<b class="nc">&nbsp;                    .scope(AttributeScope.SERVER_SCOPE)</b>
<b class="nc">&nbsp;                    .entry(new LongDataEntry(key, value))</b>
<b class="nc">&nbsp;                    .callback(new AttributeSaveCallback(tenantId, edgeId, key, value))</b>
<b class="nc">&nbsp;                    .build());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void save(TenantId tenantId, EdgeId edgeId, String key, boolean value) {
<b class="nc">&nbsp;        log.debug(&quot;[{}][{}] Updating boolean edge telemetry [{}] [{}]&quot;, tenantId, edgeId, key, value);</b>
<b class="nc">&nbsp;        if (persistToTelemetry) {</b>
<b class="nc">&nbsp;            tsSubService.saveTimeseries(TimeseriesSaveRequest.builder()</b>
<b class="nc">&nbsp;                    .tenantId(tenantId)</b>
<b class="nc">&nbsp;                    .entityId(edgeId)</b>
<b class="nc">&nbsp;                    .entry(new BooleanDataEntry(key, value))</b>
<b class="nc">&nbsp;                    .callback(new AttributeSaveCallback(tenantId, edgeId, key, value))</b>
<b class="nc">&nbsp;                    .build());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            tsSubService.saveAttributes(AttributesSaveRequest.builder()</b>
<b class="nc">&nbsp;                    .tenantId(tenantId)</b>
<b class="nc">&nbsp;                    .entityId(edgeId)</b>
<b class="nc">&nbsp;                    .scope(AttributeScope.SERVER_SCOPE)</b>
<b class="nc">&nbsp;                    .entry(new BooleanDataEntry(key, value))</b>
<b class="nc">&nbsp;                    .callback(new AttributeSaveCallback(tenantId, edgeId, key, value))</b>
<b class="nc">&nbsp;                    .build());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class AttributeSaveCallback implements FutureCallback&lt;Void&gt; {
&nbsp;
&nbsp;        private final TenantId tenantId;
&nbsp;        private final EdgeId edgeId;
&nbsp;        private final String key;
&nbsp;        private final Object value;
&nbsp;
<b class="nc">&nbsp;        AttributeSaveCallback(TenantId tenantId, EdgeId edgeId, String key, Object value) {</b>
<b class="nc">&nbsp;            this.tenantId = tenantId;</b>
<b class="nc">&nbsp;            this.edgeId = edgeId;</b>
<b class="nc">&nbsp;            this.key = key;</b>
<b class="nc">&nbsp;            this.value = value;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onSuccess(@Nullable Void result) {
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}] Successfully updated attribute [{}] with value [{}]&quot;, tenantId, edgeId, key, value);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onFailure(Throwable t) {
<b class="nc">&nbsp;            log.warn(&quot;[{}][{}] Failed to update attribute [{}] with value [{}]&quot;, tenantId, edgeId, key, value, t);</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    private void pushRuleEngineMessage(TenantId tenantId, Edge edge, long ts, TbMsgType msgType) {
&nbsp;        try {
<b class="nc">&nbsp;            EdgeId edgeId = edge.getId();</b>
<b class="nc">&nbsp;            ObjectNode edgeState = JacksonUtil.newObjectNode();</b>
<b class="nc">&nbsp;            boolean isConnected = TbMsgType.CONNECT_EVENT.equals(msgType);</b>
<b class="nc">&nbsp;            if (isConnected) {</b>
<b class="nc">&nbsp;                edgeState.put(ACTIVITY_STATE, true);</b>
<b class="nc">&nbsp;                edgeState.put(LAST_CONNECT_TIME, ts);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                edgeState.put(ACTIVITY_STATE, false);</b>
<b class="nc">&nbsp;                edgeState.put(LAST_DISCONNECT_TIME, ts);</b>
&nbsp;            }
<b class="nc">&nbsp;            ctx.getRuleProcessor().process(EdgeConnectionTrigger.builder()</b>
<b class="nc">&nbsp;                    .tenantId(tenantId)</b>
<b class="nc">&nbsp;                    .customerId(edge.getCustomerId())</b>
<b class="nc">&nbsp;                    .edgeId(edgeId)</b>
<b class="nc">&nbsp;                    .edgeName(edge.getName())</b>
<b class="nc">&nbsp;                    .connected(isConnected).build());</b>
<b class="nc">&nbsp;            String data = JacksonUtil.toString(edgeState);</b>
<b class="nc">&nbsp;            TbMsgMetaData md = new TbMsgMetaData();</b>
<b class="nc">&nbsp;            if (!persistToTelemetry) {</b>
<b class="nc">&nbsp;                md.putValue(DataConstants.SCOPE, DataConstants.SERVER_SCOPE);</b>
<b class="nc">&nbsp;                md.putValue(&quot;edgeName&quot;, edge.getName());</b>
<b class="nc">&nbsp;                md.putValue(&quot;edgeType&quot;, edge.getType());</b>
&nbsp;            }
<b class="nc">&nbsp;            TbMsg tbMsg = TbMsg.newMsg()</b>
<b class="nc">&nbsp;                    .type(msgType)</b>
<b class="nc">&nbsp;                    .originator(edgeId)</b>
<b class="nc">&nbsp;                    .copyMetaData(md)</b>
<b class="nc">&nbsp;                    .dataType(TbMsgDataType.JSON)</b>
<b class="nc">&nbsp;                    .data(data)</b>
<b class="nc">&nbsp;                    .build();</b>
<b class="nc">&nbsp;            clusterService.pushMsgToRuleEngine(tenantId, edgeId, tbMsg, null);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.warn(&quot;[{}][{}] Failed to push {}&quot;, tenantId, edge.getId(), msgType, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void cleanupZombieSessions() {
&nbsp;        try {
<b class="nc">&nbsp;            tryToDestroyZombieSessions(getZombieSessions(sessions.values()), s -&gt; sessions.remove(s.getEdge().getId()));</b>
<b class="nc">&nbsp;            tryToDestroyZombieSessions(getZombieSessions(sessionsById.values()), s -&gt; sessionsById.remove(s.getSessionId()));</b>
&nbsp;
<b class="nc">&nbsp;            zombieSessions.removeIf(zombie -&gt; {</b>
<b class="nc">&nbsp;                if (zombie.destroy()) {</b>
<b class="nc">&nbsp;                    log.info(&quot;[{}][{}] Successfully cleaned up zombie session [{}] for edge [{}].&quot;,</b>
<b class="nc">&nbsp;                            zombie.getTenantId(), zombie.getEdge().getId(), zombie.getSessionId(), zombie.getEdge().getName());</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    log.warn(&quot;[{}][{}] Failed to remove zombie session [{}] for edge [{}].&quot;,</b>
<b class="nc">&nbsp;                            zombie.getTenantId(), zombie.getEdge().getId(), zombie.getSessionId(), zombie.getEdge().getName());</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            });
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.warn(&quot;Failed to cleanup kafka sessions&quot;, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;EdgeGrpcSession&gt; getZombieSessions(Collection&lt;EdgeGrpcSession&gt; sessions) {
<b class="nc">&nbsp;        List&lt;EdgeGrpcSession&gt; result = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (EdgeGrpcSession session : sessions) {</b>
<b class="nc">&nbsp;            if (isKafkaSessionAndZombie(session)) {</b>
<b class="nc">&nbsp;                result.add(session);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void tryToDestroyZombieSessions(List&lt;EdgeGrpcSession&gt; sessionsToRemove, Function&lt;EdgeGrpcSession, EdgeGrpcSession&gt; removeFunc) {
<b class="nc">&nbsp;        for (EdgeGrpcSession toRemove : sessionsToRemove) {</b>
<b class="nc">&nbsp;            log.info(&quot;[{}] Destroying session for edge because edge is not connected&quot;, toRemove.getEdge().getId());</b>
<b class="nc">&nbsp;            if (toRemove.destroy()) {</b>
<b class="nc">&nbsp;                removeFunc.apply(toRemove);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private boolean isKafkaSessionAndZombie(EdgeGrpcSession session) {
<b class="nc">&nbsp;        if (session instanceof KafkaEdgeGrpcSession kafkaSession) {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}] kafkaSession.isConnected() = {}, kafkaSession.getConsumer().getConsumer().isStopped() = {}&quot;,</b>
<b class="nc">&nbsp;                    kafkaSession.getEdge().getId(),</b>
<b class="nc">&nbsp;                    kafkaSession.isConnected(),</b>
<b class="nc">&nbsp;                    kafkaSession.getConsumer() != null ? kafkaSession.getConsumer().getConsumer() != null ? kafkaSession.getConsumer().getConsumer().isStopped() : null : null);</b>
<b class="nc">&nbsp;            return !kafkaSession.isConnected() &amp;&amp;</b>
<b class="nc">&nbsp;                    kafkaSession.getConsumer() != null &amp;&amp;</b>
<b class="nc">&nbsp;                    kafkaSession.getConsumer().getConsumer() != null &amp;&amp;</b>
<b class="nc">&nbsp;                    !kafkaSession.getConsumer().getConsumer().isStopped();</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
