<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > TbAlarmDataSubCtx</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.server.service.subscription</a>
</div>

<h1>Coverage Summary for Class: TbAlarmDataSubCtx (org.thingsboard.server.service.subscription)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TbAlarmDataSubCtx</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/85)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/161)
  </span>
</td>
</tr>
  <tr>
    <td class="name">TbAlarmDataSubCtx$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/85)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/162)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.server.service.subscription;
&nbsp;
&nbsp;import lombok.Getter;
&nbsp;import lombok.Setter;
&nbsp;import lombok.ToString;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.thingsboard.server.common.data.alarm.Alarm;
&nbsp;import org.thingsboard.server.common.data.alarm.AlarmSearchStatus;
&nbsp;import org.thingsboard.server.common.data.id.AlarmId;
&nbsp;import org.thingsboard.server.common.data.id.EntityId;
&nbsp;import org.thingsboard.server.common.data.kv.Aggregation;
&nbsp;import org.thingsboard.server.common.data.page.PageData;
&nbsp;import org.thingsboard.server.common.data.query.AlarmData;
&nbsp;import org.thingsboard.server.common.data.query.AlarmDataPageLink;
&nbsp;import org.thingsboard.server.common.data.query.AlarmDataQuery;
&nbsp;import org.thingsboard.server.common.data.query.EntityData;
&nbsp;import org.thingsboard.server.common.data.query.EntityDataPageLink;
&nbsp;import org.thingsboard.server.common.data.query.EntityDataQuery;
&nbsp;import org.thingsboard.server.common.data.query.EntityDataSortOrder;
&nbsp;import org.thingsboard.server.common.data.query.EntityKey;
&nbsp;import org.thingsboard.server.common.data.query.EntityKeyType;
&nbsp;import org.thingsboard.server.common.data.query.TsValue;
&nbsp;import org.thingsboard.server.dao.alarm.AlarmService;
&nbsp;import org.thingsboard.server.dao.attributes.AttributesService;
&nbsp;import org.thingsboard.server.dao.entity.EntityService;
&nbsp;import org.thingsboard.server.dao.sql.query.EntityKeyMapping;
&nbsp;import org.thingsboard.server.service.ws.WebSocketService;
&nbsp;import org.thingsboard.server.service.ws.WebSocketSessionRef;
&nbsp;import org.thingsboard.server.service.ws.telemetry.cmd.v2.AlarmDataUpdate;
&nbsp;import org.thingsboard.server.service.ws.telemetry.sub.AlarmSubscriptionUpdate;
&nbsp;import org.thingsboard.server.service.ws.telemetry.sub.TelemetrySubscriptionUpdate;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import java.util.function.Function;
&nbsp;import java.util.stream.Collectors;
&nbsp;
<b class="nc">&nbsp;@Slf4j</b>
&nbsp;@ToString(callSuper = true)
&nbsp;public class TbAlarmDataSubCtx extends TbAbstractDataSubCtx&lt;AlarmDataQuery&gt; {
&nbsp;
&nbsp;    private final AlarmService alarmService;
&nbsp;    @Getter
&nbsp;    private final LinkedHashMap&lt;EntityId, EntityData&gt; entitiesMap;
&nbsp;    @Getter
&nbsp;    private final HashMap&lt;AlarmId, AlarmData&gt; alarmsMap;
&nbsp;
&nbsp;    private final int maxEntitiesPerAlarmSubscription;
&nbsp;
&nbsp;    private final int maxAlarmQueriesPerRefreshInterval;
&nbsp;
&nbsp;    @Getter
&nbsp;    @Setter
&nbsp;    private PageData&lt;AlarmData&gt; alarms;
&nbsp;    @Getter
&nbsp;    @Setter
&nbsp;    private boolean tooManyEntities;
&nbsp;
&nbsp;    private int alarmInvocationAttempts;
&nbsp;
&nbsp;    public TbAlarmDataSubCtx(String serviceId, WebSocketService wsService,
&nbsp;                             EntityService entityService, TbLocalSubscriptionService localSubscriptionService,
&nbsp;                             AttributesService attributesService, SubscriptionServiceStatistics stats, AlarmService alarmService,
&nbsp;                             WebSocketSessionRef sessionRef, int cmdId,
&nbsp;                             int maxEntitiesPerAlarmSubscription, int maxAlarmQueriesPerRefreshInterval) {
<b class="nc">&nbsp;        super(serviceId, wsService, entityService, localSubscriptionService, attributesService, stats, sessionRef, cmdId);</b>
<b class="nc">&nbsp;        this.maxEntitiesPerAlarmSubscription = maxEntitiesPerAlarmSubscription;</b>
<b class="nc">&nbsp;        this.maxAlarmQueriesPerRefreshInterval = maxAlarmQueriesPerRefreshInterval;</b>
<b class="nc">&nbsp;        this.alarmService = alarmService;</b>
<b class="nc">&nbsp;        this.entitiesMap = new LinkedHashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        this.alarmsMap = new HashMap&lt;&gt;();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void clearSubscriptions() {
<b class="nc">&nbsp;        super.clearSubscriptions();</b>
&nbsp;    }
&nbsp;
&nbsp;    public void fetchAlarms() {
<b class="nc">&nbsp;        alarmInvocationAttempts++;</b>
<b class="nc">&nbsp;        log.trace(&quot;[{}] Fetching alarms: {}&quot;, cmdId, alarmInvocationAttempts);</b>
<b class="nc">&nbsp;        if (alarmInvocationAttempts &lt;= maxAlarmQueriesPerRefreshInterval) {</b>
<b class="nc">&nbsp;            doFetchAlarms();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            log.trace(&quot;[{}] Ignore alarm fetch due to rate limit: [{}] of maximum [{}]&quot;, cmdId, alarmInvocationAttempts, maxAlarmQueriesPerRefreshInterval);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void doFetchAlarms() {
&nbsp;        AlarmDataUpdate update;
<b class="nc">&nbsp;        if (!entitiesMap.isEmpty()) {</b>
<b class="nc">&nbsp;            long start = System.currentTimeMillis();</b>
<b class="nc">&nbsp;            PageData&lt;AlarmData&gt; alarms = alarmService.findAlarmDataByQueryForEntities(getTenantId(), query, getOrderedEntityIds());</b>
<b class="nc">&nbsp;            long end = System.currentTimeMillis();</b>
<b class="nc">&nbsp;            stats.getAlarmQueryInvocationCnt().incrementAndGet();</b>
<b class="nc">&nbsp;            stats.getAlarmQueryTimeSpent().addAndGet(end - start);</b>
<b class="nc">&nbsp;            alarms = setAndMergeAlarmsData(alarms);</b>
<b class="nc">&nbsp;            update = new AlarmDataUpdate(cmdId, alarms, null, maxEntitiesPerAlarmSubscription, data.getTotalElements());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            update = new AlarmDataUpdate(cmdId, new PageData&lt;&gt;(), null, maxEntitiesPerAlarmSubscription, data.getTotalElements());</b>
&nbsp;        }
<b class="nc">&nbsp;        sendWsMsg(update);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void fetchData() {
<b class="nc">&nbsp;        resetInvocationCounter();</b>
<b class="nc">&nbsp;        log.trace(&quot;[{}] Fetching data: {}&quot;, cmdId, alarmInvocationAttempts);</b>
<b class="nc">&nbsp;        super.fetchData();</b>
<b class="nc">&nbsp;        entitiesMap.clear();</b>
<b class="nc">&nbsp;        tooManyEntities = data.hasNext();</b>
<b class="nc">&nbsp;        for (EntityData entityData : data.getData()) {</b>
<b class="nc">&nbsp;            entitiesMap.put(entityData.getEntityId(), entityData);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public Collection&lt;EntityId&gt; getOrderedEntityIds() {
<b class="nc">&nbsp;        return entitiesMap.keySet();</b>
&nbsp;    }
&nbsp;
&nbsp;    public PageData&lt;AlarmData&gt; setAndMergeAlarmsData(PageData&lt;AlarmData&gt; alarms) {
<b class="nc">&nbsp;        this.alarms = alarms;</b>
<b class="nc">&nbsp;        for (AlarmData alarmData : alarms.getData()) {</b>
<b class="nc">&nbsp;            EntityId entityId = alarmData.getEntityId();</b>
<b class="nc">&nbsp;            if (entityId != null) {</b>
<b class="nc">&nbsp;                EntityData entityData = entitiesMap.get(entityId);</b>
<b class="nc">&nbsp;                if (entityData != null) {</b>
<b class="nc">&nbsp;                    alarmData.getLatest().putAll(entityData.getLatest());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        alarmsMap.clear();</b>
<b class="nc">&nbsp;        alarmsMap.putAll(alarms.getData().stream().collect(Collectors.toMap(AlarmData::getId, Function.identity(), (a, b) -&gt; a)));</b>
<b class="nc">&nbsp;        return this.alarms;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void createLatestValuesSubscriptions(List&lt;EntityKey&gt; keys) {
<b class="nc">&nbsp;        super.createLatestValuesSubscriptions(keys);</b>
<b class="nc">&nbsp;        createAlarmSubscriptions();</b>
&nbsp;    }
&nbsp;
&nbsp;    public void createAlarmSubscriptions() {
<b class="nc">&nbsp;        AlarmDataPageLink pageLink = query.getPageLink();</b>
<b class="nc">&nbsp;        long startTs = System.currentTimeMillis() - pageLink.getTimeWindow();</b>
<b class="nc">&nbsp;        for (EntityData entityData : entitiesMap.values()) {</b>
<b class="nc">&nbsp;            createAlarmSubscriptionForEntity(pageLink, startTs, entityData);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void createAlarmSubscriptionForEntity(AlarmDataPageLink pageLink, long startTs, EntityData entityData) {
<b class="nc">&nbsp;        int subIdx = sessionRef.getSessionSubIdSeq().incrementAndGet();</b>
<b class="nc">&nbsp;        subToEntityIdMap.put(subIdx, entityData.getEntityId());</b>
<b class="nc">&nbsp;        log.trace(&quot;[{}][{}][{}] Creating alarms subscription for [{}] with query: {}&quot;, serviceId, cmdId, subIdx, entityData.getEntityId(), pageLink);</b>
<b class="nc">&nbsp;        TbAlarmsSubscription subscription = TbAlarmsSubscription.builder()</b>
<b class="nc">&nbsp;                .serviceId(serviceId)</b>
<b class="nc">&nbsp;                .sessionId(sessionRef.getSessionId())</b>
<b class="nc">&nbsp;                .subscriptionId(subIdx)</b>
<b class="nc">&nbsp;                .tenantId(sessionRef.getSecurityCtx().getTenantId())</b>
<b class="nc">&nbsp;                .entityId(entityData.getEntityId())</b>
<b class="nc">&nbsp;                .updateProcessor((sub, update) -&gt; sendWsMsg(sub.getSessionId(), update))</b>
<b class="nc">&nbsp;                .ts(startTs)</b>
<b class="nc">&nbsp;                .build();</b>
<b class="nc">&nbsp;        localSubscriptionService.addSubscription(subscription, sessionRef);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    void sendWsMsg(String sessionId, TelemetrySubscriptionUpdate subscriptionUpdate, EntityKeyType keyType, boolean resultToLatestValues) {
<b class="nc">&nbsp;        EntityId entityId = subToEntityIdMap.get(subscriptionUpdate.getSubscriptionId());</b>
<b class="nc">&nbsp;        if (entityId != null) {</b>
<b class="nc">&nbsp;            Map&lt;String, TsValue&gt; latestUpdate = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;            subscriptionUpdate.getValues().forEach((key, values) -&gt; {</b>
<b class="nc">&nbsp;                latestUpdate.put(key, getLatest(values));</b>
&nbsp;            });
<b class="nc">&nbsp;            EntityData entityData = entitiesMap.get(entityId);</b>
<b class="nc">&nbsp;            entityData.getLatest().computeIfAbsent(keyType, tmp -&gt; new HashMap&lt;&gt;()).putAll(latestUpdate);</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}][{}][{}] Received subscription update: {}&quot;, sessionId, cmdId, subscriptionUpdate.getSubscriptionId(), keyType, subscriptionUpdate);</b>
<b class="nc">&nbsp;            List&lt;AlarmData&gt; update = alarmsMap.values().stream().filter(alarm -&gt; entityId.equals(alarm.getEntityId())).map(alarm -&gt; {</b>
<b class="nc">&nbsp;                alarm.getLatest().computeIfAbsent(keyType, tmp -&gt; new HashMap&lt;&gt;()).putAll(latestUpdate);</b>
<b class="nc">&nbsp;                return alarm;</b>
<b class="nc">&nbsp;            }).collect(Collectors.toList());</b>
<b class="nc">&nbsp;            if (!update.isEmpty()) {</b>
<b class="nc">&nbsp;                sendWsMsg(new AlarmDataUpdate(cmdId, null, update, maxEntitiesPerAlarmSubscription, data.getTotalElements()));</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}][{}][{}] Received stale subscription update: {}&quot;, sessionId, cmdId, subscriptionUpdate.getSubscriptionId(), keyType, subscriptionUpdate);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected Aggregation getCurrentAggregation() {
<b class="nc">&nbsp;        return Aggregation.NONE;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void sendWsMsg(String sessionId, AlarmSubscriptionUpdate subscriptionUpdate) {
<b class="nc">&nbsp;        Alarm alarm = subscriptionUpdate.getAlarm();</b>
<b class="nc">&nbsp;        AlarmId alarmId = alarm.getId();</b>
<b class="nc">&nbsp;        if (subscriptionUpdate.isAlarmDeleted()) {</b>
<b class="nc">&nbsp;            Alarm deleted = alarmsMap.remove(alarmId);</b>
<b class="nc">&nbsp;            if (deleted != null) {</b>
<b class="nc">&nbsp;                fetchAlarms();</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            AlarmData current = alarmsMap.get(alarmId);</b>
<b class="nc">&nbsp;            boolean onCurrentPage = current != null;</b>
<b class="nc">&nbsp;            boolean matchesFilter = filter(alarm);</b>
<b class="nc">&nbsp;            if (onCurrentPage) {</b>
<b class="nc">&nbsp;                if (matchesFilter) {</b>
<b class="nc">&nbsp;                    AlarmData updated = new AlarmData(subscriptionUpdate.getAlarm(), current);</b>
<b class="nc">&nbsp;                    alarmsMap.put(alarmId, updated);</b>
<b class="nc">&nbsp;                    sendWsMsg(new AlarmDataUpdate(cmdId, null, Collections.singletonList(updated), maxEntitiesPerAlarmSubscription, data.getTotalElements()));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    fetchAlarms();</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (matchesFilter &amp;&amp; query.getPageLink().getPage() == 0) {</b>
<b class="nc">&nbsp;                fetchAlarms();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void cleanupOldAlarms() {
<b class="nc">&nbsp;        long expTime = System.currentTimeMillis() - query.getPageLink().getTimeWindow();</b>
<b class="nc">&nbsp;        boolean shouldRefresh = false;</b>
<b class="nc">&nbsp;        for (AlarmData alarmData : alarms.getData()) {</b>
<b class="nc">&nbsp;            if (alarmData.getCreatedTime() &lt; expTime) {</b>
<b class="nc">&nbsp;                shouldRefresh = true;</b>
&nbsp;                break;
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (shouldRefresh) {</b>
<b class="nc">&nbsp;            doFetchAlarms();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private boolean filter(Alarm alarm) {
<b class="nc">&nbsp;        AlarmDataPageLink filter = query.getPageLink();</b>
<b class="nc">&nbsp;        long startTs = System.currentTimeMillis() - filter.getTimeWindow();</b>
<b class="nc">&nbsp;        if (alarm.getCreatedTime() &lt; startTs) {</b>
&nbsp;            //Skip update that does not match time window.
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (filter.getTypeList() != null &amp;&amp; !filter.getTypeList().isEmpty() &amp;&amp; !filter.getTypeList().contains(alarm.getType())) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (filter.getSeverityList() != null &amp;&amp; !filter.getSeverityList().isEmpty()) {</b>
<b class="nc">&nbsp;            if (!filter.getSeverityList().contains(alarm.getSeverity())) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (filter.getStatusList() != null &amp;&amp; !filter.getStatusList().isEmpty()) {</b>
<b class="nc">&nbsp;            boolean matches = false;</b>
<b class="nc">&nbsp;            for (AlarmSearchStatus status : filter.getStatusList()) {</b>
<b class="nc">&nbsp;                switch (status) {</b>
&nbsp;                    case ANY:
<b class="nc">&nbsp;                        matches = true;</b>
&nbsp;                        break;
&nbsp;                    case ACK:
<b class="nc">&nbsp;                        matches = alarm.isAcknowledged();</b>
&nbsp;                        break;
&nbsp;                    case UNACK:
<b class="nc">&nbsp;                        matches = !alarm.isAcknowledged();</b>
&nbsp;                        break;
&nbsp;                    case CLEARED:
<b class="nc">&nbsp;                        matches = alarm.isCleared();</b>
&nbsp;                        break;
&nbsp;                    case ACTIVE:
<b class="nc">&nbsp;                        matches = !alarm.isCleared();</b>
&nbsp;                        break;
&nbsp;                }
<b class="nc">&nbsp;                if (matches) {</b>
&nbsp;                    break;
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (!matches) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    public synchronized void checkAndResetInvocationCounter() {
<b class="nc">&nbsp;        boolean fetchNeeded = this.alarmInvocationAttempts &gt; maxAlarmQueriesPerRefreshInterval;</b>
<b class="nc">&nbsp;        resetInvocationCounter();</b>
<b class="nc">&nbsp;        if (fetchNeeded) {</b>
<b class="nc">&nbsp;            fetchAlarms();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            cleanupOldAlarms();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected synchronized void doUpdate(Map&lt;EntityId, EntityData&gt; newDataMap) {
<b class="nc">&nbsp;        resetInvocationCounter();</b>
<b class="nc">&nbsp;        entitiesMap.clear();</b>
<b class="nc">&nbsp;        tooManyEntities = data.hasNext();</b>
<b class="nc">&nbsp;        for (EntityData entityData : data.getData()) {</b>
<b class="nc">&nbsp;            entitiesMap.put(entityData.getEntityId(), entityData);</b>
&nbsp;        }
<b class="nc">&nbsp;        fetchAlarms();</b>
<b class="nc">&nbsp;        List&lt;Integer&gt; subIdsToCancel = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        List&lt;TbSubscription&gt; subsToAdd = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        Set&lt;EntityId&gt; currentSubs = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;        subToEntityIdMap.forEach((subId, entityId) -&gt; {</b>
<b class="nc">&nbsp;            if (!newDataMap.containsKey(entityId)) {</b>
<b class="nc">&nbsp;                subIdsToCancel.add(subId);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                currentSubs.add(entityId);</b>
&nbsp;            }
&nbsp;        });
<b class="nc">&nbsp;        log.trace(&quot;[{}][{}] Subscriptions that are invalid: {}&quot;, sessionRef.getSessionId(), cmdId, subIdsToCancel);</b>
<b class="nc">&nbsp;        subIdsToCancel.forEach(subToEntityIdMap::remove);</b>
<b class="nc">&nbsp;        List&lt;EntityData&gt; newSubsList = newDataMap.entrySet().stream().filter(entry -&gt; !currentSubs.contains(entry.getKey())).map(Map.Entry::getValue).collect(Collectors.toList());</b>
<b class="nc">&nbsp;        if (!newSubsList.isEmpty()) {</b>
<b class="nc">&nbsp;            List&lt;EntityKey&gt; keys = query.getLatestValues();</b>
<b class="nc">&nbsp;            if (keys != null &amp;&amp; !keys.isEmpty()) {</b>
<b class="nc">&nbsp;                Map&lt;EntityKeyType, List&lt;EntityKey&gt;&gt; keysByType = getEntityKeyByTypeMap(keys);</b>
<b class="nc">&nbsp;                newSubsList.forEach(</b>
&nbsp;                        entity -&gt; {
<b class="nc">&nbsp;                            log.trace(&quot;[{}][{}] Found new subscription for entity: {}&quot;, sessionRef.getSessionId(), cmdId, entity.getEntityId());</b>
<b class="nc">&nbsp;                            subsToAdd.addAll(addSubscriptions(entity, keysByType, true, 0, 0));</b>
&nbsp;                        }
&nbsp;                );
&nbsp;            }
<b class="nc">&nbsp;            long startTs = System.currentTimeMillis() - query.getPageLink().getTimeWindow();</b>
<b class="nc">&nbsp;            newSubsList.forEach(entity -&gt; createAlarmSubscriptionForEntity(query.getPageLink(), startTs, entity));</b>
&nbsp;        }
<b class="nc">&nbsp;        subIdsToCancel.forEach(subId -&gt; localSubscriptionService.cancelSubscription(getTenantId(), getSessionId(), subId));</b>
<b class="nc">&nbsp;        subsToAdd.forEach(subscription -&gt; localSubscriptionService.addSubscription(subscription, sessionRef));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void resetInvocationCounter() {
<b class="nc">&nbsp;        alarmInvocationAttempts = 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected EntityDataQuery buildEntityDataQuery() {
<b class="nc">&nbsp;        EntityDataSortOrder sortOrder = query.getPageLink().getSortOrder();</b>
&nbsp;        EntityDataSortOrder entitiesSortOrder;
<b class="nc">&nbsp;        if (sortOrder == null || sortOrder.getKey().getType().equals(EntityKeyType.ALARM_FIELD)) {</b>
<b class="nc">&nbsp;            entitiesSortOrder = new EntityDataSortOrder(new EntityKey(EntityKeyType.ENTITY_FIELD, EntityKeyMapping.CREATED_TIME));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            entitiesSortOrder = sortOrder;</b>
&nbsp;        }
<b class="nc">&nbsp;        EntityDataPageLink edpl = new EntityDataPageLink(maxEntitiesPerAlarmSubscription, 0, null, entitiesSortOrder);</b>
<b class="nc">&nbsp;        return new EntityDataQuery(query.getEntityFilter(), edpl, query.getEntityFields(), query.getLatestValues(), query.getKeyFilters());</b>
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
