<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > TbAbstractDataSubCtx</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.server.service.subscription</a>
</div>

<h1>Coverage Summary for Class: TbAbstractDataSubCtx (org.thingsboard.server.service.subscription)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TbAbstractDataSubCtx</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/26)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/39)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/101)
  </span>
</td>
</tr>
  <tr>
    <td class="name">TbAbstractDataSubCtx$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/27)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/39)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/102)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.server.service.subscription;
&nbsp;
&nbsp;import lombok.Getter;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.thingsboard.server.common.data.id.EntityId;
&nbsp;import org.thingsboard.server.common.data.kv.Aggregation;
&nbsp;import org.thingsboard.server.common.data.page.PageData;
&nbsp;import org.thingsboard.server.common.data.query.AbstractDataQuery;
&nbsp;import org.thingsboard.server.common.data.query.EntityData;
&nbsp;import org.thingsboard.server.common.data.query.EntityDataPageLink;
&nbsp;import org.thingsboard.server.common.data.query.EntityDataQuery;
&nbsp;import org.thingsboard.server.common.data.query.EntityKey;
&nbsp;import org.thingsboard.server.common.data.query.EntityKeyType;
&nbsp;import org.thingsboard.server.common.data.query.TsValue;
&nbsp;import org.thingsboard.server.dao.attributes.AttributesService;
&nbsp;import org.thingsboard.server.dao.entity.EntityService;
&nbsp;import org.thingsboard.server.service.ws.WebSocketService;
&nbsp;import org.thingsboard.server.service.ws.WebSocketSessionRef;
&nbsp;import org.thingsboard.server.service.ws.telemetry.sub.TelemetrySubscriptionUpdate;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.function.Function;
&nbsp;import java.util.stream.Collectors;
&nbsp;
<b class="nc">&nbsp;@Slf4j</b>
&nbsp;public abstract class TbAbstractDataSubCtx&lt;T extends AbstractDataQuery&lt;? extends EntityDataPageLink&gt;&gt; extends TbAbstractEntityQuerySubCtx&lt;T&gt; {
&nbsp;
&nbsp;    protected final Map&lt;Integer, EntityId&gt; subToEntityIdMap;
&nbsp;    @Getter
&nbsp;    protected PageData&lt;EntityData&gt; data;
&nbsp;
&nbsp;    public TbAbstractDataSubCtx(String serviceId, WebSocketService wsService,
&nbsp;                                EntityService entityService, TbLocalSubscriptionService localSubscriptionService,
&nbsp;                                AttributesService attributesService, SubscriptionServiceStatistics stats,
&nbsp;                                WebSocketSessionRef sessionRef, int cmdId) {
<b class="nc">&nbsp;        super(serviceId, wsService, entityService, localSubscriptionService, attributesService, stats, sessionRef, cmdId);</b>
<b class="nc">&nbsp;        this.subToEntityIdMap = new ConcurrentHashMap&lt;&gt;();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void fetchData() {
<b class="nc">&nbsp;        this.data = findEntityData();</b>
&nbsp;    }
&nbsp;
&nbsp;    protected PageData&lt;EntityData&gt; findEntityData() {
<b class="nc">&nbsp;        PageData&lt;EntityData&gt; result = entityService.findEntityDataByQuery(getTenantId(), getCustomerId(), buildEntityDataQuery());</b>
<b class="nc">&nbsp;        if (log.isTraceEnabled()) {</b>
<b class="nc">&nbsp;            result.getData().forEach(ed -&gt; {</b>
<b class="nc">&nbsp;                log.trace(&quot;[{}][{}] EntityData: {}&quot;, getSessionId(), getCmdId(), ed);</b>
&nbsp;            });
&nbsp;        }
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isDynamic() {
<b class="nc">&nbsp;        return query != null &amp;&amp; query.getPageLink().isDynamic();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected synchronized void update() {
<b class="nc">&nbsp;        PageData&lt;EntityData&gt; newData = findEntityData();</b>
&nbsp;        Map&lt;EntityId, EntityData&gt; oldDataMap;
<b class="nc">&nbsp;        if (data != null &amp;&amp; !data.getData().isEmpty()) {</b>
<b class="nc">&nbsp;            oldDataMap = data.getData().stream().collect(Collectors.toMap(EntityData::getEntityId, Function.identity(), (a, b) -&gt; a));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            oldDataMap = Collections.emptyMap();</b>
&nbsp;        }
<b class="nc">&nbsp;        Map&lt;EntityId, EntityData&gt; newDataMap = newData.getData().stream().collect(Collectors.toMap(EntityData::getEntityId, Function.identity(), (a, b) -&gt; a));</b>
<b class="nc">&nbsp;        if (oldDataMap.size() == newDataMap.size() &amp;&amp; oldDataMap.keySet().equals(newDataMap.keySet())) {</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}] No updates to entity data found&quot;, sessionRef.getSessionId(), cmdId);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            this.data = newData;</b>
<b class="nc">&nbsp;            doUpdate(newDataMap);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected abstract void doUpdate(Map&lt;EntityId, EntityData&gt; newDataMap);
&nbsp;
&nbsp;    protected abstract EntityDataQuery buildEntityDataQuery();
&nbsp;
&nbsp;    public List&lt;EntityData&gt; getEntitiesData() {
<b class="nc">&nbsp;        return data.getData();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void clearSubscriptions() {
<b class="nc">&nbsp;        clearEntitySubscriptions();</b>
<b class="nc">&nbsp;        super.clearSubscriptions();</b>
&nbsp;    }
&nbsp;
&nbsp;    public void clearEntitySubscriptions() {
<b class="nc">&nbsp;        if (subToEntityIdMap != null) {</b>
<b class="nc">&nbsp;            for (Integer subId : subToEntityIdMap.keySet()) {</b>
<b class="nc">&nbsp;                localSubscriptionService.cancelSubscription(getTenantId(), getSessionId(), subId);</b>
&nbsp;            }
<b class="nc">&nbsp;            subToEntityIdMap.clear();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void createLatestValuesSubscriptions(List&lt;EntityKey&gt; keys) {
<b class="nc">&nbsp;        createSubscriptions(keys, true, 0, 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void createTimeSeriesSubscriptions(Map&lt;EntityData, Map&lt;String, Long&gt;&gt; entityKeyStates, long startTs, long endTs) {
<b class="nc">&nbsp;        createTimeSeriesSubscriptions(entityKeyStates, startTs, endTs, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void createTimeSeriesSubscriptions(Map&lt;EntityData, Map&lt;String, Long&gt;&gt; entityKeyStates, long startTs, long endTs, boolean resultToLatestValues) {
<b class="nc">&nbsp;        entityKeyStates.forEach((entityData, keyStates) -&gt; {</b>
<b class="nc">&nbsp;            int subIdx = sessionRef.getSessionSubIdSeq().incrementAndGet();</b>
<b class="nc">&nbsp;            subToEntityIdMap.put(subIdx, entityData.getEntityId());</b>
<b class="nc">&nbsp;            localSubscriptionService.addSubscription(</b>
<b class="nc">&nbsp;                    createTsSub(entityData, subIdx, false, startTs, endTs, keyStates, resultToLatestValues), sessionRef);</b>
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    private void createSubscriptions(List&lt;EntityKey&gt; keys, boolean latestValues, long startTs, long endTs) {
<b class="nc">&nbsp;        Map&lt;EntityKeyType, List&lt;EntityKey&gt;&gt; keysByType = getEntityKeyByTypeMap(keys);</b>
<b class="nc">&nbsp;        for (EntityData entityData : data.getData()) {</b>
<b class="nc">&nbsp;            List&lt;TbSubscription&gt; entitySubscriptions = addSubscriptions(entityData, keysByType, latestValues, startTs, endTs);</b>
<b class="nc">&nbsp;            entitySubscriptions.forEach(subscription -&gt; localSubscriptionService.addSubscription(subscription, sessionRef));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected Map&lt;EntityKeyType, List&lt;EntityKey&gt;&gt; getEntityKeyByTypeMap(List&lt;EntityKey&gt; keys) {
<b class="nc">&nbsp;        Map&lt;EntityKeyType, List&lt;EntityKey&gt;&gt; keysByType = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        keys.forEach(key -&gt; keysByType.computeIfAbsent(key.getType(), k -&gt; new ArrayList&lt;&gt;()).add(key));</b>
<b class="nc">&nbsp;        return keysByType;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected List&lt;TbSubscription&gt; addSubscriptions(EntityData entityData, Map&lt;EntityKeyType, List&lt;EntityKey&gt;&gt; keysByType, boolean latestValues, long startTs, long endTs) {
<b class="nc">&nbsp;        List&lt;TbSubscription&gt; subscriptionList = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        keysByType.forEach((keysType, keysList) -&gt; {</b>
<b class="nc">&nbsp;            int subIdx = sessionRef.getSessionSubIdSeq().incrementAndGet();</b>
<b class="nc">&nbsp;            subToEntityIdMap.put(subIdx, entityData.getEntityId());</b>
<b class="nc">&nbsp;            switch (keysType) {</b>
&nbsp;                case TIME_SERIES:
<b class="nc">&nbsp;                    subscriptionList.add(createTsSub(entityData, subIdx, keysList, latestValues, startTs, endTs));</b>
&nbsp;                    break;
&nbsp;                case CLIENT_ATTRIBUTE:
<b class="nc">&nbsp;                    subscriptionList.add(createAttrSub(entityData, subIdx, keysType, TbAttributeSubscriptionScope.CLIENT_SCOPE, keysList));</b>
&nbsp;                    break;
&nbsp;                case SHARED_ATTRIBUTE:
<b class="nc">&nbsp;                    subscriptionList.add(createAttrSub(entityData, subIdx, keysType, TbAttributeSubscriptionScope.SHARED_SCOPE, keysList));</b>
&nbsp;                    break;
&nbsp;                case SERVER_ATTRIBUTE:
<b class="nc">&nbsp;                    subscriptionList.add(createAttrSub(entityData, subIdx, keysType, TbAttributeSubscriptionScope.SERVER_SCOPE, keysList));</b>
&nbsp;                    break;
&nbsp;                case ATTRIBUTE:
<b class="nc">&nbsp;                    subscriptionList.add(createAttrSub(entityData, subIdx, keysType, TbAttributeSubscriptionScope.ANY_SCOPE, keysList));</b>
&nbsp;                    break;
&nbsp;            }
&nbsp;        });
<b class="nc">&nbsp;        return subscriptionList;</b>
&nbsp;    }
&nbsp;
&nbsp;    private TbSubscription createAttrSub(EntityData entityData, int subIdx, EntityKeyType keysType, TbAttributeSubscriptionScope scope, List&lt;EntityKey&gt; subKeys) {
<b class="nc">&nbsp;        Map&lt;String, Long&gt; keyStates = buildKeyStats(entityData, keysType, subKeys, true);</b>
<b class="nc">&nbsp;        log.trace(&quot;[{}][{}][{}] Creating attributes subscription for [{}] with keys: {}&quot;, serviceId, cmdId, subIdx, entityData.getEntityId(), keyStates);</b>
<b class="nc">&nbsp;        return TbAttributeSubscription.builder()</b>
<b class="nc">&nbsp;                .serviceId(serviceId)</b>
<b class="nc">&nbsp;                .sessionId(sessionRef.getSessionId())</b>
<b class="nc">&nbsp;                .subscriptionId(subIdx)</b>
<b class="nc">&nbsp;                .tenantId(sessionRef.getSecurityCtx().getTenantId())</b>
<b class="nc">&nbsp;                .entityId(entityData.getEntityId())</b>
<b class="nc">&nbsp;                .updateProcessor((sub, subscriptionUpdate) -&gt; sendWsMsg(sub.getSessionId(), subscriptionUpdate, keysType))</b>
<b class="nc">&nbsp;                .queryTs(createdTime)</b>
<b class="nc">&nbsp;                .allKeys(false)</b>
<b class="nc">&nbsp;                .keyStates(keyStates)</b>
<b class="nc">&nbsp;                .scope(scope)</b>
<b class="nc">&nbsp;                .build();</b>
&nbsp;    }
&nbsp;
&nbsp;    private TbSubscription createTsSub(EntityData entityData, int subIdx, List&lt;EntityKey&gt; subKeys, boolean latestValues, long startTs, long endTs) {
<b class="nc">&nbsp;        Map&lt;String, Long&gt; keyStates = buildKeyStats(entityData, EntityKeyType.TIME_SERIES, subKeys, latestValues);</b>
<b class="nc">&nbsp;        if (!latestValues &amp;&amp; entityData.getTimeseries() != null) {</b>
<b class="nc">&nbsp;            entityData.getTimeseries().forEach((k, v) -&gt; {</b>
<b class="nc">&nbsp;                long ts = Arrays.stream(v).map(TsValue::getTs).max(Long::compareTo).orElse(0L);</b>
<b class="nc">&nbsp;                log.trace(&quot;[{}][{}] Updating key: {} with ts: {}&quot;, serviceId, cmdId, k, ts);</b>
<b class="nc">&nbsp;                if (!Aggregation.NONE.equals(getCurrentAggregation()) &amp;&amp; ts &lt; endTs) {</b>
<b class="nc">&nbsp;                    ts = endTs;</b>
&nbsp;                }
<b class="nc">&nbsp;                keyStates.put(k, ts);</b>
&nbsp;            });
&nbsp;        }
<b class="nc">&nbsp;        return createTsSub(entityData, subIdx, latestValues, startTs, endTs, keyStates);</b>
&nbsp;    }
&nbsp;
&nbsp;    private TbTimeSeriesSubscription createTsSub(EntityData entityData, int subIdx, boolean latestValues, long startTs, long endTs, Map&lt;String, Long&gt; keyStates) {
<b class="nc">&nbsp;        return createTsSub(entityData, subIdx, latestValues, startTs, endTs, keyStates, latestValues);</b>
&nbsp;    }
&nbsp;
&nbsp;    private TbTimeSeriesSubscription createTsSub(EntityData entityData, int subIdx, boolean latestValues, long startTs, long endTs, Map&lt;String, Long&gt; keyStates, boolean resultToLatestValues) {
<b class="nc">&nbsp;        log.trace(&quot;[{}][{}][{}] Creating time-series subscription for [{}] with keys: {}&quot;, serviceId, cmdId, subIdx, entityData.getEntityId(), keyStates);</b>
<b class="nc">&nbsp;        return TbTimeSeriesSubscription.builder()</b>
<b class="nc">&nbsp;                .serviceId(serviceId)</b>
<b class="nc">&nbsp;                .sessionId(sessionRef.getSessionId())</b>
<b class="nc">&nbsp;                .subscriptionId(subIdx)</b>
<b class="nc">&nbsp;                .tenantId(sessionRef.getSecurityCtx().getTenantId())</b>
<b class="nc">&nbsp;                .entityId(entityData.getEntityId())</b>
<b class="nc">&nbsp;                .updateProcessor((sub, subscriptionUpdate) -&gt; sendWsMsg(sub.getSessionId(), subscriptionUpdate, EntityKeyType.TIME_SERIES, resultToLatestValues))</b>
<b class="nc">&nbsp;                .queryTs(createdTime)</b>
<b class="nc">&nbsp;                .allKeys(false)</b>
<b class="nc">&nbsp;                .keyStates(keyStates)</b>
<b class="nc">&nbsp;                .latestValues(latestValues)</b>
<b class="nc">&nbsp;                .startTime(startTs)</b>
<b class="nc">&nbsp;                .endTime(endTs)</b>
<b class="nc">&nbsp;                .build();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void sendWsMsg(String sessionId, TelemetrySubscriptionUpdate subscriptionUpdate, EntityKeyType keyType) {
<b class="nc">&nbsp;        sendWsMsg(sessionId, subscriptionUpdate, keyType, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Map&lt;String, Long&gt; buildKeyStats(EntityData entityData, EntityKeyType keysType, List&lt;EntityKey&gt; subKeys, boolean latestValues) {
<b class="nc">&nbsp;        Map&lt;String, Long&gt; keyStates = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        subKeys.forEach(key -&gt; keyStates.put(key.getKey(), 0L));</b>
<b class="nc">&nbsp;        if (latestValues &amp;&amp; entityData.getLatest() != null) {</b>
<b class="nc">&nbsp;            Map&lt;String, TsValue&gt; currentValues = entityData.getLatest().get(keysType);</b>
<b class="nc">&nbsp;            if (currentValues != null) {</b>
<b class="nc">&nbsp;                currentValues.forEach((k, v) -&gt; {</b>
<b class="nc">&nbsp;                    if (subKeys.contains(new EntityKey(keysType, k))) {</b>
<b class="nc">&nbsp;                        log.trace(&quot;[{}][{}] Updating key: {} with ts: {}&quot;, serviceId, cmdId, k, v.getTs());</b>
<b class="nc">&nbsp;                        keyStates.put(k, v.getTs());</b>
&nbsp;                    }
&nbsp;                });
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return keyStates;</b>
&nbsp;    }
&nbsp;
&nbsp;    abstract void sendWsMsg(String sessionId, TelemetrySubscriptionUpdate subscriptionUpdate, EntityKeyType keyType, boolean resultToLatestValues);
&nbsp;
&nbsp;    protected abstract Aggregation getCurrentAggregation();
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
