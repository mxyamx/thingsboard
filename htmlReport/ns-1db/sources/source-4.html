<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > DefaultGitVersionControlQueueService</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.server.service.sync.vc</a>
</div>

<h1>Coverage Summary for Class: DefaultGitVersionControlQueueService (org.thingsboard.server.service.sync.vc)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DefaultGitVersionControlQueueService</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/50)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/78)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/267)
  </span>
</td>
</tr>
  <tr>
    <td class="name">DefaultGitVersionControlQueueService$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/53)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/78)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/270)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.server.service.sync.vc;
&nbsp;
&nbsp;import com.google.common.collect.Iterables;
&nbsp;import com.google.common.util.concurrent.Futures;
&nbsp;import com.google.common.util.concurrent.ListenableFuture;
&nbsp;import com.google.common.util.concurrent.SettableFuture;
&nbsp;import lombok.SneakyThrows;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.apache.commons.lang3.exception.ExceptionUtils;
&nbsp;import org.springframework.beans.factory.annotation.Value;
&nbsp;import org.springframework.context.annotation.Lazy;
&nbsp;import org.springframework.stereotype.Service;
&nbsp;import org.thingsboard.common.util.JacksonUtil;
&nbsp;import org.thingsboard.server.cluster.TbClusterService;
&nbsp;import org.thingsboard.server.common.data.EntityType;
&nbsp;import org.thingsboard.server.common.data.ExportableEntity;
&nbsp;import org.thingsboard.server.common.data.StringUtils;
&nbsp;import org.thingsboard.server.common.data.User;
&nbsp;import org.thingsboard.server.common.data.id.EntityId;
&nbsp;import org.thingsboard.server.common.data.id.EntityIdFactory;
&nbsp;import org.thingsboard.server.common.data.id.TenantId;
&nbsp;import org.thingsboard.server.common.data.page.PageData;
&nbsp;import org.thingsboard.server.common.data.page.PageLink;
&nbsp;import org.thingsboard.server.common.data.sync.ie.EntityExportData;
&nbsp;import org.thingsboard.server.common.data.sync.vc.BranchInfo;
&nbsp;import org.thingsboard.server.common.data.sync.vc.EntityVersion;
&nbsp;import org.thingsboard.server.common.data.sync.vc.EntityVersionsDiff;
&nbsp;import org.thingsboard.server.common.data.sync.vc.RepositorySettings;
&nbsp;import org.thingsboard.server.common.data.sync.vc.VersionCreationResult;
&nbsp;import org.thingsboard.server.common.data.sync.vc.VersionedEntityInfo;
&nbsp;import org.thingsboard.server.common.data.sync.vc.request.create.VersionCreateRequest;
&nbsp;import org.thingsboard.server.common.data.util.CollectionsUtil;
&nbsp;import org.thingsboard.server.common.util.ProtoUtils;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.CommitRequestMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.EntitiesContentRequestMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.EntityContentRequestMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.GenericRepositoryRequestMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.ListEntitiesRequestMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.ListVersionsRequestMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.PrepareMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.ToVersionControlServiceMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.VersionControlResponseMsg;
&nbsp;import org.thingsboard.server.queue.TbQueueCallback;
&nbsp;import org.thingsboard.server.queue.TbQueueMsgMetadata;
&nbsp;import org.thingsboard.server.queue.discovery.TbServiceInfoProvider;
&nbsp;import org.thingsboard.server.queue.scheduler.SchedulerComponent;
&nbsp;import org.thingsboard.server.queue.util.TbCoreComponent;
&nbsp;import org.thingsboard.server.service.executors.VersionControlExecutor;
&nbsp;import org.thingsboard.server.service.sync.vc.data.ClearRepositoryGitRequest;
&nbsp;import org.thingsboard.server.service.sync.vc.data.CommitGitRequest;
&nbsp;import org.thingsboard.server.service.sync.vc.data.EntitiesContentGitRequest;
&nbsp;import org.thingsboard.server.service.sync.vc.data.EntityContentGitRequest;
&nbsp;import org.thingsboard.server.service.sync.vc.data.ListBranchesGitRequest;
&nbsp;import org.thingsboard.server.service.sync.vc.data.ListEntitiesGitRequest;
&nbsp;import org.thingsboard.server.service.sync.vc.data.ListVersionsGitRequest;
&nbsp;import org.thingsboard.server.service.sync.vc.data.PendingGitRequest;
&nbsp;import org.thingsboard.server.service.sync.vc.data.VersionsDiffGitRequest;
&nbsp;import org.thingsboard.server.service.sync.vc.data.VoidGitRequest;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Comparator;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Optional;
&nbsp;import java.util.UUID;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.concurrent.TimeoutException;
&nbsp;import java.util.concurrent.atomic.AtomicInteger;
&nbsp;import java.util.function.Consumer;
&nbsp;import java.util.function.Function;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;@TbCoreComponent
&nbsp;@Service
<b class="nc">&nbsp;@Slf4j</b>
&nbsp;@SuppressWarnings(&quot;UnstableApiUsage&quot;)
&nbsp;public class DefaultGitVersionControlQueueService implements GitVersionControlQueueService {
&nbsp;
&nbsp;    private final TbServiceInfoProvider serviceInfoProvider;
&nbsp;    private final TbClusterService clusterService;
&nbsp;    private final DefaultEntitiesVersionControlService entitiesVersionControlService;
&nbsp;    private final SchedulerComponent scheduler;
&nbsp;    private final VersionControlExecutor executor;
&nbsp;
<b class="nc">&nbsp;    private final Map&lt;UUID, PendingGitRequest&lt;?&gt;&gt; pendingRequestMap = new ConcurrentHashMap&lt;&gt;();</b>
<b class="nc">&nbsp;    private final Map&lt;UUID, HashMap&lt;Integer, String[]&gt;&gt; chunkedMsgs = new ConcurrentHashMap&lt;&gt;();</b>
&nbsp;
&nbsp;    @Value(&quot;${queue.vc.request-timeout:180000}&quot;)
&nbsp;    private int requestTimeout;
&nbsp;    @Value(&quot;${queue.vc.msg-chunk-size:250000}&quot;)
&nbsp;    private int msgChunkSize;
&nbsp;
&nbsp;    public DefaultGitVersionControlQueueService(TbServiceInfoProvider serviceInfoProvider, TbClusterService clusterService,
&nbsp;                                                @Lazy DefaultEntitiesVersionControlService entitiesVersionControlService,
<b class="nc">&nbsp;                                                SchedulerComponent scheduler, VersionControlExecutor executor) {</b>
<b class="nc">&nbsp;        this.serviceInfoProvider = serviceInfoProvider;</b>
<b class="nc">&nbsp;        this.clusterService = clusterService;</b>
<b class="nc">&nbsp;        this.entitiesVersionControlService = entitiesVersionControlService;</b>
<b class="nc">&nbsp;        this.scheduler = scheduler;</b>
<b class="nc">&nbsp;        this.executor = executor;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ListenableFuture&lt;CommitGitRequest&gt; prepareCommit(User user, VersionCreateRequest request) {
<b class="nc">&nbsp;        log.debug(&quot;Executing prepareCommit [{}][{}]&quot;, request.getBranch(), request.getVersionName());</b>
<b class="nc">&nbsp;        CommitGitRequest commit = new CommitGitRequest(user.getTenantId(), request);</b>
<b class="nc">&nbsp;        ListenableFuture&lt;Void&gt; future = registerAndSend(commit, builder -&gt; builder.setCommitRequest(</b>
<b class="nc">&nbsp;                buildCommitRequest(commit).setPrepareMsg(getCommitPrepareMsg(user, request)).build()</b>
<b class="nc">&nbsp;        ).build());</b>
<b class="nc">&nbsp;        return Futures.transform(future, f -&gt; commit, executor);</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    @SneakyThrows</b>
&nbsp;    @Override
&nbsp;    public ListenableFuture&lt;Void&gt; addToCommit(CommitGitRequest commit, EntityExportData&lt;ExportableEntity&lt;EntityId&gt;&gt; entityData) {
<b class="nc">&nbsp;        log.debug(&quot;Executing addToCommit [{}][{}][{}]&quot;, entityData.getEntityType(), entityData.getEntity().getId(), commit.getRequestId());</b>
<b class="nc">&nbsp;        String path = getRelativePath(entityData.getEntityType(), entityData.getExternalId());</b>
<b class="nc">&nbsp;        String entityDataJson = JacksonUtil.toPrettyString(entityData.sort());</b>
&nbsp;
<b class="nc">&nbsp;        Iterable&lt;String&gt; entityDataChunks = StringUtils.split(entityDataJson, msgChunkSize);</b>
<b class="nc">&nbsp;        String chunkedMsgId = UUID.randomUUID().toString();</b>
<b class="nc">&nbsp;        int chunksCount = Iterables.size(entityDataChunks);</b>
&nbsp;
<b class="nc">&nbsp;        AtomicInteger chunkIndex = new AtomicInteger();</b>
<b class="nc">&nbsp;        List&lt;ListenableFuture&lt;Void&gt;&gt; futures = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        entityDataChunks.forEach(chunk -&gt; {</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}] sending chunk {} for &#39;addToCommit&#39;&quot;, chunkedMsgId, chunkIndex.get());</b>
<b class="nc">&nbsp;            ListenableFuture&lt;Void&gt; chunkFuture = registerAndSend(commit, builder -&gt; builder.setCommitRequest(</b>
<b class="nc">&nbsp;                    buildCommitRequest(commit).setAddMsg(TransportProtos.AddMsg.newBuilder()</b>
<b class="nc">&nbsp;                            .setRelativePath(path).setEntityDataJsonChunk(chunk)</b>
<b class="nc">&nbsp;                            .setChunkedMsgId(chunkedMsgId).setChunkIndex(chunkIndex.getAndIncrement())</b>
<b class="nc">&nbsp;                            .setChunksCount(chunksCount)</b>
<b class="nc">&nbsp;                    ).build()</b>
<b class="nc">&nbsp;            ).build());</b>
<b class="nc">&nbsp;            futures.add(chunkFuture);</b>
&nbsp;        });
<b class="nc">&nbsp;        return Futures.transform(Futures.allAsList(futures), r -&gt; {</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}] sent all chunks for &#39;addToCommit&#39;&quot;, chunkedMsgId);</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }, executor);
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ListenableFuture&lt;Void&gt; deleteAll(CommitGitRequest commit, EntityType entityType) {
<b class="nc">&nbsp;        log.debug(&quot;Executing deleteAll [{}][{}][{}]&quot;, commit.getTenantId(), entityType, commit.getRequestId());</b>
<b class="nc">&nbsp;        String path = getRelativePath(entityType, null);</b>
<b class="nc">&nbsp;        return registerAndSend(commit, builder -&gt; builder.setCommitRequest(</b>
<b class="nc">&nbsp;                buildCommitRequest(commit).setDeleteMsg(</b>
<b class="nc">&nbsp;                        TransportProtos.DeleteMsg.newBuilder().setRelativePath(path)</b>
<b class="nc">&nbsp;                )).build());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ListenableFuture&lt;VersionCreationResult&gt; push(CommitGitRequest commit) {
<b class="nc">&nbsp;        log.debug(&quot;Executing push [{}][{}]&quot;, commit.getTenantId(), commit.getRequestId());</b>
<b class="nc">&nbsp;        return sendRequest(commit, builder -&gt; builder.setCommitRequest(</b>
<b class="nc">&nbsp;                buildCommitRequest(commit).setPushMsg(TransportProtos.PushMsg.getDefaultInstance())</b>
&nbsp;        ));
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ListenableFuture&lt;PageData&lt;EntityVersion&gt;&gt; listVersions(TenantId tenantId, String branch, PageLink pageLink) {
<b class="nc">&nbsp;        return listVersions(tenantId,</b>
<b class="nc">&nbsp;                applyPageLinkParameters(</b>
<b class="nc">&nbsp;                        ListVersionsRequestMsg.newBuilder()</b>
<b class="nc">&nbsp;                                .setBranchName(branch),</b>
&nbsp;                        pageLink
<b class="nc">&nbsp;                ).build());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ListenableFuture&lt;PageData&lt;EntityVersion&gt;&gt; listVersions(TenantId tenantId, String branch, EntityType entityType, PageLink pageLink) {
<b class="nc">&nbsp;        return listVersions(tenantId,</b>
<b class="nc">&nbsp;                applyPageLinkParameters(</b>
<b class="nc">&nbsp;                        ListVersionsRequestMsg.newBuilder()</b>
<b class="nc">&nbsp;                                .setBranchName(branch)</b>
<b class="nc">&nbsp;                                .setEntityType(entityType.name()),</b>
&nbsp;                        pageLink
<b class="nc">&nbsp;                ).build());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ListenableFuture&lt;PageData&lt;EntityVersion&gt;&gt; listVersions(TenantId tenantId, String branch, EntityId entityId, PageLink pageLink) {
<b class="nc">&nbsp;        return listVersions(tenantId,</b>
<b class="nc">&nbsp;                applyPageLinkParameters(</b>
<b class="nc">&nbsp;                        ListVersionsRequestMsg.newBuilder()</b>
<b class="nc">&nbsp;                                .setBranchName(branch)</b>
<b class="nc">&nbsp;                                .setEntityType(entityId.getEntityType().name())</b>
<b class="nc">&nbsp;                                .setEntityIdMSB(entityId.getId().getMostSignificantBits())</b>
<b class="nc">&nbsp;                                .setEntityIdLSB(entityId.getId().getLeastSignificantBits()),</b>
&nbsp;                        pageLink
<b class="nc">&nbsp;                ).build());</b>
&nbsp;    }
&nbsp;
&nbsp;    private ListVersionsRequestMsg.Builder applyPageLinkParameters(ListVersionsRequestMsg.Builder builder, PageLink pageLink) {
<b class="nc">&nbsp;        builder.setPageSize(pageLink.getPageSize())</b>
<b class="nc">&nbsp;                .setPage(pageLink.getPage());</b>
<b class="nc">&nbsp;        if (pageLink.getTextSearch() != null) {</b>
<b class="nc">&nbsp;            builder.setTextSearch(pageLink.getTextSearch());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (pageLink.getSortOrder() != null) {</b>
<b class="nc">&nbsp;            if (pageLink.getSortOrder().getProperty() != null) {</b>
<b class="nc">&nbsp;                builder.setSortProperty(pageLink.getSortOrder().getProperty());</b>
&nbsp;            }
<b class="nc">&nbsp;            if (pageLink.getSortOrder().getDirection() != null) {</b>
<b class="nc">&nbsp;                builder.setSortDirection(pageLink.getSortOrder().getDirection().name());</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return builder;</b>
&nbsp;    }
&nbsp;
&nbsp;    private ListenableFuture&lt;PageData&lt;EntityVersion&gt;&gt; listVersions(TenantId tenantId, ListVersionsRequestMsg requestMsg) {
<b class="nc">&nbsp;        ListVersionsGitRequest request = new ListVersionsGitRequest(tenantId);</b>
<b class="nc">&nbsp;        return sendRequest(request, builder -&gt; builder.setListVersionRequest(requestMsg));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ListenableFuture&lt;List&lt;VersionedEntityInfo&gt;&gt; listEntitiesAtVersion(TenantId tenantId, String versionId, EntityType entityType) {
<b class="nc">&nbsp;        return listEntitiesAtVersion(tenantId, ListEntitiesRequestMsg.newBuilder()</b>
<b class="nc">&nbsp;                .setVersionId(versionId)</b>
<b class="nc">&nbsp;                .setEntityType(entityType.name())</b>
<b class="nc">&nbsp;                .build());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ListenableFuture&lt;List&lt;VersionedEntityInfo&gt;&gt; listEntitiesAtVersion(TenantId tenantId, String versionId) {
<b class="nc">&nbsp;        return listEntitiesAtVersion(tenantId, ListEntitiesRequestMsg.newBuilder()</b>
<b class="nc">&nbsp;                .setVersionId(versionId)</b>
<b class="nc">&nbsp;                .build());</b>
&nbsp;    }
&nbsp;
&nbsp;    private ListenableFuture&lt;List&lt;VersionedEntityInfo&gt;&gt; listEntitiesAtVersion(TenantId tenantId, TransportProtos.ListEntitiesRequestMsg requestMsg) {
<b class="nc">&nbsp;        ListEntitiesGitRequest request = new ListEntitiesGitRequest(tenantId);</b>
<b class="nc">&nbsp;        return sendRequest(request, builder -&gt; builder.setListEntitiesRequest(requestMsg));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ListenableFuture&lt;List&lt;BranchInfo&gt;&gt; listBranches(TenantId tenantId) {
<b class="nc">&nbsp;        ListBranchesGitRequest request = new ListBranchesGitRequest(tenantId);</b>
<b class="nc">&nbsp;        return sendRequest(request, builder -&gt; builder.setListBranchesRequest(TransportProtos.ListBranchesRequestMsg.newBuilder().build()));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ListenableFuture&lt;List&lt;EntityVersionsDiff&gt;&gt; getVersionsDiff(TenantId tenantId, EntityType entityType, EntityId externalId, String versionId1, String versionId2) {
<b class="nc">&nbsp;        String path = entityType != null ? getRelativePath(entityType, externalId) : &quot;&quot;;</b>
<b class="nc">&nbsp;        VersionsDiffGitRequest request = new VersionsDiffGitRequest(tenantId, path, versionId1, versionId2);</b>
<b class="nc">&nbsp;        return sendRequest(request, builder -&gt; builder.setVersionsDiffRequest(TransportProtos.VersionsDiffRequestMsg.newBuilder()</b>
<b class="nc">&nbsp;                .setPath(request.getPath())</b>
<b class="nc">&nbsp;                .setVersionId1(request.getVersionId1())</b>
<b class="nc">&nbsp;                .setVersionId2(request.getVersionId2())</b>
<b class="nc">&nbsp;                .build()));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @SuppressWarnings(&quot;rawtypes&quot;)
&nbsp;    public ListenableFuture&lt;EntityExportData&gt; getEntity(TenantId tenantId, String versionId, EntityId entityId) {
<b class="nc">&nbsp;        log.debug(&quot;Executing getEntity [{}][{}][{}]&quot;, tenantId, versionId, entityId);</b>
<b class="nc">&nbsp;        EntityContentGitRequest request = new EntityContentGitRequest(tenantId, versionId, entityId);</b>
<b class="nc">&nbsp;        chunkedMsgs.put(request.getRequestId(), new HashMap&lt;&gt;());</b>
<b class="nc">&nbsp;        return sendRequest(request, builder -&gt; builder.setEntityContentRequest(EntityContentRequestMsg.newBuilder()</b>
<b class="nc">&nbsp;                .setVersionId(versionId)</b>
<b class="nc">&nbsp;                .setEntityType(entityId.getEntityType().name())</b>
<b class="nc">&nbsp;                .setEntityIdMSB(entityId.getId().getMostSignificantBits())</b>
<b class="nc">&nbsp;                .setEntityIdLSB(entityId.getId().getLeastSignificantBits())).build());</b>
&nbsp;    }
&nbsp;
&nbsp;    private &lt;T&gt; ListenableFuture&lt;Void&gt; registerAndSend(PendingGitRequest&lt;T&gt; request,
&nbsp;                                                       Function&lt;ToVersionControlServiceMsg.Builder, ToVersionControlServiceMsg&gt; enrichFunction) {
<b class="nc">&nbsp;        return registerAndSend(request, enrichFunction, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    private &lt;T&gt; ListenableFuture&lt;Void&gt; registerAndSend(PendingGitRequest&lt;T&gt; request,
&nbsp;                                                       Function&lt;ToVersionControlServiceMsg.Builder, ToVersionControlServiceMsg&gt; enrichFunction,
&nbsp;                                                       RepositorySettings settings) {
<b class="nc">&nbsp;        if (!request.getFuture().isDone()) {</b>
<b class="nc">&nbsp;            pendingRequestMap.putIfAbsent(request.getRequestId(), request);</b>
<b class="nc">&nbsp;            var requestBody = enrichFunction.apply(newRequestProto(request, settings));</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}] PUSHING request: {}&quot;, request.getTenantId(), request.getRequestId(), requestBody);</b>
<b class="nc">&nbsp;            SettableFuture&lt;Void&gt; submitFuture = SettableFuture.create();</b>
<b class="nc">&nbsp;            clusterService.pushMsgToVersionControl(request.getTenantId(), requestBody, new TbQueueCallback() {</b>
&nbsp;                @Override
&nbsp;                public void onSuccess(TbQueueMsgMetadata metadata) {
<b class="nc">&nbsp;                    submitFuture.set(null);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onFailure(Throwable t) {
<b class="nc">&nbsp;                    submitFuture.setException(t);</b>
&nbsp;                }
&nbsp;            });
<b class="nc">&nbsp;            if (request.getTimeoutTask() == null) {</b>
<b class="nc">&nbsp;                request.setTimeoutTask(scheduler.schedule(() -&gt; processTimeout(request.getRequestId()), requestTimeout, TimeUnit.MILLISECONDS));</b>
&nbsp;            }
<b class="nc">&nbsp;            return submitFuture;</b>
&nbsp;        } else {
&nbsp;            try {
<b class="nc">&nbsp;                request.getFuture().get();</b>
<b class="nc">&nbsp;                throw new RuntimeException(&quot;Failed to process the request&quot;);</b>
&nbsp;            } catch (Exception e) {
<b class="nc">&nbsp;                Throwable cause = ExceptionUtils.getRootCause(e);</b>
<b class="nc">&nbsp;                throw new RuntimeException(cause.getMessage(), cause);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private &lt;T&gt; ListenableFuture&lt;T&gt; sendRequest(PendingGitRequest&lt;T&gt; request, Consumer&lt;ToVersionControlServiceMsg.Builder&gt; enrichFunction) {
<b class="nc">&nbsp;        return sendRequest(request, enrichFunction, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    private &lt;T&gt; ListenableFuture&lt;T&gt; sendRequest(PendingGitRequest&lt;T&gt; request, Consumer&lt;ToVersionControlServiceMsg.Builder&gt; enrichFunction, RepositorySettings settings) {
<b class="nc">&nbsp;        ListenableFuture&lt;Void&gt; submitFuture = registerAndSend(request, builder -&gt; {</b>
<b class="nc">&nbsp;            enrichFunction.accept(builder);</b>
<b class="nc">&nbsp;            return builder.build();</b>
&nbsp;        }, settings);
<b class="nc">&nbsp;        return Futures.transformAsync(submitFuture, input -&gt; request.getFuture(), executor);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @SuppressWarnings(&quot;rawtypes&quot;)
&nbsp;    public ListenableFuture&lt;List&lt;EntityExportData&gt;&gt; getEntities(TenantId tenantId, String versionId, EntityType entityType, int offset, int limit) {
<b class="nc">&nbsp;        log.debug(&quot;Executing getEntities [{}][{}][{}]&quot;, tenantId, versionId, entityType);</b>
<b class="nc">&nbsp;        EntitiesContentGitRequest request = new EntitiesContentGitRequest(tenantId, versionId, entityType);</b>
<b class="nc">&nbsp;        chunkedMsgs.put(request.getRequestId(), new HashMap&lt;&gt;());</b>
<b class="nc">&nbsp;        return sendRequest(request, builder -&gt; builder.setEntitiesContentRequest(</b>
<b class="nc">&nbsp;                EntitiesContentRequestMsg.newBuilder()</b>
<b class="nc">&nbsp;                        .setVersionId(versionId)</b>
<b class="nc">&nbsp;                        .setEntityType(entityType.name())</b>
<b class="nc">&nbsp;                        .setOffset(offset)</b>
<b class="nc">&nbsp;                        .setLimit(limit)</b>
<b class="nc">&nbsp;        ).build());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ListenableFuture&lt;Void&gt; initRepository(TenantId tenantId, RepositorySettings settings) {
<b class="nc">&nbsp;        log.debug(&quot;Executing initRepository [{}]&quot;, tenantId);</b>
<b class="nc">&nbsp;        VoidGitRequest request = new VoidGitRequest(tenantId);</b>
<b class="nc">&nbsp;        return sendRequest(request, builder -&gt; builder.setInitRepositoryRequest(GenericRepositoryRequestMsg.getDefaultInstance()), settings);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ListenableFuture&lt;Void&gt; testRepository(TenantId tenantId, RepositorySettings settings) {
<b class="nc">&nbsp;        log.debug(&quot;Executing testRepository [{}]&quot;, tenantId);</b>
<b class="nc">&nbsp;        VoidGitRequest request = new VoidGitRequest(tenantId);</b>
<b class="nc">&nbsp;        return sendRequest(request, builder -&gt; builder.setTestRepositoryRequest(GenericRepositoryRequestMsg.getDefaultInstance()), settings);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ListenableFuture&lt;Void&gt; clearRepository(TenantId tenantId) {
<b class="nc">&nbsp;        log.debug(&quot;Executing clearRepository [{}]&quot;, tenantId);</b>
<b class="nc">&nbsp;        ClearRepositoryGitRequest request = new ClearRepositoryGitRequest(tenantId);</b>
<b class="nc">&nbsp;        return sendRequest(request, builder -&gt; builder.setClearRepositoryRequest(GenericRepositoryRequestMsg.getDefaultInstance()));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void processResponse(VersionControlResponseMsg vcResponseMsg) {
<b class="nc">&nbsp;        UUID requestId = new UUID(vcResponseMsg.getRequestIdMSB(), vcResponseMsg.getRequestIdLSB());</b>
<b class="nc">&nbsp;        PendingGitRequest&lt;?&gt; request = pendingRequestMap.get(requestId);</b>
<b class="nc">&nbsp;        if (request == null) {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}] received stale response: {}&quot;, requestId, vcResponseMsg);</b>
&nbsp;            return;
&nbsp;        } else {
<b class="nc">&nbsp;            log.debug(&quot;[{}] processing response: {}&quot;, requestId, vcResponseMsg);</b>
&nbsp;        }
<b class="nc">&nbsp;        var future = request.getFuture();</b>
<b class="nc">&nbsp;        boolean completed = true;</b>
<b class="nc">&nbsp;        if (!StringUtils.isEmpty(vcResponseMsg.getError())) {</b>
<b class="nc">&nbsp;            future.setException(new RuntimeException(vcResponseMsg.getError()));</b>
&nbsp;        } else {
&nbsp;            try {
<b class="nc">&nbsp;                if (vcResponseMsg.hasGenericResponse()) {</b>
<b class="nc">&nbsp;                    future.set(null);</b>
<b class="nc">&nbsp;                } else if (vcResponseMsg.hasCommitResponse()) {</b>
<b class="nc">&nbsp;                    var commitResponse = vcResponseMsg.getCommitResponse();</b>
<b class="nc">&nbsp;                    var commitResult = new VersionCreationResult();</b>
<b class="nc">&nbsp;                    if (commitResponse.getTs() &gt; 0) {</b>
<b class="nc">&nbsp;                        commitResult.setVersion(new EntityVersion(commitResponse.getTs(), commitResponse.getCommitId(), commitResponse.getName(), commitResponse.getAuthor()));</b>
&nbsp;                    }
<b class="nc">&nbsp;                    commitResult.setAdded(commitResponse.getAdded());</b>
<b class="nc">&nbsp;                    commitResult.setRemoved(commitResponse.getRemoved());</b>
<b class="nc">&nbsp;                    commitResult.setModified(commitResponse.getModified());</b>
<b class="nc">&nbsp;                    commitResult.setDone(true);</b>
<b class="nc">&nbsp;                    ((CommitGitRequest) request).getFuture().set(commitResult);</b>
<b class="nc">&nbsp;                } else if (vcResponseMsg.hasListBranchesResponse()) {</b>
<b class="nc">&nbsp;                    var listBranchesResponse = vcResponseMsg.getListBranchesResponse();</b>
<b class="nc">&nbsp;                    ((ListBranchesGitRequest) request).getFuture().set(listBranchesResponse.getBranchesList().stream().map(this::getBranchInfo).collect(Collectors.toList()));</b>
<b class="nc">&nbsp;                } else if (vcResponseMsg.hasListEntitiesResponse()) {</b>
<b class="nc">&nbsp;                    var listEntitiesResponse = vcResponseMsg.getListEntitiesResponse();</b>
<b class="nc">&nbsp;                    ((ListEntitiesGitRequest) request).getFuture().set(</b>
<b class="nc">&nbsp;                            listEntitiesResponse.getEntitiesList().stream().map(this::getVersionedEntityInfo).collect(Collectors.toList()));</b>
<b class="nc">&nbsp;                } else if (vcResponseMsg.hasListVersionsResponse()) {</b>
<b class="nc">&nbsp;                    var listVersionsResponse = vcResponseMsg.getListVersionsResponse();</b>
<b class="nc">&nbsp;                    ((ListVersionsGitRequest) request).getFuture().set(toPageData(listVersionsResponse));</b>
<b class="nc">&nbsp;                } else if (vcResponseMsg.hasEntityContentResponse()) {</b>
<b class="nc">&nbsp;                    TransportProtos.EntityContentResponseMsg responseMsg = vcResponseMsg.getEntityContentResponse();</b>
<b class="nc">&nbsp;                    log.trace(&quot;Received chunk {} for &#39;getEntity&#39;&quot;, responseMsg.getChunkIndex());</b>
<b class="nc">&nbsp;                    var joined = joinChunks(requestId, responseMsg, 0, 1);</b>
<b class="nc">&nbsp;                    if (joined.isPresent()) {</b>
<b class="nc">&nbsp;                        log.trace(&quot;Collected all chunks for &#39;getEntity&#39;&quot;);</b>
<b class="nc">&nbsp;                        ((EntityContentGitRequest) request).getFuture().set(joined.get().get(0));</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        completed = false;</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (vcResponseMsg.hasEntitiesContentResponse()) {</b>
<b class="nc">&nbsp;                    TransportProtos.EntitiesContentResponseMsg responseMsg = vcResponseMsg.getEntitiesContentResponse();</b>
<b class="nc">&nbsp;                    TransportProtos.EntityContentResponseMsg item = responseMsg.getItem();</b>
<b class="nc">&nbsp;                    if (responseMsg.getItemsCount() &gt; 0) {</b>
<b class="nc">&nbsp;                        var joined = joinChunks(requestId, item, responseMsg.getItemIdx(), responseMsg.getItemsCount());</b>
<b class="nc">&nbsp;                        if (joined.isPresent()) {</b>
<b class="nc">&nbsp;                            ((EntitiesContentGitRequest) request).getFuture().set(joined.get());</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            completed = false;</b>
&nbsp;                        }
&nbsp;                    } else {
<b class="nc">&nbsp;                        ((EntitiesContentGitRequest) request).getFuture().set(Collections.emptyList());</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (vcResponseMsg.hasVersionsDiffResponse()) {</b>
<b class="nc">&nbsp;                    TransportProtos.VersionsDiffResponseMsg diffResponse = vcResponseMsg.getVersionsDiffResponse();</b>
<b class="nc">&nbsp;                    List&lt;EntityVersionsDiff&gt; entityVersionsDiffList = diffResponse.getDiffList().stream()</b>
<b class="nc">&nbsp;                            .map(diff -&gt; EntityVersionsDiff.builder()</b>
<b class="nc">&nbsp;                                    .externalId(EntityIdFactory.getByTypeAndUuid(EntityType.valueOf(diff.getEntityType()),</b>
<b class="nc">&nbsp;                                            new UUID(diff.getEntityIdMSB(), diff.getEntityIdLSB())))</b>
<b class="nc">&nbsp;                                    .entityDataAtVersion1(StringUtils.isNotEmpty(diff.getEntityDataAtVersion1()) ?</b>
<b class="nc">&nbsp;                                            toData(diff.getEntityDataAtVersion1()) : null)</b>
<b class="nc">&nbsp;                                    .entityDataAtVersion2(StringUtils.isNotEmpty(diff.getEntityDataAtVersion2()) ?</b>
<b class="nc">&nbsp;                                            toData(diff.getEntityDataAtVersion2()) : null)</b>
<b class="nc">&nbsp;                                    .rawDiff(diff.getRawDiff())</b>
<b class="nc">&nbsp;                                    .build())</b>
<b class="nc">&nbsp;                            .collect(Collectors.toList());</b>
<b class="nc">&nbsp;                    ((VersionsDiffGitRequest) request).getFuture().set(entityVersionsDiffList);</b>
&nbsp;                }
&nbsp;            } catch (Exception e) {
<b class="nc">&nbsp;                future.setException(e);</b>
&nbsp;                throw e;
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (completed) {</b>
<b class="nc">&nbsp;            removePendingRequest(requestId);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;rawtypes&quot;)
&nbsp;    private Optional&lt;List&lt;EntityExportData&gt;&gt; joinChunks(UUID requestId, TransportProtos.EntityContentResponseMsg responseMsg, int itemIdx, int expectedMsgCount) {
<b class="nc">&nbsp;        var chunksMap = chunkedMsgs.get(requestId);</b>
<b class="nc">&nbsp;        if (chunksMap == null) {</b>
<b class="nc">&nbsp;            return Optional.empty();</b>
&nbsp;        }
<b class="nc">&nbsp;        String[] msgChunks = chunksMap.computeIfAbsent(itemIdx, id -&gt; new String[responseMsg.getChunksCount()]);</b>
<b class="nc">&nbsp;        msgChunks[responseMsg.getChunkIndex()] = responseMsg.getData();</b>
<b class="nc">&nbsp;        if (chunksMap.size() == expectedMsgCount &amp;&amp; chunksMap.values().stream()</b>
<b class="nc">&nbsp;                .allMatch(chunks -&gt; CollectionsUtil.countNonNull(chunks) == chunks.length)) {</b>
<b class="nc">&nbsp;            return Optional.of(chunksMap.entrySet().stream()</b>
<b class="nc">&nbsp;                    .sorted(Comparator.comparingInt(Map.Entry::getKey)).map(Map.Entry::getValue)</b>
<b class="nc">&nbsp;                    .map(chunks -&gt; String.join(&quot;&quot;, chunks))</b>
<b class="nc">&nbsp;                    .map(this::toData)</b>
<b class="nc">&nbsp;                    .collect(Collectors.toList()));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return Optional.empty();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void processTimeout(UUID requestId) {
<b class="nc">&nbsp;        PendingGitRequest&lt;?&gt; pendingRequest = removePendingRequest(requestId);</b>
<b class="nc">&nbsp;        if (pendingRequest != null) {</b>
<b class="nc">&nbsp;            log.debug(&quot;[{}] request timed out ({} ms}&quot;, requestId, requestTimeout);</b>
<b class="nc">&nbsp;            pendingRequest.getFuture().setException(new TimeoutException(&quot;Request timed out&quot;));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private PendingGitRequest&lt;?&gt; removePendingRequest(UUID requestId) {
<b class="nc">&nbsp;        PendingGitRequest&lt;?&gt; pendingRequest = pendingRequestMap.remove(requestId);</b>
<b class="nc">&nbsp;        if (pendingRequest != null &amp;&amp; pendingRequest.getTimeoutTask() != null) {</b>
<b class="nc">&nbsp;            pendingRequest.getTimeoutTask().cancel(true);</b>
<b class="nc">&nbsp;            pendingRequest.setTimeoutTask(null);</b>
&nbsp;        }
<b class="nc">&nbsp;        chunkedMsgs.remove(requestId);</b>
<b class="nc">&nbsp;        return pendingRequest;</b>
&nbsp;    }
&nbsp;
&nbsp;    private PageData&lt;EntityVersion&gt; toPageData(TransportProtos.ListVersionsResponseMsg listVersionsResponse) {
<b class="nc">&nbsp;        var listVersions = listVersionsResponse.getVersionsList().stream().map(this::getEntityVersion).collect(Collectors.toList());</b>
<b class="nc">&nbsp;        return new PageData&lt;&gt;(listVersions, listVersionsResponse.getTotalPages(), listVersionsResponse.getTotalElements(), listVersionsResponse.getHasNext());</b>
&nbsp;    }
&nbsp;
&nbsp;    private EntityVersion getEntityVersion(TransportProtos.EntityVersionProto proto) {
<b class="nc">&nbsp;        return new EntityVersion(proto.getTs(), proto.getId(), proto.getName(), proto.getAuthor());</b>
&nbsp;    }
&nbsp;
&nbsp;    private VersionedEntityInfo getVersionedEntityInfo(TransportProtos.VersionedEntityInfoProto proto) {
<b class="nc">&nbsp;        return new VersionedEntityInfo(EntityIdFactory.getByTypeAndUuid(proto.getEntityType(), new UUID(proto.getEntityIdMSB(), proto.getEntityIdLSB())));</b>
&nbsp;    }
&nbsp;
&nbsp;    private BranchInfo getBranchInfo(TransportProtos.BranchInfoProto proto) {
<b class="nc">&nbsp;        return new BranchInfo(proto.getName(), proto.getIsDefault());</b>
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;rawtypes&quot;)
<b class="nc">&nbsp;    @SneakyThrows</b>
&nbsp;    private EntityExportData toData(String data) {
<b class="nc">&nbsp;        return JacksonUtil.fromString(data, EntityExportData.class);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static String getRelativePath(EntityType entityType, EntityId entityId) {
<b class="nc">&nbsp;        String path = entityType.name().toLowerCase();</b>
<b class="nc">&nbsp;        if (entityId != null) {</b>
<b class="nc">&nbsp;            path += &quot;/&quot; + entityId + &quot;.json&quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        return path;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static PrepareMsg getCommitPrepareMsg(User user, VersionCreateRequest request) {
<b class="nc">&nbsp;        return PrepareMsg.newBuilder().setCommitMsg(request.getVersionName())</b>
<b class="nc">&nbsp;                .setBranchName(request.getBranch()).setAuthorName(getAuthorName(user)).setAuthorEmail(user.getEmail()).build();</b>
&nbsp;    }
&nbsp;
&nbsp;    private static String getAuthorName(User user) {
<b class="nc">&nbsp;        List&lt;String&gt; parts = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        if (StringUtils.isNotBlank(user.getFirstName())) {</b>
<b class="nc">&nbsp;            parts.add(user.getFirstName());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (StringUtils.isNotBlank(user.getLastName())) {</b>
<b class="nc">&nbsp;            parts.add(user.getLastName());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (parts.isEmpty()) {</b>
<b class="nc">&nbsp;            parts.add(user.getName());</b>
&nbsp;        }
<b class="nc">&nbsp;        return String.join(&quot; &quot;, parts);</b>
&nbsp;    }
&nbsp;
&nbsp;    private ToVersionControlServiceMsg.Builder newRequestProto(PendingGitRequest&lt;?&gt; request, RepositorySettings settings) {
<b class="nc">&nbsp;        var tenantId = request.getTenantId();</b>
<b class="nc">&nbsp;        var requestId = request.getRequestId();</b>
<b class="nc">&nbsp;        var builder = ToVersionControlServiceMsg.newBuilder()</b>
<b class="nc">&nbsp;                .setNodeId(serviceInfoProvider.getServiceId())</b>
<b class="nc">&nbsp;                .setTenantIdMSB(tenantId.getId().getMostSignificantBits())</b>
<b class="nc">&nbsp;                .setTenantIdLSB(tenantId.getId().getLeastSignificantBits())</b>
<b class="nc">&nbsp;                .setRequestIdMSB(requestId.getMostSignificantBits())</b>
<b class="nc">&nbsp;                .setRequestIdLSB(requestId.getLeastSignificantBits());</b>
<b class="nc">&nbsp;        RepositorySettings vcSettings = settings;</b>
<b class="nc">&nbsp;        if (vcSettings == null &amp;&amp; request.requiresSettings()) {</b>
<b class="nc">&nbsp;            vcSettings = entitiesVersionControlService.getVersionControlSettings(tenantId);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (vcSettings != null) {</b>
<b class="nc">&nbsp;            builder.setVcSettings(ProtoUtils.toProto(vcSettings));</b>
<b class="nc">&nbsp;        } else if (request.requiresSettings()) {</b>
<b class="nc">&nbsp;            throw new RuntimeException(&quot;No entity version control settings provisioned!&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return builder;</b>
&nbsp;    }
&nbsp;
&nbsp;    private CommitRequestMsg.Builder buildCommitRequest(CommitGitRequest commit) {
<b class="nc">&nbsp;        return CommitRequestMsg.newBuilder().setTxId(commit.getTxId().toString());</b>
&nbsp;    }
&nbsp;
&nbsp;}
&nbsp;
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
