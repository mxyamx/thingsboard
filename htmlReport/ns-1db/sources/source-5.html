<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > GitRepository</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.server.service.sync.vc</a>
</div>

<h1>Coverage Summary for Class: GitRepository (org.thingsboard.server.service.sync.vc)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">GitRepository</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/35)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/88)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/234)
  </span>
</td>
</tr>
  <tr>
    <td class="name">GitRepository$AuthHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/36)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">GitRepository$AuthHandler$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">GitRepository$Commit</td>
  </tr>
  <tr>
    <td class="name">GitRepository$CommitFilter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">GitRepository$Diff</td>
  </tr>
  <tr>
    <td class="name">GitRepository$FileType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">GitRepository$RepoFile</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">GitRepository$Status</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/51)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/114)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/283)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.server.service.sync.vc;
&nbsp;
&nbsp;import com.google.common.collect.Iterables;
&nbsp;import com.google.common.collect.Ordering;
&nbsp;import com.google.common.collect.Streams;
&nbsp;import lombok.Data;
&nbsp;import lombok.Getter;
&nbsp;import lombok.RequiredArgsConstructor;
&nbsp;import lombok.SneakyThrows;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.apache.commons.io.FileUtils;
&nbsp;import org.apache.commons.lang3.StringUtils;
&nbsp;import org.apache.sshd.common.util.security.SecurityUtils;
&nbsp;import org.eclipse.jgit.api.CloneCommand;
&nbsp;import org.eclipse.jgit.api.Git;
&nbsp;import org.eclipse.jgit.api.GitCommand;
&nbsp;import org.eclipse.jgit.api.LogCommand;
&nbsp;import org.eclipse.jgit.api.LsRemoteCommand;
&nbsp;import org.eclipse.jgit.api.ResetCommand;
&nbsp;import org.eclipse.jgit.api.TransportCommand;
&nbsp;import org.eclipse.jgit.api.errors.GitAPIException;
&nbsp;import org.eclipse.jgit.diff.DiffEntry;
&nbsp;import org.eclipse.jgit.diff.DiffFormatter;
&nbsp;import org.eclipse.jgit.diff.EditList;
&nbsp;import org.eclipse.jgit.diff.HistogramDiff;
&nbsp;import org.eclipse.jgit.diff.RawText;
&nbsp;import org.eclipse.jgit.diff.RawTextComparator;
&nbsp;import org.eclipse.jgit.errors.LargeObjectException;
&nbsp;import org.eclipse.jgit.errors.RepositoryNotFoundException;
&nbsp;import org.eclipse.jgit.lib.Constants;
&nbsp;import org.eclipse.jgit.lib.ObjectId;
&nbsp;import org.eclipse.jgit.lib.ObjectLoader;
&nbsp;import org.eclipse.jgit.lib.ObjectReader;
&nbsp;import org.eclipse.jgit.lib.Ref;
&nbsp;import org.eclipse.jgit.revwalk.RevCommit;
&nbsp;import org.eclipse.jgit.revwalk.RevWalk;
&nbsp;import org.eclipse.jgit.revwalk.filter.RevFilter;
&nbsp;import org.eclipse.jgit.transport.CredentialsProvider;
&nbsp;import org.eclipse.jgit.transport.FetchResult;
&nbsp;import org.eclipse.jgit.transport.PushResult;
&nbsp;import org.eclipse.jgit.transport.RefSpec;
&nbsp;import org.eclipse.jgit.transport.RemoteRefUpdate;
&nbsp;import org.eclipse.jgit.transport.SshTransport;
&nbsp;import org.eclipse.jgit.transport.URIish;
&nbsp;import org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider;
&nbsp;import org.eclipse.jgit.transport.sshd.JGitKeyCache;
&nbsp;import org.eclipse.jgit.transport.sshd.ServerKeyDatabase;
&nbsp;import org.eclipse.jgit.transport.sshd.SshdSessionFactory;
&nbsp;import org.eclipse.jgit.transport.sshd.SshdSessionFactoryBuilder;
&nbsp;import org.eclipse.jgit.treewalk.CanonicalTreeParser;
&nbsp;import org.eclipse.jgit.treewalk.TreeWalk;
&nbsp;import org.eclipse.jgit.treewalk.filter.PathFilter;
&nbsp;import org.thingsboard.server.common.data.page.PageData;
&nbsp;import org.thingsboard.server.common.data.page.PageLink;
&nbsp;import org.thingsboard.server.common.data.page.SortOrder;
&nbsp;import org.thingsboard.server.common.data.sync.vc.BranchInfo;
&nbsp;import org.thingsboard.server.common.data.sync.vc.RepositoryAuthMethod;
&nbsp;import org.thingsboard.server.common.data.sync.vc.RepositorySettings;
&nbsp;import org.thingsboard.server.common.data.util.CollectionsUtil;
&nbsp;
&nbsp;import java.io.ByteArrayInputStream;
&nbsp;import java.io.ByteArrayOutputStream;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.net.InetSocketAddress;
&nbsp;import java.nio.charset.StandardCharsets;
&nbsp;import java.nio.file.Files;
&nbsp;import java.nio.file.Path;
&nbsp;import java.security.KeyPair;
&nbsp;import java.security.PublicKey;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Comparator;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Optional;
&nbsp;import java.util.Set;
&nbsp;import java.util.UUID;
&nbsp;import java.util.function.Function;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;import static org.eclipse.jgit.api.ListBranchCommand.ListMode;
&nbsp;import static org.eclipse.jgit.transport.RemoteRefUpdate.Status.REJECTED_NODELETE;
&nbsp;import static org.eclipse.jgit.transport.RemoteRefUpdate.Status.REJECTED_NONFASTFORWARD;
&nbsp;import static org.eclipse.jgit.transport.RemoteRefUpdate.Status.REJECTED_OTHER_REASON;
&nbsp;import static org.eclipse.jgit.transport.RemoteRefUpdate.Status.REJECTED_REMOTE_CHANGED;
&nbsp;
<b class="nc">&nbsp;@Slf4j</b>
&nbsp;public class GitRepository {
&nbsp;
&nbsp;    private final Git git;
&nbsp;    private final AuthHandler authHandler;
&nbsp;    @Getter
&nbsp;    private final RepositorySettings settings;
&nbsp;
&nbsp;    @Getter
&nbsp;    private final String directory;
&nbsp;
&nbsp;    private ObjectId headId;
&nbsp;
<b class="nc">&nbsp;    private GitRepository(Git git, RepositorySettings settings, AuthHandler authHandler, String directory) {</b>
<b class="nc">&nbsp;        this.git = git;</b>
<b class="nc">&nbsp;        this.settings = settings;</b>
<b class="nc">&nbsp;        this.authHandler = authHandler;</b>
<b class="nc">&nbsp;        this.directory = directory;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static GitRepository create(RepositorySettings settings, File directory) throws GitAPIException {
<b class="nc">&nbsp;        log.debug(&quot;Executing create [{}]&quot;, directory);</b>
<b class="nc">&nbsp;        Git git = Git.init()</b>
<b class="nc">&nbsp;                .setDirectory(directory)</b>
<b class="nc">&nbsp;                .call();</b>
<b class="nc">&nbsp;        return new GitRepository(git, settings, null, directory.getAbsolutePath());</b>
&nbsp;    }
&nbsp;
&nbsp;    public static GitRepository clone(RepositorySettings settings, File directory) throws GitAPIException {
<b class="nc">&nbsp;        log.debug(&quot;Executing clone [{}]&quot;, settings.getRepositoryUri());</b>
<b class="nc">&nbsp;        CloneCommand cloneCommand = Git.cloneRepository()</b>
<b class="nc">&nbsp;                .setURI(settings.getRepositoryUri())</b>
<b class="nc">&nbsp;                .setDirectory(directory)</b>
<b class="nc">&nbsp;                .setNoCheckout(true);</b>
<b class="nc">&nbsp;        AuthHandler authHandler = AuthHandler.createFor(settings, directory);</b>
<b class="nc">&nbsp;        authHandler.configureCommand(cloneCommand);</b>
<b class="nc">&nbsp;        Git git = cloneCommand.call();</b>
<b class="nc">&nbsp;        return new GitRepository(git, settings, authHandler, directory.getAbsolutePath());</b>
&nbsp;    }
&nbsp;
&nbsp;    public static GitRepository open(File directory, RepositorySettings settings) throws IOException {
<b class="nc">&nbsp;        log.debug(&quot;Executing open [{}][{}]&quot;, settings.getRepositoryUri(), directory);</b>
<b class="nc">&nbsp;        Git git = Git.open(directory);</b>
<b class="nc">&nbsp;        AuthHandler authHandler = AuthHandler.createFor(settings, directory);</b>
<b class="nc">&nbsp;        return new GitRepository(git, settings, authHandler, directory.getAbsolutePath());</b>
&nbsp;    }
&nbsp;
&nbsp;    public static GitRepository openOrClone(Path directory, RepositorySettings settings, boolean fetch) throws IOException, GitAPIException {
<b class="nc">&nbsp;        if (GitRepository.exists(directory.toString())) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                GitRepository repository = GitRepository.open(directory.toFile(), settings);</b>
<b class="nc">&nbsp;                if (fetch) {</b>
<b class="nc">&nbsp;                    repository.fetch();</b>
&nbsp;                }
<b class="nc">&nbsp;                return repository;</b>
&nbsp;            } catch (RepositoryNotFoundException e) {
<b class="nc">&nbsp;                log.warn(&quot;{} not a git repository, reinitializing&quot;, directory);</b>
&nbsp;            } catch (org.eclipse.jgit.errors.TransportException | org.eclipse.jgit.api.errors.TransportException e) {
<b class="nc">&nbsp;                if (StringUtils.containsIgnoreCase(e.getMessage(), &quot;missing commit&quot;)) {</b>
<b class="nc">&nbsp;                    log.warn(&quot;Couldn&#39;t fetch {} due to {}, reinitializing&quot;, directory, e.getMessage());</b>
&nbsp;                } else {
&nbsp;                    throw e;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        FileUtils.deleteDirectory(directory.toFile());</b>
<b class="nc">&nbsp;        Files.createDirectories(directory);</b>
<b class="nc">&nbsp;        if (settings.isLocalOnly()) {</b>
<b class="nc">&nbsp;            return GitRepository.create(settings, directory.toFile());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return GitRepository.clone(settings, directory.toFile());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static void test(RepositorySettings settings, File directory) throws Exception {
<b class="nc">&nbsp;        if (settings.isLocalOnly()) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        log.debug(&quot;Executing test [{}]&quot;, settings.getRepositoryUri());</b>
<b class="nc">&nbsp;        AuthHandler authHandler = AuthHandler.createFor(settings, directory);</b>
<b class="nc">&nbsp;        if (settings.isReadOnly()) {</b>
<b class="nc">&nbsp;            LsRemoteCommand lsRemoteCommand = Git.lsRemoteRepository().setRemote(settings.getRepositoryUri());</b>
<b class="nc">&nbsp;            authHandler.configureCommand(lsRemoteCommand);</b>
<b class="nc">&nbsp;            lsRemoteCommand.call();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            Files.createDirectories(directory.toPath());</b>
&nbsp;            try {
<b class="nc">&nbsp;                Git git = Git.init().setDirectory(directory).call();</b>
<b class="nc">&nbsp;                GitRepository repository = new GitRepository(git, settings, authHandler, directory.getAbsolutePath());</b>
<b class="nc">&nbsp;                repository.execute(repository.git.remoteAdd()</b>
<b class="nc">&nbsp;                        .setName(&quot;origin&quot;)</b>
<b class="nc">&nbsp;                        .setUri(new URIish(settings.getRepositoryUri())));</b>
<b class="nc">&nbsp;                repository.push(&quot;&quot;, UUID.randomUUID().toString()); // trying to delete non-existing branch on remote repo</b>
&nbsp;            } finally {
&nbsp;                try {
<b class="nc">&nbsp;                    FileUtils.forceDelete(directory);</b>
&nbsp;                } catch (Exception ignored) {}
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public boolean fetch() throws GitAPIException {
<b class="nc">&nbsp;        if (settings.isLocalOnly()) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        log.debug(&quot;Executing fetch [{}]&quot;, settings.getRepositoryUri());</b>
<b class="nc">&nbsp;        FetchResult result = execute(git.fetch()</b>
<b class="nc">&nbsp;                .setRemoveDeletedRefs(true));</b>
<b class="nc">&nbsp;        Ref head = result.getAdvertisedRef(Constants.HEAD);</b>
<b class="nc">&nbsp;        if (head != null) {</b>
<b class="nc">&nbsp;            this.headId = head.getObjectId();</b>
&nbsp;        }
<b class="nc">&nbsp;        return CollectionsUtil.isNotEmpty(result.getTrackingRefUpdates());</b>
&nbsp;    }
&nbsp;
&nbsp;    public void deleteLocalBranchIfExists(String branch) throws GitAPIException {
<b class="nc">&nbsp;        log.debug(&quot;Executing deleteLocalBranchIfExists [{}][{}]&quot;, settings.getRepositoryUri(), branch);</b>
<b class="nc">&nbsp;        execute(git.branchDelete()</b>
<b class="nc">&nbsp;                .setBranchNames(branch)</b>
<b class="nc">&nbsp;                .setForce(true));</b>
&nbsp;    }
&nbsp;
&nbsp;    public void resetAndClean() throws GitAPIException {
<b class="nc">&nbsp;        log.debug(&quot;Executing resetAndClean [{}]&quot;, settings.getRepositoryUri());</b>
<b class="nc">&nbsp;        execute(git.reset()</b>
<b class="nc">&nbsp;                .setMode(ResetCommand.ResetType.HARD));</b>
<b class="nc">&nbsp;        execute(git.clean()</b>
<b class="nc">&nbsp;                .setForce(true)</b>
<b class="nc">&nbsp;                .setCleanDirectories(true));</b>
&nbsp;    }
&nbsp;
&nbsp;    public void merge(String branch) throws IOException, GitAPIException {
<b class="nc">&nbsp;        log.debug(&quot;Executing merge [{}][{}]&quot;, settings.getRepositoryUri(), branch);</b>
<b class="nc">&nbsp;        ObjectId branchId = resolve(&quot;origin/&quot; + branch);</b>
<b class="nc">&nbsp;        if (branchId == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Branch not found&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        execute(git.merge()</b>
<b class="nc">&nbsp;                .include(branchId));</b>
&nbsp;    }
&nbsp;
&nbsp;    public List&lt;BranchInfo&gt; listBranches() throws GitAPIException {
<b class="nc">&nbsp;        log.debug(&quot;Executing listBranches [{}]&quot;, settings.getRepositoryUri());</b>
<b class="nc">&nbsp;        return execute(git.branchList()</b>
<b class="nc">&nbsp;                .setListMode(settings.isLocalOnly() ? ListMode.ALL : ListMode.REMOTE)).stream()</b>
<b class="nc">&nbsp;                .filter(ref -&gt; !ref.getName().equals(Constants.HEAD))</b>
<b class="nc">&nbsp;                .map(this::toBranchInfo)</b>
<b class="nc">&nbsp;                .distinct().collect(Collectors.toList());</b>
&nbsp;    }
&nbsp;
&nbsp;    public PageData&lt;Commit&gt; listCommits(String branch, PageLink pageLink) throws IOException, GitAPIException {
<b class="nc">&nbsp;        return listCommits(branch, null, pageLink);</b>
&nbsp;    }
&nbsp;
&nbsp;    public PageData&lt;Commit&gt; listCommits(String branch, String path, PageLink pageLink) throws IOException, GitAPIException {
<b class="nc">&nbsp;        log.debug(&quot;Executing listCommits [{}][{}][{}]&quot;, settings.getRepositoryUri(), branch, path);</b>
<b class="nc">&nbsp;        ObjectId branchId = resolve(&quot;origin/&quot; + branch);</b>
<b class="nc">&nbsp;        if (branchId == null) {</b>
<b class="nc">&nbsp;            return new PageData&lt;&gt;();</b>
&nbsp;        }
<b class="nc">&nbsp;        LogCommand command = git.log()</b>
<b class="nc">&nbsp;                .add(branchId);</b>
&nbsp;
<b class="nc">&nbsp;        command.setRevFilter(new CommitFilter(pageLink.getTextSearch(), settings.isShowMergeCommits()));</b>
<b class="nc">&nbsp;        if (StringUtils.isNotEmpty(path)) {</b>
<b class="nc">&nbsp;            command.addPath(path);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Iterable&lt;RevCommit&gt; commits = execute(command);</b>
<b class="nc">&nbsp;        return iterableToPageData(commits, this::toCommit, pageLink, revCommitComparatorFunction);</b>
&nbsp;    }
&nbsp;
&nbsp;    public List&lt;String&gt; listFilesAtCommit(String commitId, String path) {
<b class="nc">&nbsp;        return listFilesAtCommit(commitId, path, -1).stream().map(RepoFile::path).toList();</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    @SneakyThrows</b>
&nbsp;    public List&lt;RepoFile&gt; listFilesAtCommit(String commitId, String path, int depth) {
<b class="nc">&nbsp;        log.debug(&quot;Executing listFilesAtCommit [{}][{}][{}]&quot;, settings.getRepositoryUri(), commitId, path);</b>
<b class="nc">&nbsp;        List&lt;RepoFile&gt; files = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        RevCommit revCommit = resolveCommit(commitId);</b>
<b class="nc">&nbsp;        try (TreeWalk treeWalk = new TreeWalk(git.getRepository())) {</b>
<b class="nc">&nbsp;            treeWalk.reset(revCommit.getTree().getId());</b>
<b class="nc">&nbsp;            if (StringUtils.isNotEmpty(path)) {</b>
<b class="nc">&nbsp;                treeWalk.setFilter(PathFilter.create(path));</b>
&nbsp;            }
<b class="nc">&nbsp;            boolean fixedDepth = depth != -1;</b>
<b class="nc">&nbsp;            treeWalk.setRecursive(!fixedDepth);</b>
<b class="nc">&nbsp;            while (treeWalk.next()) {</b>
<b class="nc">&nbsp;                if (!fixedDepth || treeWalk.getDepth() == depth) {</b>
<b class="nc">&nbsp;                    files.add(new RepoFile(treeWalk.getPathString(), treeWalk.getNameString(), treeWalk.isSubtree() ? FileType.DIRECTORY : FileType.FILE));</b>
&nbsp;                }
<b class="nc">&nbsp;                if (fixedDepth &amp;&amp; treeWalk.getDepth() &lt; depth) {</b>
<b class="nc">&nbsp;                    treeWalk.enterSubtree();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return files;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    @SneakyThrows</b>
&nbsp;    public byte[] getFileContentAtCommit(String file, String commitId) {
<b class="nc">&nbsp;        log.debug(&quot;Executing getFileContentAtCommit [{}][{}][{}]&quot;, settings.getRepositoryUri(), commitId, file);</b>
<b class="nc">&nbsp;        RevCommit revCommit = resolveCommit(commitId);</b>
<b class="nc">&nbsp;        try (TreeWalk treeWalk = TreeWalk.forPath(git.getRepository(), file, revCommit.getTree())) {</b>
<b class="nc">&nbsp;            if (treeWalk == null) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;File not found&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            ObjectId blobId = treeWalk.getObjectId(0);</b>
<b class="nc">&nbsp;            try (ObjectReader objectReader = git.getRepository().newObjectReader()) {</b>
<b class="nc">&nbsp;                ObjectLoader objectLoader = objectReader.open(blobId);</b>
&nbsp;                try {
<b class="nc">&nbsp;                    return objectLoader.getBytes();</b>
&nbsp;                } catch (LargeObjectException e) {
<b class="nc">&nbsp;                    throw new RuntimeException(&quot;File &quot; + file + &quot; is too big to load&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    public void createAndCheckoutOrphanBranch(String name) throws GitAPIException {
<b class="nc">&nbsp;        log.debug(&quot;Executing createAndCheckoutOrphanBranch [{}][{}]&quot;, settings.getRepositoryUri(), name);</b>
<b class="nc">&nbsp;        execute(git.checkout()</b>
<b class="nc">&nbsp;                .setOrphan(true)</b>
<b class="nc">&nbsp;                .setForced(true)</b>
<b class="nc">&nbsp;                .setName(name));</b>
&nbsp;    }
&nbsp;
&nbsp;    public void checkoutBranch(String name) throws GitAPIException {
<b class="nc">&nbsp;        log.debug(&quot;Executing checkoutBranch [{}][{}]&quot;, settings.getRepositoryUri(), name);</b>
<b class="nc">&nbsp;        git.checkout()</b>
<b class="nc">&nbsp;                .setForced(true)</b>
<b class="nc">&nbsp;                .setName(name)</b>
<b class="nc">&nbsp;                .call();</b>
&nbsp;    }
&nbsp;
&nbsp;    public void add(String filesPattern) throws GitAPIException {
<b class="nc">&nbsp;        log.debug(&quot;Executing add [{}][{}]&quot;, settings.getRepositoryUri(), filesPattern);</b>
<b class="nc">&nbsp;        execute(git.add().setUpdate(true).addFilepattern(filesPattern));</b>
<b class="nc">&nbsp;        execute(git.add().addFilepattern(filesPattern));</b>
&nbsp;    }
&nbsp;
&nbsp;    public Status status() throws GitAPIException {
<b class="nc">&nbsp;        log.debug(&quot;Executing status [{}]&quot;, settings.getRepositoryUri());</b>
<b class="nc">&nbsp;        org.eclipse.jgit.api.Status status = execute(git.status());</b>
<b class="nc">&nbsp;        Set&lt;String&gt; modified = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;        modified.addAll(status.getModified());</b>
<b class="nc">&nbsp;        modified.addAll(status.getChanged());</b>
<b class="nc">&nbsp;        return new Status(status.getAdded(), modified, status.getRemoved());</b>
&nbsp;    }
&nbsp;
&nbsp;    public Commit commit(String message, String authorName, String authorEmail) throws GitAPIException {
<b class="nc">&nbsp;        log.debug(&quot;Executing commit [{}][{}]&quot;, settings.getRepositoryUri(), message);</b>
<b class="nc">&nbsp;        RevCommit revCommit = execute(git.commit()</b>
<b class="nc">&nbsp;                .setAuthor(authorName, authorEmail)</b>
<b class="nc">&nbsp;                .setMessage(message));</b>
<b class="nc">&nbsp;        return toCommit(revCommit);</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    public void push(String localBranch, String remoteBranch) throws GitAPIException {
<b class="nc">&nbsp;        if (settings.isLocalOnly()) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        log.debug(&quot;Executing push [{}][{}]&quot;, settings.getRepositoryUri(), remoteBranch);</b>
<b class="nc">&nbsp;        Iterable&lt;PushResult&gt; result = execute(git.push()</b>
<b class="nc">&nbsp;                .setRefSpecs(new RefSpec(localBranch + &quot;:&quot; + remoteBranch)));</b>
<b class="nc">&nbsp;        result.forEach(pushResult -&gt; {</b>
<b class="nc">&nbsp;            for (RemoteRefUpdate update : pushResult.getRemoteUpdates()) {</b>
<b class="nc">&nbsp;                RemoteRefUpdate.Status status = update.getStatus();</b>
<b class="nc">&nbsp;                if (status == REJECTED_NONFASTFORWARD || status == REJECTED_NODELETE ||</b>
&nbsp;                        status == REJECTED_REMOTE_CHANGED || status == REJECTED_OTHER_REASON) {
<b class="nc">&nbsp;                    throw new RuntimeException(&quot;Remote repository answered with error: &quot; +</b>
<b class="nc">&nbsp;                            Optional.ofNullable(update.getMessage()).orElseGet(status::name));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    public String getContentsDiff(String content1, String content2) throws IOException {
<b class="nc">&nbsp;        RawText rawContent1 = new RawText(content1.getBytes());</b>
<b class="nc">&nbsp;        RawText rawContent2 = new RawText(content2.getBytes());</b>
&nbsp;
<b class="nc">&nbsp;        ByteArrayOutputStream out = new ByteArrayOutputStream();</b>
<b class="nc">&nbsp;        DiffFormatter diffFormatter = new DiffFormatter(out);</b>
<b class="nc">&nbsp;        diffFormatter.setRepository(git.getRepository());</b>
&nbsp;
<b class="nc">&nbsp;        EditList edits = new EditList();</b>
<b class="nc">&nbsp;        edits.addAll(new HistogramDiff().diff(RawTextComparator.DEFAULT, rawContent1, rawContent2));</b>
<b class="nc">&nbsp;        diffFormatter.format(edits, rawContent1, rawContent2);</b>
<b class="nc">&nbsp;        return out.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    public List&lt;Diff&gt; getDiffList(String commit1, String commit2, String path) throws IOException {
<b class="nc">&nbsp;        ObjectReader reader = git.getRepository().newObjectReader();</b>
&nbsp;
<b class="nc">&nbsp;        CanonicalTreeParser tree1Iter = new CanonicalTreeParser();</b>
<b class="nc">&nbsp;        ObjectId tree1 = resolveCommit(commit1).getTree();</b>
<b class="nc">&nbsp;        tree1Iter.reset(reader, tree1);</b>
&nbsp;
<b class="nc">&nbsp;        CanonicalTreeParser tree2Iter = new CanonicalTreeParser();</b>
<b class="nc">&nbsp;        ObjectId tree2 = resolveCommit(commit2).getTree();</b>
<b class="nc">&nbsp;        tree2Iter.reset(reader, tree2);</b>
&nbsp;
<b class="nc">&nbsp;        ByteArrayOutputStream out = new ByteArrayOutputStream();</b>
<b class="nc">&nbsp;        DiffFormatter diffFormatter = new DiffFormatter(out);</b>
<b class="nc">&nbsp;        diffFormatter.setRepository(git.getRepository());</b>
<b class="nc">&nbsp;        if (StringUtils.isNotEmpty(path)) {</b>
<b class="nc">&nbsp;            diffFormatter.setPathFilter(PathFilter.create(path));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return diffFormatter.scan(tree1, tree2).stream()</b>
<b class="nc">&nbsp;                .map(diffEntry -&gt; {</b>
<b class="nc">&nbsp;                    Diff diff = new Diff();</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        out.reset();</b>
<b class="nc">&nbsp;                        diffFormatter.format(diffEntry);</b>
<b class="nc">&nbsp;                        diff.setDiffStringValue(out.toString());</b>
<b class="nc">&nbsp;                        diff.setFilePath(diffEntry.getChangeType() != DiffEntry.ChangeType.DELETE ? diffEntry.getNewPath() : diffEntry.getOldPath());</b>
<b class="nc">&nbsp;                        diff.setChangeType(diffEntry.getChangeType());</b>
&nbsp;                        try {
<b class="nc">&nbsp;                            diff.setFileContentAtCommit1(new String(getFileContentAtCommit(diff.getFilePath(), commit1), StandardCharsets.UTF_8));</b>
&nbsp;                        } catch (IllegalArgumentException ignored) {
&nbsp;                        }
&nbsp;                        try {
<b class="nc">&nbsp;                            diff.setFileContentAtCommit2(new String(getFileContentAtCommit(diff.getFilePath(), commit2), StandardCharsets.UTF_8));</b>
&nbsp;                        } catch (IllegalArgumentException ignored) {
&nbsp;                        }
<b class="nc">&nbsp;                        return diff;</b>
&nbsp;                    } catch (Exception e) {
<b class="nc">&nbsp;                        throw new RuntimeException(e);</b>
&nbsp;                    }
&nbsp;                })
<b class="nc">&nbsp;                .collect(Collectors.toList());</b>
&nbsp;    }
&nbsp;
&nbsp;    private BranchInfo toBranchInfo(Ref ref) {
<b class="nc">&nbsp;        String name = org.eclipse.jgit.lib.Repository.shortenRefName(ref.getName());</b>
<b class="nc">&nbsp;        String branchName = StringUtils.removeStart(name, &quot;origin/&quot;);</b>
<b class="nc">&nbsp;        boolean isDefault = this.headId != null &amp;&amp; this.headId.equals(ref.getObjectId());</b>
<b class="nc">&nbsp;        return new BranchInfo(branchName, isDefault);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Commit toCommit(RevCommit revCommit) {
<b class="nc">&nbsp;        return new Commit(revCommit.getCommitTime() * 1000l, revCommit.getName(),</b>
<b class="nc">&nbsp;                revCommit.getFullMessage(), revCommit.getAuthorIdent().getName(), revCommit.getAuthorIdent().getEmailAddress());</b>
&nbsp;    }
&nbsp;
&nbsp;    private RevCommit resolveCommit(String id) throws IOException {
<b class="nc">&nbsp;        return git.getRepository().parseCommit(resolve(id));</b>
&nbsp;    }
&nbsp;
&nbsp;    private ObjectId resolve(String rev) throws IOException {
<b class="nc">&nbsp;        if (settings.isLocalOnly()) {</b>
<b class="nc">&nbsp;            rev = StringUtils.removeStart(rev, &quot;origin/&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        ObjectId result = git.getRepository().resolve(rev);</b>
<b class="nc">&nbsp;        if (result == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Failed to resolve &#39;&quot; + rev + &quot;&#39;&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    @SneakyThrows</b>
&nbsp;    public static boolean exists(String directory) {
<b class="nc">&nbsp;        File gitDirectory = Path.of(directory, &quot;.git&quot;).toFile();</b>
<b class="nc">&nbsp;        return FileUtils.isDirectory(gitDirectory) &amp;&amp; !FileUtils.isEmptyDirectory(gitDirectory);</b>
&nbsp;    }
&nbsp;
&nbsp;    private &lt;C extends GitCommand&lt;T&gt;, T&gt; T execute(C command) throws GitAPIException {
<b class="nc">&nbsp;        if (command instanceof TransportCommand transportCommand &amp;&amp; authHandler != null) {</b>
<b class="nc">&nbsp;            authHandler.configureCommand(transportCommand);</b>
&nbsp;        }
<b class="nc">&nbsp;        return command.call();</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static final Function&lt;PageLink, Comparator&lt;RevCommit&gt;&gt; revCommitComparatorFunction = pageLink -&gt; {</b>
<b class="nc">&nbsp;        SortOrder sortOrder = pageLink.getSortOrder();</b>
<b class="nc">&nbsp;        if (sortOrder != null</b>
<b class="nc">&nbsp;                &amp;&amp; sortOrder.getProperty().equals(&quot;timestamp&quot;)</b>
<b class="nc">&nbsp;                &amp;&amp; SortOrder.Direction.ASC.equals(sortOrder.getDirection())) {</b>
<b class="nc">&nbsp;            return Comparator.comparingInt(RevCommit::getCommitTime);</b>
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    };
&nbsp;
&nbsp;    private static &lt;T, R&gt; PageData&lt;R&gt; iterableToPageData(Iterable&lt;T&gt; iterable,
&nbsp;                                                         Function&lt;? super T, ? extends R&gt; mapper,
&nbsp;                                                         PageLink pageLink,
&nbsp;                                                         Function&lt;PageLink, Comparator&lt;T&gt;&gt; comparatorFunction) {
<b class="nc">&nbsp;        iterable = Streams.stream(iterable).collect(Collectors.toList());</b>
<b class="nc">&nbsp;        int totalElements = Iterables.size(iterable);</b>
<b class="nc">&nbsp;        int totalPages = pageLink.getPageSize() &gt; 0 ? (int) Math.ceil((float) totalElements / pageLink.getPageSize()) : 1;</b>
<b class="nc">&nbsp;        int startIndex = pageLink.getPageSize() * pageLink.getPage();</b>
<b class="nc">&nbsp;        int limit = startIndex + pageLink.getPageSize();</b>
<b class="nc">&nbsp;        if (comparatorFunction != null) {</b>
<b class="nc">&nbsp;            Comparator&lt;T&gt; comparator = comparatorFunction.apply(pageLink);</b>
<b class="nc">&nbsp;            if (comparator != null) {</b>
<b class="nc">&nbsp;                iterable = Ordering.from(comparator).immutableSortedCopy(iterable);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        iterable = Iterables.limit(iterable, limit);</b>
<b class="nc">&nbsp;        if (startIndex &lt; totalElements) {</b>
<b class="nc">&nbsp;            iterable = Iterables.skip(iterable, startIndex);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            iterable = Collections.emptyList();</b>
&nbsp;        }
<b class="nc">&nbsp;        List&lt;R&gt; data = Streams.stream(iterable).map(mapper)</b>
<b class="nc">&nbsp;                .collect(Collectors.toList());</b>
<b class="nc">&nbsp;        boolean hasNext = pageLink.getPageSize() &gt; 0 &amp;&amp; totalElements &gt; startIndex + data.size();</b>
<b class="nc">&nbsp;        return new PageData&lt;&gt;(data, totalPages, totalElements, hasNext);</b>
&nbsp;    }
&nbsp;
&nbsp;    @RequiredArgsConstructor
&nbsp;    private static class AuthHandler {
&nbsp;        private final CredentialsProvider credentialsProvider;
&nbsp;        private final SshdSessionFactory sshSessionFactory;
&nbsp;
&nbsp;        protected static AuthHandler createFor(RepositorySettings settings, File directory) {
<b class="nc">&nbsp;            if (settings.isLocalOnly()) {</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
<b class="nc">&nbsp;            CredentialsProvider credentialsProvider = null;</b>
<b class="nc">&nbsp;            SshdSessionFactory sshSessionFactory = null;</b>
<b class="nc">&nbsp;            if (RepositoryAuthMethod.USERNAME_PASSWORD.equals(settings.getAuthMethod())) {</b>
<b class="nc">&nbsp;                credentialsProvider = newCredentialsProvider(settings.getUsername(), settings.getPassword());</b>
<b class="nc">&nbsp;            } else if (RepositoryAuthMethod.PRIVATE_KEY.equals(settings.getAuthMethod())) {</b>
<b class="nc">&nbsp;                if (StringUtils.startsWith(settings.getRepositoryUri(), &quot;https://&quot;)) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;Invalid URI format for private key authentication&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                sshSessionFactory = newSshdSessionFactory(settings.getPrivateKey(), settings.getPrivateKeyPassword(), directory);</b>
&nbsp;            }
<b class="nc">&nbsp;            return new AuthHandler(credentialsProvider, sshSessionFactory);</b>
&nbsp;        }
&nbsp;
&nbsp;        protected void configureCommand(TransportCommand command) {
<b class="nc">&nbsp;            if (credentialsProvider != null) {</b>
<b class="nc">&nbsp;                command.setCredentialsProvider(credentialsProvider);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (sshSessionFactory != null) {</b>
<b class="nc">&nbsp;                command.setTransportConfigCallback(transport -&gt; {</b>
<b class="nc">&nbsp;                    if (transport instanceof SshTransport) {</b>
<b class="nc">&nbsp;                        SshTransport sshTransport = (SshTransport) transport;</b>
<b class="nc">&nbsp;                        sshTransport.setSshSessionFactory(sshSessionFactory);</b>
&nbsp;                    }
&nbsp;                });
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        private static CredentialsProvider newCredentialsProvider(String username, String password) {
<b class="nc">&nbsp;            return new UsernamePasswordCredentialsProvider(username, password == null ? &quot;&quot; : password);</b>
&nbsp;        }
&nbsp;
&nbsp;        private static SshdSessionFactory newSshdSessionFactory(String privateKey, String password, File directory) {
<b class="nc">&nbsp;            SshdSessionFactory sshSessionFactory = null;</b>
<b class="nc">&nbsp;            if (StringUtils.isNotBlank(privateKey)) {</b>
<b class="nc">&nbsp;                Iterable&lt;KeyPair&gt; keyPairs = loadKeyPairs(privateKey, password);</b>
<b class="nc">&nbsp;                sshSessionFactory = new SshdSessionFactoryBuilder()</b>
<b class="nc">&nbsp;                        .setPreferredAuthentications(&quot;publickey&quot;)</b>
<b class="nc">&nbsp;                        .setDefaultKeysProvider(file -&gt; keyPairs)</b>
<b class="nc">&nbsp;                        .setHomeDirectory(directory)</b>
<b class="nc">&nbsp;                        .setSshDirectory(directory)</b>
<b class="nc">&nbsp;                        .setServerKeyDatabase((file, file2) -&gt; new ServerKeyDatabase() {</b>
&nbsp;                            @Override
&nbsp;                            public List&lt;PublicKey&gt; lookup(String connectAddress, InetSocketAddress remoteAddress, Configuration config) {
<b class="nc">&nbsp;                                return Collections.emptyList();</b>
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public boolean accept(String connectAddress, InetSocketAddress remoteAddress, PublicKey serverKey, Configuration config, CredentialsProvider provider) {
<b class="nc">&nbsp;                                return true;</b>
&nbsp;                            }
&nbsp;                        })
<b class="nc">&nbsp;                        .build(new JGitKeyCache());</b>
&nbsp;            }
<b class="nc">&nbsp;            return sshSessionFactory;</b>
&nbsp;        }
&nbsp;
&nbsp;        private static Iterable&lt;KeyPair&gt; loadKeyPairs(String privateKeyContent, String password) {
<b class="nc">&nbsp;            Iterable&lt;KeyPair&gt; keyPairs = null;</b>
&nbsp;            try {
<b class="nc">&nbsp;                keyPairs = SecurityUtils.loadKeyPairIdentities(null,</b>
<b class="nc">&nbsp;                        null, new ByteArrayInputStream(privateKeyContent.getBytes()), (session, resourceKey, retryIndex) -&gt; password);</b>
&nbsp;            } catch (Exception e) {}
<b class="nc">&nbsp;            if (keyPairs == null) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Failed to load ssh private key&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            return keyPairs;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class CommitFilter extends RevFilter {
&nbsp;
&nbsp;        private final String textSearch;
&nbsp;        private final boolean showMergeCommits;
&nbsp;
<b class="nc">&nbsp;        CommitFilter(String textSearch, boolean showMergeCommits) {</b>
<b class="nc">&nbsp;            this.textSearch = textSearch.toLowerCase();</b>
<b class="nc">&nbsp;            this.showMergeCommits = showMergeCommits;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean include(RevWalk walker, RevCommit c) {
<b class="nc">&nbsp;            return (showMergeCommits || c.getParentCount() &lt; 2) &amp;&amp; (StringUtils.isEmpty(textSearch)</b>
<b class="nc">&nbsp;                    || c.getFullMessage().toLowerCase().contains(textSearch));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public RevFilter clone() {
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean requiresCommitBody() {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    @Data
&nbsp;    public static class Commit {
&nbsp;        private final long timestamp;
&nbsp;        private final String id;
&nbsp;        private final String message;
&nbsp;        private final String authorName;
&nbsp;        private final String authorEmail;
&nbsp;    }
&nbsp;
&nbsp;    @Data
&nbsp;    public static class Status {
&nbsp;        private final Set&lt;String&gt; added;
&nbsp;        private final Set&lt;String&gt; modified;
&nbsp;        private final Set&lt;String&gt; removed;
&nbsp;    }
&nbsp;
&nbsp;    @Data
&nbsp;    public static class Diff {
&nbsp;        private String filePath;
&nbsp;        private DiffEntry.ChangeType changeType;
&nbsp;        private String fileContentAtCommit1;
&nbsp;        private String fileContentAtCommit2;
&nbsp;        private String diffStringValue;
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public record RepoFile(String path, String name, FileType type) {}</b>
&nbsp;
<b class="nc">&nbsp;    public enum FileType {</b>
<b class="nc">&nbsp;        FILE, DIRECTORY</b>
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
