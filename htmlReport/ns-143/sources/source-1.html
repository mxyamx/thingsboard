<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > MainQueueConsumerManager</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.server.queue.common.consumer</a>
</div>

<h1>Coverage Summary for Class: MainQueueConsumerManager (org.thingsboard.server.queue.common.consumer)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MainQueueConsumerManager</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/44)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/101)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MainQueueConsumerManager$ConsumerPerPartitionWrapper</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/23)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MainQueueConsumerManager$ConsumerWrapper</td>
  </tr>
  <tr>
    <td class="name">MainQueueConsumerManager$MsgPackProcessor</td>
  </tr>
  <tr>
    <td class="name">MainQueueConsumerManager$SingleConsumerWrapper</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/29)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/62)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/139)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.server.queue.common.consumer;
&nbsp;
&nbsp;import lombok.Builder;
&nbsp;import lombok.Getter;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.thingsboard.common.util.ThingsBoardThreadFactory;
&nbsp;import org.thingsboard.server.common.data.queue.QueueConfig;
&nbsp;import org.thingsboard.server.common.msg.queue.TopicPartitionInfo;
&nbsp;import org.thingsboard.server.queue.TbQueueConsumer;
&nbsp;import org.thingsboard.server.queue.TbQueueMsg;
&nbsp;import org.thingsboard.server.queue.common.consumer.TbQueueConsumerManagerTask.UpdateConfigTask;
&nbsp;import org.thingsboard.server.queue.common.consumer.TbQueueConsumerManagerTask.UpdatePartitionsTask;
&nbsp;import org.thingsboard.server.queue.common.consumer.TbQueueConsumerTask.ConsumerKey;
&nbsp;import org.thingsboard.server.queue.kafka.TbKafkaConsumerTemplate;
&nbsp;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Optional;
&nbsp;import java.util.Set;
&nbsp;import java.util.concurrent.ConcurrentLinkedQueue;
&nbsp;import java.util.concurrent.ExecutorService;
&nbsp;import java.util.concurrent.Future;
&nbsp;import java.util.concurrent.ScheduledExecutorService;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.concurrent.locks.ReentrantLock;
&nbsp;import java.util.function.BiFunction;
&nbsp;import java.util.function.Consumer;
&nbsp;import java.util.function.Function;
&nbsp;
<b class="nc">&nbsp;@Slf4j</b>
&nbsp;public class MainQueueConsumerManager&lt;M extends TbQueueMsg, C extends QueueConfig&gt; {
&nbsp;
&nbsp;    @Getter
&nbsp;    protected final Object queueKey;
&nbsp;    @Getter
&nbsp;    protected C config;
&nbsp;    protected final MsgPackProcessor&lt;M, C&gt; msgPackProcessor;
&nbsp;    protected final BiFunction&lt;C, TopicPartitionInfo, TbQueueConsumer&lt;M&gt;&gt; consumerCreator;
&nbsp;    @Getter
&nbsp;    protected final ExecutorService consumerExecutor;
&nbsp;    @Getter
&nbsp;    protected final ScheduledExecutorService scheduler;
&nbsp;    @Getter
&nbsp;    protected final ExecutorService taskExecutor;
&nbsp;    protected final Consumer&lt;Throwable&gt; uncaughtErrorHandler;
&nbsp;
<b class="nc">&nbsp;    private final java.util.Queue&lt;TbQueueConsumerManagerTask&gt; tasks = new ConcurrentLinkedQueue&lt;&gt;();</b>
<b class="nc">&nbsp;    private final ReentrantLock lock = new ReentrantLock();</b>
&nbsp;
&nbsp;    @Getter
&nbsp;    private volatile Set&lt;TopicPartitionInfo&gt; partitions;
&nbsp;    protected volatile ConsumerWrapper&lt;M&gt; consumerWrapper;
&nbsp;    protected volatile boolean stopped;
&nbsp;
&nbsp;    @Builder
&nbsp;    public MainQueueConsumerManager(Object queueKey, C config,
&nbsp;                                    MsgPackProcessor&lt;M, C&gt; msgPackProcessor,
&nbsp;                                    BiFunction&lt;C, TopicPartitionInfo, TbQueueConsumer&lt;M&gt;&gt; consumerCreator,
&nbsp;                                    ExecutorService consumerExecutor,
&nbsp;                                    ScheduledExecutorService scheduler,
&nbsp;                                    ExecutorService taskExecutor,
<b class="nc">&nbsp;                                    Consumer&lt;Throwable&gt; uncaughtErrorHandler) {</b>
<b class="nc">&nbsp;        this.queueKey = queueKey;</b>
<b class="nc">&nbsp;        this.config = config;</b>
<b class="nc">&nbsp;        this.msgPackProcessor = msgPackProcessor;</b>
<b class="nc">&nbsp;        this.consumerCreator = consumerCreator;</b>
<b class="nc">&nbsp;        this.consumerExecutor = consumerExecutor;</b>
<b class="nc">&nbsp;        this.scheduler = scheduler;</b>
<b class="nc">&nbsp;        this.taskExecutor = taskExecutor;</b>
<b class="nc">&nbsp;        this.uncaughtErrorHandler = uncaughtErrorHandler;</b>
<b class="nc">&nbsp;        if (config != null) {</b>
<b class="nc">&nbsp;            init(config);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void init(C config) {
<b class="nc">&nbsp;        this.config = config;</b>
<b class="nc">&nbsp;        this.consumerWrapper = createConsumerWrapper(config);</b>
<b class="nc">&nbsp;        log.debug(&quot;[{}] Initialized consumer for queue: {}&quot;, queueKey, config);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected ConsumerWrapper&lt;M&gt; createConsumerWrapper(C config) {
<b class="nc">&nbsp;        if (config.isConsumerPerPartition()) {</b>
<b class="nc">&nbsp;            return new ConsumerPerPartitionWrapper();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return new SingleConsumerWrapper();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void update(C config) {
<b class="nc">&nbsp;        addTask(new UpdateConfigTask(config));</b>
&nbsp;    }
&nbsp;
&nbsp;    public void update(Set&lt;TopicPartitionInfo&gt; partitions) {
<b class="nc">&nbsp;        addTask(new UpdatePartitionsTask(partitions));</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void addTask(TbQueueConsumerManagerTask todo) {
<b class="nc">&nbsp;        if (stopped) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        tasks.add(todo);</b>
<b class="nc">&nbsp;        log.trace(&quot;[{}] Added task: {}&quot;, queueKey, todo);</b>
<b class="nc">&nbsp;        tryProcessTasks();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void tryProcessTasks() {
<b class="nc">&nbsp;        taskExecutor.submit(() -&gt; {</b>
<b class="nc">&nbsp;            if (lock.tryLock()) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    C newConfig = null;</b>
<b class="nc">&nbsp;                    Set&lt;TopicPartitionInfo&gt; newPartitions = null;</b>
<b class="nc">&nbsp;                    while (!stopped) {</b>
<b class="nc">&nbsp;                        TbQueueConsumerManagerTask task = tasks.poll();</b>
<b class="nc">&nbsp;                        if (task == null) {</b>
&nbsp;                            break;
&nbsp;                        }
<b class="nc">&nbsp;                        log.trace(&quot;[{}] Processing task: {}&quot;, queueKey, task);</b>
&nbsp;
<b class="nc">&nbsp;                        if (task instanceof UpdatePartitionsTask updatePartitionsTask) {</b>
<b class="nc">&nbsp;                            newPartitions = updatePartitionsTask.partitions();</b>
<b class="nc">&nbsp;                        } else if (task instanceof UpdateConfigTask updateConfigTask) {</b>
<b class="nc">&nbsp;                            newConfig = (C) updateConfigTask.config();</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            processTask(task);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    if (stopped) {</b>
&nbsp;                        return;
&nbsp;                    }
<b class="nc">&nbsp;                    if (newConfig != null) {</b>
<b class="nc">&nbsp;                        doUpdate(newConfig);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (newPartitions != null) {</b>
<b class="nc">&nbsp;                        doUpdate(newPartitions);</b>
&nbsp;                    }
&nbsp;                } catch (Exception e) {
<b class="nc">&nbsp;                    log.error(&quot;[{}] Failed to process tasks&quot;, queueKey, e);</b>
&nbsp;                } finally {
<b class="nc">&nbsp;                    lock.unlock();</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            } else {
<b class="nc">&nbsp;                log.trace(&quot;[{}] Failed to acquire lock&quot;, queueKey);</b>
<b class="nc">&nbsp;                scheduler.schedule(this::tryProcessTasks, 1, TimeUnit.SECONDS);</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    protected void processTask(TbQueueConsumerManagerTask task) {
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private void doUpdate(C newConfig) {
<b class="nc">&nbsp;        log.info(&quot;[{}] Processing queue update: {}&quot;, queueKey, newConfig);</b>
<b class="nc">&nbsp;        var oldConfig = this.config;</b>
<b class="nc">&nbsp;        this.config = newConfig;</b>
<b class="nc">&nbsp;        if (log.isTraceEnabled()) {</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}] Old queue configuration: {}&quot;, queueKey, oldConfig);</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}] New queue configuration: {}&quot;, queueKey, newConfig);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (oldConfig == null) {</b>
<b class="nc">&nbsp;            init(config);</b>
<b class="nc">&nbsp;        } else if (newConfig.isConsumerPerPartition() != oldConfig.isConsumerPerPartition()) {</b>
<b class="nc">&nbsp;            consumerWrapper.getConsumers().forEach(TbQueueConsumerTask::initiateStop);</b>
<b class="nc">&nbsp;            consumerWrapper.getConsumers().forEach(TbQueueConsumerTask::awaitCompletion);</b>
&nbsp;
<b class="nc">&nbsp;            init(config);</b>
<b class="nc">&nbsp;            if (partitions != null) {</b>
<b class="nc">&nbsp;                doUpdate(partitions); // even if partitions number was changed, there can be no partition change event</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            log.trace(&quot;[{}] Silently applied new config, because consumer-per-partition not changed&quot;, queueKey);</b>
&nbsp;            // do nothing, because partitions change (if they changed) will be handled on PartitionChangeEvent,
&nbsp;            // and changes to other config values will be picked up by consumer on the fly,
&nbsp;            // and queue topic and name are immutable
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void doUpdate(Set&lt;TopicPartitionInfo&gt; partitions) {
<b class="nc">&nbsp;        this.partitions = partitions;</b>
<b class="nc">&nbsp;        consumerWrapper.updatePartitions(partitions);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void launchConsumer(TbQueueConsumerTask&lt;M&gt; consumerTask) {
<b class="nc">&nbsp;        log.info(&quot;[{}] Launching consumer&quot;, consumerTask.getKey());</b>
<b class="nc">&nbsp;        Future&lt;?&gt; consumerLoop = consumerExecutor.submit(() -&gt; {</b>
<b class="nc">&nbsp;            ThingsBoardThreadFactory.updateCurrentThreadName(consumerTask.getKey().toString());</b>
<b class="nc">&nbsp;            consumerLoop(consumerTask.getKey(), consumerTask.getConsumer());</b>
<b class="nc">&nbsp;            log.info(&quot;[{}] Consumer stopped&quot;, consumerTask.getKey());</b>
&nbsp;
&nbsp;            try {
<b class="nc">&nbsp;                Runnable callback = consumerTask.getCallback();</b>
<b class="nc">&nbsp;                if (callback != null) {</b>
<b class="nc">&nbsp;                    callback.run();</b>
&nbsp;                }
&nbsp;            } catch (Throwable t) {
<b class="nc">&nbsp;                log.error(&quot;Failed to execute finish callback&quot;, t);</b>
&nbsp;            }
&nbsp;        });
<b class="nc">&nbsp;        consumerTask.setTask(consumerLoop);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void consumerLoop(ConsumerKey consumerKey, TbQueueConsumer&lt;M&gt; consumer) {
&nbsp;        try {
<b class="nc">&nbsp;            while (!stopped &amp;&amp; !consumer.isStopped()) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    List&lt;M&gt; msgs = consumer.poll(config.getPollInterval());</b>
<b class="nc">&nbsp;                    if (msgs.isEmpty()) {</b>
&nbsp;                        continue;
&nbsp;                    }
<b class="nc">&nbsp;                    processMsgs(msgs, consumer, consumerKey, config);</b>
&nbsp;                } catch (Exception e) {
<b class="nc">&nbsp;                    if (!consumer.isStopped()) {</b>
<b class="nc">&nbsp;                        log.warn(&quot;Failed to process messages from queue&quot;, e);</b>
&nbsp;                        try {
<b class="nc">&nbsp;                            Thread.sleep(config.getPollInterval());</b>
&nbsp;                        } catch (InterruptedException e2) {
<b class="nc">&nbsp;                            log.trace(&quot;Failed to wait until the server has capacity to handle new requests&quot;, e2);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (consumer.isStopped()) {</b>
<b class="nc">&nbsp;                consumer.unsubscribe();</b>
&nbsp;            }
&nbsp;        } catch (Throwable t) {
<b class="nc">&nbsp;            log.error(&quot;Failure in consumer loop&quot;, t);</b>
<b class="nc">&nbsp;            if (uncaughtErrorHandler != null) {</b>
<b class="nc">&nbsp;                uncaughtErrorHandler.accept(t);</b>
&nbsp;            }
<b class="nc">&nbsp;            consumer.unsubscribe();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected void processMsgs(List&lt;M&gt; msgs, TbQueueConsumer&lt;M&gt; consumer, ConsumerKey consumerKey, C config) throws Exception {
<b class="nc">&nbsp;        log.trace(&quot;Processing {} messages&quot;, msgs.size());</b>
<b class="nc">&nbsp;        msgPackProcessor.process(msgs, consumer, consumerKey, config);</b>
<b class="nc">&nbsp;        log.trace(&quot;Processed {} messages&quot;, msgs.size());</b>
&nbsp;    }
&nbsp;
&nbsp;    public void stop() {
<b class="nc">&nbsp;        log.debug(&quot;[{}] Stopping consumers&quot;, queueKey);</b>
<b class="nc">&nbsp;        consumerWrapper.getConsumers().forEach(TbQueueConsumerTask::initiateStop);</b>
<b class="nc">&nbsp;        stopped = true;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void awaitStop() {
<b class="nc">&nbsp;        awaitStop(30);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void awaitStop(int timeoutSec) {
<b class="nc">&nbsp;        log.debug(&quot;[{}] Waiting for consumers to stop&quot;, queueKey);</b>
<b class="nc">&nbsp;        consumerWrapper.getConsumers().forEach(consumerTask -&gt; consumerTask.awaitCompletion(timeoutSec));</b>
<b class="nc">&nbsp;        log.debug(&quot;[{}] Unsubscribed and stopped consumers&quot;, queueKey);</b>
&nbsp;    }
&nbsp;
&nbsp;    public interface MsgPackProcessor&lt;M extends TbQueueMsg, C extends QueueConfig&gt; {
&nbsp;        void process(List&lt;M&gt; msgs, TbQueueConsumer&lt;M&gt; consumer, ConsumerKey consumerKey, C config) throws Exception;
&nbsp;    }
&nbsp;
&nbsp;    public interface ConsumerWrapper&lt;M extends TbQueueMsg&gt; {
&nbsp;
&nbsp;        void updatePartitions(Set&lt;TopicPartitionInfo&gt; partitions);
&nbsp;
&nbsp;        Collection&lt;TbQueueConsumerTask&lt;M&gt;&gt; getConsumers();
&nbsp;
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    class ConsumerPerPartitionWrapper implements ConsumerWrapper&lt;M&gt; {</b>
&nbsp;
<b class="nc">&nbsp;        private final Map&lt;TopicPartitionInfo, TbQueueConsumerTask&lt;M&gt;&gt; consumers = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void updatePartitions(Set&lt;TopicPartitionInfo&gt; partitions) {
<b class="nc">&nbsp;            Set&lt;TopicPartitionInfo&gt; addedPartitions = new HashSet&lt;&gt;(partitions);</b>
<b class="nc">&nbsp;            addedPartitions.removeAll(consumers.keySet());</b>
&nbsp;
<b class="nc">&nbsp;            Set&lt;TopicPartitionInfo&gt; removedPartitions = new HashSet&lt;&gt;(consumers.keySet());</b>
<b class="nc">&nbsp;            removedPartitions.removeAll(partitions);</b>
&nbsp;
<b class="nc">&nbsp;            log.info(&quot;[{}] Added partitions: {}, removed partitions: {}&quot;, queueKey, addedPartitions, removedPartitions);</b>
<b class="nc">&nbsp;            removePartitions(removedPartitions);</b>
<b class="nc">&nbsp;            addPartitions(addedPartitions, null, null);</b>
&nbsp;        }
&nbsp;
&nbsp;        protected void removePartitions(Set&lt;TopicPartitionInfo&gt; removedPartitions) {
<b class="nc">&nbsp;            removedPartitions.forEach((tpi) -&gt; Optional.ofNullable(consumers.get(tpi)).ifPresent(TbQueueConsumerTask::initiateStop));</b>
<b class="nc">&nbsp;            removedPartitions.forEach((tpi) -&gt; Optional.ofNullable(consumers.remove(tpi)).ifPresent(TbQueueConsumerTask::awaitCompletion));</b>
&nbsp;        }
&nbsp;
&nbsp;        protected void addPartitions(Set&lt;TopicPartitionInfo&gt; partitions, Consumer&lt;TopicPartitionInfo&gt; onStop, Function&lt;String, Long&gt; startOffsetProvider) {
<b class="nc">&nbsp;            partitions.forEach(tpi -&gt; {</b>
<b class="nc">&nbsp;                ConsumerKey key = new ConsumerKey(queueKey, tpi);</b>
<b class="nc">&nbsp;                Runnable callback = onStop != null ? () -&gt; onStop.accept(tpi) : null;</b>
&nbsp;
<b class="nc">&nbsp;                TbQueueConsumerTask&lt;M&gt; consumer = new TbQueueConsumerTask&lt;&gt;(key, () -&gt; {</b>
<b class="nc">&nbsp;                    TbQueueConsumer&lt;M&gt; queueConsumer = consumerCreator.apply(config, tpi);</b>
<b class="nc">&nbsp;                    if (startOffsetProvider != null &amp;&amp; queueConsumer instanceof TbKafkaConsumerTemplate&lt;M&gt; kafkaConsumer) {</b>
<b class="nc">&nbsp;                        kafkaConsumer.setStartOffsetProvider(startOffsetProvider);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return queueConsumer;</b>
&nbsp;                }, callback);
<b class="nc">&nbsp;                consumers.put(tpi, consumer);</b>
<b class="nc">&nbsp;                consumer.subscribe(Set.of(tpi));</b>
<b class="nc">&nbsp;                launchConsumer(consumer);</b>
&nbsp;            });
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Collection&lt;TbQueueConsumerTask&lt;M&gt;&gt; getConsumers() {
<b class="nc">&nbsp;            return consumers.values();</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    class SingleConsumerWrapper implements ConsumerWrapper&lt;M&gt; {</b>
&nbsp;
&nbsp;        private TbQueueConsumerTask&lt;M&gt; consumer;
&nbsp;
&nbsp;        @Override
&nbsp;        public void updatePartitions(Set&lt;TopicPartitionInfo&gt; partitions) {
<b class="nc">&nbsp;            log.info(&quot;[{}] New partitions: {}&quot;, queueKey, partitions);</b>
<b class="nc">&nbsp;            if (partitions.isEmpty()) {</b>
<b class="nc">&nbsp;                if (consumer != null &amp;&amp; consumer.isRunning()) {</b>
<b class="nc">&nbsp;                    consumer.initiateStop();</b>
<b class="nc">&nbsp;                    consumer.awaitCompletion();</b>
&nbsp;                }
<b class="nc">&nbsp;                consumer = null;</b>
&nbsp;                return;
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (consumer == null) {</b>
<b class="nc">&nbsp;                consumer = new TbQueueConsumerTask&lt;&gt;(new ConsumerKey(queueKey, null), () -&gt; consumerCreator.apply(config, null), null); // no partitionId passed</b>
&nbsp;            }
<b class="nc">&nbsp;            consumer.subscribe(partitions);</b>
<b class="nc">&nbsp;            if (!consumer.isRunning()) {</b>
<b class="nc">&nbsp;                launchConsumer(consumer);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Collection&lt;TbQueueConsumerTask&lt;M&gt;&gt; getConsumers() {
<b class="nc">&nbsp;            if (consumer == null) {</b>
<b class="nc">&nbsp;                return Collections.emptyList();</b>
&nbsp;            }
<b class="nc">&nbsp;            return List.of(consumer);</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
