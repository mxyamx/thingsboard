<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > AbstractBufferedRateExecutor</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.server.dao.util</a>
</div>

<h1>Coverage Summary for Class: AbstractBufferedRateExecutor (org.thingsboard.server.dao.util)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AbstractBufferedRateExecutor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/62)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/141)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AbstractBufferedRateExecutor$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/64)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/153)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.server.dao.util;
&nbsp;
&nbsp;import com.datastax.oss.driver.api.core.ProtocolVersion;
&nbsp;import com.datastax.oss.driver.api.core.cql.BoundStatement;
&nbsp;import com.datastax.oss.driver.api.core.cql.ColumnDefinition;
&nbsp;import com.datastax.oss.driver.api.core.cql.ColumnDefinitions;
&nbsp;import com.datastax.oss.driver.api.core.cql.PreparedStatement;
&nbsp;import com.datastax.oss.driver.api.core.type.DataType;
&nbsp;import com.datastax.oss.driver.api.core.type.codec.TypeCodec;
&nbsp;import com.datastax.oss.driver.api.core.type.codec.registry.CodecRegistry;
&nbsp;import com.google.common.util.concurrent.FutureCallback;
&nbsp;import com.google.common.util.concurrent.Futures;
&nbsp;import com.google.common.util.concurrent.ListenableFuture;
&nbsp;import com.google.common.util.concurrent.SettableFuture;
&nbsp;import jakarta.annotation.Nullable;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.thingsboard.common.util.ThingsBoardExecutors;
&nbsp;import org.thingsboard.common.util.ThingsBoardThreadFactory;
&nbsp;import org.thingsboard.server.cache.limits.RateLimitService;
&nbsp;import org.thingsboard.server.common.data.exception.RateLimitExceededException;
&nbsp;import org.thingsboard.server.common.data.id.TenantId;
&nbsp;import org.thingsboard.server.common.data.limit.LimitedApi;
&nbsp;import org.thingsboard.server.common.msg.queue.ServiceType;
&nbsp;import org.thingsboard.server.common.stats.DefaultCounter;
&nbsp;import org.thingsboard.server.common.stats.StatsCounter;
&nbsp;import org.thingsboard.server.common.stats.StatsFactory;
&nbsp;import org.thingsboard.server.common.stats.StatsType;
&nbsp;import org.thingsboard.server.dao.entity.EntityService;
&nbsp;import org.thingsboard.server.dao.nosql.CassandraStatementTask;
&nbsp;import org.thingsboard.server.queue.discovery.TbServiceInfoProvider;
&nbsp;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.Map;
&nbsp;import java.util.UUID;
&nbsp;import java.util.concurrent.BlockingQueue;
&nbsp;import java.util.concurrent.ExecutorService;
&nbsp;import java.util.concurrent.Executors;
&nbsp;import java.util.concurrent.LinkedBlockingDeque;
&nbsp;import java.util.concurrent.ScheduledExecutorService;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.concurrent.TimeoutException;
&nbsp;import java.util.concurrent.atomic.AtomicInteger;
&nbsp;import java.util.regex.Matcher;
&nbsp;
&nbsp;/**
&nbsp; * Created by ashvayka on 24.10.18.
&nbsp; */
<b class="nc">&nbsp;@Slf4j</b>
&nbsp;public abstract class AbstractBufferedRateExecutor&lt;T extends AsyncTask, F extends ListenableFuture&lt;V&gt;, V&gt; implements BufferedRateExecutor&lt;T, F&gt; {
&nbsp;
&nbsp;    public static final String CONCURRENCY_LEVEL = &quot;currBuffer&quot;;
&nbsp;
&nbsp;    private final long maxWaitTime;
&nbsp;    private final long pollMs;
&nbsp;    private final String bufferName;
&nbsp;    private final BlockingQueue&lt;AsyncTaskContext&lt;T, V&gt;&gt; queue;
&nbsp;    private final ExecutorService dispatcherExecutor;
&nbsp;    private final ExecutorService callbackExecutor;
&nbsp;    private final ScheduledExecutorService timeoutExecutor;
&nbsp;    private final int concurrencyLimit;
&nbsp;    private final int printQueriesFreq;
&nbsp;
<b class="nc">&nbsp;    private final AtomicInteger printQueriesIdx = new AtomicInteger(0);</b>
&nbsp;
&nbsp;    protected final AtomicInteger concurrencyLevel;
&nbsp;    protected final BufferedRateExecutorStats stats;
&nbsp;
&nbsp;    private final EntityService entityService;
&nbsp;    private final RateLimitService rateLimitService;
&nbsp;
&nbsp;    private final boolean printTenantNames;
<b class="nc">&nbsp;    private final Map&lt;TenantId, String&gt; tenantNamesCache = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;    private final LimitedApi myLimitedApi;
&nbsp;
&nbsp;    public AbstractBufferedRateExecutor(int queueLimit, int concurrencyLimit, long maxWaitTime, int dispatcherThreads,
&nbsp;                                        int callbackThreads, long pollMs, int printQueriesFreq, BufferedRateExecutorType executorType, TbServiceInfoProvider serviceInfoProvider,
<b class="nc">&nbsp;                                        RateLimitService rateLimitService, StatsFactory statsFactory, EntityService entityService, boolean printTenantNames) {</b>
<b class="nc">&nbsp;        this.maxWaitTime = maxWaitTime;</b>
<b class="nc">&nbsp;        this.pollMs = pollMs;</b>
<b class="nc">&nbsp;        this.bufferName = executorType.getDisplayName();</b>
<b class="nc">&nbsp;        this.myLimitedApi = resolveLimitedApi(serviceInfoProvider, executorType);</b>
<b class="nc">&nbsp;        this.concurrencyLimit = concurrencyLimit;</b>
<b class="nc">&nbsp;        this.printQueriesFreq = printQueriesFreq;</b>
<b class="nc">&nbsp;        this.queue = new LinkedBlockingDeque&lt;&gt;(queueLimit);</b>
<b class="nc">&nbsp;        this.dispatcherExecutor = Executors.newFixedThreadPool(dispatcherThreads, ThingsBoardThreadFactory.forName(&quot;nosql-&quot; + bufferName + &quot;-dispatcher&quot;));</b>
<b class="nc">&nbsp;        this.callbackExecutor = ThingsBoardExecutors.newWorkStealingPool(callbackThreads, &quot;nosql-&quot; + bufferName + &quot;-callback&quot;);</b>
<b class="nc">&nbsp;        this.timeoutExecutor = ThingsBoardExecutors.newSingleThreadScheduledExecutor(&quot;nosql-&quot; + bufferName + &quot;-timeout&quot;);</b>
<b class="nc">&nbsp;        this.stats = new BufferedRateExecutorStats(statsFactory);</b>
<b class="nc">&nbsp;        String concurrencyLevelKey = StatsType.RATE_EXECUTOR.getName() + &quot;.&quot; + CONCURRENCY_LEVEL + bufferName; //metric name may change with buffer name suffix</b>
<b class="nc">&nbsp;        this.concurrencyLevel = statsFactory.createGauge(concurrencyLevelKey, new AtomicInteger(0));</b>
&nbsp;
<b class="nc">&nbsp;        this.entityService = entityService;</b>
<b class="nc">&nbsp;        this.rateLimitService = rateLimitService;</b>
<b class="nc">&nbsp;        this.printTenantNames = printTenantNames;</b>
&nbsp;
<b class="nc">&nbsp;        for (int i = 0; i &lt; dispatcherThreads; i++) {</b>
<b class="nc">&nbsp;            dispatcherExecutor.submit(this::dispatch);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public F submit(T task) {
<b class="nc">&nbsp;        SettableFuture&lt;V&gt; settableFuture = create();</b>
<b class="nc">&nbsp;        F result = wrap(task, settableFuture);</b>
&nbsp;
<b class="nc">&nbsp;        boolean perTenantLimitReached = false;</b>
<b class="nc">&nbsp;        TenantId tenantId = task.getTenantId();</b>
<b class="nc">&nbsp;        if (tenantId != null &amp;&amp; !tenantId.isSysTenantId()) {</b>
<b class="nc">&nbsp;            if (!rateLimitService.checkRateLimit(myLimitedApi, tenantId, tenantId, true)) {</b>
<b class="nc">&nbsp;                stats.incrementRateLimitedTenant(tenantId);</b>
<b class="nc">&nbsp;                stats.getTotalRateLimited().increment();</b>
<b class="nc">&nbsp;                settableFuture.setException(new RateLimitExceededException(myLimitedApi));</b>
<b class="nc">&nbsp;                perTenantLimitReached = true;</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (tenantId == null) {</b>
<b class="nc">&nbsp;            log.info(&quot;[{}] Invalid task received: {}&quot;, bufferName, task);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!perTenantLimitReached) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                stats.getTotalAdded().increment();</b>
<b class="nc">&nbsp;                queue.add(new AsyncTaskContext&lt;&gt;(UUID.randomUUID(), task, settableFuture, System.currentTimeMillis()));</b>
&nbsp;            } catch (IllegalStateException e) {
<b class="nc">&nbsp;                stats.getTotalRejected().increment();</b>
<b class="nc">&nbsp;                settableFuture.setException(e);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    private LimitedApi resolveLimitedApi(TbServiceInfoProvider serviceInfoProvider, BufferedRateExecutorType executorType) {
<b class="nc">&nbsp;        if (serviceInfoProvider == null || serviceInfoProvider.isMonolith()) {</b>
<b class="nc">&nbsp;            return executorType.getMonolithLimitedApi();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (serviceInfoProvider.isService(ServiceType.TB_RULE_ENGINE)) {</b>
<b class="nc">&nbsp;            return executorType.getRuleEngineLimitedApi();</b>
&nbsp;        }
<b class="nc">&nbsp;        return executorType.getCoreLimitedApi();</b>
&nbsp;    }
&nbsp;
&nbsp;    public void stop() {
<b class="nc">&nbsp;        if (dispatcherExecutor != null) {</b>
<b class="nc">&nbsp;            dispatcherExecutor.shutdownNow();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (callbackExecutor != null) {</b>
<b class="nc">&nbsp;            callbackExecutor.shutdownNow();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (timeoutExecutor != null) {</b>
<b class="nc">&nbsp;            timeoutExecutor.shutdownNow();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected abstract SettableFuture&lt;V&gt; create();
&nbsp;
&nbsp;    protected abstract F wrap(T task, SettableFuture&lt;V&gt; future);
&nbsp;
&nbsp;    protected abstract ListenableFuture&lt;V&gt; execute(AsyncTaskContext&lt;T, V&gt; taskCtx);
&nbsp;
&nbsp;    private void dispatch() {
<b class="nc">&nbsp;        log.info(&quot;[{}] Buffered rate executor thread started&quot;, bufferName);</b>
<b class="nc">&nbsp;        while (!Thread.interrupted()) {</b>
<b class="nc">&nbsp;            int curLvl = concurrencyLevel.get();</b>
<b class="nc">&nbsp;            AsyncTaskContext&lt;T, V&gt; taskCtx = null;</b>
&nbsp;            try {
<b class="nc">&nbsp;                if (curLvl &lt;= concurrencyLimit) {</b>
<b class="nc">&nbsp;                    taskCtx = queue.take();</b>
<b class="nc">&nbsp;                    final AsyncTaskContext&lt;T, V&gt; finalTaskCtx = taskCtx;</b>
<b class="nc">&nbsp;                    if (printQueriesFreq &gt; 0) {</b>
<b class="nc">&nbsp;                        if (printQueriesIdx.incrementAndGet() &gt;= printQueriesFreq) {</b>
<b class="nc">&nbsp;                            printQueriesIdx.set(0);</b>
<b class="nc">&nbsp;                            String query = queryToString(finalTaskCtx);</b>
<b class="nc">&nbsp;                            log.info(&quot;[{}][{}] Cassandra query: {}&quot;, bufferName, taskCtx.getId(), query);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    logTask(&quot;Processing&quot;, finalTaskCtx);</b>
<b class="nc">&nbsp;                    concurrencyLevel.incrementAndGet();</b>
<b class="nc">&nbsp;                    long timeout = finalTaskCtx.getCreateTime() + maxWaitTime - System.currentTimeMillis();</b>
<b class="nc">&nbsp;                    if (timeout &gt; 0) {</b>
<b class="nc">&nbsp;                        stats.getTotalLaunched().increment();</b>
<b class="nc">&nbsp;                        ListenableFuture&lt;V&gt; result = execute(finalTaskCtx);</b>
<b class="nc">&nbsp;                        result = Futures.withTimeout(result, timeout, TimeUnit.MILLISECONDS, timeoutExecutor);</b>
<b class="nc">&nbsp;                        Futures.addCallback(result, new FutureCallback&lt;V&gt;() {</b>
&nbsp;                            @Override
&nbsp;                            public void onSuccess(@Nullable V result) {
<b class="nc">&nbsp;                                logTask(&quot;Releasing&quot;, finalTaskCtx);</b>
<b class="nc">&nbsp;                                stats.getTotalReleased().increment();</b>
<b class="nc">&nbsp;                                concurrencyLevel.decrementAndGet();</b>
<b class="nc">&nbsp;                                finalTaskCtx.getFuture().set(result);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public void onFailure(Throwable t) {
<b class="nc">&nbsp;                                if (t instanceof TimeoutException) {</b>
<b class="nc">&nbsp;                                    logTask(&quot;Expired During Execution&quot;, finalTaskCtx);</b>
&nbsp;                                } else {
<b class="nc">&nbsp;                                    logTask(&quot;Failed&quot;, finalTaskCtx);</b>
&nbsp;                                }
<b class="nc">&nbsp;                                stats.getTotalFailed().increment();</b>
<b class="nc">&nbsp;                                concurrencyLevel.decrementAndGet();</b>
<b class="nc">&nbsp;                                finalTaskCtx.getFuture().setException(t);</b>
<b class="nc">&nbsp;                                log.debug(&quot;[{}] Failed to execute task: {}&quot;, finalTaskCtx.getId(), finalTaskCtx.getTask(), t);</b>
&nbsp;                            }
&nbsp;                        }, callbackExecutor);
&nbsp;                    } else {
<b class="nc">&nbsp;                        logTask(&quot;Expired Before Execution&quot;, finalTaskCtx);</b>
<b class="nc">&nbsp;                        stats.getTotalExpired().increment();</b>
<b class="nc">&nbsp;                        concurrencyLevel.decrementAndGet();</b>
<b class="nc">&nbsp;                        taskCtx.getFuture().setException(new TimeoutException());</b>
&nbsp;                    }
&nbsp;                } else {
<b class="nc">&nbsp;                    Thread.sleep(pollMs);</b>
&nbsp;                }
&nbsp;            } catch (InterruptedException e) {
&nbsp;                break;
&nbsp;            } catch (Throwable e) {
<b class="nc">&nbsp;                if (taskCtx != null) {</b>
<b class="nc">&nbsp;                    log.debug(&quot;[{}] Failed to execute task: {}&quot;, taskCtx.getId(), taskCtx, e);</b>
<b class="nc">&nbsp;                    stats.getTotalFailed().increment();</b>
<b class="nc">&nbsp;                    concurrencyLevel.decrementAndGet();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    log.debug(&quot;Failed to queue task:&quot;, e);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        log.info(&quot;[{}] Buffered rate executor thread stopped&quot;, bufferName);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void logTask(String action, AsyncTaskContext&lt;T, V&gt; taskCtx) {
<b class="nc">&nbsp;        if (log.isTraceEnabled()) {</b>
<b class="nc">&nbsp;            if (taskCtx.getTask() instanceof CassandraStatementTask) {</b>
<b class="nc">&nbsp;                String query = queryToString(taskCtx);</b>
<b class="nc">&nbsp;                log.trace(&quot;[{}] {} task: {}, BoundStatement query: {}&quot;, taskCtx.getId(), action, taskCtx, query);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                log.trace(&quot;[{}] {} task: {}&quot;, taskCtx.getId(), action, taskCtx);</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            log.debug(&quot;[{}] {} task&quot;, taskCtx.getId(), action);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private String queryToString(AsyncTaskContext&lt;T, V&gt; taskCtx) {
<b class="nc">&nbsp;        CassandraStatementTask cassStmtTask = (CassandraStatementTask) taskCtx.getTask();</b>
<b class="nc">&nbsp;        if (cassStmtTask.getStatement() instanceof BoundStatement) {</b>
<b class="nc">&nbsp;            BoundStatement stmt = (BoundStatement) cassStmtTask.getStatement();</b>
<b class="nc">&nbsp;            String query = stmt.getPreparedStatement().getQuery();</b>
&nbsp;            try {
<b class="nc">&nbsp;                query = toStringWithValues(stmt, ProtocolVersion.V5);</b>
&nbsp;            } catch (Exception e) {
<b class="nc">&nbsp;                log.warn(&quot;Can&#39;t convert to query with values&quot;, e);</b>
&nbsp;            }
<b class="nc">&nbsp;            return query;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return &quot;Not Cassandra Statement Task&quot;;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static String toStringWithValues(BoundStatement boundStatement, ProtocolVersion protocolVersion) {
<b class="nc">&nbsp;        CodecRegistry codecRegistry = boundStatement.codecRegistry();</b>
<b class="nc">&nbsp;        PreparedStatement preparedStatement = boundStatement.getPreparedStatement();</b>
<b class="nc">&nbsp;        String query = preparedStatement.getQuery();</b>
<b class="nc">&nbsp;        ColumnDefinitions defs = preparedStatement.getVariableDefinitions();</b>
<b class="nc">&nbsp;        int index = 0;</b>
<b class="nc">&nbsp;        for (ColumnDefinition def : defs) {</b>
<b class="nc">&nbsp;            DataType type = def.getType();</b>
<b class="nc">&nbsp;            TypeCodec&lt;Object&gt; codec = codecRegistry.codecFor(type);</b>
<b class="nc">&nbsp;            if (boundStatement.getBytesUnsafe(index) != null) {</b>
<b class="nc">&nbsp;                Object value = codec.decode(boundStatement.getBytesUnsafe(index), protocolVersion);</b>
<b class="nc">&nbsp;                String replacement = Matcher.quoteReplacement(codec.format(value));</b>
<b class="nc">&nbsp;                query = query.replaceFirst(&quot;\\?&quot;, replacement);</b>
&nbsp;            }
<b class="nc">&nbsp;            index++;</b>
&nbsp;        }
<b class="nc">&nbsp;        return query;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected int getQueueSize() {
<b class="nc">&nbsp;        return queue.size();</b>
&nbsp;    }
&nbsp;
&nbsp;    public void printStats() {
<b class="nc">&nbsp;        int queueSize = getQueueSize();</b>
<b class="nc">&nbsp;        int rateLimitedTenantsCount = (int) stats.getRateLimitedTenants().values().stream()</b>
<b class="nc">&nbsp;                .filter(defaultCounter -&gt; defaultCounter.get() &gt; 0)</b>
<b class="nc">&nbsp;                .count();</b>
&nbsp;
<b class="nc">&nbsp;        if (queueSize &gt; 0</b>
&nbsp;            || rateLimitedTenantsCount &gt; 0
<b class="nc">&nbsp;            || concurrencyLevel.get() &gt; 0</b>
<b class="nc">&nbsp;            || stats.getStatsCounters().stream().anyMatch(counter -&gt; counter.get() &gt; 0)</b>
&nbsp;        ) {
<b class="nc">&nbsp;            StringBuilder statsBuilder = new StringBuilder();</b>
&nbsp;
<b class="nc">&nbsp;            statsBuilder.append(&quot;queueSize&quot;).append(&quot; = [&quot;).append(queueSize).append(&quot;] &quot;);</b>
<b class="nc">&nbsp;            stats.getStatsCounters().forEach(counter -&gt; {</b>
<b class="nc">&nbsp;                statsBuilder.append(counter.getName()).append(&quot; = [&quot;).append(counter.get()).append(&quot;] &quot;);</b>
&nbsp;            });
<b class="nc">&nbsp;            statsBuilder.append(&quot;totalRateLimitedTenants&quot;).append(&quot; = [&quot;).append(rateLimitedTenantsCount).append(&quot;] &quot;);</b>
<b class="nc">&nbsp;            statsBuilder.append(CONCURRENCY_LEVEL).append(&quot; = [&quot;).append(concurrencyLevel.get()).append(&quot;] &quot;);</b>
&nbsp;
<b class="nc">&nbsp;            stats.getStatsCounters().forEach(StatsCounter::clear);</b>
<b class="nc">&nbsp;            log.info(&quot;[{}] Permits {}&quot;, bufferName, statsBuilder);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        stats.getRateLimitedTenants().entrySet().stream()</b>
<b class="nc">&nbsp;                .filter(entry -&gt; entry.getValue().get() &gt; 0)</b>
<b class="nc">&nbsp;                .forEach(entry -&gt; {</b>
<b class="nc">&nbsp;                    TenantId tenantId = entry.getKey();</b>
<b class="nc">&nbsp;                    DefaultCounter counter = entry.getValue();</b>
<b class="nc">&nbsp;                    int rateLimitedRequests = counter.get();</b>
<b class="nc">&nbsp;                    counter.clear();</b>
<b class="nc">&nbsp;                    if (printTenantNames) {</b>
<b class="nc">&nbsp;                        String name = tenantNamesCache.computeIfAbsent(tenantId, tId -&gt; {</b>
<b class="nc">&nbsp;                            String defaultName = &quot;N/A&quot;;</b>
&nbsp;                            try {
<b class="nc">&nbsp;                                return entityService.fetchEntityName(TenantId.SYS_TENANT_ID, tenantId).orElse(defaultName);</b>
&nbsp;                            } catch (Exception e) {
<b class="nc">&nbsp;                                log.error(&quot;[{}][{}] Failed to get tenant name&quot;, bufferName, tenantId, e);</b>
<b class="nc">&nbsp;                                return defaultName;</b>
&nbsp;                            }
&nbsp;                        });
<b class="nc">&nbsp;                        log.info(&quot;[{}][{}][{}] Rate limited requests: {}&quot;, bufferName, tenantId, name, rateLimitedRequests);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        log.info(&quot;[{}][{}] Rate limited requests: {}&quot;, bufferName, tenantId, rateLimitedRequests);</b>
&nbsp;                    }
&nbsp;                });
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
