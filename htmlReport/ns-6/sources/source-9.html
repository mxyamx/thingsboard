<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > JacksonUtil</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.common.util</a>
</div>

<h1>Coverage Summary for Class: JacksonUtil (org.thingsboard.common.util)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">JacksonUtil</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/51)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/172)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/235)
  </span>
</td>
</tr>
  <tr>
    <td class="name">JacksonUtil$JsonNodeProcessingTask</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JacksonUtil$JsonPathProcessingTask</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/58)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/174)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/253)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.common.util;
&nbsp;
&nbsp;import com.fasterxml.jackson.core.JsonParser;
&nbsp;import com.fasterxml.jackson.core.JsonProcessingException;
&nbsp;import com.fasterxml.jackson.core.json.JsonWriteFeature;
&nbsp;import com.fasterxml.jackson.core.type.TypeReference;
&nbsp;import com.fasterxml.jackson.databind.DeserializationFeature;
&nbsp;import com.fasterxml.jackson.databind.JavaType;
&nbsp;import com.fasterxml.jackson.databind.JsonNode;
&nbsp;import com.fasterxml.jackson.databind.MapperFeature;
&nbsp;import com.fasterxml.jackson.databind.ObjectMapper;
&nbsp;import com.fasterxml.jackson.databind.SerializationFeature;
&nbsp;import com.fasterxml.jackson.databind.json.JsonMapper;
&nbsp;import com.fasterxml.jackson.databind.node.ArrayNode;
&nbsp;import com.fasterxml.jackson.databind.node.ObjectNode;
&nbsp;import com.fasterxml.jackson.databind.node.TextNode;
&nbsp;import com.fasterxml.jackson.databind.type.CollectionType;
&nbsp;import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;
&nbsp;import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
&nbsp;import com.google.common.base.Strings;
&nbsp;import com.google.common.collect.Lists;
&nbsp;import lombok.Data;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.apache.commons.lang3.StringUtils;
&nbsp;import org.jetbrains.annotations.Contract;
&nbsp;import org.thingsboard.server.common.data.Views;
&nbsp;import org.thingsboard.server.common.data.kv.DataType;
&nbsp;import org.thingsboard.server.common.data.kv.KvEntry;
&nbsp;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.Reader;
&nbsp;import java.io.Writer;
&nbsp;import java.nio.file.Files;
&nbsp;import java.nio.file.Path;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.LinkedList;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Queue;
&nbsp;import java.util.Set;
&nbsp;import java.util.UUID;
&nbsp;import java.util.function.BiFunction;
&nbsp;import java.util.function.UnaryOperator;
&nbsp;import java.util.regex.Pattern;
&nbsp;
<b class="nc">&nbsp;@Slf4j</b>
<b class="nc">&nbsp;public class JacksonUtil {</b>
&nbsp;
<b class="nc">&nbsp;    public static final ObjectMapper OBJECT_MAPPER = JsonMapper.builder()</b>
<b class="nc">&nbsp;            .addModule(new Jdk8Module())</b>
<b class="nc">&nbsp;            .build();</b>
<b class="nc">&nbsp;    public static final ObjectMapper PRETTY_SORTED_JSON_MAPPER = JsonMapper.builder()</b>
<b class="nc">&nbsp;            .addModule(new Jdk8Module())</b>
<b class="nc">&nbsp;            .enable(SerializationFeature.INDENT_OUTPUT)</b>
<b class="nc">&nbsp;            .configure(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS, true)</b>
<b class="nc">&nbsp;            .configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, true)</b>
<b class="nc">&nbsp;            .build();</b>
<b class="nc">&nbsp;    public static ObjectMapper ALLOW_UNQUOTED_FIELD_NAMES_MAPPER = JsonMapper.builder()</b>
<b class="nc">&nbsp;            .addModule(new Jdk8Module())</b>
<b class="nc">&nbsp;            .configure(JsonWriteFeature.QUOTE_FIELD_NAMES.mappedFeature(), false)</b>
<b class="nc">&nbsp;            .configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true)</b>
<b class="nc">&nbsp;            .build();</b>
<b class="nc">&nbsp;    public static final ObjectMapper IGNORE_UNKNOWN_PROPERTIES_JSON_MAPPER = JsonMapper.builder()</b>
<b class="nc">&nbsp;            .addModule(new Jdk8Module())</b>
<b class="nc">&nbsp;            .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)</b>
<b class="nc">&nbsp;            .build();</b>
<b class="nc">&nbsp;    public static final ObjectMapper CANONICAL_JSON_MAPPER = JsonMapper.builder()</b>
<b class="nc">&nbsp;            .addModule(new Jdk8Module())</b>
<b class="nc">&nbsp;            .configure(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS, true)</b>
<b class="nc">&nbsp;            .configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, true)</b>
<b class="nc">&nbsp;            .serializationInclusion(com.fasterxml.jackson.annotation.JsonInclude.Include.NON_NULL)</b>
<b class="nc">&nbsp;            .build();</b>
&nbsp;
&nbsp;    public static ObjectMapper getObjectMapperWithJavaTimeModule() {
<b class="nc">&nbsp;        return JsonMapper.builder()</b>
<b class="nc">&nbsp;                .addModule(new Jdk8Module())</b>
<b class="nc">&nbsp;                .addModule(new JavaTimeModule())</b>
<b class="nc">&nbsp;                .build();</b>
&nbsp;    }
&nbsp;
&nbsp;    public static &lt;T&gt; T convertValue(Object fromValue, Class&lt;T&gt; toValueType) {
&nbsp;        try {
<b class="nc">&nbsp;            return fromValue != null ? OBJECT_MAPPER.convertValue(fromValue, toValueType) : null;</b>
&nbsp;        } catch (IllegalArgumentException e) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;The given object value cannot be converted to &quot; + toValueType + &quot;: &quot; + fromValue, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static &lt;T&gt; T convertValue(Object fromValue, TypeReference&lt;T&gt; toValueTypeRef) {
&nbsp;        try {
<b class="nc">&nbsp;            return fromValue != null ? OBJECT_MAPPER.convertValue(fromValue, toValueTypeRef) : null;</b>
&nbsp;        } catch (IllegalArgumentException e) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;The given object value cannot be converted to &quot; + toValueTypeRef + &quot;: &quot; + fromValue, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Contract(&quot;null, _ -&gt; null&quot;) // so that IDE doesn&#39;t show NPE warning when input is not null
&nbsp;    public static &lt;T&gt; T fromString(String string, Class&lt;T&gt; clazz) {
<b class="nc">&nbsp;        return fromString(string, clazz, &quot;The given string value cannot be transformed to Json object: &quot; + string);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Contract(&quot;null, _, _ -&gt; null&quot;) // so that IDE doesn&#39;t show NPE warning when input is not null
&nbsp;    public static &lt;T&gt; T fromString(String string, Class&lt;T&gt; clazz, String errorMsg) {
&nbsp;        try {
<b class="nc">&nbsp;            return string != null ? OBJECT_MAPPER.readValue(string, clazz) : null;</b>
&nbsp;        } catch (IOException e) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(errorMsg, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static &lt;T&gt; T fromString(String string, TypeReference&lt;T&gt; valueTypeRef) {
&nbsp;        try {
<b class="nc">&nbsp;            return string != null ? OBJECT_MAPPER.readValue(string, valueTypeRef) : null;</b>
&nbsp;        } catch (IOException e) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;The given string value cannot be transformed to Json object: &quot; + string, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static &lt;T&gt; T fromString(String string, JavaType javaType) {
&nbsp;        try {
<b class="nc">&nbsp;            return string != null ? OBJECT_MAPPER.readValue(string, javaType) : null;</b>
&nbsp;        } catch (IOException e) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;The given String value cannot be transformed to Json object: &quot; + string, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static &lt;T&gt; T fromString(String string, Class&lt;T&gt; clazz, boolean ignoreUnknownFields) {
&nbsp;        try {
<b class="nc">&nbsp;            return string != null ? IGNORE_UNKNOWN_PROPERTIES_JSON_MAPPER.readValue(string, clazz) : null;</b>
&nbsp;        } catch (IOException e) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;The given string value cannot be transformed to Json object: &quot; + string, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static &lt;T&gt; T fromBytes(byte[] bytes, Class&lt;T&gt; clazz) {
&nbsp;        try {
<b class="nc">&nbsp;            return bytes != null ? OBJECT_MAPPER.readValue(bytes, clazz) : null;</b>
&nbsp;        } catch (IOException e) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;The given byte[] value cannot be transformed to Json object:&quot; + Arrays.toString(bytes), e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static &lt;T&gt; T fromBytes(byte[] bytes, TypeReference&lt;T&gt; valueTypeRef) {
&nbsp;        try {
<b class="nc">&nbsp;            return bytes != null ? OBJECT_MAPPER.readValue(bytes, valueTypeRef) : null;</b>
&nbsp;        } catch (IOException e) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;The given string value cannot be transformed to Json object: &quot; + Arrays.toString(bytes), e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static JsonNode fromBytes(byte[] bytes) {
&nbsp;        try {
<b class="nc">&nbsp;            return OBJECT_MAPPER.readTree(bytes);</b>
&nbsp;        } catch (IOException e) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;The given byte[] value cannot be transformed to Json object: &quot; + Arrays.toString(bytes), e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static String toString(Object value) {
&nbsp;        try {
<b class="nc">&nbsp;            return value != null ? OBJECT_MAPPER.writeValueAsString(value) : null;</b>
&nbsp;        } catch (JsonProcessingException e) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;The given Json object value cannot be transformed to a String: &quot; + value, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static String writeValueAsString(Object value) {
&nbsp;        try {
<b class="nc">&nbsp;            return OBJECT_MAPPER.writeValueAsString(value);</b>
&nbsp;        } catch (JsonProcessingException e) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;The given Json object value: &quot;</b>
&nbsp;                    + value + &quot; cannot be transformed to a String&quot;, e);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static String writeValueAsViewIgnoringNullFields(Object value, Class&lt;Views.Public&gt; serializationView) throws JsonProcessingException {
<b class="nc">&nbsp;        return value == null ? &quot;&quot; : OBJECT_MAPPER.writerWithView(serializationView).writeValueAsString(value);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static String toPrettyString(Object o) {
&nbsp;        try {
<b class="nc">&nbsp;            return PRETTY_SORTED_JSON_MAPPER.writeValueAsString(o);</b>
&nbsp;        } catch (JsonProcessingException e) {
<b class="nc">&nbsp;            throw new RuntimeException(e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static String toPlainText(String data) {
<b class="nc">&nbsp;        if (data == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (data.startsWith(&quot;\&quot;&quot;) &amp;&amp; data.endsWith(&quot;\&quot;&quot;) &amp;&amp; data.length() &gt;= 2) {</b>
<b class="nc">&nbsp;            final String dataBefore = data;</b>
&nbsp;            try {
<b class="nc">&nbsp;                data = JacksonUtil.fromString(data, String.class);</b>
&nbsp;            } catch (Exception ignored) {}
<b class="nc">&nbsp;            log.trace(&quot;Trimming double quotes. Before trim: [{}], after trim: [{}]&quot;, dataBefore, data);</b>
&nbsp;        }
<b class="nc">&nbsp;        return data;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static String toCanonicalString(Object value) {
&nbsp;        try {
<b class="nc">&nbsp;            if (value == null) {</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (value instanceof JsonNode) {</b>
<b class="nc">&nbsp;                Object pojo = CANONICAL_JSON_MAPPER.convertValue(value, Object.class);</b>
<b class="nc">&nbsp;                return CANONICAL_JSON_MAPPER.writeValueAsString(pojo);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return CANONICAL_JSON_MAPPER.writeValueAsString(value);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;The given Json object value cannot be transformed to a canonical String: &quot; + value, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static &lt;T&gt; T treeToValue(JsonNode node, Class&lt;T&gt; clazz) {
&nbsp;        try {
<b class="nc">&nbsp;            return OBJECT_MAPPER.treeToValue(node, clazz);</b>
&nbsp;        } catch (IOException e) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Can&#39;t convert value: &quot; + node.toString(), e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static JsonNode toJsonNode(String value) {
<b class="nc">&nbsp;        return toJsonNode(value, OBJECT_MAPPER);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static JsonNode toJsonNode(String value, ObjectMapper mapper) {
<b class="nc">&nbsp;        if (value == null || value.isEmpty()) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;        try {
<b class="nc">&nbsp;            return mapper.readTree(value);</b>
&nbsp;        } catch (IOException e) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static &lt;T&gt; T readValue(String file, CollectionType clazz) {
&nbsp;        try {
<b class="nc">&nbsp;            return OBJECT_MAPPER.readValue(file, clazz);</b>
&nbsp;        } catch (IOException e) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Can&#39;t read file: &quot; + file, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static &lt;T&gt; T readValue(String object, TypeReference&lt;T&gt; clazz) {
&nbsp;        try {
<b class="nc">&nbsp;            return OBJECT_MAPPER.readValue(object, clazz);</b>
&nbsp;        } catch (IOException e) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Can&#39;t read object: &quot; + object, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static &lt;T&gt; T readValue(File file, TypeReference&lt;T&gt; clazz) {
&nbsp;        try {
<b class="nc">&nbsp;            return OBJECT_MAPPER.readValue(file, clazz);</b>
&nbsp;        } catch (IOException e) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Can&#39;t read file: &quot; + file, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static &lt;T&gt; T readValue(File file, Class&lt;T&gt; clazz) {
&nbsp;        try {
<b class="nc">&nbsp;            return OBJECT_MAPPER.readValue(file, clazz);</b>
&nbsp;        } catch (IOException e) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Can&#39;t read file: &quot; + file, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static JsonNode toJsonNode(Path file) {
&nbsp;        try {
<b class="nc">&nbsp;            return OBJECT_MAPPER.readTree(Files.readAllBytes(file));</b>
&nbsp;        } catch (IOException e) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Can&#39;t read file: &quot; + file, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static JsonNode toJsonNode(File value) {
&nbsp;        try {
<b class="nc">&nbsp;            return value != null ? OBJECT_MAPPER.readTree(value) : null;</b>
&nbsp;        } catch (IOException e) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;The given File object value: &quot;</b>
&nbsp;                    + value + &quot; cannot be transformed to a JsonNode&quot;, e);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static JsonNode toJsonNode(InputStream value) {
&nbsp;        try {
<b class="nc">&nbsp;            return value != null ? OBJECT_MAPPER.readTree(value) : null;</b>
&nbsp;        } catch (IOException e) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;The given InputStream value: &quot;</b>
&nbsp;                    + value + &quot; cannot be transformed to a JsonNode&quot;, e);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static ObjectNode newObjectNode() {
<b class="nc">&nbsp;        return newObjectNode(OBJECT_MAPPER);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static ObjectNode newObjectNode(ObjectMapper mapper) {
<b class="nc">&nbsp;        return mapper.createObjectNode();</b>
&nbsp;    }
&nbsp;
&nbsp;    public static ArrayNode newArrayNode() {
<b class="nc">&nbsp;        return newArrayNode(OBJECT_MAPPER);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static ArrayNode newArrayNode(ObjectMapper mapper) {
<b class="nc">&nbsp;        return mapper.createArrayNode();</b>
&nbsp;    }
&nbsp;
&nbsp;    public static &lt;T&gt; T clone(T value) {
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
<b class="nc">&nbsp;        Class&lt;T&gt; valueClass = (Class&lt;T&gt;) value.getClass();</b>
<b class="nc">&nbsp;        return fromString(toString(value), valueClass);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static &lt;T&gt; JsonNode valueToTree(T value) {
<b class="nc">&nbsp;        return OBJECT_MAPPER.valueToTree(value);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static &lt;T&gt; byte[] writeValueAsBytes(T value) {
&nbsp;        try {
<b class="nc">&nbsp;            return OBJECT_MAPPER.writeValueAsBytes(value);</b>
&nbsp;        } catch (JsonProcessingException e) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;The given Json object value cannot be transformed to a String: &quot; + value, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static JsonNode getSafely(JsonNode node, String... path) {
<b class="nc">&nbsp;        if (node == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (String p : path) {</b>
<b class="nc">&nbsp;            if (!node.has(p)) {</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                node = node.get(p);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return node;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static ObjectNode asObject(JsonNode node) {
<b class="nc">&nbsp;        return node != null &amp;&amp; node.isObject() ? ((ObjectNode) node) : newObjectNode();</b>
&nbsp;    }
&nbsp;
&nbsp;    public static void replaceUuidsRecursively(JsonNode node, Set&lt;String&gt; skippedRootFields, Pattern includedFieldsPattern, UnaryOperator&lt;UUID&gt; replacer, boolean root) {
<b class="nc">&nbsp;        if (node == null) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        if (node.isObject()) {</b>
<b class="nc">&nbsp;            ObjectNode objectNode = (ObjectNode) node;</b>
<b class="nc">&nbsp;            List&lt;String&gt; fieldNames = Lists.newArrayList(objectNode.fieldNames());</b>
<b class="nc">&nbsp;            for (String fieldName : fieldNames) {</b>
<b class="nc">&nbsp;                if (root &amp;&amp; skippedRootFields.contains(fieldName)) {</b>
&nbsp;                    continue;
&nbsp;                }
<b class="nc">&nbsp;                var child = objectNode.get(fieldName);</b>
<b class="nc">&nbsp;                if (child.isObject() || child.isArray()) {</b>
<b class="nc">&nbsp;                    replaceUuidsRecursively(child, skippedRootFields, includedFieldsPattern, replacer, false);</b>
<b class="nc">&nbsp;                } else if (child.isTextual()) {</b>
<b class="nc">&nbsp;                    if (includedFieldsPattern != null &amp;&amp; !RegexUtils.matches(fieldName, includedFieldsPattern)) {</b>
&nbsp;                        continue;
&nbsp;                    }
<b class="nc">&nbsp;                    String text = child.asText();</b>
<b class="nc">&nbsp;                    String newText = RegexUtils.replace(text, RegexUtils.UUID_PATTERN, uuid -&gt; replacer.apply(UUID.fromString(uuid)).toString());</b>
<b class="nc">&nbsp;                    if (!text.equals(newText)) {</b>
<b class="nc">&nbsp;                        objectNode.put(fieldName, newText);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        } else if (node.isArray()) {</b>
<b class="nc">&nbsp;            ArrayNode array = (ArrayNode) node;</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; array.size(); i++) {</b>
<b class="nc">&nbsp;                JsonNode arrayElement = array.get(i);</b>
<b class="nc">&nbsp;                if (arrayElement.isObject() || arrayElement.isArray()) {</b>
<b class="nc">&nbsp;                    replaceUuidsRecursively(arrayElement, skippedRootFields, includedFieldsPattern, replacer, false);</b>
<b class="nc">&nbsp;                } else if (arrayElement.isTextual()) {</b>
<b class="nc">&nbsp;                    String text = arrayElement.asText();</b>
<b class="nc">&nbsp;                    String newText = RegexUtils.replace(text, RegexUtils.UUID_PATTERN, uuid -&gt; replacer.apply(UUID.fromString(uuid)).toString());</b>
<b class="nc">&nbsp;                    if (!text.equals(newText)) {</b>
<b class="nc">&nbsp;                        array.set(i, newText);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static Map&lt;String, String&gt; toFlatMap(JsonNode node) {
<b class="nc">&nbsp;        HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        toFlatMap(node, &quot;&quot;, map);</b>
<b class="nc">&nbsp;        return map;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static &lt;T&gt; T fromReader(Reader reader, Class&lt;T&gt; clazz) {
&nbsp;        try {
<b class="nc">&nbsp;            return reader != null ? OBJECT_MAPPER.readValue(reader, clazz) : null;</b>
&nbsp;        } catch (IOException e) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Invalid request payload&quot;, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static &lt;T&gt; void writeValue(Writer writer, T value) {
&nbsp;        try {
<b class="nc">&nbsp;            OBJECT_MAPPER.writeValue(writer, value);</b>
&nbsp;        } catch (IOException e) {
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;The given writer value: &quot;</b>
&nbsp;                    + writer + &quot;cannot be wrote&quot;, e);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static JavaType constructCollectionType(Class collectionClass, Class&lt;?&gt; elementClass) {
<b class="nc">&nbsp;        return OBJECT_MAPPER.getTypeFactory().constructCollectionType(collectionClass, elementClass);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static void toFlatMap(JsonNode node, String currentPath, Map&lt;String, String&gt; map) {
<b class="nc">&nbsp;        if (node.isObject()) {</b>
<b class="nc">&nbsp;            Iterator&lt;Map.Entry&lt;String, JsonNode&gt;&gt; fields = node.fields();</b>
<b class="nc">&nbsp;            currentPath = currentPath.isEmpty() ? &quot;&quot; : currentPath + &quot;.&quot;;</b>
<b class="nc">&nbsp;            while (fields.hasNext()) {</b>
<b class="nc">&nbsp;                Map.Entry&lt;String, JsonNode&gt; entry = fields.next();</b>
<b class="nc">&nbsp;                toFlatMap(entry.getValue(), currentPath + entry.getKey(), map);</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (node.isValueNode()) {</b>
<b class="nc">&nbsp;            map.put(currentPath, node.asText());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static void addKvEntry(ObjectNode entityNode, KvEntry kvEntry) {
<b class="nc">&nbsp;        addKvEntry(entityNode, kvEntry, kvEntry.getKey());</b>
&nbsp;    }
&nbsp;
&nbsp;    public static void addKvEntry(ObjectNode entityNode, KvEntry kvEntry, String key) {
<b class="nc">&nbsp;        addKvEntry(entityNode, kvEntry, key, OBJECT_MAPPER);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static void addKvEntry(ObjectNode entityNode, KvEntry kvEntry, String key, ObjectMapper mapper) {
<b class="nc">&nbsp;        if (kvEntry.getDataType() == DataType.BOOLEAN) {</b>
<b class="nc">&nbsp;            kvEntry.getBooleanValue().ifPresent(value -&gt; entityNode.put(key, value));</b>
<b class="nc">&nbsp;        } else if (kvEntry.getDataType() == DataType.DOUBLE) {</b>
<b class="nc">&nbsp;            kvEntry.getDoubleValue().ifPresent(value -&gt; entityNode.put(key, value));</b>
<b class="nc">&nbsp;        } else if (kvEntry.getDataType() == DataType.LONG) {</b>
<b class="nc">&nbsp;            kvEntry.getLongValue().ifPresent(value -&gt; entityNode.put(key, value));</b>
<b class="nc">&nbsp;        } else if (kvEntry.getDataType() == DataType.JSON) {</b>
<b class="nc">&nbsp;            if (kvEntry.getJsonValue().isPresent()) {</b>
<b class="nc">&nbsp;                entityNode.set(key, toJsonNode(kvEntry.getJsonValue().get(), mapper));</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            entityNode.put(key, kvEntry.getValueAsString());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static void replaceAll(JsonNode root, String pathPrefix, BiFunction&lt;String, String, String&gt; processor) {
<b class="nc">&nbsp;        Queue&lt;JsonNodeProcessingTask&gt; tasks = new LinkedList&lt;&gt;();</b>
<b class="nc">&nbsp;        tasks.add(new JsonNodeProcessingTask(pathPrefix, root));</b>
<b class="nc">&nbsp;        while (!tasks.isEmpty()) {</b>
<b class="nc">&nbsp;            JsonNodeProcessingTask task = tasks.poll();</b>
<b class="nc">&nbsp;            JsonNode node = task.getNode();</b>
<b class="nc">&nbsp;            if (node == null) {</b>
&nbsp;                continue;
&nbsp;            }
<b class="nc">&nbsp;            String currentPath = StringUtils.isBlank(task.getPath()) ? &quot;&quot; : (task.getPath() + &quot;.&quot;);</b>
<b class="nc">&nbsp;            if (node.isObject()) {</b>
<b class="nc">&nbsp;                ObjectNode on = (ObjectNode) node;</b>
<b class="nc">&nbsp;                for (Iterator&lt;String&gt; it = on.fieldNames(); it.hasNext(); ) {</b>
<b class="nc">&nbsp;                    String childName = it.next();</b>
<b class="nc">&nbsp;                    JsonNode childValue = on.get(childName);</b>
<b class="nc">&nbsp;                    if (childValue.isTextual()) {</b>
<b class="nc">&nbsp;                        on.put(childName, processor.apply(currentPath + childName, childValue.asText()));</b>
<b class="nc">&nbsp;                    } else if (childValue.isObject() || childValue.isArray()) {</b>
<b class="nc">&nbsp;                        tasks.add(new JsonNodeProcessingTask(currentPath + childName, childValue));</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            } else if (node.isArray()) {</b>
<b class="nc">&nbsp;                ArrayNode childArray = (ArrayNode) node;</b>
<b class="nc">&nbsp;                for (int i = 0; i &lt; childArray.size(); i++) {</b>
<b class="nc">&nbsp;                    JsonNode element = childArray.get(i);</b>
<b class="nc">&nbsp;                    if (element.isObject()) {</b>
<b class="nc">&nbsp;                        tasks.add(new JsonNodeProcessingTask(currentPath + &quot;.&quot; + i, element));</b>
<b class="nc">&nbsp;                    } else if (element.isTextual()) {</b>
<b class="nc">&nbsp;                        childArray.set(i, processor.apply(currentPath + &quot;.&quot; + i, element.asText()));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static void replaceAllByMapping(JsonNode jsonNode, Map&lt;String, String&gt; mapping, Map&lt;String, String&gt; templateParams, BiFunction&lt;String, String, String&gt; processor) {
<b class="nc">&nbsp;        replaceByMapping(jsonNode, mapping, templateParams, (name, value) -&gt; {</b>
<b class="nc">&nbsp;            if (value.isTextual()) {</b>
<b class="nc">&nbsp;                return new TextNode(processor.apply(name, value.asText()));</b>
<b class="nc">&nbsp;            } else if (value.isArray()) {</b>
<b class="nc">&nbsp;                ArrayNode array = (ArrayNode) value;</b>
<b class="nc">&nbsp;                for (int i = 0; i &lt; array.size(); i++) {</b>
<b class="nc">&nbsp;                    String arrayElementName = name.replace(&quot;$index&quot;, Integer.toString(i));</b>
<b class="nc">&nbsp;                    array.set(i, processor.apply(arrayElementName, array.get(i).asText()));</b>
&nbsp;                }
<b class="nc">&nbsp;                return array;</b>
&nbsp;            }
<b class="nc">&nbsp;            return value;</b>
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    public static void replaceByMapping(JsonNode jsonNode, Map&lt;String, String&gt; mapping, Map&lt;String, String&gt; templateParams, BiFunction&lt;String, JsonNode, JsonNode&gt; processor) {
<b class="nc">&nbsp;        for (var entry : mapping.entrySet()) {</b>
<b class="nc">&nbsp;            String expression = entry.getValue();</b>
<b class="nc">&nbsp;            Queue&lt;JsonPathProcessingTask&gt; tasks = new LinkedList&lt;&gt;();</b>
<b class="nc">&nbsp;            tasks.add(new JsonPathProcessingTask(entry.getKey().split(&quot;\\.&quot;), templateParams, jsonNode));</b>
<b class="nc">&nbsp;            while (!tasks.isEmpty()) {</b>
<b class="nc">&nbsp;                JsonPathProcessingTask task = tasks.poll();</b>
<b class="nc">&nbsp;                String token = task.currentToken();</b>
<b class="nc">&nbsp;                JsonNode node = task.getNode();</b>
<b class="nc">&nbsp;                if (node == null) {</b>
&nbsp;                    continue;
&nbsp;                }
<b class="nc">&nbsp;                if (token.equals(&quot;*&quot;) || token.startsWith(&quot;$&quot;)) {</b>
<b class="nc">&nbsp;                    String variableName = token.startsWith(&quot;$&quot;) ? token.substring(1) : null;</b>
<b class="nc">&nbsp;                    if (node.isArray()) {</b>
<b class="nc">&nbsp;                        ArrayNode childArray = (ArrayNode) node;</b>
<b class="nc">&nbsp;                        for (JsonNode element : childArray) {</b>
<b class="nc">&nbsp;                            tasks.add(task.next(element));</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } else if (node.isObject()) {</b>
<b class="nc">&nbsp;                        ObjectNode on = (ObjectNode) node;</b>
<b class="nc">&nbsp;                        for (Iterator&lt;Map.Entry&lt;String, JsonNode&gt;&gt; it = on.fields(); it.hasNext(); ) {</b>
<b class="nc">&nbsp;                            var kv = it.next();</b>
<b class="nc">&nbsp;                            if (variableName != null) {</b>
<b class="nc">&nbsp;                                tasks.add(task.next(kv.getValue(), variableName, kv.getKey()));</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                tasks.add(task.next(kv.getValue()));</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                } else {
<b class="nc">&nbsp;                    String variableName = null;</b>
<b class="nc">&nbsp;                    String variableValue = null;</b>
<b class="nc">&nbsp;                    if (token.contains(&quot;[$&quot;)) {</b>
<b class="nc">&nbsp;                        variableName = StringUtils.substringBetween(token, &quot;[$&quot;, &quot;]&quot;);</b>
<b class="nc">&nbsp;                        token = StringUtils.substringBefore(token, &quot;[$&quot;);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (node.has(token)) {</b>
<b class="nc">&nbsp;                        JsonNode value = node.get(token);</b>
<b class="nc">&nbsp;                        if (variableName != null &amp;&amp; value.has(variableName) &amp;&amp; value.get(variableName).isTextual()) {</b>
<b class="nc">&nbsp;                            variableValue = value.get(variableName).asText();</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (task.isLast()) {</b>
<b class="nc">&nbsp;                            String name = expression;</b>
<b class="nc">&nbsp;                            for (var replacement : task.getVariables().entrySet()) {</b>
<b class="nc">&nbsp;                                name = name.replace(&quot;$&quot; + replacement.getKey(), Strings.nullToEmpty(replacement.getValue()));</b>
&nbsp;                            }
<b class="nc">&nbsp;                            ((ObjectNode) node).set(token, processor.apply(name, value));</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            if (StringUtils.isNotEmpty(variableName)) {</b>
<b class="nc">&nbsp;                                tasks.add(task.next(value, variableName, variableValue));</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                tasks.add(task.next(value));</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Data
&nbsp;    public static class JsonNodeProcessingTask {
&nbsp;        private final String path;
&nbsp;        private final JsonNode node;
&nbsp;
<b class="nc">&nbsp;        public JsonNodeProcessingTask(String path, JsonNode node) {</b>
<b class="nc">&nbsp;            this.path = path;</b>
<b class="nc">&nbsp;            this.node = node;</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    @Data
&nbsp;    public static class JsonPathProcessingTask {
&nbsp;        private final String[] tokens;
&nbsp;        private final Map&lt;String, String&gt; variables;
&nbsp;        private final JsonNode node;
&nbsp;
<b class="nc">&nbsp;        public JsonPathProcessingTask(String[] tokens, Map&lt;String, String&gt; variables, JsonNode node) {</b>
<b class="nc">&nbsp;            this.tokens = tokens;</b>
<b class="nc">&nbsp;            this.variables = variables;</b>
<b class="nc">&nbsp;            this.node = node;</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean isLast() {
<b class="nc">&nbsp;            return tokens.length == 1;</b>
&nbsp;        }
&nbsp;
&nbsp;        public String currentToken() {
<b class="nc">&nbsp;            return tokens[0];</b>
&nbsp;        }
&nbsp;
&nbsp;        public JsonPathProcessingTask next(JsonNode next) {
<b class="nc">&nbsp;            return new JsonPathProcessingTask(</b>
<b class="nc">&nbsp;                    Arrays.copyOfRange(tokens, 1, tokens.length),</b>
&nbsp;                    variables,
&nbsp;                    next);
&nbsp;        }
&nbsp;
&nbsp;        public JsonPathProcessingTask next(JsonNode next, String key, String value) {
<b class="nc">&nbsp;            Map&lt;String, String&gt; variables = new HashMap&lt;&gt;(this.variables);</b>
<b class="nc">&nbsp;            variables.put(key, value);</b>
<b class="nc">&nbsp;            return new JsonPathProcessingTask(</b>
<b class="nc">&nbsp;                    Arrays.copyOfRange(tokens, 1, tokens.length),</b>
&nbsp;                    variables,
&nbsp;                    next);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return &quot;JsonPathProcessingTask{&quot; +</b>
<b class="nc">&nbsp;                    &quot;tokens=&quot; + Arrays.toString(tokens) +</b>
&nbsp;                    &quot;, variables=&quot; + variables +
<b class="nc">&nbsp;                    &quot;, node=&quot; + node.toString().substring(0, 20) +</b>
&nbsp;                    &#39;}&#39;;
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
