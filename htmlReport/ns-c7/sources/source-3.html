<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > DefaultTransportService</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.server.common.transport.service</a>
</div>

<h1>Coverage Summary for Class: DefaultTransportService (org.thingsboard.server.common.transport.service)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DefaultTransportService</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/83)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/219)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/562)
  </span>
</td>
</tr>
  <tr>
    <td class="name">DefaultTransportService$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultTransportService$ApiStatsProxyCallback</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultTransportService$MsgPackCallback</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultTransportService$StatsCallback</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultTransportService$TransportTbQueueCallback</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/96)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/225)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/591)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.server.common.transport.service;
&nbsp;
&nbsp;import com.fasterxml.jackson.databind.JsonNode;
&nbsp;import com.google.common.util.concurrent.Futures;
&nbsp;import com.google.common.util.concurrent.ListenableFuture;
&nbsp;import com.google.common.util.concurrent.MoreExecutors;
&nbsp;import com.google.gson.Gson;
&nbsp;import com.google.gson.JsonObject;
&nbsp;import jakarta.annotation.PostConstruct;
&nbsp;import jakarta.annotation.PreDestroy;
&nbsp;import lombok.RequiredArgsConstructor;
&nbsp;import lombok.extern.slf4j.Slf4j;
&nbsp;import org.apache.commons.lang3.exception.ExceptionUtils;
&nbsp;import org.springframework.beans.factory.annotation.Autowired;
&nbsp;import org.springframework.beans.factory.annotation.Value;
&nbsp;import org.springframework.context.ApplicationEventPublisher;
&nbsp;import org.springframework.context.annotation.Lazy;
&nbsp;import org.springframework.scheduling.annotation.Scheduled;
&nbsp;import org.springframework.stereotype.Service;
&nbsp;import org.thingsboard.common.util.ThingsBoardExecutors;
&nbsp;import org.thingsboard.common.util.ThingsBoardThreadFactory;
&nbsp;import org.thingsboard.server.common.data.ApiUsageRecordKey;
&nbsp;import org.thingsboard.server.common.data.ApiUsageState;
&nbsp;import org.thingsboard.server.common.data.DataConstants;
&nbsp;import org.thingsboard.server.common.data.Device;
&nbsp;import org.thingsboard.server.common.data.DeviceProfile;
&nbsp;import org.thingsboard.server.common.data.DeviceTransportType;
&nbsp;import org.thingsboard.server.common.data.EntityType;
&nbsp;import org.thingsboard.server.common.data.ResourceType;
&nbsp;import org.thingsboard.server.common.data.StringUtils;
&nbsp;import org.thingsboard.server.common.data.Tenant;
&nbsp;import org.thingsboard.server.common.data.device.data.PowerMode;
&nbsp;import org.thingsboard.server.common.data.id.CustomerId;
&nbsp;import org.thingsboard.server.common.data.id.DeviceId;
&nbsp;import org.thingsboard.server.common.data.id.DeviceProfileId;
&nbsp;import org.thingsboard.server.common.data.id.EntityId;
&nbsp;import org.thingsboard.server.common.data.id.RuleChainId;
&nbsp;import org.thingsboard.server.common.data.id.TenantId;
&nbsp;import org.thingsboard.server.common.data.id.TenantProfileId;
&nbsp;import org.thingsboard.server.common.data.limit.LimitedApi;
&nbsp;import org.thingsboard.server.common.data.msg.TbMsgType;
&nbsp;import org.thingsboard.server.common.data.notification.rule.trigger.RateLimitsTrigger;
&nbsp;import org.thingsboard.server.common.data.plugin.ComponentLifecycleEvent;
&nbsp;import org.thingsboard.server.common.data.rpc.RpcStatus;
&nbsp;import org.thingsboard.server.common.msg.TbMsg;
&nbsp;import org.thingsboard.server.common.msg.TbMsgMetaData;
&nbsp;import org.thingsboard.server.common.msg.notification.NotificationRuleProcessor;
&nbsp;import org.thingsboard.server.common.msg.queue.ServiceType;
&nbsp;import org.thingsboard.server.common.msg.queue.TopicPartitionInfo;
&nbsp;import org.thingsboard.server.common.msg.tools.TbRateLimitsException;
&nbsp;import org.thingsboard.server.common.stats.MessagesStats;
&nbsp;import org.thingsboard.server.common.stats.StatsFactory;
&nbsp;import org.thingsboard.server.common.stats.StatsType;
&nbsp;import org.thingsboard.server.common.stats.TbApiUsageReportClient;
&nbsp;import org.thingsboard.server.common.transport.DeviceDeletedEvent;
&nbsp;import org.thingsboard.server.common.transport.DeviceProfileUpdatedEvent;
&nbsp;import org.thingsboard.server.common.transport.DeviceUpdatedEvent;
&nbsp;import org.thingsboard.server.common.transport.SessionMsgListener;
&nbsp;import org.thingsboard.server.common.transport.TransportDeviceProfileCache;
&nbsp;import org.thingsboard.server.common.transport.TransportResourceCache;
&nbsp;import org.thingsboard.server.common.transport.TransportService;
&nbsp;import org.thingsboard.server.common.transport.TransportServiceCallback;
&nbsp;import org.thingsboard.server.common.transport.TransportTenantProfileCache;
&nbsp;import org.thingsboard.server.common.transport.auth.GetOrCreateDeviceFromGatewayResponse;
&nbsp;import org.thingsboard.server.common.transport.auth.TransportDeviceInfo;
&nbsp;import org.thingsboard.server.common.transport.auth.ValidateDeviceCredentialsResponse;
&nbsp;import org.thingsboard.server.common.transport.limits.EntityLimitKey;
&nbsp;import org.thingsboard.server.common.transport.limits.EntityLimitsCache;
&nbsp;import org.thingsboard.server.common.transport.limits.TransportRateLimitService;
&nbsp;import org.thingsboard.server.common.transport.util.JsonUtils;
&nbsp;import org.thingsboard.server.common.util.ProtoUtils;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.ProvisionDeviceRequestMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.ProvisionDeviceResponseMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.ToCoreMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.ToRuleEngineMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.ToTransportMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.TransportApiRequestMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.TransportApiResponseMsg;
&nbsp;import org.thingsboard.server.gen.transport.TransportProtos.TransportToDeviceActorMsg;
&nbsp;import org.thingsboard.server.queue.TbQueueCallback;
&nbsp;import org.thingsboard.server.queue.TbQueueConsumer;
&nbsp;import org.thingsboard.server.queue.TbQueueMsgMetadata;
&nbsp;import org.thingsboard.server.queue.TbQueueProducer;
&nbsp;import org.thingsboard.server.queue.TbQueueRequestTemplate;
&nbsp;import org.thingsboard.server.queue.common.AsyncCallbackTemplate;
&nbsp;import org.thingsboard.server.queue.common.TbProtoQueueMsg;
&nbsp;import org.thingsboard.server.queue.common.TbRuleEngineProducerService;
&nbsp;import org.thingsboard.server.queue.common.consumer.QueueConsumerManager;
&nbsp;import org.thingsboard.server.queue.discovery.PartitionService;
&nbsp;import org.thingsboard.server.queue.discovery.TbServiceInfoProvider;
&nbsp;import org.thingsboard.server.queue.discovery.TopicService;
&nbsp;import org.thingsboard.server.queue.provider.TbQueueProducerProvider;
&nbsp;import org.thingsboard.server.queue.provider.TbTransportQueueFactory;
&nbsp;import org.thingsboard.server.queue.scheduler.SchedulerComponent;
&nbsp;import org.thingsboard.server.queue.util.AfterStartUp;
&nbsp;import org.thingsboard.server.queue.util.TbTransportComponent;
&nbsp;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Optional;
&nbsp;import java.util.Random;
&nbsp;import java.util.Set;
&nbsp;import java.util.UUID;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.concurrent.ExecutionException;
&nbsp;import java.util.concurrent.ExecutorService;
&nbsp;import java.util.concurrent.Executors;
&nbsp;import java.util.concurrent.ScheduledFuture;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.concurrent.atomic.AtomicInteger;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;/**
&nbsp; * Created by ashvayka on 17.10.18.
&nbsp; */
<b class="nc">&nbsp;@Slf4j</b>
&nbsp;@Service
&nbsp;@TbTransportComponent
&nbsp;@RequiredArgsConstructor
&nbsp;public class DefaultTransportService extends TransportActivityManager implements TransportService {
&nbsp;
<b class="nc">&nbsp;    public static final TransportProtos.SessionEventMsg SESSION_EVENT_MSG_OPEN = TransportProtos.SessionEventMsg.newBuilder()</b>
<b class="nc">&nbsp;            .setSessionType(TransportProtos.SessionType.ASYNC)</b>
<b class="nc">&nbsp;            .setEvent(TransportProtos.SessionEvent.OPEN).build();</b>
<b class="nc">&nbsp;    public static final TransportProtos.SubscribeToAttributeUpdatesMsg SUBSCRIBE_TO_ATTRIBUTE_UPDATES_ASYNC_MSG = TransportProtos.SubscribeToAttributeUpdatesMsg.newBuilder()</b>
<b class="nc">&nbsp;            .setSessionType(TransportProtos.SessionType.ASYNC).build();</b>
<b class="nc">&nbsp;    public static final TransportProtos.SubscribeToRPCMsg SUBSCRIBE_TO_RPC_ASYNC_MSG = TransportProtos.SubscribeToRPCMsg.newBuilder()</b>
<b class="nc">&nbsp;            .setSessionType(TransportProtos.SessionType.ASYNC).build();</b>
&nbsp;
&nbsp;    private final AtomicInteger atomicTs = new AtomicInteger(0);
&nbsp;
&nbsp;    @Value(&quot;${transport.log.enabled:true}&quot;)
&nbsp;    private boolean logEnabled;
&nbsp;    @Value(&quot;${transport.log.max_length:1024}&quot;)
&nbsp;    private int logMaxLength;
&nbsp;    @Value(&quot;${transport.client_side_rpc.timeout:60000}&quot;)
&nbsp;    private long clientSideRpcTimeout;
&nbsp;    @Value(&quot;${queue.transport.poll_interval}&quot;)
&nbsp;    private int notificationsPollDuration;
&nbsp;    @Value(&quot;${transport.stats.enabled:false}&quot;)
&nbsp;    private boolean statsEnabled;
&nbsp;
&nbsp;    @Autowired
&nbsp;    @Lazy
&nbsp;    private TbApiUsageReportClient apiUsageClient;
&nbsp;    private final Map&lt;String, Number&gt; statsMap = new LinkedHashMap&lt;&gt;();
&nbsp;
&nbsp;    private final Gson gson = new Gson();
&nbsp;    private final PartitionService partitionService;
&nbsp;    private final TbTransportQueueFactory queueProvider;
&nbsp;    private final TbQueueProducerProvider producerProvider;
&nbsp;    private final TbRuleEngineProducerService ruleEngineProducerService;
&nbsp;
&nbsp;    private final TopicService topicService;
&nbsp;    private final TbServiceInfoProvider serviceInfoProvider;
&nbsp;    private final StatsFactory statsFactory;
&nbsp;    private final TransportDeviceProfileCache deviceProfileCache;
&nbsp;    private final TransportTenantProfileCache tenantProfileCache;
&nbsp;
&nbsp;    private final TransportRateLimitService rateLimitService;
&nbsp;    private final SchedulerComponent scheduler;
&nbsp;    private final ApplicationEventPublisher eventPublisher;
&nbsp;    private final TransportResourceCache transportResourceCache;
&nbsp;    private final NotificationRuleProcessor notificationRuleProcessor;
&nbsp;    private final EntityLimitsCache entityLimitsCache;
&nbsp;
&nbsp;    protected TbQueueRequestTemplate&lt;TbProtoQueueMsg&lt;TransportApiRequestMsg&gt;, TbProtoQueueMsg&lt;TransportApiResponseMsg&gt;&gt; transportApiRequestTemplate;
&nbsp;    protected TbQueueProducer&lt;TbProtoQueueMsg&lt;ToRuleEngineMsg&gt;&gt; ruleEngineMsgProducer;
&nbsp;    protected TbQueueProducer&lt;TbProtoQueueMsg&lt;ToCoreMsg&gt;&gt; tbCoreMsgProducer;
&nbsp;    protected QueueConsumerManager&lt;TbProtoQueueMsg&lt;ToTransportMsg&gt;&gt; transportNotificationsConsumer;
&nbsp;
&nbsp;    protected MessagesStats ruleEngineProducerStats;
&nbsp;    protected MessagesStats tbCoreProducerStats;
&nbsp;    protected MessagesStats transportApiStats;
&nbsp;
&nbsp;    protected ExecutorService transportCallbackExecutor;
&nbsp;    private ExecutorService consumerExecutor;
&nbsp;
&nbsp;    private final Map&lt;String, RpcRequestMetadata&gt; toServerRpcPendingMap = new ConcurrentHashMap&lt;&gt;();
&nbsp;
&nbsp;    @PostConstruct
&nbsp;    public void init() {
<b class="nc">&nbsp;        super.init();</b>
<b class="nc">&nbsp;        this.ruleEngineProducerStats = statsFactory.createMessagesStats(StatsType.RULE_ENGINE.getName() + &quot;.producer&quot;);</b>
<b class="nc">&nbsp;        this.tbCoreProducerStats = statsFactory.createMessagesStats(StatsType.CORE.getName() + &quot;.producer&quot;);</b>
<b class="nc">&nbsp;        this.transportApiStats = statsFactory.createMessagesStats(StatsType.TRANSPORT.getName() + &quot;.producer&quot;);</b>
<b class="nc">&nbsp;        this.transportCallbackExecutor = ThingsBoardExecutors.newWorkStealingPool(20, getClass());</b>
<b class="nc">&nbsp;        this.scheduler.scheduleAtFixedRate(this::invalidateRateLimits, new Random().nextInt((int) sessionReportTimeout), sessionReportTimeout, TimeUnit.MILLISECONDS);</b>
<b class="nc">&nbsp;        transportApiRequestTemplate = queueProvider.createTransportApiRequestTemplate();</b>
<b class="nc">&nbsp;        transportApiRequestTemplate.setMessagesStats(transportApiStats);</b>
<b class="nc">&nbsp;        ruleEngineMsgProducer = producerProvider.getRuleEngineMsgProducer();</b>
<b class="nc">&nbsp;        tbCoreMsgProducer = producerProvider.getTbCoreMsgProducer();</b>
<b class="nc">&nbsp;        transportApiRequestTemplate.init();</b>
<b class="nc">&nbsp;        consumerExecutor = Executors.newSingleThreadExecutor(ThingsBoardThreadFactory.forName(&quot;transport-consumer&quot;));</b>
<b class="nc">&nbsp;        transportNotificationsConsumer = QueueConsumerManager.&lt;TbProtoQueueMsg&lt;ToTransportMsg&gt;&gt;builder()</b>
<b class="nc">&nbsp;                .name(&quot;TB Transport&quot;)</b>
<b class="nc">&nbsp;                .msgPackProcessor(this::processNotificationMsgs)</b>
<b class="nc">&nbsp;                .pollInterval(notificationsPollDuration)</b>
<b class="nc">&nbsp;                .consumerCreator(queueProvider::createTransportNotificationsConsumer)</b>
<b class="nc">&nbsp;                .consumerExecutor(consumerExecutor)</b>
<b class="nc">&nbsp;                .build();</b>
&nbsp;    }
&nbsp;
&nbsp;    @AfterStartUp(order = AfterStartUp.TRANSPORT_SERVICE)
&nbsp;    public void start() {
<b class="nc">&nbsp;        TopicPartitionInfo tpi = topicService.getNotificationsTopic(ServiceType.TB_TRANSPORT, serviceInfoProvider.getServiceId());</b>
<b class="nc">&nbsp;        transportNotificationsConsumer.subscribe(Set.of(tpi));</b>
<b class="nc">&nbsp;        transportNotificationsConsumer.launch();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void processNotificationMsgs(List&lt;TbProtoQueueMsg&lt;ToTransportMsg&gt;&gt; msgs, TbQueueConsumer&lt;TbProtoQueueMsg&lt;ToTransportMsg&gt;&gt; consumer) {
<b class="nc">&nbsp;        msgs.forEach(msg -&gt; {</b>
&nbsp;            try {
<b class="nc">&nbsp;                processToTransportMsg(msg.getValue());</b>
&nbsp;            } catch (Throwable e) {
<b class="nc">&nbsp;                log.warn(&quot;Failed to process the notification.&quot;, e);</b>
&nbsp;            }
&nbsp;        });
<b class="nc">&nbsp;        consumer.commit();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void invalidateRateLimits() {
<b class="nc">&nbsp;        rateLimitService.invalidateRateLimitsIpTable(sessionInactivityTimeout);</b>
&nbsp;    }
&nbsp;
&nbsp;    @PreDestroy
&nbsp;    public void destroy() {
<b class="nc">&nbsp;        if (transportNotificationsConsumer != null) {</b>
<b class="nc">&nbsp;            transportNotificationsConsumer.stop();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (transportCallbackExecutor != null) {</b>
<b class="nc">&nbsp;            transportCallbackExecutor.shutdownNow();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (consumerExecutor != null) {</b>
<b class="nc">&nbsp;            consumerExecutor.shutdownNow();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (transportApiRequestTemplate != null) {</b>
<b class="nc">&nbsp;            transportApiRequestTemplate.stop();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public SessionMetaData registerAsyncSession(TransportProtos.SessionInfoProto sessionInfo, SessionMsgListener listener) {
<b class="nc">&nbsp;        return sessions.computeIfAbsent(toSessionId(sessionInfo), (x) -&gt; new SessionMetaData(sessionInfo, TransportProtos.SessionType.ASYNC, listener));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public TransportProtos.GetEntityProfileResponseMsg getEntityProfile(TransportProtos.GetEntityProfileRequestMsg msg) {
<b class="nc">&nbsp;        TbProtoQueueMsg&lt;TransportApiRequestMsg&gt; protoMsg =</b>
<b class="nc">&nbsp;                new TbProtoQueueMsg&lt;&gt;(UUID.randomUUID(), TransportApiRequestMsg.newBuilder().setEntityProfileRequestMsg(msg).build());</b>
&nbsp;        try {
<b class="nc">&nbsp;            TbProtoQueueMsg&lt;TransportApiResponseMsg&gt; response = transportApiRequestTemplate.send(protoMsg).get();</b>
<b class="nc">&nbsp;            return response.getValue().getEntityProfileResponseMsg();</b>
&nbsp;        } catch (InterruptedException | ExecutionException e) {
<b class="nc">&nbsp;            throw new RuntimeException(e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public List&lt;TransportProtos.GetQueueRoutingInfoResponseMsg&gt; getQueueRoutingInfo(TransportProtos.GetAllQueueRoutingInfoRequestMsg msg) {
<b class="nc">&nbsp;        TbProtoQueueMsg&lt;TransportApiRequestMsg&gt; protoMsg =</b>
<b class="nc">&nbsp;                new TbProtoQueueMsg&lt;&gt;(UUID.randomUUID(), TransportApiRequestMsg.newBuilder().setGetAllQueueRoutingInfoRequestMsg(msg).build());</b>
&nbsp;        try {
<b class="nc">&nbsp;            TbProtoQueueMsg&lt;TransportApiResponseMsg&gt; response = transportApiRequestTemplate.send(protoMsg).get();</b>
<b class="nc">&nbsp;            return response.getValue().getGetQueueRoutingInfoResponseMsgsList();</b>
&nbsp;        } catch (InterruptedException | ExecutionException e) {
<b class="nc">&nbsp;            throw new RuntimeException(e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public TransportProtos.GetResourceResponseMsg getResource(TransportProtos.GetResourceRequestMsg msg) {
<b class="nc">&nbsp;        TbProtoQueueMsg&lt;TransportApiRequestMsg&gt; protoMsg =</b>
<b class="nc">&nbsp;                new TbProtoQueueMsg&lt;&gt;(UUID.randomUUID(), TransportApiRequestMsg.newBuilder().setResourceRequestMsg(msg).build());</b>
&nbsp;        try {
<b class="nc">&nbsp;            TbProtoQueueMsg&lt;TransportApiResponseMsg&gt; response = transportApiRequestTemplate.send(protoMsg).get();</b>
<b class="nc">&nbsp;            return response.getValue().getResourceResponseMsg();</b>
&nbsp;        } catch (InterruptedException | ExecutionException e) {
<b class="nc">&nbsp;            throw new RuntimeException(e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public TransportProtos.GetSnmpDevicesResponseMsg getSnmpDevicesIds(TransportProtos.GetSnmpDevicesRequestMsg requestMsg) {
<b class="nc">&nbsp;        TbProtoQueueMsg&lt;TransportApiRequestMsg&gt; protoMsg = new TbProtoQueueMsg&lt;&gt;(</b>
<b class="nc">&nbsp;                UUID.randomUUID(), TransportApiRequestMsg.newBuilder()</b>
<b class="nc">&nbsp;                .setSnmpDevicesRequestMsg(requestMsg)</b>
<b class="nc">&nbsp;                .build()</b>
&nbsp;        );
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            TbProtoQueueMsg&lt;TransportApiResponseMsg&gt; response = transportApiRequestTemplate.send(protoMsg).get();</b>
<b class="nc">&nbsp;            return response.getValue().getSnmpDevicesResponseMsg();</b>
&nbsp;        } catch (InterruptedException | ExecutionException e) {
<b class="nc">&nbsp;            throw new RuntimeException(e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public TransportProtos.GetDeviceResponseMsg getDevice(TransportProtos.GetDeviceRequestMsg requestMsg) {
<b class="nc">&nbsp;        TbProtoQueueMsg&lt;TransportApiRequestMsg&gt; protoMsg = new TbProtoQueueMsg&lt;&gt;(</b>
<b class="nc">&nbsp;                UUID.randomUUID(), TransportApiRequestMsg.newBuilder()</b>
<b class="nc">&nbsp;                .setDeviceRequestMsg(requestMsg)</b>
<b class="nc">&nbsp;                .build()</b>
&nbsp;        );
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            TransportApiResponseMsg response = transportApiRequestTemplate.send(protoMsg).get().getValue();</b>
<b class="nc">&nbsp;            if (response.hasDeviceResponseMsg()) {</b>
<b class="nc">&nbsp;                return response.getDeviceResponseMsg();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;        } catch (InterruptedException | ExecutionException e) {
<b class="nc">&nbsp;            throw new RuntimeException(e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public TransportProtos.GetDeviceCredentialsResponseMsg getDeviceCredentials(TransportProtos.GetDeviceCredentialsRequestMsg requestMsg) {
<b class="nc">&nbsp;        TbProtoQueueMsg&lt;TransportApiRequestMsg&gt; protoMsg = new TbProtoQueueMsg&lt;&gt;(</b>
<b class="nc">&nbsp;                UUID.randomUUID(), TransportApiRequestMsg.newBuilder()</b>
<b class="nc">&nbsp;                .setDeviceCredentialsRequestMsg(requestMsg)</b>
<b class="nc">&nbsp;                .build()</b>
&nbsp;        );
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            TbProtoQueueMsg&lt;TransportApiResponseMsg&gt; response = transportApiRequestTemplate.send(protoMsg).get();</b>
<b class="nc">&nbsp;            return response.getValue().getDeviceCredentialsResponseMsg();</b>
&nbsp;        } catch (InterruptedException | ExecutionException e) {
<b class="nc">&nbsp;            throw new RuntimeException(e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void process(DeviceTransportType transportType, TransportProtos.ValidateDeviceTokenRequestMsg msg,
&nbsp;                        TransportServiceCallback&lt;ValidateDeviceCredentialsResponse&gt; callback) {
<b class="nc">&nbsp;        log.trace(&quot;Processing msg: {}&quot;, msg);</b>
<b class="nc">&nbsp;        TbProtoQueueMsg&lt;TransportApiRequestMsg&gt; protoMsg = new TbProtoQueueMsg&lt;&gt;(UUID.randomUUID(),</b>
<b class="nc">&nbsp;                TransportApiRequestMsg.newBuilder().setValidateTokenRequestMsg(msg).build());</b>
<b class="nc">&nbsp;        doProcess(transportType, protoMsg, callback);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void process(DeviceTransportType transportType, TransportProtos.ValidateBasicMqttCredRequestMsg msg,
&nbsp;                        TransportServiceCallback&lt;ValidateDeviceCredentialsResponse&gt; callback) {
<b class="nc">&nbsp;        log.trace(&quot;Processing msg: {}&quot;, msg);</b>
<b class="nc">&nbsp;        TbProtoQueueMsg&lt;TransportApiRequestMsg&gt; protoMsg = new TbProtoQueueMsg&lt;&gt;(UUID.randomUUID(),</b>
<b class="nc">&nbsp;                TransportApiRequestMsg.newBuilder().setValidateBasicMqttCredRequestMsg(msg).build());</b>
<b class="nc">&nbsp;        doProcess(transportType, protoMsg, callback);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void process(TransportProtos.ValidateDeviceLwM2MCredentialsRequestMsg requestMsg, TransportServiceCallback&lt;ValidateDeviceCredentialsResponse&gt; callback) {
<b class="nc">&nbsp;        log.trace(&quot;Processing msg: {}&quot;, requestMsg);</b>
<b class="nc">&nbsp;        TbProtoQueueMsg&lt;TransportApiRequestMsg&gt; protoMsg = new TbProtoQueueMsg&lt;&gt;(UUID.randomUUID(), TransportApiRequestMsg.newBuilder().setValidateDeviceLwM2MCredentialsRequestMsg(requestMsg).build());</b>
<b class="nc">&nbsp;        ListenableFuture&lt;ValidateDeviceCredentialsResponse&gt; response = Futures.transform(transportApiRequestTemplate.send(protoMsg), tmp -&gt; {</b>
<b class="nc">&nbsp;            TransportProtos.ValidateDeviceCredentialsResponseMsg msg = tmp.getValue().getValidateCredResponseMsg();</b>
<b class="nc">&nbsp;            ValidateDeviceCredentialsResponse.ValidateDeviceCredentialsResponseBuilder result = ValidateDeviceCredentialsResponse.builder();</b>
<b class="nc">&nbsp;            if (msg.hasDeviceInfo()) {</b>
<b class="nc">&nbsp;                result.credentials(msg.getCredentialsBody());</b>
<b class="nc">&nbsp;                TransportDeviceInfo tdi = getTransportDeviceInfo(msg.getDeviceInfo());</b>
<b class="nc">&nbsp;                result.deviceInfo(tdi);</b>
<b class="nc">&nbsp;                if (msg.hasDeviceProfile()) {</b>
<b class="nc">&nbsp;                    DeviceProfile profile = deviceProfileCache.getOrCreate(tdi.getDeviceProfileId(), msg.getDeviceProfile());</b>
<b class="nc">&nbsp;                    result.deviceProfile(profile);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return result.build();</b>
<b class="nc">&nbsp;        }, MoreExecutors.directExecutor());</b>
<b class="nc">&nbsp;        AsyncCallbackTemplate.withCallback(response, callback::onSuccess, callback::onError, transportCallbackExecutor);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void process(DeviceTransportType transportType, TransportProtos.ValidateDeviceX509CertRequestMsg msg, TransportServiceCallback&lt;ValidateDeviceCredentialsResponse&gt; callback) {
<b class="nc">&nbsp;        log.trace(&quot;Processing msg: {}&quot;, msg);</b>
<b class="nc">&nbsp;        TbProtoQueueMsg&lt;TransportApiRequestMsg&gt; protoMsg = new TbProtoQueueMsg&lt;&gt;(UUID.randomUUID(), TransportApiRequestMsg.newBuilder().setValidateX509CertRequestMsg(msg).build());</b>
<b class="nc">&nbsp;        doProcess(transportType, protoMsg, callback);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void process(DeviceTransportType transportType, TransportProtos.ValidateOrCreateDeviceX509CertRequestMsg msg, TransportServiceCallback&lt;ValidateDeviceCredentialsResponse&gt; callback) {
<b class="nc">&nbsp;        log.trace(&quot;Processing msg: {}&quot;, msg);</b>
<b class="nc">&nbsp;        TbProtoQueueMsg&lt;TransportApiRequestMsg&gt; protoMsg = new TbProtoQueueMsg&lt;&gt;(UUID.randomUUID(), TransportApiRequestMsg.newBuilder().setValidateOrCreateX509CertRequestMsg(msg).build());</b>
<b class="nc">&nbsp;        doProcess(transportType, protoMsg, callback);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void doProcess(DeviceTransportType transportType, TbProtoQueueMsg&lt;TransportApiRequestMsg&gt; protoMsg,
&nbsp;                           TransportServiceCallback&lt;ValidateDeviceCredentialsResponse&gt; callback) {
<b class="nc">&nbsp;        ListenableFuture&lt;ValidateDeviceCredentialsResponse&gt; response = Futures.transform(transportApiRequestTemplate.send(protoMsg), tmp -&gt; {</b>
<b class="nc">&nbsp;            TransportProtos.ValidateDeviceCredentialsResponseMsg msg = tmp.getValue().getValidateCredResponseMsg();</b>
<b class="nc">&nbsp;            ValidateDeviceCredentialsResponse.ValidateDeviceCredentialsResponseBuilder result = ValidateDeviceCredentialsResponse.builder();</b>
<b class="nc">&nbsp;            if (msg.hasDeviceInfo()) {</b>
<b class="nc">&nbsp;                result.credentials(msg.getCredentialsBody());</b>
<b class="nc">&nbsp;                TransportDeviceInfo tdi = getTransportDeviceInfo(msg.getDeviceInfo());</b>
<b class="nc">&nbsp;                result.deviceInfo(tdi);</b>
<b class="nc">&nbsp;                if (msg.hasDeviceProfile()) {</b>
<b class="nc">&nbsp;                    DeviceProfile profile = deviceProfileCache.getOrCreate(tdi.getDeviceProfileId(), msg.getDeviceProfile());</b>
<b class="nc">&nbsp;                    if (transportType != DeviceTransportType.DEFAULT</b>
<b class="nc">&nbsp;                            &amp;&amp; profile != null &amp;&amp; profile.getTransportType() != DeviceTransportType.DEFAULT &amp;&amp; profile.getTransportType() != transportType) {</b>
<b class="nc">&nbsp;                        log.debug(&quot;[{}] Device profile [{}] has different transport type: {}, expected: {}&quot;, tdi.getDeviceId(), tdi.getDeviceProfileId(), profile.getTransportType(), transportType);</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Device profile has different transport type: &quot; + profile.getTransportType() + &quot;. Expected: &quot; + transportType);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    result.deviceProfile(profile);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return result.build();</b>
<b class="nc">&nbsp;        }, MoreExecutors.directExecutor());</b>
<b class="nc">&nbsp;        AsyncCallbackTemplate.withCallback(response, callback::onSuccess, callback::onError, transportCallbackExecutor);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void process(TenantId tenantId, TransportProtos.GetOrCreateDeviceFromGatewayRequestMsg requestMsg, TransportServiceCallback&lt;GetOrCreateDeviceFromGatewayResponse&gt; callback) {
<b class="nc">&nbsp;        log.trace(&quot;Processing msg: {}&quot;, requestMsg);</b>
<b class="nc">&nbsp;        DeviceId gatewayId = new DeviceId(new UUID(requestMsg.getGatewayIdMSB(), requestMsg.getGatewayIdLSB()));</b>
<b class="nc">&nbsp;        if (!checkLimits(tenantId, gatewayId, null, requestMsg.getDeviceName(), requestMsg, callback, 0, false)) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        TbProtoQueueMsg&lt;TransportApiRequestMsg&gt; protoMsg = new TbProtoQueueMsg&lt;&gt;(UUID.randomUUID(), TransportApiRequestMsg.newBuilder().setGetOrCreateDeviceRequestMsg(requestMsg).build());</b>
<b class="nc">&nbsp;        var key = new EntityLimitKey(tenantId, StringUtils.truncate(requestMsg.getDeviceName(), 256));</b>
<b class="nc">&nbsp;        if (entityLimitsCache.get(key)) {</b>
<b class="nc">&nbsp;            transportCallbackExecutor.submit(() -&gt; callback.onError(new RuntimeException(DataConstants.MAXIMUM_NUMBER_OF_DEVICES_REACHED)));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            ListenableFuture&lt;GetOrCreateDeviceFromGatewayResponse&gt; response = Futures.transform(transportApiRequestTemplate.send(protoMsg), tmp -&gt; {</b>
<b class="nc">&nbsp;                TransportProtos.GetOrCreateDeviceFromGatewayResponseMsg msg = tmp.getValue().getGetOrCreateDeviceResponseMsg();</b>
<b class="nc">&nbsp;                GetOrCreateDeviceFromGatewayResponse.GetOrCreateDeviceFromGatewayResponseBuilder result = GetOrCreateDeviceFromGatewayResponse.builder();</b>
<b class="nc">&nbsp;                if (msg.hasDeviceInfo()) {</b>
<b class="nc">&nbsp;                    TransportDeviceInfo tdi = getTransportDeviceInfo(msg.getDeviceInfo());</b>
<b class="nc">&nbsp;                    result.deviceInfo(tdi);</b>
<b class="nc">&nbsp;                    if (msg.hasDeviceProfile()) {</b>
<b class="nc">&nbsp;                        result.deviceProfile(deviceProfileCache.getOrCreate(tdi.getDeviceProfileId(), msg.getDeviceProfile()));</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (TransportProtos.TransportApiRequestErrorCode.ENTITY_LIMIT.equals(msg.getError())) {</b>
<b class="nc">&nbsp;                    entityLimitsCache.put(key, true);</b>
<b class="nc">&nbsp;                    throw new RuntimeException(DataConstants.MAXIMUM_NUMBER_OF_DEVICES_REACHED);</b>
&nbsp;                }
<b class="nc">&nbsp;                return result.build();</b>
<b class="nc">&nbsp;            }, MoreExecutors.directExecutor());</b>
<b class="nc">&nbsp;            AsyncCallbackTemplate.withCallback(response, callback::onSuccess, callback::onError, transportCallbackExecutor);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void process(TransportProtos.LwM2MRequestMsg msg, TransportServiceCallback&lt;TransportProtos.LwM2MResponseMsg&gt; callback) {
<b class="nc">&nbsp;        log.trace(&quot;Processing msg: {}&quot;, msg);</b>
<b class="nc">&nbsp;        TbProtoQueueMsg&lt;TransportApiRequestMsg&gt; protoMsg = new TbProtoQueueMsg&lt;&gt;(UUID.randomUUID(),</b>
<b class="nc">&nbsp;                TransportApiRequestMsg.newBuilder().setLwM2MRequestMsg(msg).build());</b>
<b class="nc">&nbsp;        AsyncCallbackTemplate.withCallback(transportApiRequestTemplate.send(protoMsg),</b>
<b class="nc">&nbsp;                response -&gt; callback.onSuccess(response.getValue().getLwM2MResponseMsg()), callback::onError, transportCallbackExecutor);</b>
&nbsp;    }
&nbsp;
&nbsp;    private TransportDeviceInfo getTransportDeviceInfo(TransportProtos.DeviceInfoProto di) {
<b class="nc">&nbsp;        TransportDeviceInfo tdi = new TransportDeviceInfo();</b>
<b class="nc">&nbsp;        tdi.setTenantId(TenantId.fromUUID(new UUID(di.getTenantIdMSB(), di.getTenantIdLSB())));</b>
<b class="nc">&nbsp;        tdi.setCustomerId(new CustomerId(new UUID(di.getCustomerIdMSB(), di.getCustomerIdLSB())));</b>
<b class="nc">&nbsp;        tdi.setDeviceId(new DeviceId(new UUID(di.getDeviceIdMSB(), di.getDeviceIdLSB())));</b>
<b class="nc">&nbsp;        tdi.setDeviceProfileId(new DeviceProfileId(new UUID(di.getDeviceProfileIdMSB(), di.getDeviceProfileIdLSB())));</b>
<b class="nc">&nbsp;        tdi.setAdditionalInfo(di.getAdditionalInfo());</b>
<b class="nc">&nbsp;        tdi.setDeviceName(di.getDeviceName());</b>
<b class="nc">&nbsp;        tdi.setDeviceType(di.getDeviceType());</b>
<b class="nc">&nbsp;        tdi.setGateway(di.getIsGateway());</b>
<b class="nc">&nbsp;        if (StringUtils.isNotEmpty(di.getPowerMode())) {</b>
<b class="nc">&nbsp;            tdi.setPowerMode(PowerMode.valueOf(di.getPowerMode()));</b>
<b class="nc">&nbsp;            tdi.setEdrxCycle(di.getEdrxCycle());</b>
<b class="nc">&nbsp;            tdi.setPsmActivityTimer(di.getPsmActivityTimer());</b>
<b class="nc">&nbsp;            tdi.setPagingTransmissionWindow(di.getPagingTransmissionWindow());</b>
&nbsp;        }
<b class="nc">&nbsp;        return tdi;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void process(ProvisionDeviceRequestMsg requestMsg, TransportServiceCallback&lt;ProvisionDeviceResponseMsg&gt; callback) {
<b class="nc">&nbsp;        log.trace(&quot;Processing msg: {}&quot;, requestMsg);</b>
<b class="nc">&nbsp;        TbProtoQueueMsg&lt;TransportApiRequestMsg&gt; protoMsg = new TbProtoQueueMsg&lt;&gt;(UUID.randomUUID(), TransportApiRequestMsg.newBuilder().setProvisionDeviceRequestMsg(requestMsg).build());</b>
<b class="nc">&nbsp;        ListenableFuture&lt;ProvisionDeviceResponseMsg&gt; response = Futures.transform(transportApiRequestTemplate.send(protoMsg), tmp -&gt;</b>
<b class="nc">&nbsp;                        tmp.getValue().getProvisionDeviceResponseMsg()</b>
<b class="nc">&nbsp;                , MoreExecutors.directExecutor());</b>
<b class="nc">&nbsp;        AsyncCallbackTemplate.withCallback(response, callback::onSuccess, callback::onError, transportCallbackExecutor);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void process(TransportProtos.SessionInfoProto sessionInfo, TransportProtos.SubscriptionInfoProto msg, TransportServiceCallback&lt;Void&gt; callback) {
<b class="nc">&nbsp;        if (log.isTraceEnabled()) {</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}] Processing msg: {}&quot;, toSessionId(sessionInfo), msg);</b>
&nbsp;        }
<b class="nc">&nbsp;        sendToDeviceActor(sessionInfo, TransportToDeviceActorMsg.newBuilder().setSessionInfo(sessionInfo)</b>
<b class="nc">&nbsp;                .setSubscriptionInfo(msg).build(), callback);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void process(TransportProtos.SessionInfoProto sessionInfo, TransportProtos.SessionEventMsg msg, TransportServiceCallback&lt;Void&gt; callback) {
<b class="nc">&nbsp;        if (checkLimits(sessionInfo, msg, callback)) {</b>
<b class="nc">&nbsp;            recordActivityInternal(sessionInfo);</b>
<b class="nc">&nbsp;            sendToDeviceActor(sessionInfo, TransportToDeviceActorMsg.newBuilder().setSessionInfo(sessionInfo)</b>
<b class="nc">&nbsp;                    .setSessionEvent(msg).build(), callback);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void process(TransportToDeviceActorMsg msg, TransportServiceCallback&lt;Void&gt; callback) {
<b class="nc">&nbsp;        TransportProtos.SessionInfoProto sessionInfo = msg.getSessionInfo();</b>
<b class="nc">&nbsp;        if (checkLimits(sessionInfo, msg, callback)) {</b>
<b class="nc">&nbsp;            SessionMetaData sessionMetaData = sessions.get(toSessionId(sessionInfo));</b>
<b class="nc">&nbsp;            if (sessionMetaData != null) {</b>
<b class="nc">&nbsp;                if (msg.hasSubscribeToAttributes()) {</b>
<b class="nc">&nbsp;                    sessionMetaData.setSubscribedToAttributes(true);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (msg.hasSubscribeToRPC()) {</b>
<b class="nc">&nbsp;                    sessionMetaData.setSubscribedToRPC(true);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            recordActivityInternal(sessionInfo);</b>
<b class="nc">&nbsp;            sendToDeviceActor(sessionInfo, msg, callback);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void process(TransportProtos.SessionInfoProto sessionInfo, TransportProtos.PostTelemetryMsg msg, TransportServiceCallback&lt;Void&gt; callback) {
<b class="nc">&nbsp;        process(sessionInfo, msg, null, callback);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void process(TransportProtos.SessionInfoProto sessionInfo, TransportProtos.PostTelemetryMsg msg, TbMsgMetaData md, TransportServiceCallback&lt;Void&gt; callback) {
<b class="nc">&nbsp;        int dataPoints = 0;</b>
<b class="nc">&nbsp;        for (TransportProtos.TsKvListProto tsKv : msg.getTsKvListList()) {</b>
<b class="nc">&nbsp;            dataPoints += tsKv.getKvCount();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (checkLimits(sessionInfo, msg, callback, dataPoints)) {</b>
<b class="nc">&nbsp;            recordActivityInternal(sessionInfo);</b>
<b class="nc">&nbsp;            TenantId tenantId = getTenantId(sessionInfo);</b>
<b class="nc">&nbsp;            DeviceId deviceId = new DeviceId(new UUID(sessionInfo.getDeviceIdMSB(), sessionInfo.getDeviceIdLSB()));</b>
<b class="nc">&nbsp;            CustomerId customerId = getCustomerId(sessionInfo);</b>
<b class="nc">&nbsp;            MsgPackCallback packCallback = new MsgPackCallback(msg.getTsKvListCount(), new ApiStatsProxyCallback&lt;&gt;(tenantId, customerId, dataPoints, callback));</b>
<b class="nc">&nbsp;            for (TransportProtos.TsKvListProto tsKv : msg.getTsKvListList()) {</b>
<b class="nc">&nbsp;                TbMsgMetaData metaData = md != null ? md.copy() : new TbMsgMetaData();</b>
<b class="nc">&nbsp;                metaData.putValue(&quot;deviceName&quot;, sessionInfo.getDeviceName());</b>
<b class="nc">&nbsp;                metaData.putValue(&quot;deviceType&quot;, sessionInfo.getDeviceType());</b>
<b class="nc">&nbsp;                metaData.putValue(&quot;ts&quot;, tsKv.getTs() + &quot;&quot;);</b>
<b class="nc">&nbsp;                JsonObject json = JsonUtils.getJsonObject(tsKv.getKvList());</b>
<b class="nc">&nbsp;                sendToRuleEngine(tenantId, deviceId, customerId, sessionInfo, json, metaData, TbMsgType.POST_TELEMETRY_REQUEST, packCallback);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void process(TransportProtos.SessionInfoProto sessionInfo, TransportProtos.PostAttributeMsg msg, TransportServiceCallback&lt;Void&gt; callback) {
<b class="nc">&nbsp;        process(sessionInfo, msg, null, callback);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void process(TransportProtos.SessionInfoProto sessionInfo, TransportProtos.PostAttributeMsg msg, TbMsgMetaData md, TransportServiceCallback&lt;Void&gt; callback) {
<b class="nc">&nbsp;        if (checkLimits(sessionInfo, msg, callback, msg.getKvCount())) {</b>
<b class="nc">&nbsp;            recordActivityInternal(sessionInfo);</b>
<b class="nc">&nbsp;            TenantId tenantId = getTenantId(sessionInfo);</b>
<b class="nc">&nbsp;            DeviceId deviceId = new DeviceId(new UUID(sessionInfo.getDeviceIdMSB(), sessionInfo.getDeviceIdLSB()));</b>
<b class="nc">&nbsp;            JsonObject json = JsonUtils.getJsonObject(msg.getKvList());</b>
<b class="nc">&nbsp;            TbMsgMetaData metaData = md != null ? md.copy() : new TbMsgMetaData();</b>
<b class="nc">&nbsp;            metaData.putValue(&quot;deviceName&quot;, sessionInfo.getDeviceName());</b>
<b class="nc">&nbsp;            metaData.putValue(&quot;deviceType&quot;, sessionInfo.getDeviceType());</b>
<b class="nc">&nbsp;            if (msg.getShared()) {</b>
<b class="nc">&nbsp;                metaData.putValue(DataConstants.SCOPE, DataConstants.SHARED_SCOPE);</b>
&nbsp;            }
<b class="nc">&nbsp;            metaData.putValue(DataConstants.NOTIFY_DEVICE_METADATA_KEY, &quot;false&quot;);</b>
<b class="nc">&nbsp;            CustomerId customerId = getCustomerId(sessionInfo);</b>
<b class="nc">&nbsp;            sendToRuleEngine(tenantId, deviceId, customerId, sessionInfo, json, metaData, TbMsgType.POST_ATTRIBUTES_REQUEST,</b>
<b class="nc">&nbsp;                    new TransportTbQueueCallback(new ApiStatsProxyCallback&lt;&gt;(tenantId, customerId, msg.getKvList().size(), callback)));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void process(TransportProtos.SessionInfoProto sessionInfo, TransportProtos.GetAttributeRequestMsg msg, TransportServiceCallback&lt;Void&gt; callback) {
<b class="nc">&nbsp;        if (checkLimits(sessionInfo, msg, callback)) {</b>
<b class="nc">&nbsp;            recordActivityInternal(sessionInfo);</b>
<b class="nc">&nbsp;            sendToDeviceActor(sessionInfo, TransportToDeviceActorMsg.newBuilder().setSessionInfo(sessionInfo)</b>
<b class="nc">&nbsp;                    .setGetAttributes(msg).build(), new ApiStatsProxyCallback&lt;&gt;(getTenantId(sessionInfo), getCustomerId(sessionInfo), 1, callback));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void process(TransportProtos.SessionInfoProto sessionInfo, TransportProtos.SubscribeToAttributeUpdatesMsg msg, TransportServiceCallback&lt;Void&gt; callback) {
<b class="nc">&nbsp;        if (checkLimits(sessionInfo, msg, callback)) {</b>
<b class="nc">&nbsp;            SessionMetaData sessionMetaData = sessions.get(toSessionId(sessionInfo));</b>
<b class="nc">&nbsp;            if (sessionMetaData != null) {</b>
<b class="nc">&nbsp;                sessionMetaData.setSubscribedToAttributes(!msg.getUnsubscribe());</b>
&nbsp;            }
<b class="nc">&nbsp;            recordActivityInternal(sessionInfo);</b>
<b class="nc">&nbsp;            sendToDeviceActor(sessionInfo, TransportToDeviceActorMsg.newBuilder().setSessionInfo(sessionInfo).setSubscribeToAttributes(msg).build(),</b>
<b class="nc">&nbsp;                    new ApiStatsProxyCallback&lt;&gt;(getTenantId(sessionInfo), getCustomerId(sessionInfo), 1, callback));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void process(TransportProtos.SessionInfoProto sessionInfo, TransportProtos.SubscribeToRPCMsg msg, TransportServiceCallback&lt;Void&gt; callback) {
<b class="nc">&nbsp;        if (checkLimits(sessionInfo, msg, callback)) {</b>
<b class="nc">&nbsp;            SessionMetaData sessionMetaData = sessions.get(toSessionId(sessionInfo));</b>
<b class="nc">&nbsp;            if (sessionMetaData != null) {</b>
<b class="nc">&nbsp;                sessionMetaData.setSubscribedToRPC(!msg.getUnsubscribe());</b>
&nbsp;            }
<b class="nc">&nbsp;            recordActivityInternal(sessionInfo);</b>
<b class="nc">&nbsp;            sendToDeviceActor(sessionInfo, TransportToDeviceActorMsg.newBuilder().setSessionInfo(sessionInfo).setSubscribeToRPC(msg).build(),</b>
<b class="nc">&nbsp;                    new ApiStatsProxyCallback&lt;&gt;(getTenantId(sessionInfo), getCustomerId(sessionInfo), 1, callback));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void process(TransportProtos.SessionInfoProto sessionInfo, TransportProtos.ToDeviceRpcResponseMsg msg, TransportServiceCallback&lt;Void&gt; callback) {
<b class="nc">&nbsp;        if (checkLimits(sessionInfo, msg, callback)) {</b>
<b class="nc">&nbsp;            recordActivityInternal(sessionInfo);</b>
<b class="nc">&nbsp;            sendToDeviceActor(sessionInfo, TransportToDeviceActorMsg.newBuilder().setSessionInfo(sessionInfo).setToDeviceRPCCallResponse(msg).build(),</b>
<b class="nc">&nbsp;                    new ApiStatsProxyCallback&lt;&gt;(getTenantId(sessionInfo), getCustomerId(sessionInfo), 1, callback));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void notifyAboutUplink(TransportProtos.SessionInfoProto sessionInfo, TransportProtos.UplinkNotificationMsg msg, TransportServiceCallback&lt;Void&gt; callback) {
<b class="nc">&nbsp;        if (checkLimits(sessionInfo, msg, callback)) {</b>
<b class="nc">&nbsp;            recordActivityInternal(sessionInfo);</b>
<b class="nc">&nbsp;            sendToDeviceActor(sessionInfo, TransportToDeviceActorMsg.newBuilder().setSessionInfo(sessionInfo).setUplinkNotificationMsg(msg).build(), callback);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void process(TransportProtos.SessionInfoProto sessionInfo, TransportProtos.ToDeviceRpcRequestMsg msg, RpcStatus rpcStatus, TransportServiceCallback&lt;Void&gt; callback) {
<b class="nc">&nbsp;        process(sessionInfo, msg, rpcStatus, false, callback);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void process(TransportProtos.SessionInfoProto sessionInfo, TransportProtos.ToDeviceRpcRequestMsg msg, RpcStatus rpcStatus, boolean reportActivity, TransportServiceCallback&lt;Void&gt; callback) {
<b class="nc">&nbsp;        TransportProtos.ToDeviceRpcResponseStatusMsg responseMsg = TransportProtos.ToDeviceRpcResponseStatusMsg.newBuilder()</b>
<b class="nc">&nbsp;                .setRequestId(msg.getRequestId())</b>
<b class="nc">&nbsp;                .setRequestIdLSB(msg.getRequestIdLSB())</b>
<b class="nc">&nbsp;                .setRequestIdMSB(msg.getRequestIdMSB())</b>
<b class="nc">&nbsp;                .setStatus(rpcStatus.name())</b>
<b class="nc">&nbsp;                .build();</b>
&nbsp;
<b class="nc">&nbsp;        if (checkLimits(sessionInfo, responseMsg, callback)) {</b>
<b class="nc">&nbsp;            if (reportActivity) {</b>
<b class="nc">&nbsp;                recordActivityInternal(sessionInfo);</b>
&nbsp;            }
<b class="nc">&nbsp;            sendToDeviceActor(sessionInfo, TransportToDeviceActorMsg.newBuilder().setSessionInfo(sessionInfo).setRpcResponseStatusMsg(responseMsg).build(),</b>
<b class="nc">&nbsp;                    new ApiStatsProxyCallback&lt;&gt;(getTenantId(sessionInfo), getCustomerId(sessionInfo), 1, TransportServiceCallback.EMPTY));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void processTimeout(String requestId) {
<b class="nc">&nbsp;        RpcRequestMetadata data = toServerRpcPendingMap.remove(requestId);</b>
<b class="nc">&nbsp;        if (data != null) {</b>
<b class="nc">&nbsp;            SessionMetaData md = sessions.get(data.getSessionId());</b>
<b class="nc">&nbsp;            if (md != null) {</b>
<b class="nc">&nbsp;                SessionMsgListener listener = md.getListener();</b>
<b class="nc">&nbsp;                transportCallbackExecutor.submit(() -&gt; {</b>
&nbsp;                    TransportProtos.ToServerRpcResponseMsg responseMsg =
<b class="nc">&nbsp;                            TransportProtos.ToServerRpcResponseMsg.newBuilder()</b>
<b class="nc">&nbsp;                                    .setRequestId(data.getRequestId())</b>
<b class="nc">&nbsp;                                    .setError(&quot;timeout&quot;).build();</b>
<b class="nc">&nbsp;                    listener.onToServerRpcResponse(responseMsg);</b>
&nbsp;                });
<b class="nc">&nbsp;                if (md.getSessionType() == TransportProtos.SessionType.SYNC) {</b>
<b class="nc">&nbsp;                    deregisterSession(md.getSessionInfo());</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                log.debug(&quot;[{}] Missing session.&quot;, data.getSessionId());</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void process(TransportProtos.SessionInfoProto sessionInfo, TransportProtos.ToServerRpcRequestMsg msg, TransportServiceCallback&lt;Void&gt; callback) {
<b class="nc">&nbsp;        if (checkLimits(sessionInfo, msg, callback)) {</b>
<b class="nc">&nbsp;            recordActivityInternal(sessionInfo);</b>
<b class="nc">&nbsp;            UUID sessionId = toSessionId(sessionInfo);</b>
<b class="nc">&nbsp;            TenantId tenantId = getTenantId(sessionInfo);</b>
<b class="nc">&nbsp;            DeviceId deviceId = getDeviceId(sessionInfo);</b>
<b class="nc">&nbsp;            JsonObject json = new JsonObject();</b>
<b class="nc">&nbsp;            json.addProperty(&quot;method&quot;, msg.getMethodName());</b>
<b class="nc">&nbsp;            json.add(&quot;params&quot;, JsonUtils.parse(msg.getParams()));</b>
&nbsp;
<b class="nc">&nbsp;            TbMsgMetaData metaData = new TbMsgMetaData();</b>
<b class="nc">&nbsp;            metaData.putValue(&quot;deviceName&quot;, sessionInfo.getDeviceName());</b>
<b class="nc">&nbsp;            metaData.putValue(&quot;deviceType&quot;, sessionInfo.getDeviceType());</b>
<b class="nc">&nbsp;            metaData.putValue(&quot;requestId&quot;, Integer.toString(msg.getRequestId()));</b>
<b class="nc">&nbsp;            metaData.putValue(&quot;serviceId&quot;, serviceInfoProvider.getServiceId());</b>
<b class="nc">&nbsp;            metaData.putValue(&quot;sessionId&quot;, sessionId.toString());</b>
<b class="nc">&nbsp;            sendToRuleEngine(tenantId, deviceId, getCustomerId(sessionInfo), sessionInfo, json, metaData,</b>
&nbsp;                    TbMsgType.TO_SERVER_RPC_REQUEST, new TransportTbQueueCallback(callback));
<b class="nc">&nbsp;            String requestId = sessionId + &quot;-&quot; + msg.getRequestId();</b>
<b class="nc">&nbsp;            toServerRpcPendingMap.put(requestId, new RpcRequestMetadata(sessionId, msg.getRequestId()));</b>
<b class="nc">&nbsp;            scheduler.schedule(() -&gt; processTimeout(requestId), clientSideRpcTimeout, TimeUnit.MILLISECONDS);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void process(TransportProtos.SessionInfoProto sessionInfo, TransportProtos.ClaimDeviceMsg msg, TransportServiceCallback&lt;Void&gt; callback) {
<b class="nc">&nbsp;        if (checkLimits(sessionInfo, msg, callback)) {</b>
<b class="nc">&nbsp;            recordActivityInternal(sessionInfo);</b>
<b class="nc">&nbsp;            sendToDeviceActor(sessionInfo, TransportToDeviceActorMsg.newBuilder().setSessionInfo(sessionInfo)</b>
<b class="nc">&nbsp;                    .setClaimDevice(msg).build(), callback);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void process(TransportProtos.SessionInfoProto sessionInfo, TransportProtos.GetOtaPackageRequestMsg msg, TransportServiceCallback&lt;TransportProtos.GetOtaPackageResponseMsg&gt; callback) {
<b class="nc">&nbsp;        if (checkLimits(sessionInfo, msg, callback)) {</b>
<b class="nc">&nbsp;            TbProtoQueueMsg&lt;TransportApiRequestMsg&gt; protoMsg =</b>
<b class="nc">&nbsp;                    new TbProtoQueueMsg&lt;&gt;(UUID.randomUUID(), TransportApiRequestMsg.newBuilder().setOtaPackageRequestMsg(msg).build());</b>
&nbsp;
<b class="nc">&nbsp;            AsyncCallbackTemplate.withCallback(transportApiRequestTemplate.send(protoMsg), response -&gt; {</b>
<b class="nc">&nbsp;                callback.onSuccess(response.getValue().getOtaPackageResponseMsg());</b>
<b class="nc">&nbsp;            }, callback::onError, transportCallbackExecutor);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void recordActivity(TransportProtos.SessionInfoProto sessionInfo) {
<b class="nc">&nbsp;        recordActivityInternal(sessionInfo);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void recordActivityInternal(TransportProtos.SessionInfoProto sessionInfo) {
<b class="nc">&nbsp;        if (sessionInfo != null) {</b>
<b class="nc">&nbsp;            onActivity(toSessionId(sessionInfo), sessionInfo, getCurrentTimeMillis());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            log.warn(&quot;Session info is missing, unable to record activity&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void lifecycleEvent(TenantId tenantId, DeviceId deviceId, ComponentLifecycleEvent eventType, boolean success, Throwable error) {
<b class="nc">&nbsp;        ToCoreMsg msg = ToCoreMsg.newBuilder()</b>
<b class="nc">&nbsp;                .setLifecycleEventMsg(TransportProtos.LifecycleEventProto.newBuilder()</b>
<b class="nc">&nbsp;                        .setTenantIdMSB(tenantId.getId().getMostSignificantBits())</b>
<b class="nc">&nbsp;                        .setTenantIdLSB(tenantId.getId().getLeastSignificantBits())</b>
<b class="nc">&nbsp;                        .setEntityIdMSB(deviceId.getId().getMostSignificantBits())</b>
<b class="nc">&nbsp;                        .setEntityIdLSB(deviceId.getId().getLeastSignificantBits())</b>
<b class="nc">&nbsp;                        .setServiceId(serviceInfoProvider.getServiceId())</b>
<b class="nc">&nbsp;                        .setLcEventType(eventType.name())</b>
<b class="nc">&nbsp;                        .setSuccess(success)</b>
<b class="nc">&nbsp;                        .setError(error != null ? ExceptionUtils.getStackTrace(error) : &quot;&quot;))</b>
<b class="nc">&nbsp;                .build();</b>
&nbsp;        try {
<b class="nc">&nbsp;            sendToCore(tenantId, deviceId, msg, deviceId.getId(), TransportServiceCallback.EMPTY);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.error(&quot;[{}][{}] Failed to send lifecycle event to core&quot;, tenantId, deviceId, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void errorEvent(TenantId tenantId, DeviceId deviceId, String method, Throwable error) {
<b class="nc">&nbsp;        ToCoreMsg msg = ToCoreMsg.newBuilder()</b>
<b class="nc">&nbsp;                .setErrorEventMsg(TransportProtos.ErrorEventProto.newBuilder()</b>
<b class="nc">&nbsp;                        .setTenantIdMSB(tenantId.getId().getMostSignificantBits())</b>
<b class="nc">&nbsp;                        .setTenantIdLSB(tenantId.getId().getLeastSignificantBits())</b>
<b class="nc">&nbsp;                        .setEntityIdMSB(deviceId.getId().getMostSignificantBits())</b>
<b class="nc">&nbsp;                        .setEntityIdLSB(deviceId.getId().getLeastSignificantBits())</b>
<b class="nc">&nbsp;                        .setServiceId(serviceInfoProvider.getServiceId())</b>
<b class="nc">&nbsp;                        .setMethod(method)</b>
<b class="nc">&nbsp;                        .setError(ExceptionUtils.getRootCauseMessage(error)))</b>
<b class="nc">&nbsp;                .build();</b>
&nbsp;        try {
<b class="nc">&nbsp;            sendToCore(tenantId, deviceId, msg, deviceId.getId(), TransportServiceCallback.EMPTY);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.error(&quot;[{}][{}] Failed to send error event to core&quot;, tenantId, deviceId, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public SessionMetaData registerSyncSession(TransportProtos.SessionInfoProto sessionInfo, SessionMsgListener listener, long timeout) {
<b class="nc">&nbsp;        SessionMetaData currentSession = new SessionMetaData(sessionInfo, TransportProtos.SessionType.SYNC, listener);</b>
<b class="nc">&nbsp;        UUID sessionId = toSessionId(sessionInfo);</b>
<b class="nc">&nbsp;        sessions.putIfAbsent(sessionId, currentSession);</b>
&nbsp;
<b class="nc">&nbsp;        TransportProtos.SessionCloseNotificationProto notification = TransportProtos.SessionCloseNotificationProto.newBuilder().setMessage(&quot;session timeout!&quot;).build();</b>
&nbsp;
<b class="nc">&nbsp;        ScheduledFuture executorFuture = scheduler.schedule(() -&gt; {</b>
<b class="nc">&nbsp;            listener.onRemoteSessionCloseCommand(sessionId, notification);</b>
<b class="nc">&nbsp;            deregisterSession(sessionInfo);</b>
&nbsp;        }, timeout, TimeUnit.MILLISECONDS);
&nbsp;
<b class="nc">&nbsp;        currentSession.setScheduledFuture(executorFuture);</b>
<b class="nc">&nbsp;        return currentSession;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void deregisterSession(TransportProtos.SessionInfoProto sessionInfo) {
<b class="nc">&nbsp;        SessionMetaData currentSession = sessions.get(toSessionId(sessionInfo));</b>
<b class="nc">&nbsp;        if (currentSession != null &amp;&amp; currentSession.hasScheduledFuture()) {</b>
<b class="nc">&nbsp;            log.debug(&quot;Stopping scheduler to avoid resending response if request has been ack.&quot;);</b>
<b class="nc">&nbsp;            currentSession.getScheduledFuture().cancel(false);</b>
&nbsp;        }
<b class="nc">&nbsp;        sessions.remove(toSessionId(sessionInfo));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void log(TransportProtos.SessionInfoProto sessionInfo, String msg) {
<b class="nc">&nbsp;        if (!logEnabled || sessionInfo == null || StringUtils.isEmpty(msg)) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        if (msg.length() &gt; logMaxLength) {</b>
<b class="nc">&nbsp;            msg = msg.substring(0, logMaxLength);</b>
&nbsp;        }
<b class="nc">&nbsp;        TransportProtos.PostTelemetryMsg.Builder request = TransportProtos.PostTelemetryMsg.newBuilder();</b>
<b class="nc">&nbsp;        TransportProtos.TsKvListProto.Builder builder = TransportProtos.TsKvListProto.newBuilder();</b>
<b class="nc">&nbsp;        builder.setTs(TimeUnit.MILLISECONDS.toSeconds(getCurrentTimeMillis()) * 1000L + (atomicTs.getAndIncrement() % 1000));</b>
<b class="nc">&nbsp;        builder.addKv(TransportProtos.KeyValueProto.newBuilder()</b>
<b class="nc">&nbsp;                .setKey(&quot;transportLog&quot;)</b>
<b class="nc">&nbsp;                .setType(TransportProtos.KeyValueType.STRING_V)</b>
<b class="nc">&nbsp;                .setStringV(msg).build());</b>
<b class="nc">&nbsp;        request.addTsKvList(builder.build());</b>
<b class="nc">&nbsp;        TransportProtos.PostTelemetryMsg postTelemetryMsg = request.build();</b>
<b class="nc">&nbsp;        process(sessionInfo, postTelemetryMsg, TransportServiceCallback.EMPTY);</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean checkLimits(TransportProtos.SessionInfoProto sessionInfo, Object msg, TransportServiceCallback&lt;?&gt; callback) {
<b class="nc">&nbsp;        return checkLimits(sessionInfo, msg, callback, 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean checkLimits(TransportProtos.SessionInfoProto sessionInfo, Object msg, TransportServiceCallback&lt;?&gt; callback, int dataPoints) {
<b class="nc">&nbsp;        if (log.isTraceEnabled()) {</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}] Processing msg: {}&quot;, toSessionId(sessionInfo), msg);</b>
&nbsp;        }
<b class="nc">&nbsp;        TenantId tenantId = TenantId.fromUUID(new UUID(sessionInfo.getTenantIdMSB(), sessionInfo.getTenantIdLSB()));</b>
<b class="nc">&nbsp;        DeviceId deviceId = new DeviceId(new UUID(sessionInfo.getDeviceIdMSB(), sessionInfo.getDeviceIdLSB()));</b>
<b class="nc">&nbsp;        DeviceId gatewayId = null;</b>
<b class="nc">&nbsp;        if (sessionInfo.hasGatewayIdMSB() &amp;&amp; sessionInfo.hasGatewayIdLSB()) {</b>
<b class="nc">&nbsp;            gatewayId = new DeviceId(new UUID(sessionInfo.getGatewayIdMSB(), sessionInfo.getGatewayIdLSB()));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return checkLimits(tenantId, gatewayId, deviceId, sessionInfo.getDeviceName(), msg, callback, dataPoints, sessionInfo.getIsGateway());</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean checkLimits(TenantId tenantId, DeviceId gatewayId, DeviceId deviceId, String deviceName, Object msg, TransportServiceCallback&lt;?&gt; callback, int dataPoints, boolean isGateway) {
<b class="nc">&nbsp;        if (log.isTraceEnabled()) {</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}] Processing msg: {}&quot;, tenantId, deviceName, msg);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        var rateLimitedPair = rateLimitService.checkLimits(tenantId, gatewayId, deviceId, dataPoints, isGateway);</b>
<b class="nc">&nbsp;        if (rateLimitedPair == null) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            var rateLimitedEntityType = rateLimitedPair.getFirst();</b>
<b class="nc">&nbsp;            if (callback != null) {</b>
<b class="nc">&nbsp;                callback.onError(new TbRateLimitsException(rateLimitedEntityType));</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (rateLimitedEntityType == EntityType.DEVICE || rateLimitedEntityType == EntityType.TENANT) {</b>
&nbsp;                LimitedApi limitedApi;
&nbsp;
<b class="nc">&nbsp;                if (rateLimitedEntityType == EntityType.TENANT) {</b>
<b class="nc">&nbsp;                    limitedApi = LimitedApi.TRANSPORT_MESSAGES_PER_TENANT;</b>
<b class="nc">&nbsp;                } else if (rateLimitedPair.getSecond()) {</b>
<b class="nc">&nbsp;                    limitedApi = isGateway ? LimitedApi.TRANSPORT_MESSAGES_PER_GATEWAY_DEVICE : LimitedApi.TRANSPORT_MESSAGES_PER_GATEWAY;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    limitedApi = LimitedApi.TRANSPORT_MESSAGES_PER_DEVICE;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                EntityId limitLevel = rateLimitedEntityType == EntityType.DEVICE ? deviceId == null ? gatewayId : deviceId : tenantId;</b>
&nbsp;
<b class="nc">&nbsp;                notificationRuleProcessor.process(RateLimitsTrigger.builder()</b>
<b class="nc">&nbsp;                        .tenantId(tenantId)</b>
<b class="nc">&nbsp;                        .api(limitedApi)</b>
<b class="nc">&nbsp;                        .limitLevel(limitLevel)</b>
<b class="nc">&nbsp;                        .limitLevelEntityName(rateLimitedEntityType == EntityType.DEVICE ? deviceName : null)</b>
<b class="nc">&nbsp;                        .build());</b>
&nbsp;            }
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected void processToTransportMsg(ToTransportMsg toSessionMsg) {
<b class="nc">&nbsp;        UUID sessionId = new UUID(toSessionMsg.getSessionIdMSB(), toSessionMsg.getSessionIdLSB());</b>
<b class="nc">&nbsp;        SessionMetaData md = sessions.get(sessionId);</b>
<b class="nc">&nbsp;        if (md != null) {</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}] Processing notification: {}&quot;, sessionId, toSessionMsg);</b>
<b class="nc">&nbsp;            SessionMsgListener listener = md.getListener();</b>
<b class="nc">&nbsp;            transportCallbackExecutor.submit(() -&gt; {</b>
<b class="nc">&nbsp;                if (toSessionMsg.hasGetAttributesResponse()) {</b>
<b class="nc">&nbsp;                    listener.onGetAttributesResponse(toSessionMsg.getGetAttributesResponse());</b>
&nbsp;                }
<b class="nc">&nbsp;                if (toSessionMsg.hasAttributeUpdateNotification()) {</b>
<b class="nc">&nbsp;                    listener.onAttributeUpdate(sessionId, toSessionMsg.getAttributeUpdateNotification());</b>
&nbsp;                }
<b class="nc">&nbsp;                if (toSessionMsg.hasSessionCloseNotification()) {</b>
<b class="nc">&nbsp;                    listener.onRemoteSessionCloseCommand(sessionId, toSessionMsg.getSessionCloseNotification());</b>
&nbsp;                }
<b class="nc">&nbsp;                if (toSessionMsg.hasToTransportUpdateCredentialsNotification()) {</b>
<b class="nc">&nbsp;                    listener.onToTransportUpdateCredentials(toSessionMsg.getToTransportUpdateCredentialsNotification());</b>
&nbsp;                }
<b class="nc">&nbsp;                if (toSessionMsg.hasToDeviceRequest()) {</b>
<b class="nc">&nbsp;                    listener.onToDeviceRpcRequest(sessionId, toSessionMsg.getToDeviceRequest());</b>
&nbsp;                }
<b class="nc">&nbsp;                if (toSessionMsg.hasToServerResponse()) {</b>
<b class="nc">&nbsp;                    String requestId = sessionId + &quot;-&quot; + toSessionMsg.getToServerResponse().getRequestId();</b>
<b class="nc">&nbsp;                    toServerRpcPendingMap.remove(requestId);</b>
<b class="nc">&nbsp;                    listener.onToServerRpcResponse(toSessionMsg.getToServerResponse());</b>
&nbsp;                }
&nbsp;            });
<b class="nc">&nbsp;            if (md.getSessionType() == TransportProtos.SessionType.SYNC) {</b>
<b class="nc">&nbsp;                deregisterSession(md.getSessionInfo());</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            log.trace(&quot;Processing broadcast notification: {}&quot;, toSessionMsg);</b>
<b class="nc">&nbsp;            if (toSessionMsg.hasEntityUpdateMsg()) {</b>
<b class="nc">&nbsp;                onEntityUpdate(toSessionMsg.getEntityUpdateMsg());</b>
<b class="nc">&nbsp;            } else if (toSessionMsg.hasEntityDeleteMsg()) {</b>
<b class="nc">&nbsp;                TransportProtos.EntityDeleteMsg msg = toSessionMsg.getEntityDeleteMsg();</b>
<b class="nc">&nbsp;                EntityType entityType = EntityType.valueOf(msg.getEntityType());</b>
<b class="nc">&nbsp;                UUID entityUuid = new UUID(msg.getEntityIdMSB(), msg.getEntityIdLSB());</b>
<b class="nc">&nbsp;                if (EntityType.DEVICE_PROFILE.equals(entityType)) {</b>
<b class="nc">&nbsp;                    deviceProfileCache.evict(new DeviceProfileId(new UUID(msg.getEntityIdMSB(), msg.getEntityIdLSB())));</b>
<b class="nc">&nbsp;                } else if (EntityType.TENANT_PROFILE.equals(entityType)) {</b>
<b class="nc">&nbsp;                    tenantProfileCache.remove(new TenantProfileId(entityUuid));</b>
<b class="nc">&nbsp;                } else if (EntityType.TENANT.equals(entityType)) {</b>
<b class="nc">&nbsp;                    TenantId tenantId = TenantId.fromUUID(entityUuid);</b>
<b class="nc">&nbsp;                    rateLimitService.remove(tenantId);</b>
<b class="nc">&nbsp;                    partitionService.removeTenant(tenantId);</b>
<b class="nc">&nbsp;                } else if (EntityType.DEVICE.equals(entityType)) {</b>
<b class="nc">&nbsp;                    rateLimitService.remove(new DeviceId(entityUuid));</b>
<b class="nc">&nbsp;                    onDeviceDeleted(new DeviceId(entityUuid));</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (toSessionMsg.hasResourceUpdateMsg()) {</b>
<b class="nc">&nbsp;                TransportProtos.ResourceUpdateMsg msg = toSessionMsg.getResourceUpdateMsg();</b>
<b class="nc">&nbsp;                TenantId tenantId = TenantId.fromUUID(new UUID(msg.getTenantIdMSB(), msg.getTenantIdLSB()));</b>
<b class="nc">&nbsp;                ResourceType resourceType = ResourceType.valueOf(msg.getResourceType());</b>
<b class="nc">&nbsp;                String resourceId = msg.getResourceKey();</b>
<b class="nc">&nbsp;                transportResourceCache.update(tenantId, resourceType, resourceId);</b>
<b class="nc">&nbsp;                sessions.forEach((id, mdRez) -&gt; {</b>
<b class="nc">&nbsp;                    log.trace(&quot;ResourceUpdate - [{}] [{}]&quot;, id, mdRez);</b>
<b class="nc">&nbsp;                    transportCallbackExecutor.submit(() -&gt; mdRez.getListener().onResourceUpdate(msg));</b>
&nbsp;                });
<b class="nc">&nbsp;            } else if (toSessionMsg.hasResourceDeleteMsg()) {</b>
<b class="nc">&nbsp;                TransportProtos.ResourceDeleteMsg msg = toSessionMsg.getResourceDeleteMsg();</b>
<b class="nc">&nbsp;                TenantId tenantId = TenantId.fromUUID(new UUID(msg.getTenantIdMSB(), msg.getTenantIdLSB()));</b>
<b class="nc">&nbsp;                ResourceType resourceType = ResourceType.valueOf(msg.getResourceType());</b>
<b class="nc">&nbsp;                String resourceId = msg.getResourceKey();</b>
<b class="nc">&nbsp;                transportResourceCache.evict(tenantId, resourceType, resourceId);</b>
<b class="nc">&nbsp;                sessions.forEach((id, mdRez) -&gt; {</b>
<b class="nc">&nbsp;                    log.trace(&quot;ResourceDelete - [{}] [{}]&quot;, id, mdRez);</b>
<b class="nc">&nbsp;                    transportCallbackExecutor.submit(() -&gt; mdRez.getListener().onResourceDelete(msg));</b>
&nbsp;                });
<b class="nc">&nbsp;            } else if (toSessionMsg.getQueueUpdateMsgsCount() &gt; 0) {</b>
<b class="nc">&nbsp;                partitionService.updateQueues(toSessionMsg.getQueueUpdateMsgsList());</b>
<b class="nc">&nbsp;            } else if (toSessionMsg.getQueueDeleteMsgsCount() &gt; 0) {</b>
<b class="nc">&nbsp;                partitionService.removeQueues(toSessionMsg.getQueueDeleteMsgsList());</b>
&nbsp;            } else {
&nbsp;                //TODO: should we notify the device actor about missed session?
<b class="nc">&nbsp;                log.debug(&quot;[{}] Missing session.&quot;, sessionId);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    public void onProfileUpdate(DeviceProfile deviceProfile) {
<b class="nc">&nbsp;        long deviceProfileIdMSB = deviceProfile.getId().getId().getMostSignificantBits();</b>
<b class="nc">&nbsp;        long deviceProfileIdLSB = deviceProfile.getId().getId().getLeastSignificantBits();</b>
<b class="nc">&nbsp;        sessions.forEach((id, md) -&gt; {</b>
&nbsp;            //TODO: if transport types are different - we should close the session.
<b class="nc">&nbsp;            if (md.getSessionInfo().getDeviceProfileIdMSB() == deviceProfileIdMSB</b>
<b class="nc">&nbsp;                    &amp;&amp; md.getSessionInfo().getDeviceProfileIdLSB() == deviceProfileIdLSB) {</b>
<b class="nc">&nbsp;                TransportProtos.SessionInfoProto newSessionInfo = TransportProtos.SessionInfoProto.newBuilder()</b>
<b class="nc">&nbsp;                        .mergeFrom(md.getSessionInfo())</b>
<b class="nc">&nbsp;                        .setDeviceProfileIdMSB(deviceProfileIdMSB)</b>
<b class="nc">&nbsp;                        .setDeviceProfileIdLSB(deviceProfileIdLSB)</b>
<b class="nc">&nbsp;                        .setDeviceType(deviceProfile.getName())</b>
<b class="nc">&nbsp;                        .build();</b>
<b class="nc">&nbsp;                md.setSessionInfo(newSessionInfo);</b>
<b class="nc">&nbsp;                transportCallbackExecutor.submit(() -&gt; md.getListener().onDeviceProfileUpdate(newSessionInfo, deviceProfile));</b>
&nbsp;            }
&nbsp;        });
&nbsp;
<b class="nc">&nbsp;        eventPublisher.publishEvent(new DeviceProfileUpdatedEvent(deviceProfile));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void onEntityUpdate(TransportProtos.EntityUpdateMsg msg) {
<b class="nc">&nbsp;        switch (msg.getEntityUpdateCase()) {</b>
&nbsp;            case DEVICEPROFILE:
<b class="nc">&nbsp;                DeviceProfile deviceProfile = deviceProfileCache.put(msg.getDeviceProfile());</b>
<b class="nc">&nbsp;                log.debug(&quot;On device profile update: {}&quot;, deviceProfile);</b>
<b class="nc">&nbsp;                onProfileUpdate(deviceProfile);</b>
&nbsp;                break;
&nbsp;            case TENANTPROFILE:
<b class="nc">&nbsp;                rateLimitService.update(tenantProfileCache.put(msg.getTenantProfile()));</b>
&nbsp;                break;
&nbsp;            case TENANT:
<b class="nc">&nbsp;                Tenant tenant = ProtoUtils.fromProto(msg.getTenant());</b>
<b class="nc">&nbsp;                boolean updated = tenantProfileCache.put(tenant.getId(), tenant.getTenantProfileId());</b>
<b class="nc">&nbsp;                partitionService.evictTenantInfo(tenant.getId());</b>
<b class="nc">&nbsp;                if (updated) {</b>
<b class="nc">&nbsp;                    rateLimitService.update(tenant.getId());</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            case APIUSAGESTATE:
<b class="nc">&nbsp;                ApiUsageState apiUsageState = ProtoUtils.fromProto(msg.getApiUsageState());</b>
<b class="nc">&nbsp;                rateLimitService.update(apiUsageState.getTenantId(), apiUsageState.isTransportEnabled());</b>
&nbsp;                //TODO: if transport is disabled, we should close all sessions and not to check credentials.
&nbsp;                break;
&nbsp;            case DEVICE:
<b class="nc">&nbsp;                onDeviceUpdate(ProtoUtils.fromProto(msg.getDevice()));</b>
&nbsp;                break;
&nbsp;            default:
<b class="nc">&nbsp;                log.warn(&quot;UNKNOWN entity update type: [{}]&quot;, msg.getEntityUpdateCase());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void onDeviceUpdate(Device device) {
<b class="nc">&nbsp;        long deviceIdMSB = device.getId().getId().getMostSignificantBits();</b>
<b class="nc">&nbsp;        long deviceIdLSB = device.getId().getId().getLeastSignificantBits();</b>
<b class="nc">&nbsp;        long deviceProfileIdMSB = device.getDeviceProfileId().getId().getMostSignificantBits();</b>
<b class="nc">&nbsp;        long deviceProfileIdLSB = device.getDeviceProfileId().getId().getLeastSignificantBits();</b>
<b class="nc">&nbsp;        sessions.forEach((id, md) -&gt; {</b>
<b class="nc">&nbsp;            if ((md.getSessionInfo().getDeviceIdMSB() == deviceIdMSB &amp;&amp; md.getSessionInfo().getDeviceIdLSB() == deviceIdLSB)) {</b>
&nbsp;                DeviceProfile newDeviceProfile;
<b class="nc">&nbsp;                if (md.getSessionInfo().getDeviceProfileIdMSB() != deviceProfileIdMSB</b>
<b class="nc">&nbsp;                        || md.getSessionInfo().getDeviceProfileIdLSB() != deviceProfileIdLSB) {</b>
&nbsp;                    //TODO: if transport types are different - we should close the session.
<b class="nc">&nbsp;                    newDeviceProfile = deviceProfileCache.get(new DeviceProfileId(new UUID(deviceProfileIdMSB, deviceProfileIdLSB)));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    newDeviceProfile = null;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                JsonNode deviceAdditionalInfo = device.getAdditionalInfo();</b>
<b class="nc">&nbsp;                boolean isGateway = deviceAdditionalInfo.has(DataConstants.GATEWAY_PARAMETER)</b>
<b class="nc">&nbsp;                        &amp;&amp; deviceAdditionalInfo.get(DataConstants.GATEWAY_PARAMETER).asBoolean();</b>
&nbsp;
<b class="nc">&nbsp;                TransportProtos.SessionInfoProto newSessionInfo = TransportProtos.SessionInfoProto.newBuilder()</b>
<b class="nc">&nbsp;                        .mergeFrom(md.getSessionInfo())</b>
<b class="nc">&nbsp;                        .setDeviceProfileIdMSB(deviceProfileIdMSB)</b>
<b class="nc">&nbsp;                        .setDeviceProfileIdLSB(deviceProfileIdLSB)</b>
<b class="nc">&nbsp;                        .setDeviceName(device.getName())</b>
<b class="nc">&nbsp;                        .setDeviceType(device.getType())</b>
<b class="nc">&nbsp;                        .setIsGateway(isGateway).build();</b>
&nbsp;
<b class="nc">&nbsp;                if (isGateway &amp;&amp; deviceAdditionalInfo.has(DataConstants.OVERWRITE_ACTIVITY_TIME_PARAMETER)</b>
<b class="nc">&nbsp;                        &amp;&amp; deviceAdditionalInfo.get(DataConstants.OVERWRITE_ACTIVITY_TIME_PARAMETER).isBoolean()) {</b>
<b class="nc">&nbsp;                    md.setOverwriteActivityTime(deviceAdditionalInfo.get(DataConstants.OVERWRITE_ACTIVITY_TIME_PARAMETER).asBoolean());</b>
&nbsp;                }
<b class="nc">&nbsp;                md.setSessionInfo(newSessionInfo);</b>
<b class="nc">&nbsp;                transportCallbackExecutor.submit(() -&gt; md.getListener().onDeviceUpdate(newSessionInfo, device, Optional.ofNullable(newDeviceProfile)));</b>
&nbsp;            }
&nbsp;        });
&nbsp;
<b class="nc">&nbsp;        eventPublisher.publishEvent(new DeviceUpdatedEvent(device));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void onDeviceDeleted(DeviceId deviceId) {
<b class="nc">&nbsp;        sessions.forEach((id, md) -&gt; {</b>
<b class="nc">&nbsp;            DeviceId sessionDeviceId = new DeviceId(new UUID(md.getSessionInfo().getDeviceIdMSB(), md.getSessionInfo().getDeviceIdLSB()));</b>
<b class="nc">&nbsp;            if (sessionDeviceId.equals(deviceId)) {</b>
<b class="nc">&nbsp;                transportCallbackExecutor.submit(() -&gt; {</b>
<b class="nc">&nbsp;                    md.getListener().onDeviceDeleted(deviceId);</b>
&nbsp;                });
&nbsp;            }
&nbsp;        });
&nbsp;
<b class="nc">&nbsp;        eventPublisher.publishEvent(new DeviceDeletedEvent(deviceId));</b>
&nbsp;    }
&nbsp;
&nbsp;    protected UUID toSessionId(TransportProtos.SessionInfoProto sessionInfo) {
<b class="nc">&nbsp;        return new UUID(sessionInfo.getSessionIdMSB(), sessionInfo.getSessionIdLSB());</b>
&nbsp;    }
&nbsp;
&nbsp;    protected UUID getRoutingKey(TransportProtos.SessionInfoProto sessionInfo) {
<b class="nc">&nbsp;        return new UUID(sessionInfo.getDeviceIdMSB(), sessionInfo.getDeviceIdLSB());</b>
&nbsp;    }
&nbsp;
&nbsp;    protected TenantId getTenantId(TransportProtos.SessionInfoProto sessionInfo) {
<b class="nc">&nbsp;        return TenantId.fromUUID(new UUID(sessionInfo.getTenantIdMSB(), sessionInfo.getTenantIdLSB()));</b>
&nbsp;    }
&nbsp;
&nbsp;    protected CustomerId getCustomerId(TransportProtos.SessionInfoProto sessionInfo) {
<b class="nc">&nbsp;        long msb = sessionInfo.getCustomerIdMSB();</b>
<b class="nc">&nbsp;        long lsb = sessionInfo.getCustomerIdLSB();</b>
<b class="nc">&nbsp;        if (msb != 0 &amp;&amp; lsb != 0) {</b>
<b class="nc">&nbsp;            return new CustomerId(new UUID(msb, lsb));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return new CustomerId(EntityId.NULL_UUID);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected DeviceId getDeviceId(TransportProtos.SessionInfoProto sessionInfo) {
<b class="nc">&nbsp;        return new DeviceId(new UUID(sessionInfo.getDeviceIdMSB(), sessionInfo.getDeviceIdLSB()));</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void sendToDeviceActor(TransportProtos.SessionInfoProto sessionInfo, TransportToDeviceActorMsg toDeviceActorMsg, TransportServiceCallback&lt;Void&gt; callback) {
<b class="nc">&nbsp;        ToCoreMsg toCoreMsg = ToCoreMsg.newBuilder().setToDeviceActorMsg(toDeviceActorMsg).build();</b>
<b class="nc">&nbsp;        sendToCore(getTenantId(sessionInfo), getDeviceId(sessionInfo), toCoreMsg, getRoutingKey(sessionInfo), callback);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void sendToCore(TenantId tenantId, EntityId entityId, ToCoreMsg msg, UUID routingKey, TransportServiceCallback&lt;Void&gt; callback) {
&nbsp;        TopicPartitionInfo tpi;
&nbsp;        try {
<b class="nc">&nbsp;            tpi = partitionService.resolve(ServiceType.TB_CORE, tenantId, entityId);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            log.warn(&quot;Failed to send message to core. Tenant with ID [{}], routingKey [{}], msg [{}]. Message delivery aborted.&quot;, tenantId, routingKey, msg, e);</b>
<b class="nc">&nbsp;            if (callback != null) {</b>
<b class="nc">&nbsp;                callback.onError(e);</b>
&nbsp;            }
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        if (log.isTraceEnabled()) {</b>
<b class="nc">&nbsp;            log.trace(&quot;[{}][{}] Pushing to topic {} message {}&quot;, tenantId, entityId, tpi.getFullTopicName(), msg);</b>
&nbsp;        }
<b class="nc">&nbsp;        TransportTbQueueCallback transportTbQueueCallback = callback != null ?</b>
<b class="nc">&nbsp;                new TransportTbQueueCallback(callback) : null;</b>
<b class="nc">&nbsp;        tbCoreProducerStats.incrementTotal();</b>
<b class="nc">&nbsp;        StatsCallback wrappedCallback = new StatsCallback(transportTbQueueCallback, tbCoreProducerStats);</b>
<b class="nc">&nbsp;        tbCoreMsgProducer.send(tpi, new TbProtoQueueMsg&lt;&gt;(routingKey, msg), wrappedCallback);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void sendToRuleEngine(TenantId tenantId, DeviceId deviceId, CustomerId customerId, TransportProtos.SessionInfoProto sessionInfo, JsonObject json,
&nbsp;                                  TbMsgMetaData metaData, TbMsgType tbMsgType, TbQueueCallback callback) {
<b class="nc">&nbsp;        DeviceProfileId deviceProfileId = new DeviceProfileId(new UUID(sessionInfo.getDeviceProfileIdMSB(), sessionInfo.getDeviceProfileIdLSB()));</b>
<b class="nc">&nbsp;        DeviceProfile deviceProfile = deviceProfileCache.get(deviceProfileId);</b>
&nbsp;        RuleChainId ruleChainId;
&nbsp;        String queueName;
&nbsp;
<b class="nc">&nbsp;        if (deviceProfile == null) {</b>
<b class="nc">&nbsp;            log.warn(&quot;[{}] Device profile is null!&quot;, deviceProfileId);</b>
<b class="nc">&nbsp;            ruleChainId = null;</b>
<b class="nc">&nbsp;            queueName = null;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            ruleChainId = deviceProfile.getDefaultRuleChainId();</b>
<b class="nc">&nbsp;            queueName = deviceProfile.getDefaultQueueName();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        TbMsg tbMsg = TbMsg.newMsg()</b>
<b class="nc">&nbsp;                .queueName(queueName)</b>
<b class="nc">&nbsp;                .type(tbMsgType)</b>
<b class="nc">&nbsp;                .originator(deviceId)</b>
<b class="nc">&nbsp;                .customerId(customerId)</b>
<b class="nc">&nbsp;                .copyMetaData(metaData)</b>
<b class="nc">&nbsp;                .data(gson.toJson(json))</b>
<b class="nc">&nbsp;                .ruleChainId(ruleChainId)</b>
<b class="nc">&nbsp;                .build();</b>
<b class="nc">&nbsp;        ruleEngineProducerService.sendToRuleEngine(ruleEngineMsgProducer, tenantId, tbMsg, new StatsCallback(callback, ruleEngineProducerStats));</b>
<b class="nc">&nbsp;        ruleEngineProducerStats.incrementTotal();</b>
&nbsp;    }
&nbsp;
&nbsp;    private class TransportTbQueueCallback implements TbQueueCallback {
&nbsp;        private final TransportServiceCallback&lt;Void&gt; callback;
&nbsp;
<b class="nc">&nbsp;        private TransportTbQueueCallback(TransportServiceCallback&lt;Void&gt; callback) {</b>
<b class="nc">&nbsp;            this.callback = callback;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onSuccess(TbQueueMsgMetadata metadata) {
<b class="nc">&nbsp;            DefaultTransportService.this.transportCallbackExecutor.submit(() -&gt; callback.onSuccess(null));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onFailure(Throwable t) {
<b class="nc">&nbsp;            DefaultTransportService.this.transportCallbackExecutor.submit(() -&gt; callback.onError(t));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class StatsCallback implements TbQueueCallback {
&nbsp;        private final TbQueueCallback callback;
&nbsp;        private final MessagesStats stats;
&nbsp;
<b class="nc">&nbsp;        private StatsCallback(TbQueueCallback callback, MessagesStats stats) {</b>
<b class="nc">&nbsp;            this.callback = callback;</b>
<b class="nc">&nbsp;            this.stats = stats;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onSuccess(TbQueueMsgMetadata metadata) {
<b class="nc">&nbsp;            stats.incrementSuccessful();</b>
<b class="nc">&nbsp;            if (callback != null)</b>
<b class="nc">&nbsp;                callback.onSuccess(metadata);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onFailure(Throwable t) {
<b class="nc">&nbsp;            stats.incrementFailed();</b>
<b class="nc">&nbsp;            if (callback != null)</b>
<b class="nc">&nbsp;                callback.onFailure(t);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private class MsgPackCallback implements TbQueueCallback {
&nbsp;        private final AtomicInteger msgCount;
&nbsp;        private final TransportServiceCallback&lt;Void&gt; callback;
&nbsp;
<b class="nc">&nbsp;        public MsgPackCallback(Integer msgCount, TransportServiceCallback&lt;Void&gt; callback) {</b>
<b class="nc">&nbsp;            this.msgCount = new AtomicInteger(msgCount);</b>
<b class="nc">&nbsp;            this.callback = callback;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onSuccess(TbQueueMsgMetadata metadata) {
<b class="nc">&nbsp;            if (msgCount.decrementAndGet() &lt;= 0) {</b>
<b class="nc">&nbsp;                DefaultTransportService.this.transportCallbackExecutor.submit(() -&gt; callback.onSuccess(null));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onFailure(Throwable t) {
<b class="nc">&nbsp;            DefaultTransportService.this.transportCallbackExecutor.submit(() -&gt; callback.onError(t));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private class ApiStatsProxyCallback&lt;T&gt; implements TransportServiceCallback&lt;T&gt; {
&nbsp;        private final TenantId tenantId;
&nbsp;        private final CustomerId customerId;
&nbsp;        private final int dataPoints;
&nbsp;        private final TransportServiceCallback&lt;T&gt; callback;
&nbsp;
<b class="nc">&nbsp;        public ApiStatsProxyCallback(TenantId tenantId, CustomerId customerId, int dataPoints, TransportServiceCallback&lt;T&gt; callback) {</b>
<b class="nc">&nbsp;            this.tenantId = tenantId;</b>
<b class="nc">&nbsp;            this.customerId = customerId;</b>
<b class="nc">&nbsp;            this.dataPoints = dataPoints;</b>
<b class="nc">&nbsp;            this.callback = callback;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onSuccess(T msg) {
&nbsp;            try {
<b class="nc">&nbsp;                apiUsageClient.report(tenantId, customerId, ApiUsageRecordKey.TRANSPORT_MSG_COUNT, 1);</b>
<b class="nc">&nbsp;                apiUsageClient.report(tenantId, customerId, ApiUsageRecordKey.TRANSPORT_DP_COUNT, dataPoints);</b>
&nbsp;            } finally {
<b class="nc">&nbsp;                callback.onSuccess(msg);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onError(Throwable e) {
<b class="nc">&nbsp;            callback.onError(e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ExecutorService getCallbackExecutor() {
<b class="nc">&nbsp;        return transportCallbackExecutor;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean hasSession(TransportProtos.SessionInfoProto sessionInfo) {
<b class="nc">&nbsp;        return sessions.containsKey(toSessionId(sessionInfo));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void createGaugeStats(String statsName, AtomicInteger number) {
<b class="nc">&nbsp;        statsFactory.createGauge(StatsType.TRANSPORT + &quot;.&quot; + statsName, number);</b>
<b class="nc">&nbsp;        statsMap.put(statsName, number);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Scheduled(fixedDelayString = &quot;${transport.stats.print-interval-ms:60000}&quot;)
&nbsp;    public void printStats() {
<b class="nc">&nbsp;        if (statsEnabled &amp;&amp; !statsMap.isEmpty()) {</b>
<b class="nc">&nbsp;            String values = statsMap.entrySet().stream()</b>
<b class="nc">&nbsp;                    .map(kv -&gt; kv.getKey() + &quot; [&quot; + kv.getValue() + &quot;]&quot;).collect(Collectors.joining(&quot;, &quot;));</b>
<b class="nc">&nbsp;            log.info(&quot;Transport Stats: {}&quot;, values);</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
