<!--

    Copyright © 2016-2026 The Thingsboard Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->



<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > TbMsgTimeseriesNode</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.thingsboard.rule.engine.telemetry</a>
</div>

<h1>Coverage Summary for Class: TbMsgTimeseriesNode (org.thingsboard.rule.engine.telemetry)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TbMsgTimeseriesNode</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/33)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/65)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright © 2016-2026 The Thingsboard Authors
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.thingsboard.rule.engine.telemetry;
&nbsp;
&nbsp;import com.fasterxml.jackson.databind.JsonNode;
&nbsp;import com.fasterxml.jackson.databind.node.ObjectNode;
&nbsp;import com.google.gson.JsonParser;
&nbsp;import org.thingsboard.common.util.JacksonUtil;
&nbsp;import org.thingsboard.rule.engine.api.RuleNode;
&nbsp;import org.thingsboard.rule.engine.api.TbContext;
&nbsp;import org.thingsboard.rule.engine.api.TbNode;
&nbsp;import org.thingsboard.rule.engine.api.TbNodeConfiguration;
&nbsp;import org.thingsboard.rule.engine.api.TbNodeException;
&nbsp;import org.thingsboard.rule.engine.api.TimeseriesSaveRequest;
&nbsp;import org.thingsboard.rule.engine.api.util.TbNodeUtils;
&nbsp;import org.thingsboard.rule.engine.telemetry.settings.TimeseriesProcessingSettings;
&nbsp;import org.thingsboard.rule.engine.telemetry.strategy.ProcessingStrategy;
&nbsp;import org.thingsboard.server.common.adaptor.JsonConverter;
&nbsp;import org.thingsboard.server.common.data.StringUtils;
&nbsp;import org.thingsboard.server.common.data.TenantProfile;
&nbsp;import org.thingsboard.server.common.data.kv.KvEntry;
&nbsp;import org.thingsboard.server.common.data.kv.TsKvEntry;
&nbsp;import org.thingsboard.server.common.data.plugin.ComponentType;
&nbsp;import org.thingsboard.server.common.data.tenant.profile.DefaultTenantProfileConfiguration;
&nbsp;import org.thingsboard.server.common.data.util.TbPair;
&nbsp;import org.thingsboard.server.common.msg.TbMsg;
&nbsp;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.UUID;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;
&nbsp;import static org.thingsboard.rule.engine.telemetry.settings.TimeseriesProcessingSettings.Advanced;
&nbsp;import static org.thingsboard.rule.engine.telemetry.settings.TimeseriesProcessingSettings.Deduplicate;
&nbsp;import static org.thingsboard.rule.engine.telemetry.settings.TimeseriesProcessingSettings.OnEveryMessage;
&nbsp;import static org.thingsboard.rule.engine.telemetry.settings.TimeseriesProcessingSettings.WebSocketsOnly;
&nbsp;import static org.thingsboard.server.common.data.msg.TbMsgType.POST_TELEMETRY_REQUEST;
&nbsp;import static org.thingsboard.server.dao.util.KvUtils.toTsKvEntryList;
&nbsp;
&nbsp;@RuleNode(
&nbsp;        type = ComponentType.ACTION,
&nbsp;        name = &quot;save time series&quot;,
&nbsp;        configClazz = TbMsgTimeseriesNodeConfiguration.class,
&nbsp;        nodeDescription = &quot;&quot;&quot;
&nbsp;                Saves time series data with a configurable TTL and according to configured processing strategies.
&nbsp;                &quot;&quot;&quot;,
&nbsp;        nodeDetails = &quot;&quot;&quot;
&nbsp;                Node performs four &lt;strong&gt;actions:&lt;/strong&gt;
&nbsp;                &lt;ul&gt;
&nbsp;                  &lt;li&gt;&lt;strong&gt;Time series:&lt;/strong&gt; save time series data to a &lt;code&gt;ts_kv&lt;/code&gt; table in a DB.&lt;/li&gt;
&nbsp;                  &lt;li&gt;&lt;strong&gt;Latest values:&lt;/strong&gt; save time series data to a &lt;code&gt;ts_kv_latest&lt;/code&gt; table in a DB.&lt;/li&gt;
&nbsp;                  &lt;li&gt;&lt;strong&gt;WebSockets:&lt;/strong&gt; notify WebSockets subscriptions about time series data updates.&lt;/li&gt;
&nbsp;                  &lt;li&gt;&lt;strong&gt;Calculated fields:&lt;/strong&gt; notify calculated fields about time series data updates.&lt;/li&gt;
&nbsp;                &lt;/ul&gt;
&nbsp;                
&nbsp;                For each &lt;em&gt;action&lt;/em&gt;, three &lt;strong&gt;processing strategies&lt;/strong&gt; are available:
&nbsp;                &lt;ul&gt;
&nbsp;                  &lt;li&gt;&lt;strong&gt;On every message:&lt;/strong&gt; perform the action for every message.&lt;/li&gt;
&nbsp;                  &lt;li&gt;&lt;strong&gt;Deduplicate:&lt;/strong&gt; perform the action only for the first message from a particular originator within a configurable interval.&lt;/li&gt;
&nbsp;                  &lt;li&gt;&lt;strong&gt;Skip:&lt;/strong&gt; never perform the action.&lt;/li&gt;
&nbsp;                &lt;/ul&gt;
&nbsp;                
&nbsp;                &lt;strong&gt;Processing strategies&lt;/strong&gt; are configured using &lt;em&gt;processing settings&lt;/em&gt;, which support two modes:
&nbsp;                &lt;ul&gt;
&nbsp;                  &lt;li&gt;&lt;strong&gt;Basic&lt;/strong&gt;
&nbsp;                    &lt;ul&gt;
&nbsp;                      &lt;li&gt;&lt;strong&gt;On every message:&lt;/strong&gt; applies the &quot;On every message&quot; strategy to all actions.&lt;/li&gt;
&nbsp;                      &lt;li&gt;&lt;strong&gt;Deduplicate:&lt;/strong&gt; applies the &quot;Deduplicate&quot; strategy (with a specified interval) to all actions.&lt;/li&gt;
&nbsp;                      &lt;li&gt;&lt;strong&gt;WebSockets only:&lt;/strong&gt; for all actions except WebSocket notifications, the &quot;Skip&quot; strategy is applied, while WebSocket notifications use the &quot;On every message&quot; strategy.&lt;/li&gt;
&nbsp;                    &lt;/ul&gt;
&nbsp;                  &lt;/li&gt;
&nbsp;                  &lt;li&gt;&lt;strong&gt;Advanced:&lt;/strong&gt; configure each action’s strategy independently.&lt;/li&gt;
&nbsp;                &lt;/ul&gt;
&nbsp;                
&nbsp;                By default, the timestamp is taken from &lt;code&gt;metadata.ts&lt;/code&gt;. You can enable
&nbsp;                &lt;em&gt;Use server timestamp&lt;/em&gt; to always use the current server time instead. This is particularly
&nbsp;                useful in sequential processing scenarios where messages may arrive with out-of-order timestamps from
&nbsp;                multiple sources. Note that the DB layer may ignore &quot;outdated&quot; records for attributes and latest values,
&nbsp;                so enabling &lt;em&gt;Use server timestamp&lt;/em&gt; can ensure correct ordering.
&nbsp;                &lt;br&gt;&lt;br&gt;
&nbsp;                The TTL is taken first from &lt;code&gt;metadata.TTL&lt;/code&gt;. If absent, the node configuration’s default
&nbsp;                TTL is used. If neither is set, the tenant profile default applies.
&nbsp;                &lt;br&gt;&lt;br&gt;
&nbsp;                This node expects messages of type &lt;code&gt;POST_TELEMETRY_REQUEST&lt;/code&gt;.
&nbsp;                &lt;br&gt;&lt;br&gt;
&nbsp;                Output connections: &lt;code&gt;Success&lt;/code&gt;, &lt;code&gt;Failure&lt;/code&gt;.
&nbsp;                &quot;&quot;&quot;,
&nbsp;        configDirective = &quot;tbActionNodeTimeseriesConfig&quot;,
&nbsp;        icon = &quot;file_upload&quot;,
&nbsp;        version = 1,
&nbsp;        docUrl = &quot;https://thingsboard.io/docs/user-guide/rule-engine-2-0/nodes/action/save-timeseries/&quot;
&nbsp;)
<b class="nc">&nbsp;public class TbMsgTimeseriesNode implements TbNode {</b>
&nbsp;
&nbsp;    private TbMsgTimeseriesNodeConfiguration config;
&nbsp;    private TbContext ctx;
&nbsp;    private long tenantProfileDefaultStorageTtl;
&nbsp;
&nbsp;    private TimeseriesProcessingSettings processingSettings;
&nbsp;
&nbsp;    @Override
&nbsp;    public void init(TbContext ctx, TbNodeConfiguration configuration) throws TbNodeException {
<b class="nc">&nbsp;        this.config = TbNodeUtils.convert(configuration, TbMsgTimeseriesNodeConfiguration.class);</b>
<b class="nc">&nbsp;        this.ctx = ctx;</b>
<b class="nc">&nbsp;        ctx.addTenantProfileListener(this::onTenantProfileUpdate);</b>
<b class="nc">&nbsp;        onTenantProfileUpdate(ctx.getTenantProfile());</b>
<b class="nc">&nbsp;        processingSettings = config.getProcessingSettings();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void onTenantProfileUpdate(TenantProfile tenantProfile) {
<b class="nc">&nbsp;        DefaultTenantProfileConfiguration configuration = (DefaultTenantProfileConfiguration) tenantProfile.getProfileData().getConfiguration();</b>
<b class="nc">&nbsp;        tenantProfileDefaultStorageTtl = TimeUnit.DAYS.toSeconds(configuration.getDefaultStorageTtlDays());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void onMsg(TbContext ctx, TbMsg msg) {
<b class="nc">&nbsp;        if (!msg.isTypeOf(POST_TELEMETRY_REQUEST)) {</b>
<b class="nc">&nbsp;            ctx.tellFailure(msg, new IllegalArgumentException(&quot;Unsupported msg type: &quot; + msg.getType()));</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        long ts = computeTs(msg, config.isUseServerTs());</b>
&nbsp;
<b class="nc">&nbsp;        TimeseriesSaveRequest.Strategy strategy = determineSaveStrategy(ts, msg.getOriginator().getId());</b>
&nbsp;
&nbsp;        // short-circuit
<b class="nc">&nbsp;        if (!strategy.saveTimeseries() &amp;&amp; !strategy.saveLatest() &amp;&amp; !strategy.sendWsUpdate() &amp;&amp; !strategy.processCalculatedFields()) {</b>
<b class="nc">&nbsp;            ctx.tellSuccess(msg);</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        String src = msg.getData();</b>
<b class="nc">&nbsp;        Map&lt;Long, List&lt;KvEntry&gt;&gt; tsKvMap = JsonConverter.convertToTelemetry(JsonParser.parseString(src), ts);</b>
<b class="nc">&nbsp;        if (tsKvMap.isEmpty()) {</b>
<b class="nc">&nbsp;            ctx.tellFailure(msg, new IllegalArgumentException(&quot;Msg body is empty: &quot; + src));</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        List&lt;TsKvEntry&gt; tsKvEntryList = toTsKvEntryList(tsKvMap);</b>
<b class="nc">&nbsp;        String ttlValue = msg.getMetaData().getValue(&quot;TTL&quot;);</b>
<b class="nc">&nbsp;        long ttl = !StringUtils.isEmpty(ttlValue) ? Long.parseLong(ttlValue) : config.getDefaultTTL();</b>
<b class="nc">&nbsp;        if (ttl == 0L) {</b>
<b class="nc">&nbsp;            ttl = tenantProfileDefaultStorageTtl;</b>
&nbsp;        }
<b class="nc">&nbsp;        ctx.getTelemetryService().saveTimeseries(TimeseriesSaveRequest.builder()</b>
<b class="nc">&nbsp;                .tenantId(ctx.getTenantId())</b>
<b class="nc">&nbsp;                .customerId(msg.getCustomerId())</b>
<b class="nc">&nbsp;                .entityId(msg.getOriginator())</b>
<b class="nc">&nbsp;                .entries(tsKvEntryList)</b>
<b class="nc">&nbsp;                .ttl(ttl)</b>
<b class="nc">&nbsp;                .strategy(strategy)</b>
<b class="nc">&nbsp;                .previousCalculatedFieldIds(msg.getPreviousCalculatedFieldIds())</b>
<b class="nc">&nbsp;                .tbMsgId(msg.getId())</b>
<b class="nc">&nbsp;                .tbMsgType(msg.getInternalType())</b>
<b class="nc">&nbsp;                .callback(new TelemetryNodeCallback(ctx, msg))</b>
<b class="nc">&nbsp;                .build());</b>
&nbsp;    }
&nbsp;
&nbsp;    public static long computeTs(TbMsg msg, boolean ignoreMetadataTs) {
<b class="nc">&nbsp;        return ignoreMetadataTs ? System.currentTimeMillis() : msg.getMetaDataTs();</b>
&nbsp;    }
&nbsp;
&nbsp;    private TimeseriesSaveRequest.Strategy determineSaveStrategy(long ts, UUID originatorUuid) {
<b class="nc">&nbsp;        if (processingSettings instanceof OnEveryMessage) {</b>
<b class="nc">&nbsp;            return TimeseriesSaveRequest.Strategy.PROCESS_ALL;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (processingSettings instanceof WebSocketsOnly) {</b>
<b class="nc">&nbsp;            return TimeseriesSaveRequest.Strategy.WS_ONLY;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (processingSettings instanceof Deduplicate deduplicate) {</b>
<b class="nc">&nbsp;            boolean isFirstMsgInInterval = deduplicate.getProcessingStrategy().shouldProcess(ts, originatorUuid);</b>
<b class="nc">&nbsp;            return isFirstMsgInInterval ? TimeseriesSaveRequest.Strategy.PROCESS_ALL : TimeseriesSaveRequest.Strategy.SKIP_ALL;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (processingSettings instanceof Advanced advanced) {</b>
<b class="nc">&nbsp;            return new TimeseriesSaveRequest.Strategy(</b>
<b class="nc">&nbsp;                    advanced.timeseries().shouldProcess(ts, originatorUuid),</b>
<b class="nc">&nbsp;                    advanced.latest().shouldProcess(ts, originatorUuid),</b>
<b class="nc">&nbsp;                    advanced.webSockets().shouldProcess(ts, originatorUuid),</b>
<b class="nc">&nbsp;                    advanced.calculatedFields().shouldProcess(ts, originatorUuid)</b>
&nbsp;            );
&nbsp;        }
&nbsp;        // should not happen
<b class="nc">&nbsp;        throw new IllegalArgumentException(&quot;Unknown processing settings type: &quot; + processingSettings.getClass().getSimpleName());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void destroy() {
<b class="nc">&nbsp;        ctx.removeListeners();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public TbPair&lt;Boolean, JsonNode&gt; upgrade(int fromVersion, JsonNode oldConfiguration) throws TbNodeException {
<b class="nc">&nbsp;        boolean hasChanges = false;</b>
<b class="nc">&nbsp;        switch (fromVersion) {</b>
&nbsp;            case 0:
<b class="nc">&nbsp;                hasChanges = true;</b>
<b class="nc">&nbsp;                JsonNode skipLatestPersistence = oldConfiguration.get(&quot;skipLatestPersistence&quot;);</b>
<b class="nc">&nbsp;                if (skipLatestPersistence != null &amp;&amp; &quot;true&quot;.equals(skipLatestPersistence.asText())) {</b>
<b class="nc">&nbsp;                    var skipLatestProcessingSettings = new Advanced(</b>
<b class="nc">&nbsp;                            ProcessingStrategy.onEveryMessage(),</b>
<b class="nc">&nbsp;                            ProcessingStrategy.skip(),</b>
<b class="nc">&nbsp;                            ProcessingStrategy.onEveryMessage(),</b>
<b class="nc">&nbsp;                            ProcessingStrategy.onEveryMessage()</b>
&nbsp;                    );
<b class="nc">&nbsp;                    ((ObjectNode) oldConfiguration).set(&quot;processingSettings&quot;, JacksonUtil.valueToTree(skipLatestProcessingSettings));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    ((ObjectNode) oldConfiguration).set(&quot;processingSettings&quot;, JacksonUtil.valueToTree(new OnEveryMessage()));</b>
&nbsp;                }
<b class="nc">&nbsp;                ((ObjectNode) oldConfiguration).remove(&quot;skipLatestPersistence&quot;);</b>
&nbsp;                break;
&nbsp;            default:
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        return new TbPair&lt;&gt;(hasChanges, oldConfiguration);</b>
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2026-02-07 20:03</div>
</div>
</body>
</html>
